# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-02-04 23:30+0900\n"
"PO-Revision-Date: 2015-02-04 23:51+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr "GET_MEMPOLICY"

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "2008-08-15"
msgstr "2008-08-15"

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12
#: build/C/man2/mbind.2:45 build/C/man2/migrate_pages.2:18
#: build/C/man2/move_pages.2:19 build/C/man7/numa.7:29
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12
#: build/C/man2/mbind.2:45 build/C/man2/migrate_pages.2:18
#: build/C/man2/move_pages.2:19 build/C/man7/numa.7:29
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/get_mempolicy.2:28 build/C/man2/getcpu.2:13
#: build/C/man2/mbind.2:46 build/C/man2/migrate_pages.2:19
#: build/C/man2/move_pages.2:20 build/C/man7/numa.7:30
#: build/C/man2/set_mempolicy.2:28
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a process"
msgstr "get_mempolicy - プロセスの NUMA メモリーのポリシーを取得する"

#. type: SH
#: build/C/man2/get_mempolicy.2:30 build/C/man2/getcpu.2:15
#: build/C/man2/mbind.2:48 build/C/man2/migrate_pages.2:21
#: build/C/man2/move_pages.2:22 build/C/man2/set_mempolicy.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr "B<#include E<lt>numaif.hE<gt>>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, unsigned long >I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""
"B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, unsigned long >I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:39 build/C/man2/mbind.2:57
#: build/C/man2/set_mempolicy.2:38
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "I<-lnuma> でリンクする。\n"

#. type: SH
#: build/C/man2/get_mempolicy.2:40 build/C/man2/getcpu.2:25
#: build/C/man2/mbind.2:58 build/C/man2/migrate_pages.2:31
#: build/C/man2/move_pages.2:31 build/C/man7/numa.7:32
#: build/C/man2/set_mempolicy.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling process or of a "
"memory address, depending on the setting of I<flags>."
msgstr ""
"B<get_mempolicy>()  は、呼び出し元プロセスもしくは指定されたメモリーアドレス"
"の NUMA ポリシーを I<flags> の設定に従って取得する。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:50 build/C/man2/set_mempolicy.2:54
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the process."
msgstr ""
"NUMA (非対称メモリーアクセス) マシンでは、CPU により メモリーコントローラーが"
"異なり、距離も異なっている。 メモリーポリシーは、どのノードからメモリーをその"
"プロセスに 割り当てるかを定めるものである。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:67
msgid ""
"If I<flags> is specified as 0, then information about the calling process's "
"default policy (as set by B<set_mempolicy>(2))  is returned.  The policy "
"returned [I<mode> and I<nodemask>] may be used to restore the process's "
"policy to its state at the time of the call to B<get_mempolicy>()  using "
"B<set_mempolicy>(2)."
msgstr ""
"I<flags> に 0 が指定された場合、 (B<set_mempolicy>(2)  で設定された)  呼び出"
"し元プロセスのデフォルトポリシーに関する情報を返す。 返されたポリシー "
"[I<mode> と I<nodemask>] を B<set_mempolicy>(2)  に渡すことで、そのプロセスの"
"ポリシーを B<get_mempolicy>()  を呼び出した時点の状態に戻すことができる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:89
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24), "
"the I<mode> argument is ignored and the set of nodes [memories] that the "
"process is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  [in the absence of any I<mode flags>] is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr ""
"I<flags> に B<MPOL_F_MEMS_ALLOWED> (Linux 2.6.24 以降で利用可能) を指定する"
"と、 I<mode> 引き数は無視され、 そのプロセスがその後の B<mbind>(2)  や "
"B<set_mempolicy>(2)  で [I<モードフラグ> が指定されていない場合に ] 指定でき"
"るノード (メモリー) の集合が I<nodemask> に返される。 B<MPOL_F_MEMS_ALLOWED> "
"を、 B<MPOL_F_ADDR> や B<MPOL_F_NODE> と同時に指定することはできない。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:103
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the "
"policy governing the memory address given in I<addr>.  This policy may be "
"different from the process's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr ""
"I<flags> に B<MPOL_F_ADDR> が指定された場合、 I<addr> で指定されたメモリーア"
"ドレスに適用されているポリシーに関する情報を返す。 B<mbind>(2)  や "
"B<numa>(3)  で説明されているヘルパー関数を使って、 I<addr> を含むメモリー領域"
"に対するポリシーが設定されていた場合には、 返されるポリシーはプロセスのデフォ"
"ルトポリシーと違うことがある。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:124
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the "
"policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned long)>."
msgstr ""
"I<mode> 引き数が NULL でない場合、 B<get_mempolicy>()  は要求された NUMA ポリ"
"シーのモードと追加の I<モードフラグ> を I<mode> が指す場所に格納する。 "
"I<nodemask> が NULL 以外の場合、そのポリシーに対応するノードマスクを この引き"
"数が指す場所に格納する。 I<maxnode> には I<nodemask> に格納できるノード ID の"
"数、つまり最大ノード ID に 1 を足した値を指定する。 I<maxnode> で指定された値"
"は常に I<sizeof(unsigned long)> の倍数に切り上げられる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:141
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address "
"I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the process had performed a read [load] access to that "
"address, and return the ID of the node where that page was allocated."
msgstr ""
"I<flags> で B<MPOL_F_NODE> と B<MPOL_F_ADDR> の両方が指定された場合、 "
"B<get_mempolicy>()  はアドレス I<addr> が割り当てられているノードのノード ID "
"を I<mode> が指す場所に入れて返す。 指定されたアドレスにどのページもまだ割り"
"当てられていない場合、 B<get_mempolicy>()  は、あたかもそのプロセスがそのアド"
"レスに対して読み込みアクセスを 実行したかのようにページの割り当てを行い、ペー"
"ジが割り当てられた ノードの ID を返す。"

#.  Note:  code returns next interleave node via 'mode' argument -Lee Schermerhorn
#. type: Plain text
#: build/C/man2/get_mempolicy.2:166
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"process's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  "
"will return in the location pointed to by a non-NULL I<mode> argument, the "
"node ID of the next node that will be used for interleaving of internal "
"kernel pages allocated on behalf of the process.  These allocations include "
"pages for memory-mapped files in process memory ranges mapped using the "
"B<mmap>(2)  call with the B<MAP_PRIVATE> flag for read accesses, and in "
"memory ranges mapped with the B<MAP_SHARED> flag for all accesses."
msgstr ""
"I<flags> で B<MPOL_F_NODE> は指定されたが、 B<MPOL_F_ADDR> は指定されていない"
"場合で、かつ そのプロセスの現在のポリシーが B<MPOL_INTERLEAVE> の場合、 "
"B<get_mempolicy>()  は、そのプロセスに対して割り当てられたカーネルの内部ペー"
"ジで 次にインターリーブ用に使用されるノードのノード ID を、 NULL でない "
"I<mode> 引き数が指す場所に入れて返す。 読み込みアクセス用として "
"B<MAP_PRIVATE> フラグ付きで B<mmap>(2)  したプロセスメモリー領域や、 任意のア"
"クセス用として B<MAP_SHARED> フラグ付きで B<mmap>(2)  したメモリー領域の、メ"
"モリーマップされたファイルに対するページも 上記のプロセスに対して割り当てられ"
"たページに含まれる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:168
msgid "Other flag values are reserved."
msgstr "他のフラグは予約されている。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:171
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr "設定可能なポリシーの概要については B<set_mempolicy>(2)  を参照。"

#. type: SH
#: build/C/man2/get_mempolicy.2:171 build/C/man2/getcpu.2:61
#: build/C/man2/mbind.2:309 build/C/man2/migrate_pages.2:88
#: build/C/man2/move_pages.2:143 build/C/man2/set_mempolicy.2:220
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:178
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<get_mempolicy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: SH
#: build/C/man2/get_mempolicy.2:178 build/C/man2/getcpu.2:66
#: build/C/man2/mbind.2:317 build/C/man2/migrate_pages.2:96
#: build/C/man2/move_pages.2:152 build/C/man2/set_mempolicy.2:227
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/get_mempolicy.2:179 build/C/man2/getcpu.2:67
#: build/C/man2/mbind.2:319 build/C/man2/move_pages.2:161
#: build/C/man2/set_mempolicy.2:228
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:186 build/C/man2/set_mempolicy.2:235
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""
"I<nodemask> と I<maxnode> で指定されたメモリー領域の一部または全部が、 呼び出"
"し元がアクセス可能なアドレス空間外を指している。"

#. type: TP
#: build/C/man2/get_mempolicy.2:186 build/C/man2/mbind.2:330
#: build/C/man2/move_pages.2:164 build/C/man2/set_mempolicy.2:235
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:230
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current process policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> "
"specified B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or "
"B<MPOL_F_NODE>.  (And there are other B<EINVAL> cases.)"
msgstr ""
"I<maxnode> で指定された値がシステムがサポートするノード ID の数よりも少な"
"い。 または、 I<flags> に B<MPOL_F_NODE> でも B<MPOL_F_ADDR> でもない値が指定"
"された。 または、 I<flags> に B<MPOL_F_ADDR> が指定されており、 I<addr> が "
"NULL である。 または、 I<flags> に B<MPOL_F_ADDR> がされておらず、 I<addr> "
"が NULL でない。 または、 I<flags> に B<MPOL_F_NODE> が指定されており、 "
"B<MPOL_F_ADDR> が指定されておらず、 プロセスの現在のポリシーが "
"B<MPOL_INTERLEAVE> でない。 または、 I<flags> に B<MPOL_F_MEMS_ALLOWED> が指"
"定されており、さらに B<MPOL_F_ADDR> か B<MPOL_F_NODE> のいずれかが指定されて"
"いる。 (他にも B<EINVAL> となる場合がある。)"

#. type: SH
#: build/C/man2/get_mempolicy.2:230 build/C/man2/getcpu.2:70
#: build/C/man2/mbind.2:402 build/C/man2/migrate_pages.2:112
#: build/C/man2/move_pages.2:192 build/C/man2/set_mempolicy.2:275
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:234
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""
"B<get_mempolicy>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加"
"された。"

#. type: SH
#: build/C/man2/get_mempolicy.2:234 build/C/man2/getcpu.2:73
#: build/C/man2/mbind.2:406 build/C/man2/migrate_pages.2:116
#: build/C/man2/move_pages.2:195 build/C/man7/numa.7:148
#: build/C/man2/set_mempolicy.2:279
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:236 build/C/man2/mbind.2:408
#: build/C/man2/migrate_pages.2:118 build/C/man2/move_pages.2:197
#: build/C/man2/set_mempolicy.2:281
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#. type: SH
#: build/C/man2/get_mempolicy.2:236 build/C/man2/getcpu.2:76
#: build/C/man2/mbind.2:408 build/C/man2/migrate_pages.2:118
#: build/C/man2/move_pages.2:197 build/C/man7/numa.7:150
#: build/C/man2/set_mempolicy.2:281
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:239 build/C/man2/mbind.2:411
#: build/C/man2/migrate_pages.2:121 build/C/man2/move_pages.2:200
#: build/C/man2/set_mempolicy.2:289
msgid "For information on library support, see B<numa>(7)."
msgstr "ライブラリによるサポートについては B<numa>(7)  を参照。"

#. type: SH
#: build/C/man2/get_mempolicy.2:239 build/C/man2/getcpu.2:139
#: build/C/man2/mbind.2:460 build/C/man2/migrate_pages.2:148
#: build/C/man2/move_pages.2:227 build/C/man7/numa.7:183
#: build/C/man2/set_mempolicy.2:289
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:247
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"

#. type: SH
#: build/C/man2/get_mempolicy.2:247 build/C/man2/getcpu.2:145
#: build/C/man2/mbind.2:471 build/C/man2/migrate_pages.2:161
#: build/C/man2/move_pages.2:237 build/C/man7/numa.7:191
#: build/C/man2/set_mempolicy.2:298
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:255 build/C/man2/getcpu.2:153
#: build/C/man2/mbind.2:479 build/C/man2/migrate_pages.2:169
#: build/C/man2/move_pages.2:245 build/C/man7/numa.7:199
#: build/C/man2/set_mempolicy.2:306
msgid ""
"This page is part of release 3.79 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%http://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.79 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr "GETCPU"

#. type: TH
#: build/C/man2/getcpu.2:12
#, no-wrap
msgid "2013-04-03"
msgstr "2013-04-03"

#. type: Plain text
#: build/C/man2/getcpu.2:15
msgid ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr "getcpu - 呼び出し元スレッドが動作している CPU と NUMA ノードを判定する"

#. type: Plain text
#: build/C/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr "B<#include E<lt>linux/getcpu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getcpu.2:21
#, no-wrap
msgid "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"
msgstr "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"

#. type: Plain text
#: build/C/man2/getcpu.2:25
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/getcpu.2:42
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""
"B<getcpu>() システムコールは、呼び出し元のスレッドやプロセスが\n"
"現在動作しているプロセッサやノードの情報を特定し、\n"
"それぞれ引き数 I<cpu> と I<node> が指す整数に書き込む。\n"
"プロセッサ情報は CPU を識別するための一意な小さな整数である。\n"
"ノード情報は NUMAノードを識別するための一意な小さな整数である。\n"
"I<cpu> か I<node> のいずれかが NULL であれば、\n"
"その引き数に対応する情報の書き込みは行われない。"

#. type: Plain text
#: build/C/man2/getcpu.2:46
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr ""
"このシステムコールの 3 番目の引き数は現在は使われておらず、 Linux 2.6.23 以前"
"への移植性が必要な場合以外は NULL を渡すべきである (「注意」を参照)。"

#. type: Plain text
#: build/C/man2/getcpu.2:61
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr ""
"I<cpu> に格納された情報が最新だと保証できるのは、システムコールが呼ばれ\n"
"た時点だけである。B<sched_setaffinity>(2) を使って CPU affinity が固定\n"
"されていない限り、カーネルはいつでも CPU を変更してもよい (スケジューラ\n"
"はキャッシュが有効に働くように CPU の移動を最小限にしようとするので、\n"
"通常は CPU が変更されることはないが、起きる可能性はある)。\n"
"I<cpu> や I<node> で返された情報が呼び出しが返った時点ですでに\n"
"最新の状況と異なる可能性があり、呼び出し元はこの可能性を考慮して\n"
"おかなければならない。"

#. type: Plain text
#: build/C/man2/getcpu.2:66
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功すると、0 を返す。\n"
"エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/getcpu.2:70
msgid "Arguments point outside the calling process's address space."
msgstr "引き数が呼び出したプロセスのアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/getcpu.2:73
msgid "B<getcpu>()  was added in kernel 2.6.19 for x86_64 and i386."
msgstr "B<getcpu>() はカーネル 2.6.19 で x86_64 と i386 向けに追加された."

#. type: Plain text
#: build/C/man2/getcpu.2:76
msgid "B<getcpu>()  is Linux-specific."
msgstr "B<getcpu>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/getcpu.2:82
msgid ""
"Linux makes a best effort to make this call as fast possible.  The intention "
"of B<getcpu>()  is to allow programs to make optimizations with per-CPU data "
"or for NUMA optimization."
msgstr ""
"Linux はこのシステムコールを可能な限り早く実行しようとする。\n"
"B<getcpu>() は、CPU 毎のデータに対する最適化や NUMA 環境での最適化を\n"
"プログラムが行えるようにすることを目的として実装されているからである。"

#. type: Plain text
#: build/C/man2/getcpu.2:88
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2); or use B<sched_getcpu>(3)  instead."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。\n"
"B<syscall>(2) を使って呼び出すか、\n"
"代わりに B<sched_getcpu>(3) を使用すること。"

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: build/C/man2/getcpu.2:139
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls, "
"at the cost that there was a very small chance that the returned information "
"would be out of date.  The caching mechanism was considered to cause "
"problems when migrating threads between CPUs, and so the argument is now "
"ignored."
msgstr ""
"I<tcache> 引き数は Linux 2.6.24 以降では使用されない。以前のバージョン\n"
"のカーネルでは、この引き数が NULL 以外の場合、この引き数には、呼び出し\n"
"元が割り当てたスレッド専用の記憶領域 (thread-local storage) 内のバッファー\n"
"を指すポインターが指定され、このバッファーは B<getcpu>() 用のキャッシュ機構\n"
"を提供するために利用されていた。非常に低い確率だが古い情報を返してしま\n"
"うデメリットはあるものの、このキャッシュを使うことで B<getcpu>() システ\n"
"ムコールを高速化できた。このキャッシュ機構はCPU 間でのスレッドの移動時\n"
"に問題になると考えられ、この引き数は今では無視されるようになっている。"

#. type: Plain text
#: build/C/man2/getcpu.2:145
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7)"
msgstr ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7)"

#. type: TH
#: build/C/man2/mbind.2:45
#, no-wrap
msgid "MBIND"
msgstr "MBIND"

#. type: TH
#: build/C/man2/mbind.2:45
#, no-wrap
msgid "2015-01-22"
msgstr "2015-01-22"

#. type: Plain text
#: build/C/man2/mbind.2:48
msgid "mbind - set memory policy for a memory range"
msgstr "mbind - メモリー領域に対してメモリーポリシーを設定する"

#. type: Plain text
#: build/C/man2/mbind.2:51 build/C/man2/migrate_pages.2:24
#: build/C/man2/move_pages.2:25 build/C/man2/set_mempolicy.2:33
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mbind.2:55
#, no-wrap
msgid ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"
msgstr ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/mbind.2:68
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and "
"zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""
"B<mbind>()  は、 I<addr> から始まる長さ I<len> バイトの範囲のメモリーに NUMA "
"メモリーポリシーを設定する。 NUMA ポリシーはポリシーモードと 0 個以上のノード"
"から構成される。 メモリーポリシーはどのノードからメモリーを割り当てるかを決定"
"する。"

#. type: Plain text
#: build/C/man2/mbind.2:90
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a memory-"
"mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified "
"policy when the application writes [stores] to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the process policy of the "
"process that causes the page to be allocated.  This may not be the process "
"that called B<mbind>()."
msgstr ""
"I<addr> と I<len> で指定されたメモリー範囲に、 メモリーの「無名」領域 \\(em "
"B<MAP_ANONYMOUS> 付きの B<mmap>(2)  システムコールを使って作成されたメモリー"
"領域 \\(em や B<MAP_PRIVATE> 付きの B<mmap>(2)  を使ってマップされたメモリー"
"マップファイルが含まれている場合、アプリケーションがそのページへの書き込み "
"(データの格納) を行った時には指定されたポリシーのみに基づいてページが割り当て"
"られる。無名領域の場合、最初の読み出しアクセスの際には カーネル内の全データ"
"が 0 である共有ページが使用される。 B<MAP_PRIVATE> でマップされたファイルの場"
"合、最初の読み出しアクセスがあると、 ページ割り当てが発生するきっかけとなった"
"プロセスのデフォルトポリシー にしたがってページの割り当てが行われる。 ページ"
"割り当てのきっかけとなったプロセスは、 B<mbind>()  を呼び出したプロセスと同じ"
"とは限らない。"

#. type: Plain text
#: build/C/man2/mbind.2:98
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the "
"process policy of the process that caused the page to be allocated.  Again, "
"this may not be the process that called B<mbind>()."
msgstr ""
"指定されたメモリー範囲内にある B<MAP_SHARED> のマッピングでは指定されたポリ"
"シーは無視され、 ページ割り当てが発生するきっかけとなったプロセスのデフォルト"
"ポリシーに したがってページの割り当てが行われることになる。 繰り返しになる"
"が、ページ割り当てのきっかけとなったプロセスは、 B<mbind>()  を呼び出したプロ"
"セスと同じとは限らない。"

#. type: Plain text
#: build/C/man2/mbind.2:115
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""
"指定されたメモリー範囲に、 B<shmget>(2)  システムコールを使って作成された"
"り、 B<shmat>(2)  システムコールを使って付加 (attach) されたりした共有メモ"
"リー領域が 含まれる場合、無名メモリー領域や共有メモリー領域に対するページ割り"
"当ては、 共有メモリーセグメントへポリシーの設定を行ったプロセスがページ割り当"
"て のきっかけとなったかに関わらず、指定されたポリシーにしたがって割り当て が"
"行われる。 しかしながら、共有メモリー領域が B<SHM_HUGETLB> フラグを指定して作"
"成された場合には、ヒュージページ (huge page) の割り当てが 指定されたポリシー"
"にしたがって行われるのは、その領域に対して B<mbind>()  を呼び出したプロセスが"
"ページ割り当てのきっかけとなった場合のみである。"

#. type: Plain text
#: build/C/man2/mbind.2:126
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages "
"inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""
"デフォルトでは、 B<mbind>()  は新規のメモリー割り当てに対してのみ効果を持"
"つ。 ポリシーが設定される前にすでに使用されている範囲内のページに対しては、 "
"ポリシーは影響しない。 このデフォルトの動作は、以下で説明するフラグ "
"B<MPOL_MF_MOVE> や B<MPOL_MF_MOVE_ALL> により上書きされる可能性がある。"

#. type: Plain text
#: build/C/man2/mbind.2:141
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, or B<MPOL_PREFERRED>.  All policy modes except "
"B<MPOL_DEFAULT> require the caller to specify via the I<nodemask> argument, "
"the node or nodes to which the mode applies."
msgstr ""
"I<mode> 引き数には、 B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, "
"B<MPOL_PREFERRED> のいずれか一つを指定しなければならない。 B<MPOL_DEFAULT> 以"
"外のポリシーモードの場合、呼び出し元は I<nodemask> 引き数でそのポリシーモード"
"を適用するノードを指定する必要がある。"

#. type: Plain text
#: build/C/man2/mbind.2:149
msgid ""
"The I<mode> argument may also include an optional I<mode flag >.  The "
"supported I<mode flags> are:"
msgstr ""
"I<mode> 引き数には、追加で I<モードフラグ> を含めることもできる。 サポートさ"
"れている I<モードフラグ> は以下の通りである。"

#. type: TP
#: build/C/man2/mbind.2:149
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (Linux-2.6.26 以降)"

#. type: Plain text
#: build/C/man2/mbind.2:159
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux does not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""
"空でない I<nodemask> は、物理ノード ID である。 Linux では、そのプロセスが異"
"なる CPU 集合コンテキスト (cpuset context)  に移動した場合でも、そのプロセス"
"の現在の CPU 集合コンテキストで 許可されているノード集合が変化した場合でも、 "
"I<nodemask> をマッピングし直すことはない。"

#. type: TP
#: build/C/man2/mbind.2:159
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (Linux-2.6.26 以降)"

#. type: Plain text
#: build/C/man2/mbind.2:165 build/C/man2/set_mempolicy.2:113
msgid ""
"A nonempty I<nodemask> specifies node ids that are relative to the set of "
"node ids allowed by the process's current cpuset."
msgstr ""
"空でない I<nodemask> は、そのプロセスの現在の CPU 集合で許可されているノード "
"ID 集合 における相対的なノード ID である。"

#. type: Plain text
#: build/C/man2/mbind.2:193
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits.  "
"The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of "
"I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes.  "
"If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory."
msgstr ""
"I<nodemask> は、最大で I<maxnode> ビットから構成されるノードのビットマスクを"
"指す。 ビットマスクの大きさは、直近の I<sizeof(unsigned long)> の倍数に切り上"
"げられるが、カーネルが使用するのは I<maxnode> 個までのビットだけである。 "
"NULL 値の I<nodemask> もしくは値が 0 の I<maxnode> はノードの空集合を表す。 "
"I<maxnode> の値が 0 の場合、 I<nodemask> 引き数は無視される。 I<nodemask> が"
"必須の場面では、 I<nodemask> に、オンラインで、そのプロセスの現在の CPU 集合"
"コンテキストで 許可されており (B<MPOL_F_STATIC_NODES> モードフラグが指定され"
"ていない場合)、メモリーがあるノードが 少なくとも一つ入っていなければならな"
"い。"

#. type: Plain text
#: build/C/man2/mbind.2:215
msgid ""
"The B<MPOL_DEFAULT> mode requests that any nondefault policy be removed, "
"restoring default behavior.  When applied to a range of memory via "
"B<mbind>(), this means to use the process policy, which may have been set "
"with B<set_mempolicy>(2).  If the mode of the process policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The system-"
"wide default policy allocates pages on the node of the CPU that triggers the "
"allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and I<maxnode> arguments "
"must be specify the empty set of nodes."
msgstr ""
"モード B<MPOL_DEFAULT> はデフォルトではないプロセスのメモリーポリシーを削除"
"し、 デフォルトの動作に戻すことを指定するものである。 B<mbind>()  経由で、あ"
"るメモリー領域に対して B<MPOL_DEFAULT> が適用された場合、プロセスのデフォルト"
"ポリシーを使用することを意味する。 プロセスのデフォルトポリシーは、 "
"B<set_mempolicy>(2)  で変更されているかもしれない。 プロセスのポリシーのモー"
"ドも B<MPOL_DEFAULT> の場合、システム全体のデフォルトポリシーが使用される。 "
"システム全体のデフォルトポリシーでは、割り当てのきっかけとなった CPU のノード"
"からページの割り当てを行う。 B<MPOL_DEFAULT> では、引き数 I<nodemask> と "
"I<maxnode> にノードの空集合を指定しなければならない。"

#. type: Plain text
#: build/C/man2/mbind.2:232
msgid ""
"The B<MPOL_BIND> mode specifies a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest "
"numeric node ID first, until that node contains no free memory.  Allocations "
"will then come from the node with the next highest node ID specified in "
"I<nodemask> and so forth, until none of the specified nodes contain free "
"memory.  Pages will not be allocated from any node not specified in the "
"I<nodemask>."
msgstr ""
"B<MPOL_BIND> は厳しいポリシーで、メモリー割り当ては I<nodemask> に指定された"
"ノードに限定される。 他のノードへの割り当ては行われない。 I<nodemask> に 2 個"
"以上のノードが指定された場合、ページの割り当ては ノード ID が数字として最小の"
"ノードから開始され、 そのノードに空きメモリーがなくなるまでそのノードから "
"ページ割り当てが行われる。そのノードに空きメモリーがなくなったら、 次に小さな"
"ノード ID を持つノードからページ割り当てが行われる。 これを、 I<nodemask> で"
"指定された全てのノードで空きメモリーがなくなるまで繰り返す。 I<nodemask> で指"
"定された以外のノードからはページの割り当ては行われない。"

#. type: Plain text
#: build/C/man2/mbind.2:245
msgid ""
"The B<MPOL_INTERLEAVE> mode specifies that page allocations be interleaved "
"across the set of nodes specified in I<nodemask>.  This optimizes for "
"bandwidth instead of latency by spreading out pages and memory accesses to "
"those pages across multiple nodes.  To be effective the memory area should "
"be fairly large, at least 1MB or bigger with a fairly uniform access "
"pattern.  Accesses to a single page of the area will still be limited to the "
"memory bandwidth of a single node."
msgstr ""
"B<MPOL_INTERLEAVE> は、メモリー割り当てが I<nodemask> に指定されたノード間で"
"交互に行われることを指定するものである。 このポリシーでは、複数のノードにペー"
"ジを広げて配置し、これらのページへの メモリーアクセスを分散することで、遅延で"
"はなく、帯域を最適化する。 効果を得るには、メモリー領域をある程度大きくすべき"
"であり、 メモリーアクセスのパターンがかなり均一な場合でも 少なくとも 1MB 以上"
"にすべきである。 このモードでも、一つのページへのアクセスに関しては 一つの"
"ノードのメモリー帯域が上限となることは変わりない。"

#. type: Plain text
#: build/C/man2/mbind.2:264
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to other nodes if "
"the preferred nodes is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the memory is allocated on the node of the CPU that "
"triggered the allocation.  This is the only way to specify \"local allocation"
"\" for a range of memory via B<mbind>()."
msgstr ""
"B<MPOL_PREFERRED> は、割り当て時に優先されるノードを設定する。 カーネルはまず"
"優先ノードにページ割り当てを行おうとし、 優先ノードに空きメモリーが少ない場合"
"に他のノードに割り当てを行う。 I<nodemask> に複数のノード ID が指定された場合"
"は、 I<nodemask> 内の最初のノードが優先ノードとして選択される。 引き数 "
"I<nodemask>, I<maxnode> で空集合が指定された場合は、割り当てのきっかけとなっ"
"た CPU のノードに メモリー割り当てが行われる。 B<mbind>(2)  で、あるメモリー"
"領域に対して「ローカルからの割り当て (local allocation)」を 指定する方法はこ"
"れしかない。"

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: build/C/man2/mbind.2:280
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call will fail with the error B<EIO> if the "
"existing pages in the memory range don't follow the policy."
msgstr ""
"I<flags> に B<MPOL_MF_STRICT> が 指定され、 I<mode> が B<MPOL_DEFAULT> でない"
"場合、 指定されたポリシーに従っていないメモリー領域にページが存在すると、 "
"B<mbind>()  はエラー B<EIO> で失敗する。"

#. type: Plain text
#: build/C/man2/mbind.2:293
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to "
"move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call will fail with the error "
"B<EIO> if some pages could not be moved."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE> が指定されると、カーネルはそのメモリー領域内の既"
"存の全てのページを移動し、 指定されたポリシーに従うようにしようとする。 他の"
"プロセスと共有されているページは移動されない。 B<MPOL_MF_STRICT> も指定された"
"場合、移動できなかったページがあると、 B<mbind>()  はエラー B<EIO> で失敗す"
"る。"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:309
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling process must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call will fail with the error B<EIO> if some pages could "
"not be moved."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE_ALL> が指定されると、カーネルはそのメモリー領域内"
"の既存の全てのページを、 他のプロセスがページを使用しているかどうかに関わらず"
"移動する。 このフラグを使用するには、呼び出し元のプロセスは特権 "
"(B<CAP_SYS_NICE>)  を持っていなければならない。 B<MPOL_MF_STRICT> も指定され"
"た場合、移動できなかったページがあると、 B<mbind>()  はエラー B<EIO> で失敗す"
"る。"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:317
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<mbind>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> にエ"
"ラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/mbind.2:330
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range specified by I<addr> and I<len>."
msgstr ""
"I<nodemask> と I<maxnode> で指定されたメモリー領域の一部または全部が、 呼び出"
"し元がアクセス可能なアドレス空間外を指している。 もしくは I<addr> と I<len> "
"で指定されたメモリー領域にマップされていない部分 (unmapped hole)  があった、"

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/mbind.2:378
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was "
"less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or, "
"I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one or "
"more node IDs that are greater than the maximum supported node ID.  Or, none "
"of the node IDs specified by I<nodemask> are on-line and allowed by the "
"process's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr ""
"I<flags> や I<mode> に不正な値が指定された。 I<addr + len> が I<addr> より小"
"さい。 I<addr> がシステムのページサイズの倍数になっていない。 または I<mode> "
"が B<MPOL_DEFAULT> で I<nodemask> に空でない集合が指定された。 I<mode> が "
"B<MPOL_BIND> か B<MPOL_INTERLEAVE> で I<nodemask> が空であった。 I<maxnode> "
"がカーネルに適用された上限を超えている。 I<nodemask> に、サポートされている最"
"大ノード ID より大きいノードが指定された。 I<nodemask> に、オンラインで、かつ"
"そのプロセスの現在の CPU 集合コンテキストで 許可されているノードが一つも含ま"
"れていないか、 メモリーを含むノードが一つも指定されていない。 I<mode> 引き数"
"に B<MPOL_F_STATIC_NODES> と B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: TP
#: build/C/man2/mbind.2:378
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/mbind.2:389
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""
"B<MPOL_MF_STRICT> が指定されたが、このポリシーに従っていないノードに すでに"
"ページが存在していた。 もしくは B<MPOL_MF_MOVE> か B<MPOL_MF_MOVE_ALL> が指定"
"されたが、カーネルが指定された領域内の既存の全てのページを 移動することができ"
"なかった。"

#. type: TP
#: build/C/man2/mbind.2:389 build/C/man2/set_mempolicy.2:272
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/mbind.2:392 build/C/man2/set_mempolicy.2:275
msgid "Insufficient kernel memory was available."
msgstr "利用可能なカーネルメモリーが十分でなかった。"

#. type: TP
#: build/C/man2/mbind.2:392 build/C/man2/migrate_pages.2:97
#: build/C/man2/move_pages.2:180
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:402
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""
"I<flags> 引き数に B<MPOL_MF_MOVE_ALL> フラグが含まれているが、呼び出し元が "
"B<CAP_SYS_NICE> 特権を持たない。"

#. type: Plain text
#: build/C/man2/mbind.2:406
msgid ""
"The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""
"B<mbind>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加された。"

#. type: Plain text
#: build/C/man2/mbind.2:416
msgid ""
"NUMA policy is not supported on a memory-mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""
"NUMA ポリシーは、 B<MAP_SHARED> フラグが指定されてマップされたメモリーマップ"
"ファイルの領域では サポートされていない。"

#. type: Plain text
#: build/C/man2/mbind.2:448
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the process's policy reverts to system default policy "
"or local allocation.  When B<MPOL_DEFAULT> is specified for a range of "
"memory using B<mbind>(), any pages subsequently allocated for that range "
"will use the process's policy, as set by B<set_mempolicy>(2).  This "
"effectively removes the explicit policy from the specified range, \"falling "
"back\" to a possibly nondefault policy.  To select explicit \"local "
"allocation\" for a memory range, specify a I<mode> of B<MPOL_PREFERRED> with "
"an empty set of nodes.  This method will work for B<set_mempolicy>(2), as "
"well."
msgstr ""
"B<MPOL_DEFAULT> モードは、 B<mbind>()  と B<set_mempolicy>(2)  で異なる効果を"
"持つことができる。 B<set_mempolicy>(2)  で B<MPOL_DEFAULT> が指定された場合、"
"そのプロセスのポリシーはシステムの デフォルトポリシー、すなわちローカルからの"
"割り当て、に戻る。 B<mbind>()  を使ってメモリーのある領域に B<MPOL_DEFAULT> "
"が指定された場合、その範囲に対してそれ以降に行われるページの割り当てでは、 "
"B<set_mempolicy>(2)  で設定したのと同じように、そのプロセスのポリシーが適用さ"
"れる。 これにより、特定のメモリー領域についてだけ明示的なポリシーを削除し、 "
"デフォルトのポリシーに「戻す」ことができる。 あるメモリー領域に対して「ローカ"
"ルからの割り当て」を明示的に設定するには、 I<mode> に B<MPOL_PREFERRED> を指"
"定し、 I<nodemask> に空集合のノードを指定すればよい。 この方法は "
"B<set_mempolicy>(2)  でも通用する。"

#. type: Plain text
#: build/C/man2/mbind.2:452
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""
"2.6.16 でヒュージページポリシーへの対応が追加された。 インターリーブポリシー"
"がヒュージページのマッピングで効果を持つには、 ポリシーが適用されるメモリーが"
"数十メガバイト以上である必要がある。"

#. type: Plain text
#: build/C/man2/mbind.2:455
msgid "B<MPOL_MF_STRICT> is ignored on huge page mappings."
msgstr "B<MPOL_MF_STRICT> はヒュージページのマッピングでは無視される。"

#. type: Plain text
#: build/C/man2/mbind.2:460
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr ""
"B<MPOL_MF_MOVE> と B<MPOL_MF_MOVE_ALL> は Linux 2.6.16 以降でのみ利用可能であ"
"る。"

#. type: Plain text
#: build/C/man2/mbind.2:471
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2),\n"
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7),\n"
"B<numactl>(8)"

#. type: TH
#: build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr "MIGRATE_PAGES"

#. type: TH
#: build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "2012-08-01"
msgstr "2012-08-01"

#. type: Plain text
#: build/C/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr "migrate_pages - プロセスの全ページを別のノード集合に移動する"

#. type: Plain text
#: build/C/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"

#. type: Plain text
#: build/C/man2/migrate_pages.2:31 build/C/man2/move_pages.2:31
msgid "Link with I<-lnuma>."
msgstr "I<-lnuma> とリンクする。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages "
"not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr ""
"B<MIGRATE_PAGES>() は、メモリーノード I<old_nodes> にあるプロセス I<pid>\n"
"の全ページを、メモリーノード I<new_nodes> に移動しようとする。I<old_nodes> "
"で\n"
"指定されたメモリーノードに置かれていないページは移動されない。\n"
"カーネルは、 I<new_nodes> への移動の際に、 I<old_nodes> 内の相対的な\n"
"トポロジー関係を可能な限り維持しようとする。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""
"引き数 I<old_nodes> と I<new_nodes> は、最大で I<maxnode> ビットから\n"
"構成されるノード番号のビットマスクへのポインターである。\n"
"各ビットマスクは符号なし I<long> 整数の配列として管理される\n"
"(I<maxnode> で指定された長さを越えた部分のビットは無視される)。\n"
"引き数 I<maxnode> は最大ノード番号であり、ビットマスクの長さに 1 を\n"
"加えた値となる (これは B<mbind>(2) と同じだが、 B<select>(2) とは違う)。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""
"引き数 I<pid> は、移動を行うページの所有者のプロセス ID である。\n"
"別のプロセスのページを移動するには、呼び出したプロセスが特権\n"
"(B<CAP_SYS_NICE>) を持っているか、呼び出したプロセスの実ユーザー ID か\n"
"実効ユーザー ID がページ移動の対象プロセスの実ユーザー ID か saved-set \n"
"ユーザー ID と一致していなければならない。I<pid> が 0 の場合、\n"
"B<migrate_pages>() は呼び出したプロセスのページを移動する。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""
"別のプロセスと共有しているページは、呼び出したプロセスが\n"
"B<CAP_SYS_NICE> 特権を持っている場合にのみ移動される。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be "
"moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr ""
"B<migrate_pages>() は、移動できなかったページ数を返す\n"
"(つまり、移動に成功した場合は返り値は 0 となる)。\n"
"エラーの場合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:106
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""
"I<pid> で指定されたプロセスのページを移動するのに必要な特権\n"
"(B<CAP_SYS_NICE>) がなかった。または、指定された対象ノードにアクセス\n"
"するのに必要な権限 (B<CAP_SYS_NICE>) がなかった。"

#. type: TP
#: build/C/man2/migrate_pages.2:106 build/C/man2/move_pages.2:189
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#.  FIXME Document the other errors that can occur for migrate_pages()
#. type: Plain text
#: build/C/man2/migrate_pages.2:112
msgid "No process matching I<pid> could be found."
msgstr "プロセス ID が I<pid> のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:116
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr "B<migrate_pages>() システムコールは Linux 2.6.16 で初めて登場した。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:130
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""
"呼び出し元プロセスの CPU 集合で許可されているノード集合を取得するには、\n"
"B<MPOL_F_MEMS_ALLOWED> フラグを付けて B<get_mempolicy>(2) を使うこと。\n"
"この情報は、手動/自動に限らず CPU 集合の再構成によりいつでも\n"
"変更されることがある点に注意してほしい。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:142
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""
"B<migrate_pages> を使用すると、ページが置かれる場所 (ノード) が、指定\n"
"されたアドレスに対して設定されたメモリーポリシー (B<mbind>(2) 参照) や\n"
"指定されたプロセスに対して設定されたメモリーポリシー\n"
"(B<set_mempolicy>(2) 参照) に違反する状況になる可能性がある。\n"
"すなわち、メモリーポリシーによる制約は B<migrate_pages>() による移動先\n"
"ノードの選択には適用されないということである。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:148 build/C/man2/move_pages.2:227
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""
"ヘッダーファイル I<E<lt>numaif.hE<gt>> は glibc には含まれておらず、 "
"I<libnuma-devel> か同様のパッケージをインストールする必要がある。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:158 build/C/man2/move_pages.2:237
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numastat>(8)"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numastat>(8)"

#. type: Plain text
#: build/C/man2/migrate_pages.2:161
msgid "I<Documentation/vm/page_migration> in the Linux kernel source tree"
msgstr "Linux カーネルソースの I<Documentation/vm/page_migration>"

#. type: TH
#: build/C/man2/move_pages.2:19
#, no-wrap
msgid "MOVE_PAGES"
msgstr "MOVE_PAGES"

#. type: TH
#: build/C/man2/move_pages.2:19
#, no-wrap
msgid "2010-06-11"
msgstr "2010-06-11"

#. type: Plain text
#: build/C/man2/move_pages.2:22
msgid "move_pages - move individual pages of a process to another node"
msgstr "move_pages - あるプロセスの個々のページを別のノードに移動する"

#. type: Plain text
#: build/C/man2/move_pages.2:28
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"
msgstr ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/move_pages.2:44
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""
"B<move_pages>()  は、プロセス I<pid> の指定されたページ I<pages> を I<nodes> "
"で指定されたメモリーノードに移動する。 移動の結果は I<status> に反映される。 "
"I<flags> では移動されるページに関する制約を指定する。"

#. type: Plain text
#: build/C/man2/move_pages.2:57
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  To move "
"pages in another process, the caller must be privileged (B<CAP_SYS_NICE>)  "
"or the real or effective user ID of the calling process must match the real "
"or saved-set user ID of the target process.  If I<pid> is 0, then "
"B<move_pages>()  moves pages of the calling process."
msgstr ""
"I<pid> は、移動されるページが属するプロセスの ID である。 別のプロセスのペー"
"ジを移動するためには、呼び出し元が特権 (B<CAP_SYS_NICE>)  を持っているか、呼"
"び出したプロセスの実ユーザー ID か実効ユーザー ID が ページ移動対象のプロセス"
"の実ユーザー ID か保存 set-user-ID のどちらかと 一致しなければならない。 "
"I<pid> が 0 の場合、 B<move_pages>()  は呼び出したプロセスのページを移動す"
"る。"

#. type: Plain text
#: build/C/man2/move_pages.2:65
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""
"I<count> は移動するページ数である。 I<count> により I<pages>, I<nodes>, "
"I<status> の 3 つの配列の大きさが定義される。"

#.  FIXME Describe the result if pointers in the 'pages' array are
#.  not aligned to page boundaries
#. type: Plain text
#: build/C/man2/move_pages.2:73
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""
"I<pages> は、移動すべきページへのポインターの配列であり、 各ポインターはペー"
"ジ境界に揃えた値を指定すべきである。 I<pid> で指定されたプロセスで見えるアド"
"レスを指定する。"

#. type: Plain text
#: build/C/man2/move_pages.2:86
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""
"I<nodes> は、各ページの希望の移動場所を示す整数値の配列であり、 配列の各要素"
"はノード番号である。 I<nodes> には NULL を指定することもでき、この場合には "
"B<move_pages>()  はどのページも移動しないが、各ページが現在配置されているノー"
"ドを配列 I<status> に格納して返す。どのページを移動する必要があるかを判断する"
"ために、 各ページの状態の取得が必要な場合もある。"

#. type: Plain text
#: build/C/man2/move_pages.2:92
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an error."
msgstr ""
"I<status> は、各ページの状態を表す整数値の配列である。 この配列に有効な値が格"
"納されるのは、 B<move_pages>()  がエラーを返さなかった場合だけである。"

#. type: Plain text
#: build/C/man2/move_pages.2:104
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""
"I<flags> には、どの種類のページを移動するかを指定する。 B<MPOL_MF_MOVE> は、"
"そのプロセスが排他的に使用しているページだけを移動することを意味する。 "
"B<MPOL_MF_MOVE_ALL> は、複数のプロセス間で共有されているページも移動できるこ"
"とを意味する。 B<MPOL_MF_MOVE_ALL> を使用するためには、そのプロセスが特権 "
"(B<CAP_SYS_NICE>)  を持っていなければならない。"

#. type: SS
#: build/C/man2/move_pages.2:104
#, no-wrap
msgid "Page states in the status array"
msgstr "status 配列に格納されるページ状態"

#. type: Plain text
#: build/C/man2/move_pages.2:108
msgid ""
"The following values can be returned in each element of the I<status> array."
msgstr "I<status> 配列の各要素として、以下の値が返される。"

#. type: TP
#: build/C/man2/move_pages.2:108
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr "B<0..MAX_NUMNODES>"

#. type: Plain text
#: build/C/man2/move_pages.2:111
msgid "Identifies the node on which the page resides."
msgstr "そのページが配置されているノードを示す。"

#. type: TP
#: build/C/man2/move_pages.2:111
#, no-wrap
msgid "B<-EACCES>"
msgstr "B<-EACCES>"

#. type: Plain text
#: build/C/man2/move_pages.2:116
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""
"そのページは複数のプロセスによりマップされており、 B<MPOL_MF_MOVE_ALL> が指定"
"された場合にのみ移動できる。"

#. type: TP
#: build/C/man2/move_pages.2:116
#, no-wrap
msgid "B<-EBUSY>"
msgstr "B<-EBUSY>"

#. type: Plain text
#: build/C/man2/move_pages.2:122
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""
"そのページが現在ビジーであり、移動できない。後でもう一度試すこと。 この状況"
"は、ページが I/O の実行中であったり、カーネルの他のサブシステム がそのページ"
"への参照を保持している場合に発生する。"

#. type: TP
#: build/C/man2/move_pages.2:122
#, no-wrap
msgid "B<-EFAULT>"
msgstr "B<-EFAULT>"

#. type: Plain text
#: build/C/man2/move_pages.2:125
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""
"そのページが zero page であるか、そのメモリー領域はそのプロセスにより マップ"
"されていない。"

#. type: TP
#: build/C/man2/move_pages.2:125
#, no-wrap
msgid "B<-EIO>"
msgstr "B<-EIO>"

#. type: Plain text
#: build/C/man2/move_pages.2:132
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the filesystem does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""
"ページを書き戻す (write back) ことができない。 ページが dirty で、ファイルシ"
"ステムが dirty なページを移動できるような 移動機能を提供していないため、その"
"ページを移動するためにはページを 書き戻さなければならない。"

#. type: TP
#: build/C/man2/move_pages.2:132
#, no-wrap
msgid "B<-EINVAL>"
msgstr "B<-EINVAL>"

#. type: Plain text
#: build/C/man2/move_pages.2:137
msgid ""
"A dirty page cannot be moved.  The filesystem does not provide a migration "
"function and has no ability to write back pages."
msgstr ""
"dirty なページを移動できない。 ファイルシステムが dirty なページを移動するた"
"めの機能を提供しておらず、 ページを書き戻す能力もない。"

#. type: TP
#: build/C/man2/move_pages.2:137
#, no-wrap
msgid "B<-ENOENT>"
msgstr "B<-ENOENT>"

#. type: Plain text
#: build/C/man2/move_pages.2:140
msgid "The page is not present."
msgstr "ページが存在しない。"

#. type: TP
#: build/C/man2/move_pages.2:140
#, no-wrap
msgid "B<-ENOMEM>"
msgstr "B<-ENOMEM>"

#. type: Plain text
#: build/C/man2/move_pages.2:143
msgid "Unable to allocate memory on target node."
msgstr "移動先のノードでメモリーを確保することができない。"

#.  FIXME . Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: build/C/man2/move_pages.2:152
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets "
"I<errno> to indicate the error."
msgstr ""
"成功すると、 B<move_pages>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/move_pages.2:153
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/move_pages.2:156
msgid "Too many pages to move."
msgstr "移動すべきページが多過ぎる。"

#. type: TP
#: build/C/man2/move_pages.2:156
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  FIXME Clarify "current cpuset" in the description of the EACCESS error.
#.  Is that the cpuset of the caller or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:161
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr "移動先のノードのいずれかが現在の CPU 集合では許可されていない。"

#. type: Plain text
#: build/C/man2/move_pages.2:164
msgid "Parameter array could not be accessed."
msgstr "パラメーター配列にアクセスできなかった。"

#. type: Plain text
#: build/C/man2/move_pages.2:171
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an "
"attempt was made to migrate pages of a kernel thread."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE> でも B<MPOL_MF_MOVE_ALL> でもない値が指定された"
"か、カーネルスレッドのページを移動させようとした。"

#. type: TP
#: build/C/man2/move_pages.2:171
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/move_pages.2:174
msgid "One of the target nodes is not online."
msgstr "移動先のノードのいずれかがオンラインでない。"

#. type: TP
#: build/C/man2/move_pages.2:174
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/move_pages.2:180
msgid ""
"No pages were found that require moving.  All pages are either already on "
"the target node, not present, had an invalid address or could not be moved "
"because they were mapped by multiple processes."
msgstr ""
"移動が必要なページが全く見つからなかった。 指定された全てのページが、すでに移"
"動先のノードに存在するか、存在しないか、 無効なアドレスであったか、複数のプロ"
"セスによってマップされていて移動でき なかったか、のいずれかであった。"

#. type: Plain text
#: build/C/man2/move_pages.2:189
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""
"呼び出し元は B<MPOL_MF_MOVE_ALL> を指定したが、十分な特権 (B<CAP_SYS_NICE>)  "
"を持っていない。 または、呼び出し元が他のユーザーに属するプロセスのページを移"
"動しようとしたが、 それを行えるだけの特権 (B<CAP_SYS_NICE>)  を持っていなかっ"
"た。"

#. type: Plain text
#: build/C/man2/move_pages.2:192
msgid "Process does not exist."
msgstr "プロセスが存在しない。"

#. type: Plain text
#: build/C/man2/move_pages.2:195
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr "B<move_pages>()  は、バージョン 2.6.18 で初めて Linux に登場した。"

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:211
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""
"現在の CPU 集合で許可されているノードの集合を取得するには、フラグ "
"B<MPOL_F_MEMS_ALLOWED> を指定して B<get_mempolicy>(2)  を使用すればよい。 取"
"得した情報は、CPU 集合の手動または自動での再構成により いつ何時変化してしまう"
"か分からない。"

#. type: Plain text
#: build/C/man2/move_pages.2:221
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  and/"
"or the specified process (See B<set_mempolicy>(2)).  That is, memory policy "
"does not constrain the destination nodes used by B<move_pages>()."
msgstr ""
"この関数を使用すると、ページの位置 (ノード) が 指定されたアドレスに対して設定"
"されたメモリーポリシー (B<mbind>(2)  参照) や指定されたプロセスに対して設定さ"
"れたメモリーポリシー (B<set_mempolicy>(2)  参照) に違反してしまう可能性があ"
"る。 つまり、メモリーポリシーは B<move_pages>()  で使われる移動先ノードを制限"
"しないということである。"

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "NUMA"
msgstr "NUMA"

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: build/C/man7/numa.7:32
msgid "numa - overview of Non-Uniform Memory Architecture"
msgstr "numa - 非対称型メモリーアーキテクチャーの概要"

#. type: Plain text
#: build/C/man7/numa.7:43
msgid ""
"Non-Uniform Memory Access (NUMA) refers to multiprocessor systems whose "
"memory is divided into multiple memory nodes.  The access time of a memory "
"node depends on the relative locations of the accessing CPU and the accessed "
"node.  (This contrasts with a symmetric multiprocessor system, where the "
"access time for all of the memory is the same for all CPUs.)  Normally, each "
"CPU on a NUMA system has a local memory node whose contents can be accessed "
"faster than the memory in the node local to another CPU or the memory on a "
"bus shared by all CPUs."
msgstr ""
"非対称型メモリーアクセス (Non-Uniform Memory Access; NUMA) は、\n"
"メモリーが複数のメモリーノードに分割されているマルチプロセッサシステム\n"
"のことである。メモリーノードへのアクセス時間は、アクセス元の CPU と\n"
"アクセス先のノードの相対的な位置関係に依存する\n"
"(これに対し、対称型マルチプロセッサシステムでは、どの CPU から\n"
"どのメモリーへのアクセス時間も同じである)。\n"
"通常は、 NUMA システムの各 CPU にはローカルのメモリーノードがあり、\n"
"そのメモリーノードには、他の CPU のローカルノードや全ての CPU で\n"
"共有されるバス上のメモリーよりも早くアクセスすることができる。"

#. type: SS
#: build/C/man7/numa.7:43
#, no-wrap
msgid "NUMA system calls"
msgstr "NUMA システムコール"

#. type: Plain text
#: build/C/man7/numa.7:54
msgid ""
"The Linux kernel implements the following NUMA-related system calls: "
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2), B<move_pages>(2), and "
"B<set_mempolicy>(2).  However, applications should normally use the "
"interface provided by I<libnuma>; see \"Library Support\" below."
msgstr ""
"Linux カーネルには、次に示す NUMA 関連のシステムコールが実装されている:\n"
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2),\n"
"B<move_pages>(2), B<set_mempolicy>(2).\n"
"ただし、アプリケーションは通常は I<libnuma> が提供するインターフェース\n"
"を使用すべきである。下記の「ライブラリによるサポート」を参照。"

#. type: SS
#: build/C/man7/numa.7:54
#, no-wrap
msgid "/proc/[number]/numa_maps (since Linux 2.6.14)"
msgstr "/proc/[number]/numa_maps (Linux 2.6.14 以降)"

#.  See also Changelog-2.6.14
#. type: Plain text
#: build/C/man7/numa.7:58
msgid ""
"This file displays information about a process's NUMA memory policy and "
"allocation."
msgstr ""
"このファイルは、プロセスの NUMA メモリーポリシーと割り当てに関する\n"
"情報を表示する。"

#. type: Plain text
#: build/C/man7/numa.7:62
msgid ""
"Each line contains information about a memory range used by the process, "
"displaying\\(emamong other information\\(emthe effective memory policy for "
"that memory range and on which nodes the pages have been allocated."
msgstr ""
"各行に、そのプロセスが使用しているメモリー領域に関する情報が表示される。その"
"他の情報 \\(em そのメモリー領域に適用されているメモリーポリシーや、そのページ"
"がどのノード上に割り当てられているか、など \\(em もあわせて表示される。"

#. type: Plain text
#: build/C/man7/numa.7:70
msgid ""
"I<numa_maps> is a read-only file.  When I</proc/E<lt>pidE<gt>/numa_maps> is "
"read, the kernel will scan the virtual address space of the process and "
"report how memory is used.  One line is displayed for each unique memory "
"range of the process."
msgstr ""
"I<numa_maps> は読み出し専用のファイルである。 I</proc/E<lt>pidE<gt>/"
"numa_maps> から読み出しが行われると、 カーネルはそのプロセスの仮想アドレス空"
"間をスキャンし、 メモリーの使用状況を報告する。\n"
"プロセスのメモリー領域の情報が 1 行に 1 領域で表示される。"

#. type: Plain text
#: build/C/man7/numa.7:77
msgid ""
"The first field of each line shows the starting address of the memory "
"range.  This field allows a correlation with the contents of the I</proc/"
"E<lt>pidE<gt>/maps> file, which contains the end address of the range and "
"other information, such as the access permissions and sharing."
msgstr ""
"各行の最初のフィールドはメモリー領域の開始アドレスを示す。 このフィールドは "
"I</proc/E<lt>pidE<gt>/maps> ファイルの内容と対応している。 I</proc/"
"E<lt>pidE<gt>/maps> には、メモリー領域の末尾のアドレスや、アクセス許可や共有"
"といった他の情報も含まれる。"

#. type: Plain text
#: build/C/man7/numa.7:85
msgid ""
"The second field shows the memory policy currently in effect for the memory "
"range.  Note that the effective policy is not necessarily the policy "
"installed by the process for that memory range.  Specifically, if the "
"process installed a \"default\" policy for that range, the effective policy "
"for that range will be the process policy, which may or may not be \"default"
"\"."
msgstr ""
"2 番目のフィールドは、 そのメモリー領域に現在適用されているメモリーポリシーを"
"示す。 適用されているポリシーは、 必ずしもそのプロセスがこのメモリー領域に対"
"して設定したポリシーとは限らない点に注意すること。\n"
"特に、 プロセスがその領域に対して「デフォルト」ポリシーを設定した場合、その領"
"域に適用されるポリシーはプロセスのポリシーとなり、それが「デフォルト」ポリ"
"シーとなる場合もあればそうでない場合もある。"

#. type: Plain text
#: build/C/man7/numa.7:88
msgid ""
"The rest of the line contains information about the pages allocated in the "
"memory range, as follows:"
msgstr ""
"行の残りの部分には、そのメモリー領域に割り当てられたページに関する情報が入"
"る。以下に詳細を示す。"

#. type: TP
#: build/C/man7/numa.7:88
#, no-wrap
msgid "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"
msgstr "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:101
msgid ""
"The number of pages allocated on I<E<lt>nodeE<gt>>.  I<E<lt>nr_pagesE<gt>> "
"includes only pages currently mapped by the process.  Page migration and "
"memory reclaim may have temporarily unmapped pages associated with this "
"memory range.  These pages may show up again only after the process has "
"attempted to reference them.  If the memory range represents a shared memory "
"area or file mapping, other processes may currently have additional pages "
"mapped in a corresponding memory range."
msgstr ""
"I<E<lt>nodeE<gt>> に割り当てられているページ数。 I<E<lt>nr_pagesE<gt>> に"
"は、 そのプロセスが現在マッピングしているページだけが含まれる。 ページの移動"
"やメモリーの再利用により、 このメモリー領域に関連付けられているが、 一時的に"
"マッピングされていないページが存在する場合がある。 プロセスがそれらのページを"
"参照しようとした後には、 これらのページは再び現れる可能性がある。 メモリー領"
"域が共有メモリーやファイルマッピングの場合には、 そのメモリー領域内に別のペー"
"ジを他のプロセスがマッピングしている場合もある。"

#. type: TP
#: build/C/man7/numa.7:101
#, no-wrap
msgid "I<file=E<lt>filenameE<gt>>"
msgstr "I<file=E<lt>filenameE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:107
msgid ""
"The file backing the memory range.  If the file is mapped as private, write "
"accesses may have generated COW (Copy-On-Write) pages in this memory range.  "
"These pages are displayed as anonymous pages."
msgstr ""
"そのメモリー領域に関連付けられているファイル。 ファイルがプライベート (非公"
"開) でマッピングされている場合、 書き込みアクセスがあると、 このメモリー領域"
"に書き込み時コピー (Copy-On-Write) ページが生成されることがある。 これらの"
"ページは無名ページ (anonymous page) として表示される。"

#. type: TP
#: build/C/man7/numa.7:107
#, no-wrap
msgid "I<heap>"
msgstr "I<heap>"

#. type: Plain text
#: build/C/man7/numa.7:110
msgid "Memory range is used for the heap."
msgstr "ヒープに使用されているメモリー範囲。"

#. type: TP
#: build/C/man7/numa.7:110
#, no-wrap
msgid "I<stack>"
msgstr "I<stack>"

#. type: Plain text
#: build/C/man7/numa.7:113
msgid "Memory range is used for the stack."
msgstr "スタックに使用されているメモリー範囲。"

#. type: TP
#: build/C/man7/numa.7:113
#, no-wrap
msgid "I<huge>"
msgstr "I<huge>"

#. type: Plain text
#: build/C/man7/numa.7:117
msgid ""
"Huge memory range.  The page counts shown are huge pages and not regular "
"sized pages."
msgstr ""
"ヒュージメモリーの範囲。表示されるページ数は、\n"
"通常の大きさのページではなく、ヒュージページの数である。"

#. type: TP
#: build/C/man7/numa.7:117
#, no-wrap
msgid "I<anon=E<lt>pagesE<gt>>"
msgstr "I<anon=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:120
msgid "The number of anonymous page in the range."
msgstr "メモリー範囲内の無名ページ (anonymous page) の数。"

#. type: TP
#: build/C/man7/numa.7:120
#, no-wrap
msgid "I<dirty=E<lt>pagesE<gt>>"
msgstr "I<dirty=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:123
msgid "Number of dirty pages."
msgstr "dirty (変更された) ページの数。"

#. type: TP
#: build/C/man7/numa.7:123
#, no-wrap
msgid "I<mapped=E<lt>pagesE<gt>>"
msgstr "I<mapped=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:130
msgid ""
"Total number of mapped pages, if different from I<dirty> and I<anon> pages."
msgstr ""
"マッピングされているページ数。 I<dirty> および I<anon> のページ数と異なる値の"
"場合に表示される。"

#. type: TP
#: build/C/man7/numa.7:130
#, no-wrap
msgid "I<mapmax=E<lt>countE<gt>>"
msgstr "I<mapmax=E<lt>countE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:136
msgid ""
"Maximum mapcount (number of processes mapping a single page) encountered "
"during the scan.  This may be used as an indicator of the degree of sharing "
"occurring in a given memory range."
msgstr ""
"スキャン中に検出した mapcount (一つのページをマッピングしているプロセス数) の"
"最大値。 この値は、 そのメモリー領域でどの程度の共有が行われているかの指標と"
"して使うことができる。"

#. type: TP
#: build/C/man7/numa.7:136
#, no-wrap
msgid "I<swapcache=E<lt>countE<gt>>"
msgstr "I<swapcache=E<lt>countE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:139
msgid "Number of pages that have an associated entry on a swap device."
msgstr "スワップデバイスに対応するエントリーが存在するページ数。"

#. type: TP
#: build/C/man7/numa.7:139
#, no-wrap
msgid "I<active=E<lt>pagesE<gt>>"
msgstr "I<active=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:145
msgid ""
"The number of pages on the active list.  This field is shown only if "
"different from the number of pages in this range.  This means that some "
"inactive pages exist in the memory range that may be removed from memory by "
"the swapper soon."
msgstr ""
"アクティブリストに入っているページ数。 このフィールドが表示されるのは、 値が"
"このメモリー領域のページ数と異なる場合だけである。このフィールドが表示される"
"ということは、 このメモリー領域に、まもなくスワッパ (swapper) によりこの領域"
"から削除される可能性がある inactive なページが存在することを意味する。"

#. type: TP
#: build/C/man7/numa.7:145
#, no-wrap
msgid "I<writeback=E<lt>pagesE<gt>>"
msgstr "I<writeback=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:148
msgid "Number of pages that are currently being written out to disk."
msgstr "現在ディスクに書き出されているページ数。"

#. type: Plain text
#: build/C/man7/numa.7:150
msgid "No standards govern NUMA interfaces."
msgstr "NUMA インターフェースについて規定している標準はない。"

#. type: Plain text
#: build/C/man7/numa.7:157
msgid ""
"The Linux NUMA system calls and I</proc> interface are available only if the "
"kernel was configured and built with the B<CONFIG_NUMA> option."
msgstr ""
"Linux の NUMA システムコールと I</proc> インターフェースは、カーネルが\n"
"設定オプション B<CONFIG_NUMA> を有効にして作成されている場合のみ、利用\n"
"可能である。"

#. type: SS
#: build/C/man7/numa.7:157
#, no-wrap
msgid "Library support"
msgstr "ライブラリによるサポート"

#. type: Plain text
#: build/C/man7/numa.7:166
msgid ""
"Link with I<-lnuma> to get the system call definitions.  I<libnuma> and the "
"required I<E<lt>numaif.hE<gt>> header are available in the I<numactl> "
"package."
msgstr ""
"システムコールの定義を得るには I<-lnuma> でリンクすること。\n"
"I<libnuma> と必要なヘッダーファイル I<E<lt>numaif.hE<gt>> は\n"
"I<numactl> パッケージで提供されている。"

#. type: Plain text
#: build/C/man7/numa.7:183
msgid ""
"However, applications should not use these system calls directly.  Instead, "
"the higher level interface provided by the B<numa>(3)  functions in the "
"I<numactl> package is recommended.  The I<numactl> package is available at "
"E<.UR ftp://oss.sgi.com\\:/www\\:/projects\\:/libnuma\\:/download/> E<.UE .> "
"The package is also included in some Linux distributions.  Some "
"distributions include the development library and header in the separate "
"I<numactl-devel> package."
msgstr ""
"ただし、アプリケーションはこれらのシステムコールを直接利用すべきでない。\n"
"推奨される方法は、I<numactl> パッケージの B<numa>(3) の関数群が提供する\n"
"高レベルインターフェースの利用である。 I<numactl> パッケージは\n"
"E<.UR ftp://oss.sgi.com\\:/www\\:/projects\\:/libnuma\\:/download/> E<.UE> で"
"入手できる。\n"
"このパッケージが収録されている Linux ディストリビューションもある。\n"
"ディストリビューションによっては、開発用のライブラリとヘッダーファイルは\n"
"別パッケージ I<numactl-devel> で提供されている。"

#. type: Plain text
#: build/C/man7/numa.7:191
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr "SET_MEMPOLICY"

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:30
msgid ""
"set_mempolicy - set default NUMA memory policy for a process and its children"
msgstr ""
"set_mempolicy - プロセスとその子プロセスの NUMA メモリーの デフォルトポリシー"
"を設定する"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"
msgstr ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling process, "
"which consists of a policy mode and zero or more nodes, to the values "
"specified by the I<mode>, I<nodemask> and I<maxnode> arguments."
msgstr ""
"B<set_mempolicy>()  は、呼び出し元プロセスの NUMA ポリシーを I<policy> に設定"
"する。 NUMA ポリシーはポリシーモードと 0 個以上のノードから構成され、 設定内"
"容は引き数 I<mode>, I<nodemask>, I<maxnode> により指定される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the process.  The process "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"process default policy also controls allocation of any pages for memory-"
"mapped files mapped using the B<mmap>(2)  call with the B<MAP_PRIVATE> flag "
"and that are only read [loaded] from by the process and of memory-mapped "
"files mapped using the B<mmap>(2)  call with the B<MAP_SHARED> flag, "
"regardless of the access type.  The policy is applied only when a new page "
"is allocated for the process.  For anonymous memory this is when the page is "
"first touched by the application."
msgstr ""
"B<set_mempolicy>()  は、プロセスのデフォルトポリシーを定める。 プロセスのポリ"
"シーは、 B<mbind>(2)  で設定される特定のポリシーにより制御されるメモリー領域"
"以外の プロセスのアドレス空間におけるページの割り当てに適用される。 プロセス"
"のデフォルトポリシーは、 B<MAP_PRIVATE> フラグを指定した B<mmap>(2)  を使って"
"マップされたメモリーマップファイルに対する読み出し専用 (ロードされるだけ) の"
"ページの割り当てにも適用される。 また、 B<MAP_SHARED> フラグを指定した "
"B<mmap>(2)  を使ってマップされたメモリーマップファイルに対するページの割り当"
"てにも 適用される (この場合はページのアクセス種別に関わらず適用される) 。 設"
"定したポリシーは、プロセスに新規のページが割り当てられるときにのみ 適用され"
"る。無名メモリー (anonymous memory) の場合、新規ページの割り当ては アプリケー"
"ションが初めてページにアクセスした際に行われる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:89
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, or B<MPOL_PREFERRED>.  All modes except B<MPOL_DEFAULT> "
"require the caller to specify via the I<nodemask> argument one or more nodes."
msgstr ""
"I<mode> 引き数には B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, "
"B<MPOL_PREFERRED> のいずれか一つを指定してしなければならない。 "
"B<MPOL_DEFAULT> 以外のポリシーの場合、呼び出し元は I<nodemask> 引き数で一つ以"
"上のノードを指定する必要がある。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:97
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""
"I<mode> 引き数には、追加で I<モードフラグ> を含めることもできる。 サポートさ"
"れている I<モードフラグ> は以下の通りである。"

#. type: TP
#: build/C/man2/set_mempolicy.2:97
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:107
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux will not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""
"空でない I<nodemask> は、物理ノード ID である。 Linux では、そのプロセスが異"
"なる CPU 集合コンテキスト (cpuset context)  に移動した場合でも、そのプロセス"
"の現在の CPU 集合コンテキストで 許可されているノード集合が変化した場合でも、 "
"I<nodemask> をマッピングし直すことはない。"

#. type: TP
#: build/C/man2/set_mempolicy.2:107
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:133
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr ""
"I<nodemask> は、最大で I<maxnode> ビットから構成されるノード ID のビットマス"
"クを指す。 ビットマスクの大きさは、直近の I<sizeof(unsigned long)> の倍数に切"
"り上げられるが、カーネルが使用するのは I<maxnode> 個までのビットだけである。 "
"NULL 値の I<nodemask> もしくは値が 0 の I<maxnode> はノードの空集合を表す。 "
"I<maxnode> の値が 0 の場合、 I<nodemask> 引き数は無視される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:154
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""
"I<nodemask> が必須の場面では、 I<nodemask> に、オンラインで、そのプロセスの現"
"在の CPU 集合コンテキストで 許可されており (B<MPOL_F_STATIC_NODES> モードフラ"
"グが指定されていない場合)、メモリーがあるノードが 少なくとも一つ入っていなけ"
"ればならない。 I<mode> に B<MPOL_F_STATIC_NODES> がセットされ、 I<nodemask> "
"が必須の場面で、 I<nodemask> に、そのプロセスの現在の CPU 集合コンテキストで"
"許可されたノードが 一つも含まれていない場合には、メモリーのポリシーとしてデ"
"フォルトの 「ローカルから割り当て (local allocation)」が適用される。 そのプロ"
"セスの CPU 集合コンテキストが I<nodemask> で指定されたノードを少なくとも一つ"
"含むようになるまでは、 結果的に指定された動作が上書きされることになる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:165
msgid ""
"The B<MPOL_DEFAULT> mode specifies that any nondefault process memory policy "
"be removed, so that the memory policy \"falls back\" to the system default "
"policy.  The system default policy is \"local allocation\"\\(emthat is, "
"allocate memory on the node of the CPU that triggered the allocation.  "
"I<nodemask> must be specified as NULL.  If the \"local node\" contains no "
"free memory, the system will attempt to allocate memory from a \"near by\" "
"node."
msgstr ""
"B<MPOL_DEFAULT> モードは、デフォルトではないプロセスのメモリーポリシーを削除"
"することを 指定するものである。これにより、メモリーポリシーはシステムの デ"
"フォルトポリシーに「戻る」ことになる。 システムのデフォルトポリシーは「ローカ"
"ルからの割り当て (local allocation)」、 つまりメモリー割り当てのきっかけと"
"なった CPU のノードのメモリーが割り当てられる。 I<nodemask> には NULL を指定"
"しなければならない。 「自ノード (local node)」に空きメモリーが全くない場合、"
"システムは 「近くの (near by) ノード」からメモリーを割り当てようと試みる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:182
msgid ""
"The B<MPOL_BIND> mode defines a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest "
"numeric node ID first, until that node contains no free memory.  Allocations "
"will then come from the node with the next highest node ID specified in "
"I<nodemask> and so forth, until none of the specified nodes contain free "
"memory.  Pages will not be allocated from any node not specified in the "
"I<nodemask>."
msgstr ""
"B<MPOL_BIND> モードは厳密なポリシーで、メモリー割り当ては I<nodemask> に指定"
"されたノードに限定される。 I<nodemask> に 2 個以上のノードが指定された場合、"
"ページの割り当ては ノード ID が数字として最小のノードから開始され、 そのノー"
"ドに空きメモリーがなくなるまでそのノードから ページ割り当てが行われる。その"
"ノードに空きメモリーがなくなったら、 次に小さなノード ID を持つノードからペー"
"ジ割り当てが行われる。 これを、 I<nodemask> で指定された全てのノードで空きメ"
"モリーがなくなるまで繰り返す。 I<nodemask> で指定された以外のノードからはペー"
"ジの割り当ては行われない。"

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1MB or bigger.
#. type: Plain text
#: build/C/man2/set_mempolicy.2:196
msgid ""
"B<MPOL_INTERLEAVE> interleaves page allocations across the nodes specified "
"in I<nodemask> in numeric node ID order.  This optimizes for bandwidth "
"instead of latency by spreading out pages and memory accesses to those pages "
"across multiple nodes.  However, accesses to a single page will still be "
"limited to the memory bandwidth of a single node."
msgstr ""
"B<MPOL_INTERLEAVE> では、ページ割り当てを I<nodemask> に指定されたノードの間"
"でノード ID の数字順で交互に行う。 このポリシーでは、複数のノードにページを広"
"げて配置し、これらのページへのメモリー アクセスを分散することで、遅延ではな"
"く、帯域を最適化する。 ただし、一つのページへのアクセスに関しては依然として一"
"つのノードのメモリー帯域 が上限となる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:213
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to \"near by\" "
"nodes if the preferred node is low on free memory.  If I<nodemask> specifies "
"more than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr ""
"B<MPOL_PREFERRED> は、割り当て時に優先されるノード (preferred node) を設定す"
"る。 カーネルはまず優先ノードからページ割り当てを行おうとし、 優先ノードに空"
"きメモリーが少ない場合に「近くの (near by)」ノードから 割り当てを行う。 "
"I<nodemask> に複数のノード ID が指定された場合は、 I<nodemask> 内の最初のノー"
"ドが優先ノードとして選択される。 引き数 I<nodemask>, I<maxnode> で空集合が指"
"定された場合は、ポリシーは (上述のシステムの デフォルトポリシーと同様に) "
"「ローカルからの割り当て」となる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:220
msgid ""
"The process memory policy is preserved across an B<execve>(2), and is "
"inherited by child processes created using B<fork>(2)  or B<clone>(2)."
msgstr ""
"プロセスのメモリーポリシーは B<execve>(2)  の前後で保持され、 B<fork>(2)  や "
"B<clone>(2)  を使って作成された子プロセスに継承される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:227
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<set_mempolicy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:272
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are on-"
"line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""
"I<mode> が不正である。 I<mode> が B<MPOL_DEFAULT> で、 I<nodemask> が空ではな"
"い。 I<mode> が B<MPOL_BIND> か B<MPOL_INTERLEAVE> で、 I<nodemask> が空であ"
"る。 I<maxnode> で実際に意味があるビット数より多くのビット数が指定された。 "
"I<nodemask> に、サポートされている最大ノード ID より大きいノードが指定され"
"た。 I<nodemask> に、オンラインで、かつそのプロセスの現在の CPU 集合コンテキ"
"ストで 許可されているノードが一つも含まれていないか、 メモリーを含むノードが"
"一つも指定されていない。 I<mode> 引き数に B<MPOL_F_STATIC_NODES> と "
"B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:279
msgid ""
"The B<set_mempolicy>(), system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""
"B<set_mempolicy>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加"
"された。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:286
msgid ""
"Process policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the process or memory range "
"that is in effect at the time the page is allocated."
msgstr ""
"ページがスワップアウトされる場合には、 プロセスポリシーの設定は推奨されな"
"い。 スワップアウトされたページがページインする際にも、 ページ割り当て時に適"
"用されるプロセスポリシーやメモリー領域ポリシーが 使用される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:298
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
