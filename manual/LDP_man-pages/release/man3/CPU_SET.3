.\" Copyright (C) 2006 Michael Kerrisk
.\" and Copyright (C) 2008 Linux Foundation, written by Michael Kerrisk
.\"     <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CPU_SET 3 2012\-03\-15 Linux "Linux Programmer's Manual"
.SH 名前
CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR,
CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S,
CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S,
CPU_EQUAL_S \- macros for manipulating CPU sets
.SH 書式
.nf
\fB#define _GNU_SOURCE\fP             /* feature_test_macros(7) 参照 */
\fB#include <sched.h>\fP
.sp
\fBvoid CPU_ZERO(cpu_set_t *\fP\fIset\fP\fB);\fP
.sp
\fBvoid CPU_SET(int \fP\fIcpu\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
\fBvoid CPU_CLR(int \fP\fIcpu\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
\fBint  CPU_ISSET(int \fP\fIcpu\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
.sp
\fBint  CPU_COUNT(cpu_set_t *\fP\fIset\fP\fB);\fP
.sp
\fBvoid CPU_AND(cpu_set_t *\fP\fIdestset\fP\fB,\fP
\fB             cpu_set_t *\fP\fIsrcset1\fP\fB, cpu_set_t *\fP\fIsrcset2\fP\fB);\fP
\fBvoid CPU_OR(cpu_set_t *\fP\fIdestset\fP\fB,\fP
\fB             cpu_set_t *\fP\fIsrcset1\fP\fB, cpu_set_t *\fP\fIsrcset2\fP\fB);\fP
\fBvoid CPU_XOR(cpu_set_t *\fP\fIdestset\fP\fB,\fP
\fB             cpu_set_t *\fP\fIsrcset1\fP\fB, cpu_set_t *\fP\fIsrcset2\fP\fB);\fP
.sp
\fBint  CPU_EQUAL(cpu_set_t *\fP\fIset1\fP\fB, cpu_set_t *\fP\fIset2\fP\fB);\fP
.sp
\fBcpu_set_t *CPU_ALLOC(int \fP\fInum_cpus\fP\fB);\fP
\fBvoid CPU_FREE(cpu_set_t *\fP\fIset\fP\fB);\fP
\fBsize_t CPU_ALLOC_SIZE(int \fP\fInum_cpus\fP\fB);\fP
.sp
\fBvoid CPU_ZERO_S(size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
.sp
\fBvoid CPU_SET_S(int \fP\fIcpu\fP\fB, size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
\fBvoid CPU_CLR_S(int \fP\fIcpu\fP\fB, size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
\fBint  CPU_ISSET_S(int \fP\fIcpu\fP\fB, size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
.sp
\fBint  CPU_COUNT_S(size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIset\fP\fB);\fP
.sp
\fBvoid CPU_AND_S(size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIdestset\fP\fB,\fP
\fB             cpu_set_t *\fP\fIsrcset1\fP\fB, cpu_set_t *\fP\fIsrcset2\fP\fB);\fP
\fBvoid CPU_OR_S(size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIdestset\fP\fB,\fP
\fB             cpu_set_t *\fP\fIsrcset1\fP\fB, cpu_set_t *\fP\fIsrcset2\fP\fB);\fP
\fBvoid CPU_XOR_S(size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIdestset\fP\fB,\fP
\fB             cpu_set_t *\fP\fIsrcset1\fP\fB, cpu_set_t *\fP\fIsrcset2\fP\fB);\fP
.sp
\fBint  CPU_EQUAL_S(size_t \fP\fIsetsize\fP\fB, cpu_set_t *\fP\fIset1\fP\fB, cpu_set_t *\fP\fIset2\fP\fB);\fP
.fi
.SH 説明
The \fIcpu_set_t\fP data structure represents a set of CPUs.  CPU sets are used
by \fBsched_setaffinity\fP(2)  and similar interfaces.

The \fIcpu_set_t\fP data type is implemented as a bitset.  However, the data
structure treated as considered opaque: all manipulation of CPU sets should
be done via the macros described in this page.

The following macros are provided to operate on the CPU set \fIset\fP:
.TP  17
\fBCPU_ZERO\fP()
Clears \fIset\fP, so that it contains no CPUs.
.TP 
\fBCPU_SET\fP()
Add CPU \fIcpu\fP to \fIset\fP.
.TP 
\fBCPU_CLR\fP()
Remove CPU \fIcpu\fP from \fIset\fP.
.TP 
\fBCPU_ISSET\fP()
Test to see if CPU \fIcpu\fP is a member of \fIset\fP.
.TP 
\fBCPU_COUNT\fP()
Return the number of CPUs in \fIset\fP.
.PP
Where a \fIcpu\fP argument is specified, it should not produce side effects,
since the above macros may evaluate the argument more than once.
.PP
The first available CPU on the system corresponds to a \fIcpu\fP value of 0,
the next CPU corresponds to a \fIcpu\fP value of 1, and so on.  The constant
\fBCPU_SETSIZE\fP (currently 1024) specifies a value one greater than the
maximum CPU number that can be stored in \fIcpu_set_t\fP.

The following macros perform logical operations on CPU sets:
.TP  17
\fBCPU_AND\fP()
Store the intersection of the sets \fIsrcset1\fP and \fIsrcset2\fP in \fIdestset\fP
(which may be one of the source sets).
.TP 
\fBCPU_OR\fP()
Store the union of the sets \fIsrcset1\fP and \fIsrcset2\fP in \fIdestset\fP (which
may be one of the source sets).
.TP 
\fBCPU_XOR\fP()
Store the XOR of the sets \fIsrcset1\fP and \fIsrcset2\fP in \fIdestset\fP (which may
be one of the source sets).  The XOR means the set of CPUs that are in
either \fIsrcset1\fP or \fIsrcset2\fP, but not both.
.TP 
\fBCPU_EQUAL\fP()
Test whether two CPU set contain exactly the same CPUs.
.SS "Dynamically sized CPU sets"
Because some applications may require the ability to dynamically size CPU
sets (e.g., to allocate sets larger than that defined by the standard
\fIcpu_set_t\fP data type), glibc nowadays provides a set of macros to support
this.

The following macros are used to allocate and deallocate CPU sets:
.TP  17
\fBCPU_ALLOC\fP()
Allocate a CPU set large enough to hold CPUs in the range 0 to
\fInum_cpus\-1\fP.
.TP 
\fBCPU_ALLOC_SIZE\fP()
Return the size in bytes of the CPU set that would be needed to hold CPUs in
the range 0 to \fInum_cpus\-1\fP.  This macro provides the value that can be
used for the \fIsetsize\fP argument in the \fBCPU_*_S\fP()  macros described
below.
.TP 
\fBCPU_FREE\fP()
Free a CPU set previously allocated by \fBCPU_ALLOC\fP().
.PP
The macros whose names end with "_S" are the analogs of the similarly named
macros without the suffix.  These macros perform the same tasks as their
analogs, but operate on the dynamically allocated CPU set(s) whose size is
\fIsetsize\fP bytes.
.SH 返り値
\fBCPU_ISSET\fP()  and \fBCPU_ISSET_S\fP()  return nonzero if \fIcpu\fP is in \fIset\fP;
otherwise, it returns 0.

\fBCPU_COUNT\fP()  and \fBCPU_COUNT_S\fP()  return the number of CPUs in \fIset\fP.

\fBCPU_EQUAL\fP()  and \fBCPU_EQUAL_S\fP()  return nonzero if the two CPU sets are
equal; otherwise it returns 0.

\fBCPU_ALLOC\fP()  returns a pointer on success, or NULL on failure.  (Errors
are as for \fBmalloc\fP(3).)

\fBCPU_ALLOC_SIZE\fP()  returns the number of bytes required to store a CPU set
of the specified cardinality.

The other functions do not return a value.
.SH バージョン
The \fBCPU_ZERO\fP(), \fBCPU_SET\fP(), \fBCPU_CLR\fP(), and \fBCPU_ISSET\fP()  macros
were added in glibc 2.3.3.

\fBCPU_COUNT\fP()  first appeared in glibc 2.6.

\fBCPU_AND\fP(), \fBCPU_OR\fP(), \fBCPU_XOR\fP(), \fBCPU_EQUAL\fP(), \fBCPU_ALLOC\fP(),
\fBCPU_ALLOC_SIZE\fP(), \fBCPU_FREE\fP(), \fBCPU_ZERO_S\fP(), \fBCPU_SET_S\fP(),
\fBCPU_CLR_S\fP(), \fBCPU_ISSET_S\fP(), \fBCPU_AND_S\fP(), \fBCPU_OR_S\fP(),
\fBCPU_XOR_S\fP(), and \fBCPU_EQUAL_S\fP()  first appeared in glibc 2.7.
.SH 準拠
These interfaces are Linux\-specific.
.SH 注意
To duplicate a CPU set, use \fBmemcpy\fP(3).

Since CPU sets are bitsets allocated in units of long words, the actual
number of CPUs in a dynamically allocated CPU set will be rounded up to the
next multiple of \fIsizeof(unsigned long)\fP.  An application should consider
the contents of these extra bits to be undefined.

Notwithstanding the similarity in the names, note that the constant
\fBCPU_SETSIZE\fP indicates the number of CPUs in the \fIcpu_set_t\fP data type
(thus, it is effectively a count of bits in the bitset), while the
\fIsetsize\fP argument of the \fBCPU_*_S\fP()  macros is a size in bytes.

The data types for arguments and return values shown in the SYNOPSIS are
hints what about is expected in each case.  However, since these interfaces
are implemented as macros, the compiler won't necessarily catch all type
errors if you violate the suggestions.
.SH バグ
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=7029
On 32\-bit platforms with glibc 2.8 and earlier, \fBCPU_ALLOC\fP()  allocates
twice as much space as is required, and \fBCPU_ALLOC_SIZE\fP()  returns a value
twice as large as it should.  This bug should not affect the semantics of a
program, but does result in wasted memory and less efficient operation of
the macros that operate on dynamically allocated CPU sets.  These bugs are
fixed in glibc 2.9.
.SH EXAMPLE
The following program demonstrates the use of some of the macros used for
dynamically allocated CPU sets.

.nf
#define _GNU_SOURCE
#include <sched.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <assert.h>

int
main(int argc, char *argv[])
{
    cpu_set_t *cpusetp;
    size_t size;
    int num_cpus, cpu;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <num\-cpus>\en", argv[0]);
        exit(EXIT_FAILURE);
    }

    num_cpus = atoi(argv[1]);

    cpusetp = CPU_ALLOC(num_cpus);
    if (cpusetp == NULL) {
        perror("CPU_ALLOC");
        exit(EXIT_FAILURE);
    }

    size = CPU_ALLOC_SIZE(num_cpus);

    CPU_ZERO_S(size, cpusetp);
    for (cpu = 0; cpu < num_cpus; cpu += 2)
        CPU_SET_S(cpu, size, cpusetp);

    printf("CPU_COUNT() of set:    %d\en", CPU_COUNT_S(size, cpusetp));

    CPU_FREE(cpusetp);
    exit(EXIT_SUCCESS);
}
.fi
.SH 関連項目
\fBsched_setaffinity\fP(2), \fBpthread_attr_setaffinity_np\fP(3),
\fBpthread_setaffinity_np\fP(3), \fBcpuset\fP(7)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.51 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
