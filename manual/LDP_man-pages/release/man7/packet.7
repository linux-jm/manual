.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: packet.7,v 1.13 2000/08/14 08:03:45 ak Exp $
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PACKET 7 2012\-03\-25 Linux "Linux Programmer's Manual"
.SH 名前
packet, AF_PACKET \- デバイスレベルのパケットインターフェース
.SH 書式
.nf
\fB#include <sys/socket.h>\fP
.br
\fB#include <netpacket/packet.h>\fP
.br
\fB#include <net/ethernet.h> /* the L2 protocols */\fP
.sp
\fBpacket_socket = socket(AF_PACKET, int \fP\fIsocket_type\fP\fB, int \fP\fIprotocol\fP\fB);\fP
.fi
.SH 説明
packet ソケットは、デバイスドライバ (OSI レイヤ 2) レベルで 生のパケット (raw packet) を送受信するために用いられる。
packet ソケットを使うと、ユーザー空間で物理層の上に プロトコルモジュールを実装することができる。

\fIsocket_type\fP には \fBSOCK_RAW\fP と \fBSOCK_DGRAM\fP のいずれかを指定する。 \fBSOCK_RAW\fP
はリンクレベルヘッダを含む raw パケットを、 \fBSOCK_DGRAM\fP はリンクレベルヘッダが削除された加工済みパケットを示す。
リンクレベルヘッダ情報は \fIsockaddr_ll\fP で共通のフォーマットで入手できる。 \fIprotocol\fP には IEEE 802.3
プロトコル番号を ネットワークバイトオーダーで指定する。 指定できるプロトコルのリストは、インクルードファイル
\fI<linux/if_ether.h>\fP を参照。プロトコルを \fBhtons(ETH_P_ALL)\fP
にすると、全てのプロトコルが受信される。 外部から来たパケットのうち指定したプロトコルのものは、
カーネルに実装されているプロトコルに渡される前の段階で、 packet ソケットに渡される。

packet ソケットをオープンできるのは、 実効ユーザーID が 0 のプロセスか、 \fBCAP_NET_RAW\fP
ケーパビリティを持つプロセスだけである。

\fBSOCK_RAW\fP パケットでは、パケットをデバイスドライバと受け渡しする際、 パケットデータに変更が行われることはない。
パケットの受信時には、アドレスの解析だけは行われ、 標準的な \fIsockaddr_ll\fP
アドレス構造体に渡される。パケットの送信時には、ユーザが指定する バッファに物理層のヘッダが含まれている必要がある。
パケットはそのまま修正を受けずに、行き先アドレスから決定される インターフェースのネットワークドライバにキューイングされる。
デバイスドライバによっては、他のヘッダを常に追加するものもある。 \fBSOCK_RAW\fP は Linux 2.0 の obosolete な
\fBAF_INET/SOCK_PACKET\fP と似ているが、互換性があるわけではない。

\fBSOCK_DGRAM\fP はやや高位のレベルで動作する。物理ヘッダは、パケットがユーザーに 渡される前に削除される。 \fBSOCK_DGRAM\fP の
packet ソケットを通して送られるパケットは、 \fIsockaddr_ll\fP の行き先アドレスの情報に基づき、適切な物理層のヘッダが付加されてから、
キューに送られる。

デフォルトでは、指定したプロトコル型のパケットはすべて packet ソケットに送られる。特定のインターフェースからのパケットだけを
取得したい場合には、 \fIstruct sockaddr_ll\fP にアドレスを指定して \fBbind\fP(2)  を呼び、 packet
ソケットをそのインターフェースに結び付ける (バインドする)。 バインドの際には、アドレスフィールドのうち \fIsll_protocol\fP と
\fIsll_ifindex\fP だけが用いられる。

\fBconnect\fP(2)  操作は packet ソケットではサポートされていない。

\fBMSG_TRUNC\fP フラグが \fBrecvmsg\fP(2), \fBrecv\fP(2), \fBrecvfrom\fP(2)  に渡されると、
(バッファサイズより大きかったとしても) 常に実際に通信された パケットの長さが返される。
.SS アドレスのタイプ
sockaddr_ll はデバイスに依存しない物理層のアドレスである。

.in +4n
.nf
struct sockaddr_ll {
    unsigned short sll_family;   /* 常に AF_PACKET */
    unsigned short sll_protocol; /* 物理層のプロトコル */
    int            sll_ifindex;  /* インターフェース番号 */
    unsigned short sll_hatype;   /* ARP ハードウェア種別 */
    unsigned char  sll_pkttype;  /* パケット種別 */
    unsigned char  sll_halen;    /* アドレスの長さ */
    unsigned char  sll_addr[8];  /* 物理層のアドレス */
};
.fi
.in

\fIsll_protocol\fP は標準的なイーサネットプロトコルのタイプで、 ネットワーク
バイトオーダーで記述する。 インクルードファイル
\fI<linux/if_ether.h>\fP で定義されている。 これがこのソケットのプロト
コルのデフォルトとなる。 \fIsll_ifindex\fP はそのインターフェースの interface
index である (\fBnetdevice\fP(7) を参照)。 0 は (バインドが許可されている) 任
意のインターフェースにマッチする。 \fIsll_hatype\fP は、インクルードファイル
\fI<linux/if_arp.h>\fP で定義されている ARP 種別である。
\fIsll_pkttype\fP はパケット種別である。指定できる種別は以下のいずれかである:
\fBPACKET_HOST\fP (ローカルホスト向けのパケット)、 \fBPACKET_BORADCAST\fP (物理層
のブロードキャストパケット)、 \fBPACKET_MULTICAST\fP (物理層のマルチキャストア
ドレスに送るパケット)、 \fBPACKET_OTHERHOST\fP (他のホストに向けられたパケット
のうち、 無差別モード (promiscuous mode: 後述) のデバイスドライバにより補足
されたもの)、 \fBPACKET_OUTGOING\fP (ローカルホストから発信され、 packet ソケッ
トにループバックしてきたパケット)。 これらの種別が意味を持つのは受信時のみ
である。 \fIsll_addr\fP と \fIsll_halen\fP は、物理層の (つまり IEEE 802.3 の)
アドレスとその長さである。 厳密な解釈はデバイスに依存する。

パケットを送る場合は、 \fIsll_family\fP, \fIsll_addr\fP, \fIsll_halen\fP, \fIsll_ifindex\fP
を指定すれば十分である。 その他のフィールドは 0 にしておくべきである。 \fIsll_hatype\fP と \fIsll_pkttype\fP
には受信したパケットの情報が設定される。 バインドの際には、 \fIsll_protocol\fP と \fIsll_ifindex\fP だけが使用される。
.SS ソケットオプション
packet ソケットは、物理層のマルチキャストや 無差別モード (promiscuous mode) を設定して使うことができる。 これには
\fBSOL_PACKET\fP と以下のオプションのいずれかを指定して \fBsetsockopt\fP(2)  を呼べばよい。 バインドを追加する場合は
\fBPACKET_ADD_MEMBERSHIP\fP であり、取り去る場合は \fBPACKET_DROP_MEMBERSHIP\fP である。これらはいずれも
\fBpacket_mreq\fP 構造体を引き数に取る。

.in +4n
.nf
struct packet_mreq {
    int            mr_ifindex;    /* インターフェース番号 */
    unsigned short mr_type;       /* 動作 */
    unsigned short mr_alen;       /* アドレスの長さ */
    unsigned char  mr_address[8]; /* 物理層のアドレス */
};
.fi
.in

\fImr_ifindex\fP は、ステータスを変更したいインターフェースの インターフェース番号である。 \fImr_type\fP
パラメータは実行する動作を指定する: \fBPACKET_MR_PROMISC\fP は、共有している媒体からの全てのパケットを受信できるようにする
(しばしば "無差別モード (promiscuous mode)" と呼ばれる)。 \fBPACKET_MR_MULTICAST\fP は、そのソケットを、
\fImr_address\fP と \fImr_alen\fP で指定される物理層のマルチキャストブループにバインドする。
\fBPACKET_MR_ALLMULTI\fP は socket を up にして、そのインターフェースに到達したすべての
マルチキャストパケットを受信できるようにする。

昔からある ioctl だけでなく、 \fBSIOCSIFFLAGS\fP, \fBSIOCADDMULTI\fP, \fBSIOCDELMULTI\fP
を同じ目的に用いることができる。
.SS ioctl
.\" FIXME Document SIOCGSTAMPNS
\fBSIOCGSTAMP\fP を用いると、最後に受信したパケットのタイムスタンプを得ることができる。 引き数は \fIstruct timeval\fP
である。

さらに、 \fBnetdevice\fP(7)  および \fBsocket\fP(7)  で定義されている標準の ioctl はいずれも packet
ソケットに指定可能である。
.SS エラー処理
packet ソケットは、パケットをデバイスドライバに渡すときに 起きたエラーしか処理しない。遅延エラー (pending error)
に関する概念は持っていない。
.SH エラー
.TP 
\fBEADDRNOTAVAIL\fP
不明なマルチキャストグループアドレスが渡された。
.TP 
\fBEFAULT\fP
ユーザが渡したメモリアドレスが不正。
.TP 
\fBEINVAL\fP
引き数が不正。
.TP 
\fBEMSGSIZE\fP
パケットがインターフェースの MTU より大きい。
.TP 
\fBENETDOWN\fP
インターフェースが up でない。
.TP 
\fBENOBUFS\fP
パケットに割り当てるメモリが足りない。
.TP 
\fBENODEV\fP
デバイス名が不明。あるいはインターフェースアドレスで指定された インターフェースインデックスが不明。
.TP 
\fBENOENT\fP
パケットを一つも受信していない。
.TP 
\fBENOTCONN\fP
インターフェースアドレスが渡されなかった。
.TP 
\fBENXIO\fP
インターフェースアドレスに不正なインターフェースインデックスが含まれている。
.TP 
\fBEPERM\fP
この操作を行うのに必要な権限をユーザが持っていない。

上記以外のエラーが、低レベルのドライバで生成されることがある。
.SH バージョン
\fBAF_PACKET\fP は Linux 2.2 の新機能である。これより古いバージョンの Linux では \fBSOCK_PACKET\fP
のみをサポートしていた。
.PP
インクルードファイル \fI<netpacket/packet.h>\fP が存在するのは glibc 2.1 以降である。
それ以前のシステムでは以下のようにする必要がある:
.sp
.in +4n
.nf
#include <asm/types.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>  /* The L2 protocols */
.fi
.in
.SH 注意
移植性の必要なプログラムでは、 \fBpcap\fP(3)  経由で \fBAF_PACKET\fP を用いることをお薦めする。ただし、この方法では
\fBAF_PACKET\fP の機能すべてを利用することはできない。

\fBSOCK_DGRAM\fP packet ソケットは、IEEE 802.3 フレームの IEEE 802.2 LLC ヘッダの
生成や解析を行おうとしない。 \fBETH_P_802_3\fP が送信プロトコルに指定されると、カーネルは 802.3 フレームを 生成して length
フィールドに書き込む。 完全に準拠したパケットを得るためにはユーザーが LLC ヘッダを 与える必要がある。到着した 802.3 パケットでは、
DSAP/SSAP protocol の各フィールドは多重化 (multiplex) されていない。 代わりにこれらは LLC ヘッダが前置された
\fBETH_P_802_2\fP プロトコルとして与えられる。したがって、 \fBETH_P_802_3\fP にバインドすることはできない。かわりに
\fBETH_P_802_2\fP にバインドし、自分自身でプロトコルの多重化を行うこと。 送信のデフォルトは、プロトコルフィールドを持つ 標準の
Ethernet DIX encapsulation である。

packet ソケットは入出力の firewall chain に影響をうけない。
.SS 移植性
Linux 2.0 では、 packet ソケットを得る方法は \fBsocket(AF_INET, SOCK_PACKET,
\fP\fIprotocol\fP\fB)\fP を呼ぶやり方しかなかった。この方法はまだサポートされているが、 用いないことを強く推奨する。現在の方法との主な違いは、
\fBSOCK_PACKET\fP ではインターフェースの指定に古い \fIstruct sockaddr_pkt\fP
を用いる点である。これには物理層からの独立性がない。

.in +4n
.nf
struct sockaddr_pkt {
    unsigned short spkt_family;
    unsigned char  spkt_device[14];
    unsigned short spkt_protocol;
};
.fi
.in

\fIspkt_family\fP はデバイスのタイプ、 \fIspkt_protocol\fP は \fI<sys/if_ether.h>\fP
で定義されている IEEE 802.3 プロトコルタイプ、 \fIspkt_device\fP はデバイスの名前を NULL 終端された文字列で与えたもの
(例: eth0) である。

この構造体は obsolete であり、 新しくコードを書く時には用いるべきでない。
.SH バグ
glibc 2.1 には \fBSOL_PACKET\fP の定義がない。回避策としては、以下のようにするとよい。
.in +4n
.nf

#ifndef SOL_PACKET
#define SOL_PACKET 263
#endif

.fi
.in
この問題は新しいバージョンの glibc では修正されている。 libc5 のシステムにはこの問題はない。

IEEE 802.2/803.3 の LLC の扱い方は、バグと考えても良いだろう。

ソケットフィルターについて記載されていない。

.\" .SH CREDITS
.\" This man page was written by Andi Kleen with help from Matthew Wilcox.
.\" AF_PACKET in Linux 2.2 was implemented
.\" by Alexey Kuznetsov, based on code by Alan Cox and others.
\fBMSG_TRUNC\fP \fBrecvmsg\fP(2)  拡張は非常にまずい対処であり、制御メッセージで置き換えるべきである。 今のところ
\fBSOCK_DGRAM\fP 経由でパケットについていた宛先アドレスを得る方法がない。
.SH 関連項目
\fBsocket\fP(2), \fBpcap\fP(3), \fBcapabilities\fP(7), \fBip\fP(7), \fBraw\fP(7),
\fBsocket\fP(7)

標準 IP Ethernet encapsulation に関する情報は RFC\ 894 にある。

IEEE 802.3 IP encapsulation に関する情報は RFC\ 1700 にある。

物理層のプロトコルに関する記述は \fI<linux/if_ether.h>\fP インクルードファイルにある。
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.40 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
