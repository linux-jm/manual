.\" Copyright (C) Tom Bjorkholm, Markus Kuhn & David A. Wheeler 1996-1999
.\" and Copyright (C) 2007 Carsten Emde <Carsten.Emde@osadl.org>
.\" and Copyright (C) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(GPLv2+_DOC_FULL)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\" 1996-04-01 Tom Bjorkholm <tomb@mydata.se>
.\"            First version written
.\" 1996-04-10 Markus Kuhn <mskuhn@cip.informatik.uni-erlangen.de>
.\"            revision
.\" 1999-08-18 David A. Wheeler <dwheeler@ida.org> added Note.
.\" Modified, 25 Jun 2002, Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Corrected description of queue placement by sched_setparam() and
.\"		sched_setscheduler()
.\"	A couple of grammar clean-ups
.\" Modified 2004-05-27 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" 2005-03-23, mtk, Added description of SCHED_BATCH.
.\" 2007-07-10, Carsten Emde <Carsten.Emde@osadl.org>
.\"     Add text on real-time features that are currently being
.\"     added to the mainline kernel.
.\" 2008-05-07, mtk; Rewrote and restructured various parts of the page to
.\"     improve readability.
.\" 2010-06-19, mtk, documented SCHED_RESET_ON_FORK
.\"
.\" Worth looking at: http://rt.wiki.kernel.org/index.php
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" Japanese Version Copyright (c) 1996 Akira Yoshiyama
.\"         all rights reserved.
.\" Translated Thu Jul 11 01:42:52 JST 1996
.\"         by Akira Yoshiyama <yosshy@jedi.seg.kobe-u.ac.jp>
.\" Modified Sun Nov 21 19:36:18 JST 1999
.\"         by HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated Wed Jan  1 JST 2003 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-02-24, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated & Modified 2005-10-10, Akihiro MOTOKI
.\" Updated 2006-04-16, Akihiro MOTOKI, Catch up to LDP v2.28
.\" Updated 2007-10-13, Akihiro MOTOKI, LDP v2.65
.\" Updated 2008-08-13, Akihiro MOTOKI, LDP v3.05
.\" Updated 2012-06-04, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2013-05-01, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2013-05-06, Akihiro MOTOKI <amotoki@gmail.com>
.\"
.TH SCHED_SETSCHEDULER 2 2013\-09\-17 Linux "Linux Programmer's Manual"
.SH 名前
sched_setscheduler, sched_getscheduler \- スケジューリング・ポリシーとパラメータを設定/取得する
.SH 書式
.nf
\fB#include <sched.h>\fP
.sp
\fBint sched_setscheduler(pid_t \fP\fIpid\fP\fB, int \fP\fIpolicy\fP\fB,\fP
.br
\fB                       const struct sched_param *\fP\fIparam\fP\fB);\fP
.sp
\fBint sched_getscheduler(pid_t \fP\fIpid\fP\fB);\fP
.sp
\fBstruct sched_param {
    ...
    int \fP\fIsched_priority\fP\fB;
    ...
};\fP
.fi
.SH 説明
\fBsched_setscheduler\fP()  は \fIpid\fP で指定された ID を持つスレッドのスケジューリング・ポリシーや
それに関連するパラメータを設定する。\fIpid\fP が 0 の場合は 呼び出したスレッドのスケジューリング・ポリシーとパラメータが設定される。 引き数
\fIparam\fP の解釈は選択されたポリシーによる。 現在のところ、Linux では 以下に示す「通常」(リアルタイムでない)
スケジューリング・ポリシーが サポートされている。
.TP  14
\fBSCHED_OTHER\fP
.\" In the 2.6 kernel sources, SCHED_OTHER is actually called
.\" SCHED_NORMAL.
標準の、ラウンドロビンによる時分割型のスケジューリング・ポリシー。
.TP 
\fBSCHED_BATCH\fP
「バッチ」形式でのプロセスの実行用。
.TP 
\fBSCHED_IDLE\fP
「非常に」低い優先度で動作するバックグラウンド・ジョブ用。
.PP
どの実行可能スレッドを選択するかについて、より正確な制御を必要とする 時間の制約が厳しい特別なアプリケーション用として、
以下の「リアルタイム」ポリシーもサポートされている。
.TP  14
\fBSCHED_FIFO\fP
ファーストイン、ファーストアウト型のポリシー。
.TP 
\fBSCHED_RR\fP
ラウンドロビン型のポリシー。
.PP
これらのポリシーのそれぞれの動作については以下で説明する。

.\"
\fBsched_getscheduler\fP()  は \fIpid\fP で識別されるスレッドに現在適用されている
スケジューリング・ポリシーを尋ねる。\fIpid\fP が 0 ならば、呼び出した スレッド自身のスケジューリング・ポリシーが返される。
.SS "スケジューリング・ポリシー (scheduling policy)"
スケジューラ (scheduler) とはカーネルの構成要素で、 次に CPU で実行される実行可能なスレッドを決定するものである。
各々のスレッドには、スケジューリング・ポリシーと 「静的」なスケジューリング優先度 \fIsched_priority\fP が対応付けられ、 これらの設定は
\fBsched_setscheduler\fP()  で変更できる。 スケジューラは、システム上の全スレッドのスケジューリング・ポリシーと
静的優先度に関する知識に基づいて決定を行う。

通常のスケジューリング・ポリシー (\fBSCHED_OTHER\fP, \fBSCHED_IDLE\fP, \fBSCHED_BATCH\fP)
の下でスケジューリングされるスレッドでは、 \fIsched_priority\fP はスケジューリングの決定に使用されない
(\fIsched_priority\fP には 0 を指定しなければならない)。

リアルタイム・スケジューリング・ポリシー (\fBSCHED_FIFO\fP, \fBSCHED_RR\fP)  の下でスケジューリングされるスレッドは、
\fIsched_priority\fP の値は 1 (最低) から 99 (最高) の範囲となる
(数字から分かるように、リアルタイム・スレッドは常に通常のスレッドよりも 高い優先度を持つ)。 ここで注意すべきなのは、POSIX.1\-2001
が要求しているのは、 リアルタイム・ポリシーの実装において最低 32 種類の異なる優先度レベルが
サポートされることだけであり、いくつかのシステムではこの最低限の数の 優先度しか提供されていない、ということである。 移植性が必要なプログラムでは、
\fBsched_get_priority_min\fP(2)  と \fBsched_get_priority_max\fP(2)
を使って、あるポリシーがサポートする優先度の範囲を調べるべきである。

概念としては、 スケジューラはその \fIsched_priority\fP の値それぞれに対して 実行可能なスレッドのリストを管理している。
どのスレッドを次に実行するかを決定するために、 スケジューラは静的優先度の最も高い空でないリストを探して、 そのリストの先頭のスレッドを選択する。

各スレッドのスケジューリング・ポリシーは、 そのスレッドが同じ静的優先度を持つスレッドのリストの中のどこに挿入され、
このリストの中をどのように移動するかを決定する。

全てのスケジューリングはプリエンプティブ (preemptive) である: より高い優先度のスレッドが実行可能になると、現在実行中のスレッドは実行権を
取り上げられ (preempted)、そのスレッドの静的優先度レベルの待ちリストに 戻される。スケジューリング・ポリシーは同じ静的優先度を持つ実行可能な
スレッドのリストの中で順番のみを決定する。
.SS "SCHED_FIFO: ファーストイン・ファーストアウト・スケジューリング"
\fBSCHED_FIFO\fP は 0 より大きな静的優先度でのみ使用できる。このポリシーでは、 \fBSCHED_FIFO\fP
スレッドが実行可能になった場合、 そのポリシーが \fBSCHED_OTHER\fP、 \fBSCHED_BATCH\fP、 \fBSCHED_IDLE\fP の
現在実行中のスレッドは直ちに実行権を取り上げられる。 \fBSCHED_FIFO\fP は時分割のない単純なスケジューリング・アルゴリズムである。
\fBSCHED_FIFO\fP ポリシーでスケジューリングされているスレッドには以下の ルールが適用される:
.IP * 3
より高い優先度の他のスレッドによって取って代わられた \fBSCHED_FIFO\fP スレッドはその優先度のリストの先頭に留まり続け、
より高い優先度のスレッド全てが停止 (block) した場合に実行を再開する。
.IP *
\fBSCHED_FIFO\fP スレッドが実行可能になった時、その優先度のリストの最後 に挿入される。
.IP *
.\" In 2.2.x and 2.4.x, the thread is placed at the front of the queue
.\" In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
\fBsched_setscheduler\fP()  や \fBsched_setparam\fP(2)  は \fIpid\fP で指定された
\fBSCHED_FIFO\fP (または \fBSCHED_RR\fP) スレッドが 実行可能な場合、リストの最初に置く。
結果として、もし優先度が同じだった場合、 現在実行中のスレッドに先んじるかもしれない。 (POSIX.1\-2001
ではスレッドはリストの最後に行くべきと規定されている。)
.IP *
\fBsched_yield\fP(2)  を呼び出したスレッドはリストの最後に置かれる。
.PP
その他のイベントによって \fBSCHED_FIFO\fP
ポリシーでスケジューリングされるスレッドが同じ優先度の実行可能なスレッドの待ちリストの中を移動することはない。

\fBSCHED_FIFO\fP スレッドは I/O 要求によって停止するか、 より高い優先度のスレッドによって置きかえられるか、
\fBsched_yield\fP(2)  を呼び出すまで実行を続ける。
.SS "SCHED_RR: ラウンドロビン (round\-robin)・スケジューリング"
.\" On Linux 2.4, the length of the RR interval is influenced
.\" by the process nice value -- MTK
.\"
\fBSCHED_RR\fP は \fBSCHED_FIFO\fP の単純な拡張である。 上述された
\fBSCHED_FIFO\fP に関する記述は全て \fBSCHED_RR\fP に 適用できる。異なるのは
それぞれのスレッドは最大時間単位までしか実行できない ということである。
\fBSCHED_RR\fP スレッドが時間単位と同じかそれより 長い時間実行されると、
その優先度のリストの最後に置かれる。 より高い優先度のスレッドによって
置きかえられ、その後実行を再開した \fBSCHED_RR\fP スレッドは、そのラウンド
ロビン時間単位を完全に使い切る まで実行される。その時間単位の長さは
\fBsched_rr_get_interval\fP(2) を使って取得できる。
.SS "SCHED_OTHER: Linux のデフォルトの時分割スケジューリング"
.\"
\fBSCHED_OTHER\fP は静的優先度 0 でのみ使用できる。 \fBSCHED_OTHER\fP は Linux 標準の時分割スケジューラで、
特別なリアルタイム機構を必要としていない全てのスレッドで使用される。 実行するスレッドは、静的優先度 0 のリストから、このリストの中だけで
決定される「動的な」優先度 (dynamic priority) に基いて決定される。 動的な優先度は (\fBnice\fP(2)  や
\fBsetpriority\fP(2)  により設定される) nice 値に基づいて決定されるもので、
単位時間毎に、スレッドが実行可能だが、スケジューラにより実行が拒否された 場合にインクリメントされる。 これにより、全ての \fBSCHED_OTHER\fP
スレッドでの公平性が保証される。
.SS "SCHED_BATCH: バッチプロセスのスケジューリング"
(Linux 2.6.16 以降)  \fBSCHED_BATCH\fP は静的優先度 0 でのみ使用できる。 このポリシーは (nice 値に基づく)
動的な優先度にしたがってスレッドの スケジューリングが行われるという点で、\fBSCHED_OTHER\fP に似ている。
異なるのは、このポリシーでは、スレッドが常に CPU に負荷のかかる (CPU\-intensive)  処理を行うと、スケジューラが仮定する点である。
スケジューラはスレッドを呼び起こす毎にそのスレッドにスケジューリング上の ペナルティを少し課し、その結果、このスレッドはスケジューリングの決定で
若干冷遇されるようになる。

.\" The following paragraph is drawn largely from the text that
.\" accompanied Ingo Molnar's patch for the implementation of
.\" SCHED_BATCH.
.\" commit b0a9499c3dd50d333e2aedb7e894873c58da3785
.\"
このポリシーは、非対話的な処理だがその nice 値を下げたくない処理や、 (処理のタスク間で) 余計なタスクの置き換えの原因とある対話的な処理なしで
確定的な (deterministic) スケジューリング・ポリシーを適用したい処理に 対して有効である。
.SS "SCHED_IDLE: 非常に優先度の低いジョブのスケジューリング"
(Linux 2.6.23 以降)  \fBSCHED_IDLE\fP は静的優先度 0 でのみ使用できる。 このポリシーではプロセスの nice
値はスケジューリングに影響を与えない。

.\"
非常に低い優先度でのジョブの実行を目的としたものである (非常に低い優先度とは、ポリシー \fBSCHED_OTHER\fP か \fBSCHED_BATCH\fP
での nice 値 +19 よりさらに低い優先度である)。
.SS 子プロセスでのスケジューリング・ポリシーのリセット
Linux 2.6.32 以降では、 \fBsched_setscheduler\fP() を呼び出す際に \fIpolicy\fP に
\fBSCHED_RESET_ON_FORK\fP フラグを OR で指定できる。このフラグが指定されると、 \fBfork\fP(2)
で作成された子プロセスは特権が必要なスケジューリング・ポリシーを継承しない。この機能はメディア再生を行うアプリケーションを想定して作られ、この機能を使うことで、アプリケーションが複数の子プロセスを作成することで
\fBRLIMIT_RTTIME\fP リソース上限 (\fBgetrlimit\fP(2) 参照) を回避するのを防ぐことができる。

より正確には、 \fBSCHED_RESET_ON_FORK\fP フラグが指定された場合、それ以降に作成される子プロセスに以下のルールが適用される。
.IP * 3
呼び出したスレッドのスケジューリング・ポリシーが \fBSCHED_FIFO\fP か \fBSCHED_RR\fP の場合、子プロセスのポリシーは
\fBSCHED_OTHER\fP にリセットされる。
.IP *
子プロセスが負の nice 値を持っている場合、子プロセスの nice 値は 0 にリセットされる。
.PP
一度 \fBSCHED_RESET_ON_FORK\fP フラグが有効にされた後は、このフラグをリセットできるのは、スレッドが \fBCAP_SYS_NICE\fP
ケーパビリティを持つ場合だけである。このフラグは \fBfork\fP(2) で作成された子プロセスでは無効になる。

.\"
\fBSCHED_RESET_ON_FORK\fP フラグは、 \fBsched_getscheduler\fP() が返すポリシー値で参照できる。
.SS 特権とリソース制限
2.6.12 より前のバージョンの Linux カーネルでは、 特権スレッド (\fBCAP_SYS_NICE\fP ケーパビリティを持つスレッド) だけが
0 以外の静的優先度を設定する (すなわち、リアルタイム・スケジューリング・ポリシーを設定する) ことができる。 非特権スレッドができる変更は
\fBSCHED_OTHER\fP ポリシーを設定することだけであり、さらにこの変更を行えるのは \fBsched_setscheduler\fP()
の呼び出し元の実効ユーザ ID がポリシーの変更対象スレッド (\fIpid\fP で指定されたスレッド) の実ユーザ ID か実効ユーザ ID と
一致する場合だけである。

Linux 2.6.12 以降では、リソース制限 \fBRLIMIT_RTPRIO\fP が定義されており、 スケジューリング・ポリシーが
\fBSCHED_RR\fP と \fBSCHED_FIFO\fP の場合の、非特権スレッドの静的優先度の上限を定めている。
スケジューリング・ポリシーと優先度を変更する際のルールは以下の通りである。
.IP * 3
非特権スレッドに 0 以外の \fBRLIMIT_RTPRIO\fP ソフト・リミットが設定されている場合、
非特権スレッドはそのスレッドのスケジューリング・ポリシーと優先度を 変更できるが、優先度を現在の自身の優先度と \fBRLIMIT_RTPRIO\fP
ソフト・リミットの大きい方よりも高い値に設定できないという制限が課される。
.IP *
\fBRLIMIT_RTPRIO\fP ソフト・リミットが 0 の場合、優先度を下げるか、 リアルタイムでないポリシーへ切り替えるかの変更だけが許可される。
.IP *
ある非特権スレッドが別のスレッドに対してこれらの変更を行う際にも、 同じルールが適用される。変更を行えるのは、変更を行おうとするスレッド の実効ユーザ
ID が変更対象のスレッドの実ユーザ ID か実効ユーザ ID と 一致している場合に限られる。
.IP *
.\" commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
\fBSCHED_IDLE\fP の場合には特別なルールが適用される。 2.6.39 より前の Linux
カーネルでは、このポリシーで動作する非特権スレッドは、 \fBRLIMIT_RTPRIO\fP
リソース上限の値に関わらず、自分のポリシーを変更することができない。 2.6.39 以降の Linux カーネルでは、非特権スレッドは、自分の nice
値が \fBRLIMIT_NICE\fP リソース上限 (\fBgetrlimit\fP(2) 参照)
で許可された範囲である限りは、自分のスケジューリング・ポリシーを \fBSCHED_BATCH\fP か \fBSCHED_NORMAL\fP
ポリシーに切り替えることができる。
.PP
特権スレッド (\fBCAP_SYS_NICE\fP ケーパビリティを持つスレッド) の場合、 \fBRLIMIT_RTPRIO\fP の制限は無視される;
古いカーネルと同じように、スケジューリング・ポリシーと優先度に対し 任意の変更を行うことができる。 \fBRLIMIT_RTPRIO\fP
に関するもっと詳しい情報は \fBgetrlimit\fP(2)  を参照のこと。
.SS "応答時間 (response time)"
.\" as described in
.\" .BR request_irq (9).
I/O 待ちで停止したより高い優先度のスレッドは再びスケジューリングされる 前にいくらかの応答時間がかかる。デバイス・ドライバーを書く場合には
"slow interrupt" 割り込みハンドラーを使用することで この応答時間を劇的に減少させることができる。
.SS その他
子プロセスは \fBfork\fP(2)  の際に親プロセスのスケジューリング・ポリシーとパラメータを継承する。 \fBexecve\fP(2)
の前後で、スケジューリング・ポリシーとパラメータは保持される。

リアルタイム・プロセスは大抵、ページングの待ち時間を避けるために \fBmlock\fP(2)  や \fBmlockall\fP(2)
を使ってメモリ・ロックをしなければならない。

\fBSCHED_FIFO\fP や \fBSCHED_RR\fP でスケジューリングされる スレッドが停止せずに無限ループに陥ると、
他の全てのより低い優先度のスレッドを永久に停止 (block) させてしまうので、 ソフトウェア開発者はコンソールのシェルの静的優先度をテストする
アプリケーションよりも常に高く保つべきである。 これによって期待通りに停止したり終了したりしないリアルタイム・
アプリケーションを緊急終了させることが可能になる。 \fBgetrlimit\fP(2)  のリソース制限 \fBRLIMIT_RTTIME\fP
の説明も参照のこと。

POSIX システムでは \fI<unistd.h>\fP に \fB_POSIX_PRIORITY_SCHEDULING\fP
が定義されている場合にのみ \fBsched_setscheduler\fP()  と \fBsched_getscheduler\fP()  が使用できる。
.SH 返り値
成功した場合、 \fBsched_setscheduler\fP()  は 0 を返す。 成功した場合、 \fBsched_getscheduler\fP()
は現在のそのスレッドのポリシー (非負の整数) を返す。 エラーの場合、\-1 が返され、 \fIerrno\fP が適切に設定される。
.SH エラー
.TP 
\fBEINVAL\fP
スケジューリング・ポリシー \fIpolicy\fP が間違っている。
または \fIparam\fP が NULL である。
または \fIparam\fP がそのポリシーでは意味をなさない。
.TP 
\fBEPERM\fP
呼び出したスレッドが適切な特権を持っていない。
.TP 
\fBESRCH\fP
ID が \fIpid\fP のスレッドが見つからなかった。
.SH 準拠
POSIX.1\-2001 (但し、下記のバグの節も参照)。 \fBSCHED_BATCH\fP と \fBSCHED_IDLE\fP ポリシーは Linux
固有である。
.SH 注意
POSIX.1 は、非特権スレッドが \fBsched_setscheduler\fP()  を呼び出すために必要な権限の詳細を規定しておらず、
詳細はシステムにより異なる。 例えば、Solaris 7 のマニュアルページでは、 呼び出し元の実ユーザ ID または実効ユーザ ID が
設定対象の実ユーザ ID か保存 (save) set\-user\-ID と 一致していなければならない、となっている。
.PP
Linux では、 スケジューリングポリシーとスケジューリングパラメータは、 実際にはスレッド単位の属性である。 \fBgettid\fP(2)
の呼び出しの返り値をこのシステムコールの \fIpid\fP 引き数として渡すことができる。 \fIpid\fP に 0 を指定すると、
呼び出し元のスレッドの属性が設定される。 \fBgetpid\fP(2) コールからの返り値を \fIpid\fP に指定すると、
スレッドグループのメインスレッドの属性が設定される (POSIX スレッド API を使用している場合は、 \fBsched_*\fP(2)
システムコールの代わりに \fBpthread_setschedparam\fP(3), \fBpthread_getschedparam\fP(3), and
\fBpthread_setschedprio\fP(3) を使用すること)。
.PP
もともとは、標準の Linux は一般目的のオペレーティングシステムとして 設計されており、バックグラウンド・プロセスや対話的アプリケーション、
リアルタイム性の要求が厳しくないリアルタイム・アプリケーション (普通はタイミングの応答期限 (deadline) を満たす必要があるアプリケーション)
を扱うことができた。 Linux カーネル 2.6 では、 カーネルのプリエンプション (タスクの置き換え) が可能であり、 新たに導入された O(1)
スケジューラにより、 アクティブなタスクの数に関わらずスケジューリングに必要な時間は 固定で確定的 (deterministic)
であることが保証されている。 それにも関わらず、カーネル 2.6.17 までは 真のリアルタイム・コンピューティングは実現できなかった。
.SS "本流の Linux カーネルでのリアルタイム機能"
.\" FIXME . Probably this text will need some minor tweaking
.\" by about the time of 2.6.30; ask Carsten Emde about this then.
カーネル 2.6.18 から現在まで、 Linux は徐々にリアルタイム機能を備えつつ
あるが、 これらの機能のほとんどは、 Ingo Molnar, Thomas Gleixner,
Steven Rostedt らによって開発された、 以前の \fIrealtime\-preempt\fP パッチ
からのものである。 これらのパッチが本流のカーネルに完全にマージされるま
では (マージの完了はカーネル 2.6.30 あたりの予定)、 最高のリアルタイム
性能を達成するには realtime\-preempt パッチを 組み込まなければならない。
これらのパッチは
.in +4n
.nf

patch\-\fIkernelversion\fP\-rt\fIpatchversion\fP
.fi
.in
.PP
という名前で、
.UR http://www.kernel.org\:/pub\:/linux\:/kernel\:/projects\:/rt/
.UE
からダウンロードできる。

このパッチが適用されず、かつパッチの内容の本流のカーネルへのマージが 完了するまでは、カーネルの設定では \fBCONFIG_PREEMPT_NONE\fP,
\fBCONFIG_PREEMPT_VOLUNTARY\fP, \fBCONFIG_PREEMPT_DESKTOP\fP の 3つのプリエンプション・クラス
(preemption class) だけが提供される。 これらのクラスでは、最悪の場合のスケジューリング遅延がそれぞれ
全く減らない、いくらか減る、かなり減る。

パッチが適用された場合、またはパッチの内容の本流のカーネルへのマージが 完了した後では、上記に加えて設定項目として
\fBCONFIG_PREEMPT_RT\fP が利用可能になる。この項目を選択すると、 Linux
は通常のリアルタイム・オペレーティングシステムに変身する。 この場合には、 \fBsched_setscheduler\fP()  で選択できる FIFO と
RR のスケジューリング・ポリシーは、 真のリアルタイム優先度を持つスレッドを最悪の場合のスケジューリング遅延が
最小となる環境で動作させるために使われることになる。
.SH バグ
POSIX では、成功時に \fBsched_setscheduler\fP()  は直前のスケジューリング・ポリシーを返すべきとされている。 Linux の
\fBsched_setscheduler\fP()  はこの要求仕様に準拠しておらず、 成功時には常に 0 を返す。
.SH 関連項目
.ad l
.nh
\fBchrt\fP(1), \fBgetpriority\fP(2), \fBmlock\fP(2), \fBmlockall\fP(2), \fBmunlock\fP(2),
\fBmunlockall\fP(2), \fBnice\fP(2), \fBsched_get_priority_max\fP(2),
\fBsched_get_priority_min\fP(2), \fBsched_getaffinity\fP(2), \fBsched_getparam\fP(2),
\fBsched_rr_get_interval\fP(2), \fBsched_setaffinity\fP(2), \fBsched_setparam\fP(2),
\fBsched_yield\fP(2), \fBsetpriority\fP(2), \fBcapabilities\fP(7), \fBcpuset\fP(7)
.ad
.PP
\fIProgramming for the real world \- POSIX.4\fP by Bill O. Gallmeister, O'Reilly
& Associates, Inc., ISBN 1\-56592\-074\-0.
.PP
Linux カーネルソースファイル \fIDocumentation/scheduler/sched\-rt\-group.txt\fP
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.65 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
