.\" Copyright (c) 2008 Petr Baudis <pasky@suse.cz>
.\" and copyright (c) 2009, Linux Foundation, written by Michael Kerrisk
.\"     <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 2008-12-08 Petr Baudis <pasky@suse.cz>
.\"    Rewrite the BSD manpage in the Linux man pages style and account
.\"    for glibc specificities, provide an example.
.\" 2009-01-14 mtk, many edits and changes, rewrote example program.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" Japanese Version Copyright (c) 2013  Akihiro MOTOKI
.\"         all rights reserved.
.\" Translated 2013-07-31, Akihiro MOTOKI <amotoki@gmail.com>
.\"
.TH GETIFADDRS 3 2020\-11\-01 GNU "Linux Programmer's Manual"
.SH 名前
getifaddrs, freeifaddrs \- インターフェースのアドレスを取得する
.SH 書式
.nf
\fB#include <sys/types.h>\fP
\fB#include <ifaddrs.h>\fP
.PP
\fBint getifaddrs(struct ifaddrs **\fP\fIifap\fP\fB);\fP
.PP
\fBvoid freeifaddrs(struct ifaddrs *\fP\fIifa\fP\fB);\fP
.fi
.SH 説明
\fBgetifaddrs\fP() 関数は、ローカルシステムのネットワークインターフェース情報を表す構造体の連結リストを作成し、
リストの先頭の要素のアドレスを \fI*ifap\fP に格納する。 リストは \fIifaddrs\fP 構造体で構成される。 \fIifaddrs\fP
構造体は以下のように定義されている。
.PP
.in +4n
.EX
struct ifaddrs {
    struct ifaddrs  *ifa_next;    /* Next item in list */
    char            *ifa_name;    /* Name of interface */
    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */
    struct sockaddr *ifa_addr;    /* Address of interface */
    struct sockaddr *ifa_netmask; /* Netmask of interface */
    union {
        struct sockaddr *ifu_broadaddr;
                         /* Broadcast address of interface */
        struct sockaddr *ifu_dstaddr;
                         /* Point\-to\-point destination address */
    } ifa_ifu;
#define              ifa_broadaddr ifa_ifu.ifu_broadaddr
#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr
    void            *ifa_data;    /* Address\-specific data */
};
.EE
.in
.PP
\fIifa_next\fP フィールドにはリストの次の構造体へのポインターが格納される。 この要素がリストの最後の場合には NULL が入る。
.PP
.\" The constant
.\" .B IF NAMESIZE
.\" indicates the maximum length of this field.
\fIifa_name\fP はヌル終端されたインターフェース名を指す。
.PP
\fIifa_flags\fP フィールドには、 \fBSIOCGIFFLAGS\fP \fBioctl\fP(2) 操作で返されるインターフェースのフラグが格納される
(これらのフラグのリストについては \fBnetdevice\fP(7) を参照)。
.PP
\fIifa_addr\fP フィールドは、インターフェースのアドレスを格納した構造体へのポインターである (\fIsa_family\fP
サブフィールドを参照して、アドレス構造体の形式を判別すべきである)。 このフィールドはヌルポインターとなる場合がある。
.PP
\fIifa_netmask\fP フィールドには、 ネットマスクがあるアドレスファミリーであれば、 \fIifa_addr\fP
に関連付けられたネットマスクを格納した構造体へのポインターが入る。 このフィールドはヌルポインターとなる場合がある。
.PP
\fIifa_flags\fP にビット \fBIFF_BROADCAST\fP か \fBIFF_POINTOPOINT\fP のどちらが設定されているかにより
(同時にはこれらのどちらか一方だけが設定される)、 \fIifa_broadaddr\fP に \fIifa_addr\fP に対応するブロードキャストが入るか
(そのアドレスファミリーでブロードキャストがある場合)、 \fIifa_dstaddr\fP に point\-to\-point
インターフェースの宛先アドレスが入るかが決まる。
.PP
\fIifa_data\fP フィールドは、 アドレスファミリー固有のデータが入ったバッファーへのポインターである。
そのインターフェースでこのようなデータがない場合には、 このフィールドは NULL となる。
.PP
\fBgetifaddrs\fP() が返すデータは動的に確保される。 必要なくなった際には \fBfreeifaddrs\fP() を使って解放すべきである。
.SH 返り値
成功すると、 \fBgetifaddrs\fP は 0 を返す。 エラーの場合、 \-1 が返り、 \fIerrno\fP が適切に設定される。
.SH エラー
\fBgetifaddrs\fP() は失敗する場合があり、その場合には \fIerrno\fP には \fBsocket\fP(2), \fBbind\fP(2),
\fBgetsockname\fP(2), \fBrecvmsg\fP(2), \fBsendto\fP(2), \fBmalloc\fP(3), \fBrealloc\fP(3)
に対して規定されているエラーのいずれかが設定される。
.SH バージョン
\fBgetifaddrs\fP() 関数は glibc 2.3 で初めて登場したが、 glibc 2.3.3 より前のバージョンの実装では IPv4
アドレスだけがサポートされていた。 IPv6 のサポートは glibc 2.3.3 で追加された。 IPv4 以外のアドレスファミリーが
\fBgetifaddrs\fP で利用できるのは、 netlink をサポートするカーネルの場合だけである。
.SH 属性
この節で使用されている用語の説明については、 \fBattributes\fP(7) を参照。
.TS
allbox;
lbw27 lb lb
l l l.
インターフェース	属性	値
T{
\fBgetifaddrs\fP(),
\fBfreeifaddrs\fP()
T}	Thread safety	MT\-Safe
.TE
.sp 1
.SH 準拠
.\" , but the BSD-derived documentation generally
.\" appears to be confused and obsolete on this point.
.\" i.e., commonly it still says one of them will be NULL, even if
.\" the ifa_ifu union is already present
Not in POSIX.1.  This function first appeared in BSDi and is present on the
BSD systems, but with slightly different semantics documented\(emreturning
one entry per interface, not per address.  This means \fIifa_addr\fP and other
fields can actually be NULL if the interface has no address, and no
link\-level address is returned if the interface has an IP address assigned.
Also, the way of choosing either \fIifa_broadaddr\fP or \fIifa_dstaddr\fP differs
on various systems.
.SH 注意
Linux では、 返されるアドレスは通常インターフェースに割り当てられた IPv4 アドレスと IPv6 アドレスになるが、
これ以外にインターフェース毎に一つ \fBAF_PACKET\fP アドレスも返される。 \fBAF_PACKET\fP アドレスには、
インターフェースとその物理層に関する低レベルの詳細が格納される。 この場合、 \fIifa_data\fP フィールドには、
\fI<linux/if_link.h>\fP で定義される \fIstruct rtnl_link_stats\fP (Linux 2.4
以前では \fI<linux/netdevice.h>\fP で定義される \fIstruct net_device_stats\fP)
へのポインターが格納される。 この構造体には、インターフェースの様々な属性や統計情報が入る。
.SH EXAMPLES
以下のプログラムは \fBgetifaddrs\fP(), \fBfreeifaddrs\fP(), \fBgetnameinfo\fP(3) の使用例である。
以下はこのプログラムをあるシステムで実行した際の出力である。
.PP
.in +4n
.EX
$ \fB./a.out\fP
lo       AF_PACKET (17)
                tx_packets =        524; rx_packets =        524
                tx_bytes   =      38788; rx_bytes   =      38788
wlp3s0   AF_PACKET (17)
                tx_packets =     108391; rx_packets =     130245
                tx_bytes   =   30420659; rx_bytes   =   94230014
em1      AF_PACKET (17)
                tx_packets =          0; rx_packets =          0
                tx_bytes   =          0; rx_bytes   =          0
lo       AF_INET (2)
                address: <127.0.0.1>
wlp3s0   AF_INET (2)
                address: <192.168.235.137>
lo       AF_INET6 (10)
                address: <::1>
wlp3s0   AF_INET6 (10)
                address: <fe80::7ee9:d3ff:fef5:1a91%wlp3s0>
.EE
.in
.SS プログラムのソース
\&
.EX
#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <ifaddrs.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <linux/if_link.h>

int main(int argc, char *argv[])
{
    struct ifaddrs *ifaddr;
    int family, s;
    char host[NI_MAXHOST];

    if (getifaddrs(&ifaddr) == \-1) {
        perror("getifaddrs");
        exit(EXIT_FAILURE);
    }

    /* Walk through linked list, maintaining head pointer so we
       can free list later */

    for (struct ifaddrs *ifa = ifaddr; ifa != NULL;
             ifa = ifa\->ifa_next) {
        if (ifa\->ifa_addr == NULL)
            continue;

        family = ifa\->ifa_addr\->sa_family;

        /* Display interface name and family (including symbolic
           form of the latter for the common families) */

        printf("%\-8s %s (%d)\en",
               ifa\->ifa_name,
               (family == AF_PACKET) ? "AF_PACKET" :
               (family == AF_INET) ? "AF_INET" :
               (family == AF_INET6) ? "AF_INET6" : "???",
               family);

        /* For an AF_INET* interface address, display the address */

        if (family == AF_INET || family == AF_INET6) {
            s = getnameinfo(ifa\->ifa_addr,
                    (family == AF_INET) ? sizeof(struct sockaddr_in) :
                                          sizeof(struct sockaddr_in6),
                    host, NI_MAXHOST,
                    NULL, 0, NI_NUMERICHOST);
            if (s != 0) {
                printf("getnameinfo() failed: %s\en", gai_strerror(s));
                exit(EXIT_FAILURE);
            }

            printf("\et\etaddress: <%s>\en", host);

        } else if (family == AF_PACKET && ifa\->ifa_data != NULL) {
            struct rtnl_link_stats *stats = ifa\->ifa_data;

            printf("\et\ettx_packets = %10u; rx_packets = %10u\en"
                   "\et\ettx_bytes   = %10u; rx_bytes   = %10u\en",
                   stats\->tx_packets, stats\->rx_packets,
                   stats\->tx_bytes, stats\->rx_bytes);
        }
    }

    freeifaddrs(ifaddr);
    exit(EXIT_SUCCESS);
}
.EE
.SH 関連項目
\fBbind\fP(2), \fBgetsockname\fP(2), \fBsocket\fP(2), \fBpacket\fP(7), \fBifconfig\fP(8)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は
\%https://www.kernel.org/doc/man\-pages/ に書かれている。
