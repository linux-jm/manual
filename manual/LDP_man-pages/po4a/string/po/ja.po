# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-03-12 21:51+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bcmp.3:31
#, no-wrap
msgid "BCMP"
msgstr "BCMP"

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/memfrob.3:30
#: build/C/man3/memmem.3:30 build/C/man3/memmove.3:30 build/C/man3/memset.3:30
#, fuzzy, no-wrap
#| msgid "2014-03-10"
msgid "2017-03-13"
msgstr "2014-03-10"

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/bzero.3:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/bstring.3:32
#: build/C/man3/bzero.3:25 build/C/man3/ffs.3:33 build/C/man3/index.3:31
#: build/C/man3/memccpy.3:30 build/C/man3/memchr.3:32 build/C/man3/memcmp.3:30
#: build/C/man3/memcpy.3:31 build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30
#: build/C/man3/memmove.3:30 build/C/man3/mempcpy.3:10 build/C/man3/memset.3:30
#: build/C/man3/stpcpy.3:25 build/C/man3/stpncpy.3:14
#: build/C/man3/strcasecmp.3:30 build/C/man3/strcat.3:32
#: build/C/man3/strchr.3:33 build/C/man3/strcmp.3:33 build/C/man3/strcoll.3:30
#: build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31 build/C/man3/strerror.3:39
#: build/C/man3/strfry.3:30 build/C/man3/string.3:30 build/C/man3/strlen.3:30
#: build/C/man3/strnlen.3:13 build/C/man3/strpbrk.3:30 build/C/man3/strsep.3:33
#: build/C/man3/strsignal.3:31 build/C/man3/strspn.3:30
#: build/C/man3/strstr.3:33 build/C/man3/strtok.3:32
#: build/C/man3/strverscmp.3:26 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/bcmp.3:32 build/C/man3/bcopy.3:34 build/C/man3/bstring.3:33
#: build/C/man3/bzero.3:26 build/C/man3/ffs.3:34 build/C/man3/index.3:32
#: build/C/man3/memccpy.3:31 build/C/man3/memchr.3:33 build/C/man3/memcmp.3:31
#: build/C/man3/memcpy.3:32 build/C/man3/memfrob.3:31 build/C/man3/memmem.3:31
#: build/C/man3/memmove.3:31 build/C/man3/mempcpy.3:11 build/C/man3/memset.3:31
#: build/C/man3/stpcpy.3:26 build/C/man3/stpncpy.3:15
#: build/C/man3/strcasecmp.3:31 build/C/man3/strcat.3:33
#: build/C/man3/strchr.3:34 build/C/man3/strcmp.3:34 build/C/man3/strcoll.3:31
#: build/C/man3/strcpy.3:36 build/C/man3/strdup.3:32 build/C/man3/strerror.3:40
#: build/C/man3/strfry.3:31 build/C/man3/string.3:31 build/C/man3/strlen.3:31
#: build/C/man3/strnlen.3:14 build/C/man3/strpbrk.3:31 build/C/man3/strsep.3:34
#: build/C/man3/strsignal.3:32 build/C/man3/strspn.3:31
#: build/C/man3/strstr.3:34 build/C/man3/strtok.3:33
#: build/C/man3/strverscmp.3:27 build/C/man3/strxfrm.3:31
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/bcmp.3:34
msgid "bcmp - compare byte sequences"
msgstr "bcmp - バイト列を比較する"

#. type: SH
#: build/C/man3/bcmp.3:34 build/C/man3/bcopy.3:36 build/C/man3/bstring.3:36
#: build/C/man3/bzero.3:28 build/C/man3/ffs.3:36 build/C/man3/index.3:34
#: build/C/man3/memccpy.3:33 build/C/man3/memchr.3:35 build/C/man3/memcmp.3:33
#: build/C/man3/memcpy.3:34 build/C/man3/memfrob.3:33 build/C/man3/memmem.3:33
#: build/C/man3/memmove.3:33 build/C/man3/mempcpy.3:13 build/C/man3/memset.3:33
#: build/C/man3/stpcpy.3:28 build/C/man3/stpncpy.3:17
#: build/C/man3/strcasecmp.3:33 build/C/man3/strcat.3:35
#: build/C/man3/strchr.3:36 build/C/man3/strcmp.3:36 build/C/man3/strcoll.3:33
#: build/C/man3/strcpy.3:38 build/C/man3/strdup.3:34 build/C/man3/strerror.3:42
#: build/C/man3/strfry.3:33 build/C/man3/string.3:36 build/C/man3/strlen.3:33
#: build/C/man3/strnlen.3:16 build/C/man3/strpbrk.3:33 build/C/man3/strsep.3:36
#: build/C/man3/strsignal.3:34 build/C/man3/strspn.3:33
#: build/C/man3/strstr.3:36 build/C/man3/strtok.3:35
#: build/C/man3/strverscmp.3:29 build/C/man3/strxfrm.3:33
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bcmp.3:37 build/C/man3/bcopy.3:39 build/C/man3/bzero.3:31
#: build/C/man3/ffs.3:39 build/C/man3/index.3:37 build/C/man3/strcasecmp.3:36
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr "B<#include E<lt>strings.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bcmp.3:39 build/C/man3/bstring.3:41
#, no-wrap
msgid "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: SH
#: build/C/man3/bcmp.3:40 build/C/man3/bcopy.3:42 build/C/man3/bstring.3:63
#: build/C/man3/bzero.3:38 build/C/man3/ffs.3:84 build/C/man3/index.3:42
#: build/C/man3/memccpy.3:39 build/C/man3/memchr.3:54 build/C/man3/memcmp.3:39
#: build/C/man3/memcpy.3:40 build/C/man3/memfrob.3:40 build/C/man3/memmem.3:41
#: build/C/man3/memmove.3:39 build/C/man3/mempcpy.3:25 build/C/man3/memset.3:39
#: build/C/man3/stpcpy.3:53 build/C/man3/stpncpy.3:42
#: build/C/man3/strcasecmp.3:41 build/C/man3/strcat.3:43
#: build/C/man3/strchr.3:49 build/C/man3/strcmp.3:44 build/C/man3/strcoll.3:39
#: build/C/man3/strcpy.3:46 build/C/man3/strdup.3:75 build/C/man3/strerror.3:80
#: build/C/man3/strfry.3:40 build/C/man3/string.3:204 build/C/man3/strlen.3:39
#: build/C/man3/strnlen.3:41 build/C/man3/strpbrk.3:39 build/C/man3/strsep.3:53
#: build/C/man3/strsignal.3:76 build/C/man3/strspn.3:41
#: build/C/man3/strstr.3:48 build/C/man3/strtok.3:54
#: build/C/man3/strverscmp.3:36 build/C/man3/strxfrm.3:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/bcmp.3:56
msgid ""
"The B<bcmp>()  function compares the two byte sequences I<s1> and I<s2> of "
"length I<n> each.  If they are equal, and in particular if I<n> is zero, "
"B<bcmp>()  returns 0.  Otherwise, it returns a nonzero result."
msgstr ""
"B<bcmp>()  は、2 つのバイト列 I<s1> と I<s2> の先頭 I<n> バイトを 比較する。"
"2 つが等しいか、特に I<n> が 0 の場合 B<bcmp>()  は 0 を返す。 さもなければ "
"0 以外を返す。"

#. type: SH
#: build/C/man3/bcmp.3:56 build/C/man3/bcopy.3:52 build/C/man3/bzero.3:55
#: build/C/man3/ffs.3:97 build/C/man3/index.3:55 build/C/man3/memccpy.3:55
#: build/C/man3/memchr.3:105 build/C/man3/memcmp.3:45 build/C/man3/memcpy.3:49
#: build/C/man3/memfrob.3:53 build/C/man3/memmem.3:54 build/C/man3/memmove.3:57
#: build/C/man3/mempcpy.3:51 build/C/man3/memset.3:49 build/C/man3/stpcpy.3:63
#: build/C/man3/stpncpy.3:82 build/C/man3/strcasecmp.3:65
#: build/C/man3/strcat.3:123 build/C/man3/strchr.3:81 build/C/man3/strcmp.3:83
#: build/C/man3/strcoll.3:58 build/C/man3/strcpy.3:108
#: build/C/man3/strdup.3:109 build/C/man3/strerror.3:187
#: build/C/man3/strfry.3:48 build/C/man3/strlen.3:45 build/C/man3/strnlen.3:58
#: build/C/man3/strpbrk.3:47 build/C/man3/strsep.3:76
#: build/C/man3/strsignal.3:116 build/C/man3/strspn.3:57
#: build/C/man3/strstr.3:62 build/C/man3/strtok.3:163
#: build/C/man3/strverscmp.3:81 build/C/man3/strxfrm.3:62
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bcmp.3:61
msgid ""
"The B<bcmp>()  function returns 0 if the byte sequences are equal, otherwise "
"a nonzero result is returned."
msgstr "バイト列が等しい場合は 0 、等しくない場合は 0 以外を返す。"

#. type: SH
#: build/C/man3/bcmp.3:61 build/C/man3/bcopy.3:54 build/C/man3/bzero.3:60
#: build/C/man3/ffs.3:101 build/C/man3/index.3:62 build/C/man3/memccpy.3:70
#: build/C/man3/memchr.3:124 build/C/man3/memcmp.3:64 build/C/man3/memcpy.3:53
#: build/C/man3/memfrob.3:58 build/C/man3/memmem.3:59 build/C/man3/memmove.3:62
#: build/C/man3/mempcpy.3:58 build/C/man3/memset.3:54 build/C/man3/stpcpy.3:71
#: build/C/man3/stpncpy.3:91 build/C/man3/strcasecmp.3:77
#: build/C/man3/strcat.3:130 build/C/man3/strchr.3:105 build/C/man3/strcmp.3:96
#: build/C/man3/strcoll.3:69 build/C/man3/strcpy.3:116
#: build/C/man3/strdup.3:121 build/C/man3/strerror.3:242
#: build/C/man3/strfry.3:53 build/C/man3/strlen.3:50 build/C/man3/strnlen.3:71
#: build/C/man3/strpbrk.3:56 build/C/man3/strsep.3:82
#: build/C/man3/strsignal.3:143 build/C/man3/strspn.3:74
#: build/C/man3/strstr.3:65 build/C/man3/strtok.3:170
#: build/C/man3/strverscmp.3:90 build/C/man3/strxfrm.3:76
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/bcmp.3:64 build/C/man3/bcopy.3:57 build/C/man3/bzero.3:63
#: build/C/man3/ffs.3:104 build/C/man3/index.3:65 build/C/man3/memccpy.3:73
#: build/C/man3/memchr.3:127 build/C/man3/memcmp.3:67 build/C/man3/memcpy.3:56
#: build/C/man3/memfrob.3:61 build/C/man3/memmem.3:62 build/C/man3/memmove.3:65
#: build/C/man3/mempcpy.3:61 build/C/man3/memset.3:57 build/C/man3/stpcpy.3:74
#: build/C/man3/stpncpy.3:94 build/C/man3/strcasecmp.3:80
#: build/C/man3/strcat.3:133 build/C/man3/strchr.3:108 build/C/man3/strcmp.3:99
#: build/C/man3/strcoll.3:72 build/C/man3/strcpy.3:119
#: build/C/man3/strdup.3:124 build/C/man3/strerror.3:245
#: build/C/man3/strfry.3:56 build/C/man3/strlen.3:53 build/C/man3/strnlen.3:74
#: build/C/man3/strpbrk.3:59 build/C/man3/strsep.3:85
#: build/C/man3/strsignal.3:146 build/C/man3/strspn.3:77
#: build/C/man3/strstr.3:68 build/C/man3/strtok.3:173
#: build/C/man3/strverscmp.3:93 build/C/man3/strxfrm.3:79
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:61 build/C/man3/bzero.3:67
#: build/C/man3/ffs.3:108 build/C/man3/index.3:69 build/C/man3/memccpy.3:77
#: build/C/man3/memchr.3:131 build/C/man3/memcmp.3:71 build/C/man3/memcpy.3:60
#: build/C/man3/memfrob.3:65 build/C/man3/memmem.3:66 build/C/man3/memmove.3:69
#: build/C/man3/mempcpy.3:65 build/C/man3/memset.3:61 build/C/man3/stpcpy.3:78
#: build/C/man3/stpncpy.3:98 build/C/man3/strcasecmp.3:84
#: build/C/man3/strcat.3:137 build/C/man3/strchr.3:112
#: build/C/man3/strcmp.3:103 build/C/man3/strcoll.3:76
#: build/C/man3/strcpy.3:123 build/C/man3/strdup.3:128
#: build/C/man3/strerror.3:249 build/C/man3/strfry.3:60
#: build/C/man3/strlen.3:57 build/C/man3/strnlen.3:78 build/C/man3/strpbrk.3:63
#: build/C/man3/strsep.3:89 build/C/man3/strsignal.3:150
#: build/C/man3/strspn.3:81 build/C/man3/strstr.3:72 build/C/man3/strtok.3:177
#: build/C/man3/strverscmp.3:97 build/C/man3/strxfrm.3:83
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:61 build/C/man3/bzero.3:67
#: build/C/man3/ffs.3:108 build/C/man3/index.3:69 build/C/man3/memccpy.3:77
#: build/C/man3/memchr.3:131 build/C/man3/memcmp.3:71 build/C/man3/memcpy.3:60
#: build/C/man3/memfrob.3:65 build/C/man3/memmem.3:66 build/C/man3/memmove.3:69
#: build/C/man3/mempcpy.3:65 build/C/man3/memset.3:61 build/C/man3/stpcpy.3:78
#: build/C/man3/stpncpy.3:98 build/C/man3/strcasecmp.3:84
#: build/C/man3/strcat.3:137 build/C/man3/strchr.3:112
#: build/C/man3/strcmp.3:103 build/C/man3/strcoll.3:76
#: build/C/man3/strcpy.3:123 build/C/man3/strdup.3:128
#: build/C/man3/strerror.3:249 build/C/man3/strfry.3:60
#: build/C/man3/strlen.3:57 build/C/man3/strnlen.3:78 build/C/man3/strpbrk.3:63
#: build/C/man3/strsep.3:89 build/C/man3/strsignal.3:150
#: build/C/man3/strspn.3:81 build/C/man3/strstr.3:72 build/C/man3/strtok.3:177
#: build/C/man3/strverscmp.3:97 build/C/man3/strxfrm.3:83
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:61 build/C/man3/bzero.3:67
#: build/C/man3/ffs.3:108 build/C/man3/index.3:69 build/C/man3/memccpy.3:77
#: build/C/man3/memchr.3:131 build/C/man3/memcmp.3:71 build/C/man3/memcpy.3:60
#: build/C/man3/memfrob.3:65 build/C/man3/memmem.3:66 build/C/man3/memmove.3:69
#: build/C/man3/mempcpy.3:65 build/C/man3/memset.3:61 build/C/man3/stpcpy.3:78
#: build/C/man3/stpncpy.3:98 build/C/man3/strcasecmp.3:84
#: build/C/man3/strcat.3:137 build/C/man3/strchr.3:112
#: build/C/man3/strcmp.3:103 build/C/man3/strcoll.3:76
#: build/C/man3/strcpy.3:123 build/C/man3/strdup.3:128
#: build/C/man3/strerror.3:249 build/C/man3/strfry.3:60
#: build/C/man3/strlen.3:57 build/C/man3/strnlen.3:78 build/C/man3/strpbrk.3:63
#: build/C/man3/strsep.3:89 build/C/man3/strsignal.3:150
#: build/C/man3/strspn.3:81 build/C/man3/strstr.3:72 build/C/man3/strtok.3:177
#: build/C/man3/strverscmp.3:97 build/C/man3/strxfrm.3:83
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:71
#, no-wrap
msgid "B<bcmp>()"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:71 build/C/man3/bcopy.3:64 build/C/man3/bzero.3:72
#: build/C/man3/ffs.3:113 build/C/man3/index.3:73 build/C/man3/memccpy.3:80
#: build/C/man3/memchr.3:136 build/C/man3/memcmp.3:74 build/C/man3/memcpy.3:63
#: build/C/man3/memfrob.3:68 build/C/man3/memmem.3:69 build/C/man3/memmove.3:72
#: build/C/man3/mempcpy.3:69 build/C/man3/memset.3:64 build/C/man3/stpcpy.3:81
#: build/C/man3/stpncpy.3:101 build/C/man3/strcasecmp.3:88
#: build/C/man3/strcat.3:141 build/C/man3/strchr.3:117
#: build/C/man3/strcmp.3:107 build/C/man3/strcoll.3:79
#: build/C/man3/strcpy.3:127 build/C/man3/strdup.3:135
#: build/C/man3/strerror.3:252 build/C/man3/strerror.3:256
#: build/C/man3/strerror.3:261 build/C/man3/strfry.3:63
#: build/C/man3/strlen.3:60 build/C/man3/strnlen.3:81 build/C/man3/strpbrk.3:66
#: build/C/man3/strsep.3:92 build/C/man3/strsignal.3:153
#: build/C/man3/strsignal.3:157 build/C/man3/strspn.3:85
#: build/C/man3/strstr.3:75 build/C/man3/strstr.3:78 build/C/man3/strtok.3:180
#: build/C/man3/strtok.3:183 build/C/man3/strverscmp.3:100
#: build/C/man3/strxfrm.3:86
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:71 build/C/man3/bcopy.3:64 build/C/man3/bzero.3:72
#: build/C/man3/ffs.3:113 build/C/man3/index.3:73 build/C/man3/memccpy.3:80
#: build/C/man3/memchr.3:136 build/C/man3/memcmp.3:74 build/C/man3/memcpy.3:63
#: build/C/man3/memfrob.3:68 build/C/man3/memmem.3:69 build/C/man3/memmove.3:72
#: build/C/man3/mempcpy.3:69 build/C/man3/memset.3:64 build/C/man3/stpcpy.3:81
#: build/C/man3/stpncpy.3:101 build/C/man3/strcat.3:141
#: build/C/man3/strchr.3:117 build/C/man3/strcmp.3:107
#: build/C/man3/strcpy.3:127 build/C/man3/strdup.3:135
#: build/C/man3/strerror.3:256 build/C/man3/strerror.3:261
#: build/C/man3/strfry.3:63 build/C/man3/strlen.3:60 build/C/man3/strnlen.3:81
#: build/C/man3/strpbrk.3:66 build/C/man3/strsep.3:92
#: build/C/man3/strsignal.3:157 build/C/man3/strspn.3:85
#: build/C/man3/strstr.3:75 build/C/man3/strtok.3:183
#: build/C/man3/strverscmp.3:100
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:73 build/C/man3/bcopy.3:66 build/C/man3/bzero.3:74
#: build/C/man3/ffs.3:115 build/C/man3/index.3:75 build/C/man3/memccpy.3:82
#: build/C/man3/memchr.3:138 build/C/man3/memcmp.3:76 build/C/man3/memcpy.3:65
#: build/C/man3/memfrob.3:70 build/C/man3/memmem.3:71 build/C/man3/memmove.3:74
#: build/C/man3/mempcpy.3:71 build/C/man3/memset.3:66 build/C/man3/stpcpy.3:83
#: build/C/man3/stpncpy.3:103 build/C/man3/strcasecmp.3:90
#: build/C/man3/strcat.3:143 build/C/man3/strchr.3:119
#: build/C/man3/strcmp.3:109 build/C/man3/strcoll.3:82
#: build/C/man3/strcpy.3:129 build/C/man3/strdup.3:138
#: build/C/man3/strerror.3:263 build/C/man3/strfry.3:65
#: build/C/man3/strlen.3:62 build/C/man3/strnlen.3:83 build/C/man3/strpbrk.3:68
#: build/C/man3/strsep.3:94 build/C/man3/strsignal.3:160
#: build/C/man3/strspn.3:87 build/C/man3/strstr.3:80 build/C/man3/strtok.3:185
#: build/C/man3/strverscmp.3:112 build/C/man3/strxfrm.3:88
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bcmp.3:80
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memcmp>(3)  in new programs.  POSIX.1-2008 removes the specification of "
"B<bcmp>()."
msgstr ""
"4.3BSD.  この関数は廃止予定である (POSIX.1-2001 では 過去の名残 (LEGACY) とさ"
"れている)。新しいプログラムでは B<memcmp>(3)  を使うべきである。 "
"POSIX.1-2008 では B<bcmp>()  の仕様が削除されている。"

#. type: SH
#: build/C/man3/bcmp.3:80 build/C/man3/bcopy.3:80 build/C/man3/bstring.3:82
#: build/C/man3/bzero.3:172 build/C/man3/ffs.3:127 build/C/man3/index.3:86
#: build/C/man3/memccpy.3:84 build/C/man3/memchr.3:149 build/C/man3/memcmp.3:88
#: build/C/man3/memcpy.3:109 build/C/man3/memfrob.3:75 build/C/man3/memmem.3:99
#: build/C/man3/memmove.3:76 build/C/man3/mempcpy.3:84 build/C/man3/memset.3:68
#: build/C/man3/stpcpy.3:122 build/C/man3/stpncpy.3:107
#: build/C/man3/strcasecmp.3:117 build/C/man3/strcat.3:226
#: build/C/man3/strchr.3:126 build/C/man3/strcmp.3:210
#: build/C/man3/strcoll.3:93 build/C/man3/strcpy.3:233
#: build/C/man3/strdup.3:148 build/C/man3/strerror.3:314
#: build/C/man3/strfry.3:70 build/C/man3/string.3:208 build/C/man3/strlen.3:64
#: build/C/man3/strnlen.3:85 build/C/man3/strpbrk.3:70
#: build/C/man3/strsep.3:114 build/C/man3/strsignal.3:177
#: build/C/man3/strspn.3:89 build/C/man3/strstr.3:87 build/C/man3/strtok.3:282
#: build/C/man3/strverscmp.3:154 build/C/man3/strxfrm.3:90
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/bcmp.3:88
#, fuzzy
#| msgid ""
#| "B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
#| "B<strncasecmp>(3), B<strncmp>(3)"
msgid ""
"B<bstring>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3)"
msgstr ""
"B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3)"

#. type: SH
#: build/C/man3/bcmp.3:88 build/C/man3/bcopy.3:87 build/C/man3/bstring.3:94
#: build/C/man3/bzero.3:176 build/C/man3/ffs.3:129 build/C/man3/index.3:96
#: build/C/man3/memccpy.3:91 build/C/man3/memchr.3:162 build/C/man3/memcmp.3:97
#: build/C/man3/memcpy.3:118 build/C/man3/memfrob.3:78
#: build/C/man3/memmem.3:102 build/C/man3/memmove.3:84
#: build/C/man3/mempcpy.3:89 build/C/man3/memset.3:73 build/C/man3/stpcpy.3:131
#: build/C/man3/stpncpy.3:110 build/C/man3/strcasecmp.3:126
#: build/C/man3/strcat.3:235 build/C/man3/strchr.3:139
#: build/C/man3/strcmp.3:221 build/C/man3/strcoll.3:101
#: build/C/man3/strcpy.3:244 build/C/man3/strdup.3:156
#: build/C/man3/strerror.3:321 build/C/man3/strfry.3:73
#: build/C/man3/string.3:233 build/C/man3/strlen.3:69 build/C/man3/strnlen.3:87
#: build/C/man3/strpbrk.3:81 build/C/man3/strsep.3:124
#: build/C/man3/strsignal.3:180 build/C/man3/strspn.3:101
#: build/C/man3/strstr.3:100 build/C/man3/strtok.3:293
#: build/C/man3/strverscmp.3:159 build/C/man3/strxfrm.3:98
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/bcmp.3:96 build/C/man3/bcopy.3:95 build/C/man3/bstring.3:102
#: build/C/man3/bzero.3:184 build/C/man3/ffs.3:137 build/C/man3/index.3:104
#: build/C/man3/memccpy.3:99 build/C/man3/memchr.3:170
#: build/C/man3/memcmp.3:105 build/C/man3/memcpy.3:126
#: build/C/man3/memfrob.3:86 build/C/man3/memmem.3:110
#: build/C/man3/memmove.3:92 build/C/man3/mempcpy.3:97 build/C/man3/memset.3:81
#: build/C/man3/stpcpy.3:139 build/C/man3/stpncpy.3:118
#: build/C/man3/strcasecmp.3:134 build/C/man3/strcat.3:243
#: build/C/man3/strchr.3:147 build/C/man3/strcmp.3:229
#: build/C/man3/strcoll.3:109 build/C/man3/strcpy.3:252
#: build/C/man3/strdup.3:164 build/C/man3/strerror.3:329
#: build/C/man3/strfry.3:81 build/C/man3/string.3:241 build/C/man3/strlen.3:77
#: build/C/man3/strnlen.3:95 build/C/man3/strpbrk.3:89
#: build/C/man3/strsep.3:132 build/C/man3/strsignal.3:188
#: build/C/man3/strspn.3:109 build/C/man3/strstr.3:108
#: build/C/man3/strtok.3:301 build/C/man3/strverscmp.3:167
#: build/C/man3/strxfrm.3:106
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/bcopy.3:33
#, no-wrap
msgid "BCOPY"
msgstr "BCOPY"

#. type: Plain text
#: build/C/man3/bcopy.3:36
msgid "bcopy - copy byte sequence"
msgstr "bcopy - バイト列をコピーする"

#. type: Plain text
#: build/C/man3/bcopy.3:41 build/C/man3/bstring.3:43
#, no-wrap
msgid "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, size_t >I<n>B<);>\n"
msgstr "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bcopy.3:52
msgid ""
"The B<bcopy>()  function copies I<n> bytes from I<src> to I<dest>.  The "
"result is correct, even when both areas overlap."
msgstr ""
"B<bcopy>()  は I<src> から先頭 I<n> バイトを I<dest> にコピーする。 領域が重"
"なっていても、結果は正しいものである。"

#. type: Plain text
#: build/C/man3/bcopy.3:54 build/C/man3/bzero.3:57
msgid "None."
msgstr "なし。"

#. type: tbl table
#: build/C/man3/bcopy.3:64
#, fuzzy, no-wrap
#| msgid "B<stpcpy>():"
msgid "B<bcopy>()"
msgstr "B<stpcpy>():"

#. type: Plain text
#: build/C/man3/bcopy.3:80
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memcpy>(3)  or B<memmove>(3)  in new programs.  Note that the first two "
"arguments are interchanged for B<memcpy>(3)  and B<memmove>(3).  "
"POSIX.1-2008 removes the specification of B<bcopy>()."
msgstr ""
"4.3BSD.  この関数は廃止予定である (POSIX.1-2001 では 過去の名残 (LEGACY) とさ"
"れている)。新しいプログラムでは B<memcpy>()  や B<memmove>()  を使用すべきで"
"ある。 B<memcpy>()  や B<memmove>()  では、最初の 2 つの引数の順序が入れ替"
"わっていることに注意すること。 POSIX.1-2008 では、 B<bcopy>()  の仕様が削除さ"
"れている。"

#. type: Plain text
#: build/C/man3/bcopy.3:87
#, fuzzy
#| msgid ""
#| "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"
msgid ""
"B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr ""
"B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"

#. type: TH
#: build/C/man3/bstring.3:32
#, no-wrap
msgid "BSTRING"
msgstr "BSTRING"

#. type: TH
#: build/C/man3/bstring.3:32 build/C/man3/strnlen.3:13
#, fuzzy, no-wrap
#| msgid "2001-12-19"
msgid "2020-12-21"
msgstr "2001-12-19"

#. type: Plain text
#: build/C/man3/bstring.3:36
msgid ""
"bcmp, bcopy, bzero, memccpy, memchr, memcmp, memcpy, memfrob, memmem, "
"memmove, memset - byte string operations"
msgstr ""
"bcmp, bcopy, bzero, memccpy, memchr, memcmp, memcpy, memfrob, memmem, "
"memmove, memset - バイト列の操作を行なう"

#. type: Plain text
#: build/C/man3/bstring.3:39 build/C/man3/bzero.3:35 build/C/man3/ffs.3:43
#: build/C/man3/memccpy.3:36 build/C/man3/memchr.3:38 build/C/man3/memcmp.3:36
#: build/C/man3/memcpy.3:37 build/C/man3/memmove.3:36 build/C/man3/memset.3:36
#: build/C/man3/stpcpy.3:31 build/C/man3/stpncpy.3:20 build/C/man3/strcat.3:38
#: build/C/man3/strchr.3:39 build/C/man3/strcmp.3:39 build/C/man3/strcoll.3:36
#: build/C/man3/strcpy.3:41 build/C/man3/strdup.3:37 build/C/man3/strerror.3:45
#: build/C/man3/strlen.3:36 build/C/man3/strnlen.3:19 build/C/man3/strpbrk.3:36
#: build/C/man3/strsep.3:39 build/C/man3/strsignal.3:37
#: build/C/man3/strspn.3:36 build/C/man3/strstr.3:39 build/C/man3/strstr.3:45
#: build/C/man3/strtok.3:38 build/C/man3/strxfrm.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bstring.3:45 build/C/man3/bzero.3:33
#, no-wrap
msgid "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:47 build/C/man3/memccpy.3:38
#, no-wrap
msgid "B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:49 build/C/man3/memchr.3:40
#, no-wrap
msgid "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:51 build/C/man3/memcmp.3:38
#, no-wrap
msgid "B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:53 build/C/man3/memcpy.3:39
#, no-wrap
msgid "B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:55 build/C/man3/memfrob.3:39
#, no-wrap
msgid "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:58 build/C/man3/memmem.3:40
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"
msgstr ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:60 build/C/man3/memmove.3:38
#, no-wrap
msgid "B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:62 build/C/man3/memset.3:38
#, no-wrap
msgid "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:68
msgid ""
"The byte string functions perform operations on strings (byte arrays)  that "
"are not necessarily null-terminated.  See the individual man pages for "
"descriptions of each function."
msgstr ""
"これらの関数はヌル終端する必要のない文字列 (バイト配列) の操作を行う。 関数の"
"詳しい説明は、それぞれの man ページを参照すること。"

#. type: SH
#: build/C/man3/bstring.3:68 build/C/man3/bzero.3:93 build/C/man3/ffs.3:124
#: build/C/man3/memcmp.3:78 build/C/man3/memcpy.3:67
#: build/C/man3/strcasecmp.3:92 build/C/man3/strcat.3:145
#: build/C/man3/strcmp.3:111 build/C/man3/strcoll.3:84
#: build/C/man3/strcpy.3:131 build/C/man3/strerror.3:302
#: build/C/man3/strsep.3:96 build/C/man3/strsignal.3:172
#: build/C/man3/strtok.3:192
#, no-wrap
msgid "NOTES"
msgstr "注意"

#.  The old functions are not even available on some non-GNU/Linux systems.
#. type: Plain text
#: build/C/man3/bstring.3:82
#, fuzzy
#| msgid ""
#| "The functions B<bcmp>(), B<bcopy>()  and B<bzero>()  are obsolete.  Use "
#| "B<memcmp>(), B<memcpy>()  and B<memset>()  instead."
msgid ""
"The functions B<bcmp>(), B<bcopy>(), and B<bzero>()  are obsolete.  Use "
"B<memcmp>(), B<memcpy>(), and B<memset>()  instead."
msgstr ""
"B<bcmp>(), B<bcopy>(), B<bzero>()  関数は古いものである。代わりに "
"B<memcmp>(), B<memcpy>()  B<memset>()  を使うこと。"

#. type: Plain text
#: build/C/man3/bstring.3:94
msgid ""
"B<bcmp>(3), B<bcopy>(3), B<bzero>(3), B<memccpy>(3), B<memchr>(3), "
"B<memcmp>(3), B<memcpy>(3), B<memfrob>(3), B<memmem>(3), B<memmove>(3), "
"B<memset>(3)"
msgstr ""
"B<bcmp>(3), B<bcopy>(3), B<bzero>(3), B<memccpy>(3), B<memchr>(3), "
"B<memcmp>(3), B<memcpy>(3), B<memfrob>(3), B<memmem>(3), B<memmove>(3), "
"B<memset>(3)"

#. type: TH
#: build/C/man3/bzero.3:25
#, no-wrap
msgid "BZERO"
msgstr "BZERO"

#. type: TH
#: build/C/man3/bzero.3:25 build/C/man3/index.3:31 build/C/man3/memchr.3:32
#: build/C/man3/stpncpy.3:14 build/C/man3/strchr.3:33 build/C/man3/strcpy.3:35
#: build/C/man3/strdup.3:31 build/C/man3/strfry.3:30 build/C/man3/string.3:30
#: build/C/man3/strlen.3:30 build/C/man3/strsep.3:33 build/C/man3/strstr.3:33
#: build/C/man3/strxfrm.3:30
#, fuzzy, no-wrap
#| msgid "2014-03-10"
msgid "2019-03-06"
msgstr "2014-03-10"

#. type: Plain text
#: build/C/man3/bzero.3:28
msgid "bzero, explicit_bzero - zero a byte string"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:37
#, fuzzy, no-wrap
#| msgid "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgid "B<void explicit_bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bzero.3:46
#, fuzzy
#| msgid ""
#| "The B<bzero>()  function sets the first I<n> bytes of the area starting "
#| "at I<s> to zero (bytes containing \\(aq\\e0\\(aq)."
msgid ""
"The B<bzero>()  function erases the data in the I<n> bytes of the memory "
"starting at the location pointed to by I<s>, by writing zeros (bytes "
"containing \\(aq\\e0\\(aq) to that area."
msgstr ""
"B<bzero>()  関数は バイト列 I<s> から始まる領域の先頭 I<n> バイトを 数値ゼロ "
"(値が \\(aq\\e0\\(aq のバイト) で埋める。"

#. type: Plain text
#: build/C/man3/bzero.3:55
msgid ""
"The B<explicit_bzero>()  function performs the same task as B<bzero>().  It "
"differs from B<bzero>()  in that it guarantees that compiler optimizations "
"will not remove the erase operation if the compiler deduces that the "
"operation is \"unnecessary\"."
msgstr ""

#. type: SH
#: build/C/man3/bzero.3:57 build/C/man3/memchr.3:118 build/C/man3/mempcpy.3:55
#: build/C/man3/strchr.3:102 build/C/man3/strerror.3:238
#: build/C/man3/strsignal.3:132
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/bzero.3:60
#, fuzzy
#| msgid "B<memrchr>()  first appeared in glibc in version 2.2."
msgid "B<explicit_bzero>()  first appeared in glibc 2.25."
msgstr "B<memrchr>()  は glibc バージョン 2.2 で初めて登場した。"

#. type: tbl table
#: build/C/man3/bzero.3:70
#, no-wrap
msgid "B<bzero>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/bzero.3:70 build/C/man3/strdup.3:133
#: build/C/man3/strerror.3:259
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/bzero.3:72
#, no-wrap
msgid "B<explicit_bzero>()"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:85
#, fuzzy
#| msgid ""
#| "4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): "
#| "use B<memset>(3)  in new programs.  POSIX.1-2008 removes the "
#| "specification of B<bzero>()."
msgid ""
"The B<bzero>()  function is deprecated (marked as LEGACY in POSIX.1-2001); "
"use B<memset>(3)  in new programs.  POSIX.1-2008 removes the specification "
"of B<bzero>().  The B<bzero>()  function first appeared in 4.3BSD."
msgstr ""
"4.3BSD.  この関数は廃止予定である (POSIX.1-2001 では 過去の名残 (LEGACY) とさ"
"れている)。新しいプログラムでは B<memset>(3)  を使用すべきである。 "
"POSIX.1-2008 では B<bzero>()  の仕様が削除されている。"

#. type: Plain text
#: build/C/man3/bzero.3:93
msgid ""
"The B<explicit_bzero>()  function is a nonstandard extension that is also "
"present on some of the BSDs.  Some other implementations have a similar "
"function, such as B<memset_explicit>()  or B<memset_s>()."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:113
msgid ""
"The B<explicit_bzero>()  function addresses a problem that security-"
"conscious applications may run into when using B<bzero>(): if the compiler "
"can deduce that the location to zeroed will never again be touched by a "
"I<correct> program, then it may remove the B<bzero>()  call altogether.  "
"This is a problem if the intent of the B<bzero>()  call was to erase "
"sensitive data (e.g., passwords)  to prevent the possibility that the data "
"was leaked by an incorrect or compromised program.  Calls to "
"B<explicit_bzero>()  are never optimized away by the compiler."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:117
msgid ""
"The B<explicit_bzero>()  function does not solve all problems associated "
"with erasing sensitive data:"
msgstr ""

#. type: IP
#: build/C/man3/bzero.3:117
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:130
msgid ""
"The B<explicit_bzero>()  function does I<not> guarantee that sensitive data "
"is completely erased from memory.  (The same is true of B<bzero>().)  For "
"example, there may be copies of the sensitive data in a register and in "
"\"scratch\" stack areas.  The B<explicit_bzero>()  function is not aware of "
"these copies, and can't erase them."
msgstr ""

#. type: IP
#: build/C/man3/bzero.3:130
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:152
msgid ""
"In some circumstances, B<explicit_bzero>()  can I<decrease> security.  If "
"the compiler determined that the variable containing the sensitive data "
"could be optimized to be stored in a register (because it is small enough to "
"fit in a register, and no operation other than the B<explicit_bzero>()  call "
"would need to take the address of the variable), then the "
"B<explicit_bzero>()  call will force the data to be copied from the register "
"to a location in RAM that is then immediately erased (while the copy in the "
"register remains unaffected).  The problem here is that data in RAM is more "
"likely to be exposed by a bug than data in a register, and thus the "
"B<explicit_bzero>()  call creates a brief time window where the sensitive "
"data is more vulnerable than it would otherwise have been if no attempt had "
"been made to erase the data."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:162
msgid ""
"Note that declaring the sensitive variable with the B<volatile> qualifier "
"does I<not> eliminate the above problems.  Indeed, it will make them worse, "
"since, for example, it may force a variable that would otherwise have been "
"optimized into a register to instead be maintained in (more vulnerable)  RAM "
"for its entire lifetime."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:172
msgid ""
"Notwithstanding the above details, for security-conscious applications, "
"using B<explicit_bzero>()  is generally preferable to not using it.  The "
"developers of B<explicit_bzero>()  anticipate that future compilers will "
"recognize calls to B<explicit_bzero>()  and take steps to ensure that all "
"copies of the sensitive data are erased, including copies in registers or in "
"\"scratch\" stack areas."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:176
#, fuzzy
#| msgid "B<memset>(3), B<swab>(3)"
msgid "B<bstring>(3), B<memset>(3), B<swab>(3)"
msgstr "B<memset>(3), B<swab>(3)"

#. type: TH
#: build/C/man3/ffs.3:33
#, no-wrap
msgid "FFS"
msgstr "FFS"

#. type: TH
#: build/C/man3/ffs.3:33 build/C/man3/strcat.3:32 build/C/man3/strerror.3:39
#: build/C/man3/strsignal.3:31 build/C/man3/strtok.3:32
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/ffs.3:33 build/C/man3/index.3:31 build/C/man3/memccpy.3:30
#: build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30 build/C/man3/memmove.3:30
#: build/C/man3/mempcpy.3:10 build/C/man3/memset.3:30 build/C/man3/stpcpy.3:25
#: build/C/man3/stpncpy.3:14 build/C/man3/strcat.3:32 build/C/man3/strchr.3:33
#: build/C/man3/strcoll.3:30 build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31
#: build/C/man3/strfry.3:30 build/C/man3/strlen.3:30 build/C/man3/strnlen.3:13
#: build/C/man3/strsep.3:33 build/C/man3/strsignal.3:31
#: build/C/man3/strstr.3:33 build/C/man3/strtok.3:32
#: build/C/man3/strverscmp.3:26 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/ffs.3:36
msgid "ffs, ffsl, ffsll - find first bit set in a word"
msgstr "ffs, ffsl, ffsll - ワードの中で最初にセットされているビットの検出"

#. type: Plain text
#: build/C/man3/ffs.3:41
#, no-wrap
msgid "B<int ffs(int >I<i>B<);>\n"
msgstr "B<int ffs(int >I<i>B<);>\n"

#. type: Plain text
#: build/C/man3/ffs.3:45
#, fuzzy, no-wrap
#| msgid "B<int ffsl(long int >I<i>B<);>\n"
msgid "B<int ffsl(long >I<i>B<);>\n"
msgstr "B<int ffsl(long int >I<i>B<);>\n"

#. type: Plain text
#: build/C/man3/ffs.3:47
#, fuzzy, no-wrap
#| msgid "B<int ffsll(long long int >I<i>B<);>\n"
msgid "B<int ffsll(long long >I<i>B<);>\n"
msgstr "B<int ffsll(long long int >I<i>B<);>\n"

#. type: Plain text
#: build/C/man3/ffs.3:52 build/C/man3/memchr.3:49 build/C/man3/stpcpy.3:38
#: build/C/man3/stpncpy.3:27 build/C/man3/strdup.3:48
#: build/C/man3/strerror.3:62 build/C/man3/strnlen.3:26
#: build/C/man3/strsep.3:46 build/C/man3/strsignal.3:48
#: build/C/man3/strtok.3:47
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/ffs.3:57
msgid "B<ffs>():"
msgstr "B<ffs>():"

#. type: TP
#: build/C/man3/ffs.3:58
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/ffs.3:64
#, no-wrap
msgid ""
"    _XOPEN_SOURCE E<gt>= 700\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/ffs.3:64
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/ffs.3:67
msgid "none"
msgstr "none"

#. type: Plain text
#: build/C/man3/ffs.3:71
msgid "B<ffsl>(), B<ffsll>():"
msgstr "B<ffsl>(), B<ffsll>():"

#. type: TP
#: build/C/man3/ffs.3:73
#, fuzzy, no-wrap
#| msgid "Since glibc 2.12:"
msgid "Since glibc 2.27:"
msgstr "glibc 2.10 以降:"

#.  glibc commit 68fe16dd327c895c08b9ee443b234c49c13b36e9
#. type: Plain text
#: build/C/man3/ffs.3:77
#, no-wrap
msgid "    _DEFAULT_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/ffs.3:77
#, fuzzy, no-wrap
#| msgid "Before glibc 2.12:"
msgid "Before glibc 2.27:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/ffs.3:80
#, fuzzy, no-wrap
#| msgid "_GNU_SOURCE"
msgid "    _GNU_SOURCE\n"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/ffs.3:97
msgid ""
"The B<ffs>()  function returns the position of the first (least significant) "
"bit set in the word I<i>.  The least significant bit is position 1 and the "
"most significant position is, for example, 32 or 64.  The functions "
"B<ffsll>()  and B<ffsl>()  do the same but take arguments of possibly "
"different size."
msgstr ""
"B<ffs>()  関数は、ワード I<i> の中で最初にセットされている (最下位)ビットの位"
"置を返す。 最下位ビットの位置は 1、最上位ビットの位置は例えば 32 や 64 であ"
"る。 B<ffsll>()  関数と B<ffsl>()  関数も同様だが、 異なったサイズの引数をと"
"る。"

#. type: Plain text
#: build/C/man3/ffs.3:101
msgid ""
"These functions return the position of the first bit set, or 0 if no bits "
"are set in I<i>."
msgstr ""
"これらの関数は、最初にセットされているビットの位置を返し、 I<i> のどのビット"
"もセットされていなければ 0 を返す。"

#. type: tbl table
#: build/C/man3/ffs.3:113
#, fuzzy, no-wrap
#| msgid "B<ffsl>(), B<ffsll>():"
msgid ""
"B<ffs>(),\n"
"B<ffsl>(),\n"
"B<ffsll>()"
msgstr "B<ffsl>(), B<ffsll>():"

#. type: Plain text
#: build/C/man3/ffs.3:118
#, fuzzy
#| msgid "B<ffs>(): 4.3BSD, POSIX.1-2001."
msgid "B<ffs>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "B<ffs>(): 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/ffs.3:124
msgid "The B<ffsl>()  and B<ffsll>()  functions are glibc extensions."
msgstr "関数 B<ffsl>()  と B<ffsll>()  は glibc による拡張である。"

#. type: Plain text
#: build/C/man3/ffs.3:127
msgid "BSD systems have a prototype in I<E<lt>string.hE<gt>>."
msgstr "BSD システムでは I<E<lt>string.hE<gt>> にプロトタイプがある。"

#. type: Plain text
#: build/C/man3/ffs.3:129
msgid "B<memchr>(3)"
msgstr "B<memchr>(3)"

#. type: TH
#: build/C/man3/index.3:31
#, no-wrap
msgid "INDEX"
msgstr "INDEX"

#. type: Plain text
#: build/C/man3/index.3:34
msgid "index, rindex - locate character in string"
msgstr "index, rindex - 文字列中の文字の位置を示す"

#. type: Plain text
#: build/C/man3/index.3:39
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *index(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/index.3:41
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/index.3:47
msgid ""
"The B<index>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<index>()  関数は、文字列 I<s> 中に最初に文字 I<c> が 現れた位置へのポイン"
"ターを返す。"

#. type: Plain text
#: build/C/man3/index.3:52
msgid ""
"The B<rindex>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<rindex>()  関数は、文字列 I<s> 中に最後に文字 I<c> が 現れた位置へのポイン"
"ターを返す。"

#. type: Plain text
#: build/C/man3/index.3:55
msgid ""
"The terminating null byte (\\(aq\\e0\\(aq) is considered to be a part of the "
"strings."
msgstr ""
"文字列を終端するヌルバイト (\\(aq\\e0\\(aq) は、文字列の一部とみなされる。"

#. type: Plain text
#: build/C/man3/index.3:62
msgid ""
"The B<index>()  and B<rindex>()  functions return a pointer to the matched "
"character or NULL if the character is not found."
msgstr ""
"B<index>()  と B<rindex>()  関数は、一致した文字へのポインターか、 もし文字が"
"見つからない場合は NULL を返す。"

#. type: tbl table
#: build/C/man3/index.3:73
#, no-wrap
msgid ""
"B<index>(),\n"
"B<rindex>()"
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:86
msgid ""
"4.3BSD; marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the "
"specifications of B<index>()  and B<rindex>(), recommending B<strchr>(3)  "
"and B<strrchr>(3)  instead."
msgstr ""
"4.3BSD; POSIX.1-2001 では「過去の名残 (LEGACY)」と位置付けられている。 "
"POSIX.1-2008 では B<index>()  と B<rindex>()  の仕様が削除されている。 代わり"
"に、 B<strchr>(3)  と B<strrchr>(3)  の使用が推奨されている。"

#. type: Plain text
#: build/C/man3/index.3:96
msgid ""
"B<memchr>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strrchr>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""
"B<memchr>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strrchr>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"

#. type: TH
#: build/C/man3/memccpy.3:30
#, no-wrap
msgid "MEMCCPY"
msgstr "MEMCCPY"

#. type: TH
#: build/C/man3/memccpy.3:30 build/C/man3/memcmp.3:30 build/C/man3/memcpy.3:31
#: build/C/man3/strcasecmp.3:30 build/C/man3/strcoll.3:30
#, fuzzy, no-wrap
#| msgid "2010-09-15"
msgid "2017-09-15"
msgstr "2010-09-15"

#. type: Plain text
#: build/C/man3/memccpy.3:33
msgid "memccpy - copy memory area"
msgstr "memccpy - メモリー領域をコピーする"

#. type: Plain text
#: build/C/man3/memccpy.3:53
msgid ""
"The B<memccpy>()  function copies no more than I<n> bytes from memory area "
"I<src> to memory area I<dest>, stopping when the character I<c> is found."
msgstr ""
"B<memccpy>()  は、メモリー領域 I<src> からメモリー領域 I<dest> に 最大で "
"I<n> バイトのコピーを行う。 I<n> バイトコピーする前に文字 I<c> が見つかる"
"と、 そこでコピーを中止する。"

#. type: Plain text
#: build/C/man3/memccpy.3:55
msgid "If the memory areas overlap, the results are undefined."
msgstr ""
"コピー元とコピー先のメモリー領域が重なっている場合、 結果は不定である。"

#. type: Plain text
#: build/C/man3/memccpy.3:70
msgid ""
"The B<memccpy>()  function returns a pointer to the next character in "
"I<dest> after I<c>, or NULL if I<c> was not found in the first I<n> "
"characters of I<src>."
msgstr ""
"B<memccpy>()  は、I<dest> 中に見つかった I<c> の 次にあるキャラクター型の変数"
"を指すポインターを返す。 見つからなかった場合、NULL を返す。"

#. type: tbl table
#: build/C/man3/memccpy.3:80
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memccpy>()"
msgstr "B<memchr>(3)"

#. type: Plain text
#: build/C/man3/memccpy.3:84
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:91
#, fuzzy
#| msgid ""
#| "B<bcopy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr "B<bcopy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"

#. type: TH
#: build/C/man3/memchr.3:32
#, no-wrap
msgid "MEMCHR"
msgstr "MEMCHR"

#. type: Plain text
#: build/C/man3/memchr.3:35
msgid "memchr, memrchr, rawmemchr - scan memory for a character"
msgstr "memchr, memrchr, rawmemchr - 文字を探すためにメモリーをスキャンする"

#. type: Plain text
#: build/C/man3/memchr.3:42
#, no-wrap
msgid "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/memchr.3:44
#, no-wrap
msgid "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/memchr.3:54
msgid "B<memrchr>(), B<rawmemchr>(): _GNU_SOURCE"
msgstr "B<memrchr>(): B<rawmemchr>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/memchr.3:70
msgid ""
"The B<memchr>()  function scans the initial I<n> bytes of the memory area "
"pointed to by I<s> for the first instance of I<c>.  Both I<c> and the bytes "
"of the memory area pointed to by I<s> are interpreted as I<unsigned char>."
msgstr ""
"B<memchr>() 関数は、ポインター I<s> が指し示すメモリー領域の先頭の\n"
"I<n> バイトから最初に登場する文字 I<c> を探す。\n"
"I<c> と I<s> が指し示すメモリー領域の各バイトは両方とも\n"
"I<unsigned char> と解釈される。"

#. type: Plain text
#: build/C/man3/memchr.3:81
msgid ""
"The B<memrchr>()  function is like the B<memchr>()  function, except that it "
"searches backward from the end of the I<n> bytes pointed to by I<s> instead "
"of forward from the beginning."
msgstr ""
"B<memrchr>()  関数は B<memchr>()  関数に似ているが、 先頭から順方向に探すので"
"はなく、 ポインター I<s> が指し示す I<n> バイトのメモリーブロックの 末尾から"
"逆向きに探す。"

#. type: Plain text
#: build/C/man3/memchr.3:99
msgid ""
"The B<rawmemchr>()  function is similar to B<memchr>(): it assumes (i.e., "
"the programmer knows for certain)  that an instance of I<c> lies somewhere "
"in the memory area starting at the location pointed to by I<s>, and so "
"performs an optimized search for I<c> (i.e., no use of a count argument to "
"limit the range of the search).  If an instance of I<c> is not found, the "
"results are unpredictable.  The following call is a fast means of locating a "
"string's terminating null byte:"
msgstr ""
"B<rawmemchr>() 関数は B<memchr>() と同様だが、 I<c> が I<s> が指す場所\n"
"から始まるメモリー領域のどこかにあることを前提にして (つまり、プログラマ\n"
"はそのことを知っている)、最適化した方法で I<c> の検索を実行する (すなわ\n"
"ち、検索範囲の上限を示す引き数も使用されない)。I<c> が見つからなかった\n"
"場合、その結果はどうなるか分からない。次に示す呼び出しは、文字列終端の\n"
"ヌルバイトの位置を特定する高速な手段である。"

#. type: Plain text
#: build/C/man3/memchr.3:103
#, no-wrap
msgid "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"
msgstr "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"

#. type: Plain text
#: build/C/man3/memchr.3:113
msgid ""
"The B<memchr>()  and B<memrchr>()  functions return a pointer to the "
"matching byte or NULL if the character does not occur in the given memory "
"area."
msgstr ""
"B<memchr>()  関数と B<memrchr>()  関数は一致する文字へのポインターを返し、 も"
"し文字が指定メモリー領域に現れない場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/memchr.3:118
msgid ""
"The B<rawmemchr>()  function returns a pointer to the matching byte, if one "
"is found.  If no matching byte is found, the result is unspecified."
msgstr ""
"B<rawmemchr>()  関数はマッチするバイトが見つかった場合はマッチしたバイトへの"
"ポインターを返す。 マッチするバイトが見つからなかった場合、結果は不定である。"

#. type: Plain text
#: build/C/man3/memchr.3:121
msgid "B<rawmemchr>()  first appeared in glibc in version 2.1."
msgstr "B<rawmemchr>()  は glibc バージョン 2.1 で初めて登場した。"

#. type: Plain text
#: build/C/man3/memchr.3:124
msgid "B<memrchr>()  first appeared in glibc in version 2.2."
msgstr "B<memrchr>()  は glibc バージョン 2.2 で初めて登場した。"

#. type: tbl table
#: build/C/man3/memchr.3:136
#, fuzzy, no-wrap
#| msgid "The B<memchr>(), B<memrchr>(), and B<rawmemchr>()  functions are thread-safe."
msgid ""
"B<memchr>(),\n"
"B<memrchr>(),\n"
"B<rawmemchr>()"
msgstr "関数 B<memchr>(), B<memrchr>(), B<rawmemchr>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/memchr.3:141
msgid "B<memchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:145
msgid ""
"The B<memrchr>()  function is a GNU extension, available since glibc 2.1.91."
msgstr "B<memrchr>()  関数は GNU 拡張であり、glibc 2.1.91 から使用可能である。"

#. type: Plain text
#: build/C/man3/memchr.3:149
msgid ""
"The B<rawmemchr>()  function is a GNU extension, available since glibc 2.1."
msgstr "B<rawmemchr>()  関数は GNU 拡張であり、glibc 2.1 から使用可能である。"

#. type: Plain text
#: build/C/man3/memchr.3:162
#, fuzzy
#| msgid ""
#| "B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), B<strchr>(3), "
#| "B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), "
#| "B<wmemchr>(3)"
msgid ""
"B<bstring>(3), B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), "
"B<strchr>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), "
"B<strstr>(3), B<wmemchr>(3)"
msgstr ""
"B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), B<strchr>(3), "
"B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), "
"B<wmemchr>(3)"

#. type: TH
#: build/C/man3/memcmp.3:30
#, no-wrap
msgid "MEMCMP"
msgstr "MEMCMP"

#. type: Plain text
#: build/C/man3/memcmp.3:33
msgid "memcmp - compare memory areas"
msgstr "memcmp - メモリー領域を比較する"

#. type: Plain text
#: build/C/man3/memcmp.3:45
msgid ""
"The B<memcmp>()  function compares the first I<n> bytes (each interpreted as "
"I<unsigned char>)  of the memory areas I<s1> and I<s2>."
msgstr ""
"B<memcmp>()  関数は、メモリー領域 I<s1> とI<s2> の最初の I<n> バイトを比較す"
"る (各バイトは I<unsigned char> として解釈される)。"

#. type: Plain text
#: build/C/man3/memcmp.3:52
msgid ""
"The B<memcmp>()  function returns an integer less than, equal to, or greater "
"than zero if the first I<n> bytes of I<s1> is found, respectively, to be "
"less than, to match, or be greater than the first I<n> bytes of I<s2>."
msgstr ""
"B<memcmp>()  関数は、I<s1> の最初の I<n> バイトが I<s2> の最初の I<n> バイト"
"よりも 小さいか、同じか、あるいは大きいかによってそれぞれ、負の整数、0、 正の"
"整数を返す。"

#. type: Plain text
#: build/C/man3/memcmp.3:60
msgid ""
"For a nonzero return value, the sign is determined by the sign of the "
"difference between the first pair of bytes (interpreted as I<unsigned "
"char>)  that differ in I<s1> and I<s2>."
msgstr ""
"0 でない値の場合、 I<s1> と I<s2> で値が異なった最初のバイトの値の差で符号は"
"決定される (バイトは I<unsigned char> で解釈される)。"

#. type: Plain text
#: build/C/man3/memcmp.3:64
msgid "If I<n> is zero, the return value is zero."
msgstr "I<n> が 0 の場合、返り値は 0 となる。"

#. type: tbl table
#: build/C/man3/memcmp.3:74
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memcmp>()"
msgstr "B<memchr>(3)"

#. type: Plain text
#: build/C/man3/memcmp.3:78 build/C/man3/memcpy.3:67 build/C/man3/memmove.3:76
#: build/C/man3/memset.3:68 build/C/man3/strcat.3:145 build/C/man3/strcmp.3:111
#: build/C/man3/strcoll.3:84 build/C/man3/strcpy.3:131
#: build/C/man3/strpbrk.3:70 build/C/man3/strspn.3:89 build/C/man3/strtok.3:189
#: build/C/man3/strxfrm.3:90
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:88
msgid ""
"Do not use B<memcmp>()  to compare security critical data, such as "
"cryptographic secrets, because the required CPU time depends on the number "
"of equal bytes.  Instead, a function that performs comparisons in constant "
"time is required.  Some operating systems provide such a function (e.g., "
"NetBSD's B<consttime_memequal>()), but no such function is specified in "
"POSIX.  On Linux, it may be necessary to implement such a function oneself."
msgstr ""
"暗号化された秘密などセキュリティ的に重要なデータの比較には B<memcmp>() を使用"
"しないこと。 必要な CPU 時間は値が等しいバイトの量に依存するからである。 その"
"代わり、 一定時間で比較を実行する関数が必要である。 いくつかのオペレーティン"
"グシステムでは (例えば NetBSD の B<consttime_memequal>() などの) 関数が提供さ"
"れているが、 このような関数は POSIX では規定されていない。 Linux では、 この"
"ような関数自体を実装する必要があるかもしれない。"

#. type: Plain text
#: build/C/man3/memcmp.3:97
#, fuzzy
#| msgid ""
#| "B<bcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
#| "B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"
msgid ""
"B<bcmp>(3), B<bstring>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"
msgstr ""
"B<bcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"

#. type: TH
#: build/C/man3/memcpy.3:31
#, no-wrap
msgid "MEMCPY"
msgstr "MEMCPY"

#. type: Plain text
#: build/C/man3/memcpy.3:34
msgid "memcpy - copy memory area"
msgstr "memcpy - メモリー領域をコピーする。"

#. type: Plain text
#: build/C/man3/memcpy.3:49
msgid ""
"The B<memcpy>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas must not overlap.  Use B<memmove>(3)  "
"if the memory areas do overlap."
msgstr ""
"B<memcpy>()  はメモリー領域 I<src> の先頭 I<n> バイトを メモリー領域 I<dest> "
"にコピーする。コピー元の領域と コピー先の領域が重なってはならない。重なってい"
"る場合は B<memmove>(3)  を使うこと。"

#. type: Plain text
#: build/C/man3/memcpy.3:53
msgid "The B<memcpy>()  function returns a pointer to I<dest>."
msgstr "B<memcpy>()  は I<dest> へのポインターを返す。"

#. type: tbl table
#: build/C/man3/memcpy.3:63
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memcpy>()"
msgstr "B<memchr>(3)"

#.  glibc commit 6fb8cbcb58a29fff73eb2101b34caa19a7f88eba
#.  From forward copying to backward copying
#. type: Plain text
#: build/C/man3/memcpy.3:83
msgid ""
"Failure to observe the requirement that the memory areas do not overlap has "
"been the source of significant bugs.  (POSIX and the C standards are "
"explicit that employing B<memcpy>()  with overlapping areas produces "
"undefined behavior.)  Most notably, in glibc 2.13 a performance optimization "
"of B<memcpy>()  on some platforms (including x86-64) included changing the "
"order in which bytes were copied from I<src> to I<dest>."
msgstr ""

#
#
#.  Adobe Flash player was the highest profile example:
#.    https://bugzilla.redhat.com/show_bug.cgi?id=638477
#.    Reported: 2010-09-29 02:35 EDT by JCHuynh
#.    Bug 638477 - Strange sound on mp3 flash website
#.    https://sourceware.org/bugzilla/show_bug.cgi?id=12518
#.    Bug 12518 - memcpy acts randomly (and differently) with overlapping areas
#.    Reported:       2011-02-25 02:26 UTC by Linus Torvalds
#.  glibc commit 0354e355014b7bfda32622e0255399d859862fcd
#. type: Plain text
#: build/C/man3/memcpy.3:109
msgid ""
"This change revealed breakages in a number of applications that performed "
"copying with overlapping areas.  Under the previous implementation, the "
"order in which the bytes were copied had fortuitously hidden the bug, which "
"was revealed when the copying order was reversed.  In glibc 2.14, a "
"versioned symbol was added so that old binaries (i.e., those linked against "
"glibc versions earlier than 2.14)  employed a B<memcpy>()  implementation "
"that safely handles the overlapping buffers case (by providing an \"older\" "
"B<memcpy>()  implementation that was aliased to B<memmove>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/memcpy.3:118
#, fuzzy
#| msgid ""
#| "B<bcopy>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), B<strcpy>(3), "
#| "B<strncpy>(3), B<wmemcpy>(3)"
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), "
"B<strcpy>(3), B<strncpy>(3), B<wmemcpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemcpy>(3)"

#. type: TH
#: build/C/man3/memfrob.3:30
#, no-wrap
msgid "MEMFROB"
msgstr "MEMFROB"

#. type: Plain text
#: build/C/man3/memfrob.3:33
msgid "memfrob - frobnicate (encrypt) a memory area"
msgstr "memfrob - メモリーエリアの操作 (暗号化)"

#. type: Plain text
#: build/C/man3/memfrob.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/memfrob.3:50
msgid ""
"The B<memfrob>()  function encrypts the first I<n> bytes of the memory area "
"I<s> by exclusive-ORing each character with the number 42.  The effect can "
"be reversed by using B<memfrob>()  on the encrypted memory area."
msgstr ""
"B<memfrob>()  関数は、メモリーエリア I<s> の最初の I<n> バイトの それぞれの文"
"字を 42 との排他的論理をとることによって暗号化する。 変換後のデータは、暗号化"
"されているメモリーエリアに (再度)  B<memfrob>()  関数を施すことで、元に戻すこ"
"とができる。"

#. type: Plain text
#: build/C/man3/memfrob.3:53
msgid ""
"Note that this function is not a proper encryption routine as the XOR "
"constant is fixed, and is suitable only for hiding strings."
msgstr ""
"この関数は妥当な暗号化ルーチンであるとは言えないことに注意して欲しい。 XOR を"
"とる定数を固定しているので、せいぜい、文字列を隠す程度の用途にしか向いていな"
"い。"

#. type: Plain text
#: build/C/man3/memfrob.3:58
msgid ""
"The B<memfrob>()  function returns a pointer to the encrypted memory area."
msgstr "B<memfrob>()  関数は、暗号化されたメモリーエリアへのポインターを返す。"

#. type: tbl table
#: build/C/man3/memfrob.3:68
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memfrob>()"
msgstr "B<memchr>(3)"

#. type: Plain text
#: build/C/man3/memfrob.3:75
msgid "The B<memfrob>()  function is unique to the GNU C Library."
msgstr "B<memfrob>()  関数は GNU C ライブラリに固有である。"

#. type: Plain text
#: build/C/man3/memfrob.3:78
#, fuzzy
#| msgid "B<psignal>(3), B<strerror>(3)"
msgid "B<bstring>(3), B<strfry>(3)"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: TH
#: build/C/man3/memmem.3:30
#, no-wrap
msgid "MEMMEM"
msgstr "MEMMEM"

#. type: Plain text
#: build/C/man3/memmem.3:33
msgid "memmem - locate a substring"
msgstr "memmem - 部分文字列の位置を示す"

#. type: Plain text
#: build/C/man3/memmem.3:37 build/C/man3/mempcpy.3:17 build/C/man3/strchr.3:46
#: build/C/man3/strfry.3:37 build/C/man3/strverscmp.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/memmem.3:54
msgid ""
"The B<memmem>()  function finds the start of the first occurrence of the "
"substring I<needle> of length I<needlelen> in the memory area I<haystack> of "
"length I<haystacklen>."
msgstr ""
"B<memmem>()  関数は、 I<haystacklen> の大きさを持つメモリー領域 I<haystack> "
"の中で I<needlelen> の大きさを持つ部分文字列 I<needle> が 最初に現れる位置を"
"見つける。"

#. type: Plain text
#: build/C/man3/memmem.3:59
msgid ""
"The B<memmem>()  function returns a pointer to the beginning of the "
"substring, or NULL if the substring is not found."
msgstr ""
"B<memmem>()  関数は、部分文字列の開始を指すポインターを返し、もし部分文字列"
"が 見つからない場合は NULL を返す。"

#. type: tbl table
#: build/C/man3/memmem.3:69
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memmem>()"
msgstr "B<memchr>(3)"

#. type: Plain text
#: build/C/man3/memmem.3:74
msgid ""
"This function is not specified in POSIX.1, but is present on a number of "
"other systems."
msgstr ""

#. type: SH
#: build/C/man3/memmem.3:74 build/C/man3/stpcpy.3:92 build/C/man3/strcpy.3:222
#: build/C/man3/strsep.3:105 build/C/man3/strtok.3:200
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  This function was broken in Linux libraries up to and including libc 5.0.9;
#.  there the
#.  .IR needle
#.  and
#.  .I haystack
#.  arguments were interchanged,
#.  and a pointer to the end of the first occurrence of
#.  .I needle
#.  was returned.
#.  Both old and new libc's have the bug that if
#.  .I needle
#.  is empty,
#.  .I haystack\-1
#.  (instead of
#.  .IR haystack )
#.  is returned.
#. type: Plain text
#: build/C/man3/memmem.3:99
msgid ""
"In glibc 2.0, if I<needle> is empty, B<memmem>()  returns a pointer to the "
"last byte of I<haystack>.  This is fixed in glibc 2.1."
msgstr ""
"glibc 2.0 では、 I<needle> が空の場合、 B<memmem>() は I<haystack> の最後のバ"
"イトへのポインターを返す。 これは glibc 2.1 で修正されている。"

#. type: Plain text
#: build/C/man3/memmem.3:102
#, fuzzy
#| msgid "B<psignal>(3), B<strerror>(3)"
msgid "B<bstring>(3), B<strstr>(3)"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: TH
#: build/C/man3/memmove.3:30
#, no-wrap
msgid "MEMMOVE"
msgstr "MEMMOVE"

#. type: Plain text
#: build/C/man3/memmove.3:33
msgid "memmove - copy memory area"
msgstr "memmove - メモリー領域をコピーする"

#. type: Plain text
#: build/C/man3/memmove.3:57
msgid ""
"The B<memmove>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas may overlap: copying takes place as "
"though the bytes in I<src> are first copied into a temporary array that does "
"not overlap I<src> or I<dest>, and the bytes are then copied from the "
"temporary array to I<dest>."
msgstr ""
"B<memmove>()  は、メモリー領域 I<src> の先頭 I<n> バイトを メモリー領域 "
"I<dest> にコピーする。コピー元とコピー先の 領域が重なっていてもよい。 最初に "
"I<src> のバイトが I<src> とも I<dest> とも重ならない一時的な配列にコピーされ"
"てから、一時的な配列から I<dest> にバイトのコピーが行われたかのように、コピー"
"が行われる。"

#. type: Plain text
#: build/C/man3/memmove.3:62
msgid "The B<memmove>()  function returns a pointer to I<dest>."
msgstr "B<memmove>()  は I<dest> へのポインターを返す。"

#. type: tbl table
#: build/C/man3/memmove.3:72
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memmove>()"
msgstr "B<memchr>(3)"

#. type: Plain text
#: build/C/man3/memmove.3:84
#, fuzzy
#| msgid ""
#| "B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<strncpy>(3), "
#| "B<wmemmove>(3)"
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemmove>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<strncpy>(3), "
"B<wmemmove>(3)"

#. type: TH
#: build/C/man3/mempcpy.3:10
#, no-wrap
msgid "MEMPCPY"
msgstr "MEMPCPY"

#. type: TH
#: build/C/man3/mempcpy.3:10 build/C/man3/stpcpy.3:25
#: build/C/man3/strverscmp.3:26
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:13
msgid "mempcpy, wmempcpy - copy memory area"
msgstr "mempcpy, wmempcpy - メモリー領域をコピーする"

#. type: Plain text
#: build/C/man3/mempcpy.3:19
#, no-wrap
msgid "B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:22
#, fuzzy, no-wrap
#| msgid ""
#| "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
#| "B<#include E<lt>string.hE<gt>>\n"
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:24
#, no-wrap
msgid "B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:40
msgid ""
"The B<mempcpy>()  function is nearly identical to the B<memcpy>(3)  "
"function.  It copies I<n> bytes from the object beginning at I<src> into the "
"object pointed to by I<dest>.  But instead of returning the value of I<dest> "
"it returns a pointer to the byte following the last written byte."
msgstr ""
"B<mempcpy>()  関数は B<memcpy>(3)  関数とほぼ同一である。 この関数は、 "
"I<src> で始まるオブジェクトから I<n> バイトを、 I<dest> で指されるオブジェク"
"トにコピーする。 ただし I<dest> の値を返すのではなく、 最後に書き込まれたバイ"
"トの後に続くバイトへのポインターを返す。"

#. type: Plain text
#: build/C/man3/mempcpy.3:43
msgid ""
"This function is useful in situations where a number of objects shall be "
"copied to consecutive memory positions."
msgstr ""
"この関数はいくつかのオブジェクトが 連続的なメモリーの場所にコピーされるような"
"状況で役に立つ。"

#. type: Plain text
#: build/C/man3/mempcpy.3:51
msgid ""
"The B<wmempcpy>()  function is identical but takes I<wchar_t> type arguments "
"and copies I<n> wide characters."
msgstr ""
"B<wmempcpy>()  関数はこの関数と同じであるが、 I<wchar_t> 型の引き数をとり、 "
"I<n> ワイド文字列をコピーする。"

#. type: Plain text
#: build/C/man3/mempcpy.3:55
msgid "I<dest> + I<n>."
msgstr "I<dest> + I<n>."

#. type: Plain text
#: build/C/man3/mempcpy.3:58
msgid "B<mempcpy>()  first appeared in glibc in version 2.1."
msgstr "B<mempcpy>()  は glibc バージョン 2.1 で初めて登場した。"

#. type: tbl table
#: build/C/man3/mempcpy.3:69
#, fuzzy, no-wrap
#| msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgid ""
"B<mempcpy>(),\n"
"B<wmempcpy>()"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: Plain text
#: build/C/man3/mempcpy.3:73 build/C/man3/strverscmp.3:114
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: SH
#: build/C/man3/mempcpy.3:73 build/C/man3/stpcpy.3:95 build/C/man3/strcat.3:183
#: build/C/man3/strcmp.3:129 build/C/man3/strtok.3:216
#: build/C/man3/strverscmp.3:114
#, fuzzy, no-wrap
#| msgid "EXAMPLE"
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/mempcpy.3:83
#, no-wrap
msgid ""
"void *\n"
"combine(void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"
"}\n"
msgstr ""
"void *\n"
"combine (void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:89
msgid "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"
msgstr "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"

#. type: TH
#: build/C/man3/memset.3:30
#, no-wrap
msgid "MEMSET"
msgstr "MEMSET"

#. type: Plain text
#: build/C/man3/memset.3:33
msgid "memset - fill memory with a constant byte"
msgstr "memset - ある一定のバイトでメモリー領域を埋める。"

#. type: Plain text
#: build/C/man3/memset.3:49
msgid ""
"The B<memset>()  function fills the first I<n> bytes of the memory area "
"pointed to by I<s> with the constant byte I<c>."
msgstr ""
"B<memset>()  は I<s> で示されるメモリー領域の先頭から I<n> バイトを I<c> で埋"
"める。"

#. type: Plain text
#: build/C/man3/memset.3:54
msgid "The B<memset>()  function returns a pointer to the memory area I<s>."
msgstr "B<memset>()  は I<s> へのポインターを返す。"

#. type: tbl table
#: build/C/man3/memset.3:64
#, fuzzy, no-wrap
#| msgid "B<memchr>(3)"
msgid "B<memset>()"
msgstr "B<memchr>(3)"

#. type: Plain text
#: build/C/man3/memset.3:73
#, fuzzy
#| msgid "B<bzero>(3), B<swab>(3), B<wmemset>(3)"
msgid "B<bstring>(3), B<bzero>(3), B<swab>(3), B<wmemset>(3)"
msgstr "B<bzero>(3), B<swab>(3), B<wmemset>(3)"

#. type: TH
#: build/C/man3/stpcpy.3:25
#, no-wrap
msgid "STPCPY"
msgstr "STPCPY"

#. type: Plain text
#: build/C/man3/stpcpy.3:28
msgid "stpcpy - copy a string returning a pointer to its end"
msgstr "stpcpy - 文字列をコピーし、コピーした文字列の終りへのポインターを返す"

#. type: Plain text
#: build/C/man3/stpcpy.3:33
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:41
msgid "B<stpcpy>():"
msgstr "B<stpcpy>():"

#. type: TP
#: build/C/man3/stpcpy.3:44 build/C/man3/stpncpy.3:33 build/C/man3/strdup.3:62
#: build/C/man3/strnlen.3:32
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/stpcpy.3:47 build/C/man3/stpncpy.3:36 build/C/man3/strdup.3:65
#: build/C/man3/strnlen.3:35 build/C/man3/strsignal.3:64
#, fuzzy
#| msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man3/stpcpy.3:47 build/C/man3/stpncpy.3:36 build/C/man3/strdup.3:65
#: build/C/man3/strnlen.3:35 build/C/man3/strsignal.3:64
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/stpcpy.3:50 build/C/man3/stpncpy.3:39 build/C/man3/strdup.3:68
#: build/C/man3/strnlen.3:38 build/C/man3/strsignal.3:55
#: build/C/man3/strsignal.3:67
#, no-wrap
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/stpcpy.3:63
msgid ""
"The B<stpcpy>()  function copies the string pointed to by I<src> (including "
"the terminating null byte (\\(aq\\e0\\(aq)) to the array pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy."
msgstr ""
"B<stpcpy>()  関数は、I<src> で指された文字列を (文字列を終端するヌルバイト "
"(\\(aq\\e0\\(aq) を含めて) I<dest> で指された配列にコピーする。 文字列は重複"
"してはならず、コピー先の文字列 I<dest> はコピーを受け取る のに十分大きくなく"
"てはならない。"

#. type: Plain text
#: build/C/man3/stpcpy.3:71
msgid ""
"B<stpcpy>()  returns a pointer to the B<end> of the string I<dest> (that is, "
"the address of the terminating null byte)  rather than the beginning."
msgstr ""
"B<stpcpy>()  は、文字列 I<dest> の始まりではなく B<終り>を指すポインター (す"
"なわち、文字列を終端するヌルバイト) を返す。"

#. type: tbl table
#: build/C/man3/stpcpy.3:81
#, fuzzy, no-wrap
#| msgid "B<stpcpy>():"
msgid "B<stpcpy>()"
msgstr "B<stpcpy>():"

#. type: Plain text
#: build/C/man3/stpcpy.3:92
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was not part of "
"the C or POSIX.1 standards, nor customary on UNIX systems.  It first "
"appeared at least as early as 1986, in the Lattice C AmigaDOS compiler, then "
"in the GNU fileutils and GNU textutils in 1989, and in the GNU C library by "
"1992.  It is also present on the BSDs."
msgstr ""
"この関数は POSIX.1-2008 に追加された。 それ以前は、この関数は C や POSIX.1 標"
"準の一部でも UNIX システムの慣習的なものでもなかった。 この関数は Lattice C "
"AmigaDOS コンパイラで初めて登場し、それは少なくとも 1986 年時点ではそうであっ"
"た。 その後、 1989 年に GNU fileutils と GNU textutils に登場し、 1992 年まで"
"には GNU C ライブラリにも存在していた。 この関数は BSD 系にも存在する。"

#. type: Plain text
#: build/C/man3/stpcpy.3:95
msgid "This function may overrun the buffer I<dest>."
msgstr "この関数はバッファー I<dest> の範囲を行き過ぎてしまう可能性がある。"

#. type: Plain text
#: build/C/man3/stpcpy.3:105
msgid ""
"For example, this program uses B<stpcpy>()  to concatenate B<foo> and B<bar> "
"to produce B<foobar>, which it then prints."
msgstr ""
"例として、このプログラムは B<foo> と B<bar> を連結して B<foobar> を作るため"
"に B<stpcpy>()  を使用し、その後表示する。"

#. type: Plain text
#: build/C/man3/stpcpy.3:110
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:116
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:121
#, no-wrap
msgid ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"
msgstr ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:131
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"

#. type: TH
#: build/C/man3/stpncpy.3:14
#, no-wrap
msgid "STPNCPY"
msgstr "STPNCPY"

#. type: Plain text
#: build/C/man3/stpncpy.3:17
msgid "stpncpy - copy a fixed-size string, returning a pointer to its end"
msgstr "stpncpy - 固定長の文字列をコピーして、その最後へのポインターを返す"

#. type: Plain text
#: build/C/man3/stpncpy.3:22
#, no-wrap
msgid "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/stpncpy.3:30
msgid "B<stpncpy>():"
msgstr "B<stpncpy>():"

#. type: Plain text
#: build/C/man3/stpncpy.3:74
msgid ""
"The B<stpncpy>()  function copies at most I<n> characters from the string "
"pointed to by I<src>, including the terminating null byte (\\(aq\\e0\\(aq), "
"to the array pointed to by I<dest>.  Exactly I<n> characters are written at "
"I<dest>.  If the length I<strlen(src)> is smaller than I<n>, the remaining "
"characters in the array pointed to by I<dest> are filled with null bytes "
"(\\(aq\\e0\\(aq), If the length I<strlen(src)> is greater than or equal to "
"I<n>, the string pointed to by I<dest> will not be null-terminated."
msgstr ""
"B<stpncpy>()  関数は I<src> が指している文字列から終端のヌルバイト (\\(aq"
"\\e0\\(aq)  を含めて最大 I<n> バイトを I<dest> にコピーする。長さ "
"I<strlen(src)> が I<n> より小さい場合には I<dest> の残りの 部分にはヌルバイ"
"ト (\\(aq\\e0\\(aq) 文字が埋められる。 長さ I<strlen(src)> が I<n> 以上なら"
"ば、 I<dest> が指す文字列はヌルで終端されていない。"

#. type: Plain text
#: build/C/man3/stpncpy.3:76
msgid "The strings may not overlap."
msgstr "二つの文字列は重なってはならない。"

#. type: Plain text
#: build/C/man3/stpncpy.3:82
msgid ""
"The programmer must ensure that there is room for at least I<n> characters "
"at I<dest>."
msgstr ""
"プログラマーは I<dest> に少なくとも I<n> バイトの空きがあることを 保証しなけ"
"ればならない。"

#. type: Plain text
#: build/C/man3/stpncpy.3:91
msgid ""
"B<stpncpy>()  returns a pointer to the terminating null byte in I<dest>, or, "
"if I<dest> is not null-terminated, I<dest>+I<n>."
msgstr ""
"B<stpncpy>()  は I<dest> の終端のヌルバイトを指すポインターを返すか、 "
"I<dest> がヌルバイトで終端されていない場合には I<dest>+I<n> を返す。"

#. type: tbl table
#: build/C/man3/stpncpy.3:101
#, fuzzy, no-wrap
#| msgid "B<stpncpy>():"
msgid "B<stpncpy>()"
msgstr "B<stpncpy>():"

#. type: Plain text
#: build/C/man3/stpncpy.3:107
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was a GNU "
"extension.  It first appeared in version 1.07 of the GNU C library in 1993."
msgstr ""
"この関数は POSIX.1-2008 に追加された。 それ以前は GNU による拡張であった。 こ"
"の関数は 1993 年に GNU C ライブラリのバージョン 1.07 で初めて登場した。"

#. type: Plain text
#: build/C/man3/stpncpy.3:110
msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: TH
#: build/C/man3/strcasecmp.3:30
#, no-wrap
msgid "STRCASECMP"
msgstr "STRCASECMP"

#. type: Plain text
#: build/C/man3/strcasecmp.3:33
msgid "strcasecmp, strncasecmp - compare two strings ignoring case"
msgstr "strcasecmp, strncasecmp - 二つの文字列を大文字小文字を区別せず比較する"

#. type: Plain text
#: build/C/man3/strcasecmp.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: build/C/man3/strcasecmp.3:40
#, no-wrap
msgid "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcasecmp.3:55
#, fuzzy
#| msgid ""
#| "The B<strcasecmp>()  function compares the two strings I<s1> and I<s2>, "
#| "ignoring the case of the characters.  It returns an integer less than, "
#| "equal to, or greater than zero if I<s1> is found, respectively, to be "
#| "less than, to match, or be greater than I<s2>."
msgid ""
"The B<strcasecmp>()  function performs a byte-by-byte comparison of the "
"strings I<s1> and I<s2>, ignoring the case of the characters.  It returns an "
"integer less than, equal to, or greater than zero if I<s1> is found, "
"respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""
"B<strcasecmp>()  関数は、二つの文字列　I<s1> と I<s2> を、 大文字小文字を区別"
"せずに比較する。 I<s1> が I<s2> よりも小さいか、同じか、大きいかによってそれ"
"ぞれ 負の整数、0、正の整数を返す。"

#. type: Plain text
#: build/C/man3/strcasecmp.3:65
#, fuzzy
#| msgid ""
#| "The B<strncmp>()  function is similar, except it compares only the first "
#| "(at most)  I<n> bytes of I<s1> and I<s2>."
msgid ""
"The B<strncasecmp>()  function is similar, except that it compares no more "
"than I<n> bytes of I<s1> and I<s2>."
msgstr ""
"B<strncmp>() 関数は、I<s1> と I<s2> の最初の I<n> バイトだけを比較する\n"
"ことを除けば、strcmp()と同様である。"

#. type: Plain text
#: build/C/man3/strcasecmp.3:77
#, fuzzy
#| msgid ""
#| "The B<strcasecmp>()  and B<strncasecmp>()  functions return an integer "
#| "less than, equal to, or greater than zero if I<s1> (or the first I<n> "
#| "bytes thereof) is found, respectively, to be less than, to match, or be "
#| "greater than I<s2>."
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions return an integer less "
"than, equal to, or greater than zero if I<s1> is, after ignoring case, found "
"to be less than, to match, or be greater than I<s2>, respectively."
msgstr ""
"B<strcasecmp>()  と B<strncasecmp>()  関数は、I<s1> (または、その最初の I<n> "
"バイト)が I<s2> よりも小さいか、 同じか、大きいかにより、それぞれ負の整数、"
"0、正の整数を返す。"

#. type: tbl table
#: build/C/man3/strcasecmp.3:88
#, fuzzy, no-wrap
#| msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgid ""
"B<strcasecmp>(),\n"
"B<strncasecmp>()"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: tbl table
#: build/C/man3/strcasecmp.3:88 build/C/man3/strcoll.3:79
#: build/C/man3/strstr.3:78 build/C/man3/strxfrm.3:86
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:92
#, fuzzy
#| msgid "4.4BSD, POSIX.1-2001."
msgid "4.4BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/strcasecmp.3:106
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions first appeared in "
"4.4BSD, where they were declared in I<E<lt>string.hE<gt>>.  Thus, for "
"reasons of historical compatibility, the glibc I<E<lt>string.hE<gt>> header "
"file also declares these functions, if the B<_DEFAULT_SOURCE> (or, in glibc "
"2.19 and earlier, B<_BSD_SOURCE>)  feature test macro is defined."
msgstr ""
"関数 B<strcasecmp>() と B<strncasecmp>() は 4.4BSD で初めて登場し、 そのとき"
"は I<E<lt>string.hE<gt>> に宣言があった。 このような、過去との互換性確保のた"
"め、 機能検査マクロ B<_DEFAULT_SOURCE> (glibc 2.19 以前では B<_BSD_SOURCE>) "
"が定義された際に、 glibc のヘッダーファイル I<E<lt>string.hE<gt>> でもこれら"
"の関数が宣言されている。"

#. type: Plain text
#: build/C/man3/strcasecmp.3:108
msgid "The POSIX.1-2008 standard says of these functions:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:116
msgid ""
"When the B<LC_CTYPE> category of the locale being used is from the POSIX "
"locale, these functions shall behave as if the strings had been converted to "
"lowercase and then a byte comparison performed.  Otherwise, the results are "
"unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:126
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"

#. type: TH
#: build/C/man3/strcat.3:32
#, no-wrap
msgid "STRCAT"
msgstr "STRCAT"

#. type: Plain text
#: build/C/man3/strcat.3:35
msgid "strcat, strncat - concatenate two strings"
msgstr "strcat, strncat - 二つの文字列を連結する"

#. type: Plain text
#: build/C/man3/strcat.3:40
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: build/C/man3/strcat.3:42
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcat.3:62
msgid ""
"The B<strcat>()  function appends the I<src> string to the I<dest> string, "
"overwriting the terminating null byte (\\(aq\\e0\\(aq) at the end of "
"I<dest>, and then adds a terminating null byte.  The strings may not "
"overlap, and the I<dest> string must have enough space for the result.  If "
"I<dest> is not large enough, program behavior is unpredictable; I<buffer "
"overruns are a favorite avenue for attacking secure programs>."
msgstr ""
"B<strcat>()  関数は、I<dest> 文字列の後に I<src> 文字列を付け加える。 その際"
"に、I<dest> の最後にある終端のヌルバイト (\\(aq\\e0\\(aq)  は上書きされ、新た"
"に生成された文字列の末尾に終端のヌルバイトが付与される。 二つの文字列 I<src> "
"と I<dest> は重なってはならない。 また、文字列 I<dest> は、連結後の結果を格納"
"するのに 十分な大きさでなければならない。 I<dest> が十分な大きさでない場合、"
"プログラムがどのような動作をするか分からない。 バッファーオーバーランはセキュ"
"アなプログラムを攻撃する際に好んで使われる方法である。"

#. type: Plain text
#: build/C/man3/strcat.3:66
msgid "The B<strncat>()  function is similar, except that"
msgstr "B<strncat>()  も同様だが、以下の点が異なる。"

#. type: IP
#: build/C/man3/strcat.3:66 build/C/man3/strcat.3:72 build/C/man3/strsep.3:108
#: build/C/man3/strsep.3:110 build/C/man3/strsep.3:112
#: build/C/man3/strtok.3:203 build/C/man3/strtok.3:205
#: build/C/man3/strtok.3:207 build/C/man3/strtok.3:209
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/strcat.3:72
msgid "it will use at most I<n> bytes from I<src>; and"
msgstr "I<src> のうち最大 I<n> バイトが使用される。"

#. type: Plain text
#: build/C/man3/strcat.3:77
msgid ""
"I<src> does not need to be null-terminated if it contains I<n> or more bytes."
msgstr ""
"I<src> が I<n> バイト以上の場合、 \n"
"I<src> はヌル終端されている必要はない。"

#. type: Plain text
#: build/C/man3/strcat.3:83
msgid ""
"As with B<strcat>(), the resulting string in I<dest> is always null-"
"terminated."
msgstr ""
"B<strcat>()  と同じく、I<dest> に格納される結果の文字列は常にヌル終端される。"

#. type: Plain text
#: build/C/man3/strcat.3:102
msgid ""
"If I<src> contains I<n> or more bytes, B<strncat>()  writes I<n+1> bytes to "
"I<dest> (I<n> from I<src> plus the terminating null byte).  Therefore, the "
"size of I<dest> must be at least I<strlen(dest)+n+1>."
msgstr ""
"I<src> が I<n> バイト以上の場合、 B<strncat>() は I<dest> に I<n+1> \n"
"バイトを書き込む (I<src> からの I<n> バイトと終端のヌルバイトである)。\n"
"したがって、I<dest> の大きさは最低でも I<strlen(dest)+n+1> でなければ\n"
"ならない。"

#. type: Plain text
#: build/C/man3/strcat.3:106
msgid "A simple implementation of B<strncat>()  might be:"
msgstr "B<strncat>()  の簡単な実装は以下のような感じであろう:"

#. type: Plain text
#: build/C/man3/strcat.3:114
#, fuzzy, no-wrap
#| msgid ""
#| "char*\n"
#| "strncat(char *dest, const char *src, size_t n)\n"
#| "{\n"
#| "    size_t dest_len = strlen(dest);\n"
#| "    size_t i;\n"
msgid ""
"char *\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"
msgstr ""
"char*\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"

#. type: Plain text
#: build/C/man3/strcat.3:118
#, no-wrap
msgid ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man3/strcat.3:121 build/C/man3/strcpy.3:106
#, no-wrap
msgid ""
"    return dest;\n"
"}\n"
msgstr ""
"    return dest;\n"
"}\n"

#. type: Plain text
#: build/C/man3/strcat.3:130
msgid ""
"The B<strcat>()  and B<strncat>()  functions return a pointer to the "
"resulting string I<dest>."
msgstr ""
"B<strcat>()  関数と B<strncat>()  関数は、結果としてできる文字列 I<dest> への"
"ポインターを返す。"

#. type: tbl table
#: build/C/man3/strcat.3:141
#, fuzzy, no-wrap
#| msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgid ""
"B<strcat>(),\n"
"B<strncat>()"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: Plain text
#: build/C/man3/strcat.3:147 build/C/man3/strcpy.3:185
msgid ""
"Some systems (the BSDs, Solaris, and others) provide the following function:"
msgstr ""
"いくつかのシステム (BSD、Solaris など) では以下の関数が提供されている。"

#. type: Plain text
#: build/C/man3/strcat.3:149
#, no-wrap
msgid "    size_t strlcat(char *dest, const char *src, size_t size);\n"
msgstr "    size_t strlcat(char *dest, const char *src, size_t size);\n"

#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: build/C/man3/strcat.3:183
msgid ""
"This function appends the null-terminated string I<src> to the string "
"I<dest>, copying at most I<size-strlen(dest)-1> from I<src>, and adds a "
"terminating null byte to the result, I<unless> I<size> is less than "
"I<strlen(dest)>.  This function fixes the buffer overrun problem of "
"B<strcat>(), but the caller must still handle the possibility of data loss "
"if I<size> is too small.  The function returns the length of the string "
"B<strlcat>()  tried to create; if the return value is greater than or equal "
"to I<size>, data loss occurred.  If data loss matters, the caller I<must> "
"either check the arguments before the call, or test the function return "
"value.  B<strlcat>()  is not present in glibc and is not standardized by "
"POSIX, but is available on Linux via the I<libbsd> library."
msgstr ""
"この関数は、ヌル終端された文字列 I<src> を文字列 I<dest> に追加する。 具体例"
"には、 I<size> が I<strlen(dest)> より大きい場合には最大で I<size-"
"strlen(dest)-1> バイトを I<src> からコピーし、 結果の末尾に終端のヌルバイトを"
"追加する。 この関数では B<strcat>() のバッファーオーバーランが発生するという"
"問題が修正されているが、  I<size> が小さすぎた場合にはデータが失われる問題に"
"は、 依然として呼び出し側で対処する必要がある。 この関数は B<strlcat>() が作"
"成しようとした文字列の長さを返す。 返り値が I<size> 以上の場合、 データロスが"
"発生している。 データロスが問題となる場合は、 呼び出し側で、 呼び出し前に引き"
"数をチェックするか、 この関数の返り値を検査するかのいずれかをしなければならな"
"い。 B<strlcat>() は glibc には存在せず、 POSIX による標準化もされていない"
"が、 Linux では I<libbsd> ライブラリ経由で利用できる。"

#. type: Plain text
#: build/C/man3/strcat.3:200
msgid ""
"Because B<strcat>()  and B<strncat>()  must find the null byte that "
"terminates the string I<dest> using a search that starts at the beginning of "
"the string, the execution time of these functions scales according to the "
"length of the string I<dest>.  This can be demonstrated by running the "
"program below.  (If the goal is to concatenate many strings to one target, "
"then manually copying the bytes from each source string while maintaining a "
"pointer to the end of the target string will provide better performance.)"
msgstr ""

#. type: SS
#: build/C/man3/strcat.3:200 build/C/man3/strcmp.3:170
#: build/C/man3/strtok.3:241 build/C/man3/strverscmp.3:128
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/strcat.3:207
#, fuzzy, no-wrap
#| msgid ""
#| "#include E<lt>stdio.hE<gt>\n"
#| "#include E<lt>stdlib.hE<gt>\n"
#| "#include E<lt>string.hE<gt>\n"
msgid ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/strcat.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define LIM 4000000\n"
"    char p[LIM + 1];    /* +1 for terminating null byte */\n"
"    time_t base;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:217
#, no-wrap
msgid ""
"    base = time(NULL);\n"
"    p[0] = \\(aq\\e0\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:224
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> LIM; j++) {\n"
"        if ((j % 10000) == 0)\n"
"            printf(\"%d %jd\\en\", j, (intmax_t) (time(NULL) - base));\n"
"        strcat(p, \"a\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:235
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"

#. type: TH
#: build/C/man3/strchr.3:33
#, no-wrap
msgid "STRCHR"
msgstr "STRCHR"

#. type: Plain text
#: build/C/man3/strchr.3:36
msgid "strchr, strrchr, strchrnul - locate character in string"
msgstr "strchr, strrchr, strchrnul - 文字列中の文字の位置を特定する"

#. type: Plain text
#: build/C/man3/strchr.3:41
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/strchr.3:43
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/strchr.3:48
#, no-wrap
msgid "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/strchr.3:57
msgid ""
"The B<strchr>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<strchr>()  関数は、文字列 I<s> 中に最初に文字 I<c> が現れた位置へのポイン"
"ターを返す。"

#. type: Plain text
#: build/C/man3/strchr.3:65
msgid ""
"The B<strrchr>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<strrchr>()  関数は、文字列 I<s> 中に最後に文字 I<c> が現れた位置へのポイン"
"ターを返す。"

#. type: Plain text
#: build/C/man3/strchr.3:78
msgid ""
"The B<strchrnul>()  function is like B<strchr>()  except that if I<c> is not "
"found in I<s>, then it returns a pointer to the null byte at the end of "
"I<s>, rather than NULL."
msgstr ""
"B<strchrnul>()  関数は B<strchr>()  と同様だが、 I<c> が I<s> 中に見つからな"
"かった場合に、返り値として NULL でなく、I<s> の末尾のヌルバイトへのポインター"
"を返す点が異なる。"

#. type: Plain text
#: build/C/man3/strchr.3:81
msgid ""
"Here \"character\" means \"byte\"; these functions do not work with wide or "
"multibyte characters."
msgstr ""
"ここでいう「文字」は「バイト」の意味なので、 これらの関数はワイド文字やマルチ"
"バイト文字では動作しない。"

#. type: Plain text
#: build/C/man3/strchr.3:93
msgid ""
"The B<strchr>()  and B<strrchr>()  functions return a pointer to the matched "
"character or NULL if the character is not found.  The terminating null byte "
"is considered part of the string, so that if I<c> is specified as \\(aq"
"\\e0\\(aq, these functions return a pointer to the terminator."
msgstr ""
"B<strchr>() と B<strrchr>() 関数は一致した文字へのポインターを返し、もし\n"
"文字が見つからない場合は NULL を返す。終端のヌルバイトは文字列の一部と\n"
"みなされ、I<c> に \\(aq\\e0\\(aq が指定された場合には、これらの関数は\n"
"終端のヌルバイトへのポインターを返す。"

#. type: Plain text
#: build/C/man3/strchr.3:102
msgid ""
"The B<strchrnul>()  function returns a pointer to the matched character, or "
"a pointer to the null byte at the end of I<s> (i.e., I<s+strlen(s)>)  if the "
"character is not found."
msgstr ""
"B<strchrnul>()  関数は一致した文字へのポインターを返す。 文字が見つからない場"
"合は、I<s> の末尾のヌルバイトへの ポインター (つまり I<s+strlen(s)>) を返す。"

#. type: Plain text
#: build/C/man3/strchr.3:105
msgid "B<strchrnul>()  first appeared in glibc in version 2.1.1."
msgstr "B<strchrnul>()  は glibc バージョン 2.1.1 で初めて登場した。"

#. type: tbl table
#: build/C/man3/strchr.3:117
#, fuzzy, no-wrap
#| msgid "The B<strchr>(), B<strrchr>(), and B<strchrnul>()  functions are thread-safe."
msgid ""
"B<strchr>(),\n"
"B<strrchr>(),\n"
"B<strchrnul>()"
msgstr "関数 B<strchr>(), B<strrchr>(), B<strchrnul>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/strchr.3:123
msgid ""
"B<strchr>(), B<strrchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, "
"4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:126
#, fuzzy
#| msgid "This function is a GNU extension."
msgid "B<strchrnul>()  is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/strchr.3:139
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"

#. type: TH
#: build/C/man3/strcmp.3:33
#, no-wrap
msgid "STRCMP"
msgstr "STRCMP"

#. type: TH
#: build/C/man3/strcmp.3:33
#, fuzzy, no-wrap
#| msgid "2014-04-14"
msgid "2020-04-11"
msgstr "2014-04-14"

#. type: Plain text
#: build/C/man3/strcmp.3:36
msgid "strcmp, strncmp - compare two strings"
msgstr "strcmp, strncmp - 二つの文字列を比べる"

#. type: Plain text
#: build/C/man3/strcmp.3:41
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: build/C/man3/strcmp.3:43
#, no-wrap
msgid "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcmp.3:54
msgid ""
"The B<strcmp>()  function compares the two strings I<s1> and I<s2>.  The "
"locale is not taken into account (for a locale-aware comparison, see "
"B<strcoll>(3)).  The comparison is done using unsigned characters."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:57
msgid ""
"B<strcmp>()  returns an integer indicating the result of the comparison, as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man3/strcmp.3:57 build/C/man3/strcmp.3:63 build/C/man3/strcmp.3:68
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:63
msgid "0, if the I<s1> and I<s2> are equal;"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:68
msgid "a negative value if I<s1> is less than I<s2>;"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:73
msgid "a positive value if I<s1> is greater than I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:83
msgid ""
"The B<strncmp>()  function is similar, except it compares only the first (at "
"most)  I<n> bytes of I<s1> and I<s2>."
msgstr ""
"B<strncmp>() 関数は、I<s1> と I<s2> の最初の I<n> バイトだけを比較する\n"
"ことを除けば、strcmp()と同様である。"

#. type: Plain text
#: build/C/man3/strcmp.3:96
msgid ""
"The B<strcmp>()  and B<strncmp>()  functions return an integer less than, "
"equal to, or greater than zero if I<s1> (or the first I<n> bytes thereof) is "
"found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""
"B<strcmp>()  関数と B<strncmp>()  関数は整数を返す。 この整数は、ゼロよりも、"
"1)小さい、2)等しい、3)大きいのいずれかである。 それぞれは、I<s1>（または、こ"
"の文字列の最初の I<n> バイト）が I<s2> よりも、1)小さい、2)等しい、3)大きいに"
"対応している。"

#. type: tbl table
#: build/C/man3/strcmp.3:107
#, fuzzy, no-wrap
#| msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgid ""
"B<strcmp>(),\n"
"B<strncmp>()"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: Plain text
#: build/C/man3/strcmp.3:113
msgid "POSIX.1 specifies only that:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:120
#, fuzzy
#| msgid ""
#| "For a nonzero return value, the sign is determined by the sign of the "
#| "difference between the first pair of bytes (interpreted as I<unsigned "
#| "char>)  that differ in I<s1> and I<s2>."
msgid ""
"The sign of a nonzero return value shall be determined by the sign of the "
"difference between the values of the first pair of bytes (both interpreted "
"as type I<unsigned char>)  that differ in the strings being compared."
msgstr ""
"0 でない値の場合、 I<s1> と I<s2> で値が異なった最初のバイトの値の差で符号は"
"決定される (バイトは I<unsigned char> で解釈される)。"

#. type: Plain text
#: build/C/man3/strcmp.3:129
msgid ""
"In glibc, as in most other implementations, the return value is the "
"arithmetic result of subtracting the last compared byte in I<s2> from the "
"last compared byte in I<s1>.  (If the two characters are equal, this "
"difference is 0.)"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:137
msgid ""
"The program below can be used to demonstrate the operation of B<strcmp>()  "
"(when given two arguments) and B<strncmp>()  (when given three arguments).  "
"First, some examples using B<strcmp>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:150
#, no-wrap
msgid ""
"$ B<./string_comp ABC ABC>\n"
"E<lt>str1E<gt> and E<lt>str2E<gt> are equal\n"
"$ B<./string_comp ABC AB>      # \\(aqC\\(aq is ASCII 67; \\(aqC\\(aq - \\(aq\\0\\(aq = 67\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (67)\n"
"$ B<./string_comp ABA ABZ>     # \\(aqA\\(aq is ASCII 65; \\(aqZ\\(aq is ASCII 90\n"
"E<lt>str1E<gt> is less than E<lt>str2E<gt> (-25)\n"
"$ B<./string_comp ABJ ABC>\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (7)\n"
"$ .B</string_comp $\\(aq\\e201\\(aq A>   # 0201 - 0101 = 0100 (or 64 decimal)\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (64)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:158
msgid ""
"The last example uses B<bash>(1)-specific syntax to produce a string "
"containing an 8-bit ASCII code; the result demonstrates that the string "
"comparison uses unsigned characters."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:161
msgid "And then some examples using B<strncmp>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:168
#, no-wrap
msgid ""
"$ B<./string_comp ABC AB 3>\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (67)\n"
"$ B<./string_comp ABC AB 2>\n"
"E<lt>str1E<gt> and E<lt>str2E<gt> are equal in the first 2 bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:174
#, no-wrap
msgid "/* string_comp.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:180
#, fuzzy, no-wrap
#| msgid ""
#| "#include E<lt>stdio.hE<gt>\n"
#| "#include E<lt>stdlib.hE<gt>\n"
#| "#include E<lt>string.hE<gt>\n"
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/strcmp.3:185 build/C/man3/strverscmp.3:140
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:190
#, fuzzy, no-wrap
#| msgid ""
#| "    if (argc != 4) {\n"
#| "        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
#| "                argv[0]);\n"
#| "        exit(EXIT_FAILURE);\n"
#| "    }\n"
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>str1E<gt> E<lt>str2E<gt> [E<lt>lenE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/strcmp.3:195
#, no-wrap
msgid ""
"    if (argc == 3)\n"
"        res = strcmp(argv[1], argv[2]);\n"
"    else\n"
"        res = strncmp(argv[1], argv[2], atoi(argv[3]));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:206
#, no-wrap
msgid ""
"    if (res == 0) {\n"
"        printf(\"E<lt>str1E<gt> and E<lt>str2E<gt> are equal\");\n"
"        if (argc E<gt> 3)\n"
"            printf(\" in the first %d bytes\\en\", atoi(argv[3]));\n"
"        printf(\"\\en\");\n"
"    } else if (res E<lt> 0) {\n"
"        printf(\"E<lt>str1E<gt> is less than E<lt>str2E<gt> (%d)\\en\", res);\n"
"    } else {\n"
"        printf(\"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (%d)\\en\", res);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:209 build/C/man3/strtok.3:276
#: build/C/man3/strverscmp.3:153
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/strcmp.3:221
#, fuzzy
#| msgid ""
#| "B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
#| "B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3), B<ascii>(7)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"

#. type: TH
#: build/C/man3/strcoll.3:30
#, no-wrap
msgid "STRCOLL"
msgstr "STRCOLL"

#. type: Plain text
#: build/C/man3/strcoll.3:33
msgid "strcoll - compare two strings using the current locale"
msgstr "strcoll - 現在のロケールを使用して二つの文字列を比較する"

#. type: Plain text
#: build/C/man3/strcoll.3:38
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: build/C/man3/strcoll.3:58
msgid ""
"The B<strcoll>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>.  "
"The comparison is based on strings interpreted as appropriate for the "
"program's current locale for category B<LC_COLLATE>.  (See B<setlocale>(3).)"
msgstr ""
"B<strcoll>() 関数は二つの文字列 I<s1> と I<s2> を比較する。 この関数は、"
"I<s1> が I<s2> よりも小さいか、等しいか、大きいかによって それぞれ負の整数、"
"0、正の整数を返す。 比較は、プログラムの現在のロケールの B<LC_COLLATE> カテゴ"
"リーに応じて 解釈された文字列に基づいて行われる (B<setlocale>(3)  参照)。"

#. type: Plain text
#: build/C/man3/strcoll.3:69
msgid ""
"The B<strcoll>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be less than, to "
"match, or be greater than I<s2>, when both are interpreted as appropriate "
"for the current locale."
msgstr ""
"B<strcoll>()  関数は、I<s1> が I<s2> よりも小さいか、等しいか、 大きいかに"
"よって、それぞれ負の整数、0、正の整数を返す。 どちらの文字列も現在のロケール"
"に応じて解釈されたものが使用される。"

#. type: tbl table
#: build/C/man3/strcoll.3:79
#, fuzzy, no-wrap
#| msgid "B<strtok>()"
msgid "B<strcoll>()"
msgstr "B<strtok>()"

#. type: Plain text
#: build/C/man3/strcoll.3:93
msgid ""
"In the I<POSIX> or I<C> locales B<strcoll>()  is equivalent to B<strcmp>(3)."
msgstr ""
"I<POSIX> および I<C> ロケールにおいては、 B<strcoll>()  は B<strcmp>(3)  と等"
"価である。"

#. type: Plain text
#: build/C/man3/strcoll.3:101
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"

#. type: TH
#: build/C/man3/strcpy.3:35
#, no-wrap
msgid "STRCPY"
msgstr "STRCPY"

#. type: Plain text
#: build/C/man3/strcpy.3:38
msgid "strcpy, strncpy - copy a string"
msgstr "strcpy, strncpy - 文字列をコピーする"

#. type: Plain text
#: build/C/man3/strcpy.3:43
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: build/C/man3/strcpy.3:45
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcpy.3:59
msgid ""
"The B<strcpy>()  function copies the string pointed to by I<src>, including "
"the terminating null byte (\\(aq\\e0\\(aq), to the buffer pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy.  I<Beware of buffer overruns!> "
"(See BUGS.)"
msgstr ""
"B<strcpy>()  関数は I<src> が指す文字列を末尾のヌルバイト (\\(aq\\e0\\(aq) も"
"含めて I<dest> が指すバッファーにコピーする。 二つの文字列は重なってはならな"
"い。受け側の文字列 I<dest> は コピーを受け取るのに十分な大きさでなければなら"
"ない。 I<バッファーオーバーランに気を付けること!> (「バグ」の節を参照)"

#. type: Plain text
#: build/C/man3/strcpy.3:76
msgid ""
"The B<strncpy>()  function is similar, except that at most I<n> bytes of "
"I<src> are copied.  B<Warning>: If there is no null byte among the first "
"I<n> bytes of I<src>, the string placed in I<dest> will not be null-"
"terminated."
msgstr ""
"B<strncpy>()  関数も同様だが、 I<src> のうち最大でも I<n> バイトしかコピーさ"
"れない点が異なる。 B<警告>: I<src> の最初の I<n> バイトの中にヌルバイトがない"
"場合、 I<dest> に格納される文字列はヌルで終端されないことになる。"

#. type: Plain text
#: build/C/man3/strcpy.3:87
msgid ""
"If the length of I<src> is less than I<n>, B<strncpy>()  writes additional "
"null bytes to I<dest> to ensure that a total of I<n> bytes are written."
msgstr ""
"I<src> の長さが I<n> よりも短い場合、 B<strncpy>() は I<dest> に追加のヌルバ"
"イトを書き込み、全部で I<n> バイトが書き込まれるようにする。"

#. type: Plain text
#: build/C/man3/strcpy.3:91
msgid "A simple implementation of B<strncpy>()  might be:"
msgstr "B<strncpy>()  の簡単な実装は以下のような感じであろう:"

#. type: Plain text
#: build/C/man3/strcpy.3:98
#, no-wrap
msgid ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"
msgstr ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"

#. type: Plain text
#: build/C/man3/strcpy.3:103
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man3/strcpy.3:116
msgid ""
"The B<strcpy>()  and B<strncpy>()  functions return a pointer to the "
"destination string I<dest>."
msgstr ""
"B<strcpy>()  関数と B<strncpy>()  関数は 受け側の文字列I<dest>へのポインター"
"を返す。"

#. type: tbl table
#: build/C/man3/strcpy.3:127
#, fuzzy, no-wrap
#| msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgid ""
"B<strcpy>(),\n"
"B<strncpy>()"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: Plain text
#: build/C/man3/strcpy.3:144
msgid ""
"Some programmers consider B<strncpy>()  to be inefficient and error prone.  "
"If the programmer knows (i.e., includes code to test!)  that the size of "
"I<dest> is greater than the length of I<src>, then B<strcpy>()  can be used."
msgstr ""
"B<strncpy>()  は効率的でなく間違いを起こしやすいと考えるプログラマもいるだろ"
"う。 プログラマが I<dest> の大きさが I<src> の長さよりも 大きいことを知ってい"
"る (つまり、そのことをチェックするコードを 書いている) 場合は、 B<strcpy()> "
"を使うことができる。"

#. type: Plain text
#: build/C/man3/strcpy.3:153
#, fuzzy
#| msgid ""
#| "One valid (and intended) use of B<strncpy>()  is to copy a C string to a "
#| "fixed-length buffer while ensuring both that the buffer is not overflowed "
#| "and that unused bytes in the target buffer are zeroed out (perhaps to "
#| "prevent information leaks if the buffer is to be written to media or "
#| "transmitted to another process via an interprocess communication "
#| "technique)."
msgid ""
"One valid (and intended) use of B<strncpy>()  is to copy a C string to a "
"fixed-length buffer while ensuring both that the buffer is not overflowed "
"and that unused bytes in the destination buffer are zeroed out (perhaps to "
"prevent information leaks if the buffer is to be written to media or "
"transmitted to another process via an interprocess communication technique)."
msgstr ""
"B<strncpy>() の正しい (かつ意図された) 用途は、 C 文字列の固定長バッファーへ"
"のコピーを、 バッファーがオーバーフローしないことと、 宛先バッファーの未使用"
"バイトが 0 で埋められることの両方を保証しつつ行うことである。 (宛先バッファー"
"を 0 で埋めるのは、 たいていの場合、 バッファーを媒体に書き込んだり、別のプロ"
"セスにプロセス間通信を用いて送信したりした場合に情報洩れを防ぐためである)。"

#. type: Plain text
#: build/C/man3/strcpy.3:166
msgid ""
"If there is no terminating null byte in the first I<n> bytes of I<src>, "
"B<strncpy>()  produces an unterminated string in I<dest>.  If I<buf> has "
"length I<buflen>, you can force termination using something like the "
"following:"
msgstr ""
"I<src> の最初の I<n> バイトに終端のヌルバイトがない場合、 B<strncpy>() は "
"I<dest> に終端されていない文字列を生成する。 I<buf> の長さが I<buflen> の場"
"合、以下のようにして強制的に終端することができる。"

#. type: Plain text
#: build/C/man3/strcpy.3:173
#, fuzzy, no-wrap
#| msgid ""
#| "strncpy(buf, str, buflen - 1);\n"
#| "if (buflen E<gt> 0)\n"
#| "    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"
msgid ""
"if (buflen E<gt> 0) {\n"
"    strncpy(buf, str, buflen - 1);\n"
"    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"
"}\n"
msgstr ""
"strncpy(buf, str, buflen - 1);\n"
"if (buflen E<gt> 0)\n"
"    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man3/strcpy.3:183
msgid ""
"(Of course, the above technique ignores the fact that, if I<src> contains "
"more than I<buflen\\ -\\ 1> bytes, information is lost in the copying to "
"I<dest>.)"
msgstr ""
"(もちろん、上記の方法では、 I<src> に入っている情報が I<buflen\\ -\\ 1> バイ"
"トよりも多い場合には、 I<dest> へのコピー時に情報が失われるという事実は無視し"
"ている。)"

#. type: SS
#: build/C/man3/strcpy.3:183
#, no-wrap
msgid "strlcpy()"
msgstr "strlcpy()"

#. type: Plain text
#: build/C/man3/strcpy.3:187
#, no-wrap
msgid "    size_t strlcpy(char *dest, const char *src, size_t size);\n"
msgstr "    size_t strlcpy(char *dest, const char *src, size_t size);\n"

#.  http://static.usenix.org/event/usenix99/full_papers/millert/millert_html/index.html
#.      "strlcpy and strlcat - consistent, safe, string copy and concatenation"
#.      1999 USENIX Annual Technical Conference
#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: build/C/man3/strcpy.3:222
#, fuzzy
#| msgid ""
#| "This function is similar to B<strncpy>(), but it copies at most I<size-1> "
#| "bytes to I<dest>, always adds a terminating null byte, and does not pad "
#| "the target with (further) null bytes.  This function fixes some of the "
#| "problems of B<strcpy>()  and B<strncpy>(), but the caller must still "
#| "handle the possibility of data loss if I<size> is too small.  The return "
#| "value of the function is the length of I<src>, which allows truncation to "
#| "be easily detected: if the return value is greater than or equal to "
#| "I<size>, truncation occurred.  If loss of data matters, the caller "
#| "I<must> either check the arguments before the call, or test the function "
#| "return value.  B<strlcpy>()  is not present in glibc and is not "
#| "standardized by POSIX, but is available on Linux via the I<libbsd> "
#| "library."
msgid ""
"This function is similar to B<strncpy>(), but it copies at most I<size-1> "
"bytes to I<dest>, always adds a terminating null byte, and does not pad the "
"destination with (further) null bytes.  This function fixes some of the "
"problems of B<strcpy>()  and B<strncpy>(), but the caller must still handle "
"the possibility of data loss if I<size> is too small.  The return value of "
"the function is the length of I<src>, which allows truncation to be easily "
"detected: if the return value is greater than or equal to I<size>, "
"truncation occurred.  If loss of data matters, the caller I<must> either "
"check the arguments before the call, or test the function return value.  "
"B<strlcpy>()  is not present in glibc and is not standardized by POSIX, but "
"is available on Linux via the I<libbsd> library."
msgstr ""
"この関数は B<strncpy>() と同様だが、 最大でも I<size-1> バイトしか I<dest> に"
"コピーをせず、 末尾への終端のヌルバイトの追加が必ず行われ、 宛先バッファー "
"(の未使用部分) へのヌルバイトの書き込みが行われない。 この関数では "
"B<strcpy>() や B<strncpy>() の持つ問題のいくつかが修正されているが、 I<size> "
"が小さすぎた場合にはデータが失われる問題には、 依然として呼び出し側で対処する"
"必要がある。 この関数の返り値は I<src> の長さである。 これにより、 末尾の切り"
"詰めが行われたかを簡単に検出することができる。 返り値が I<size> 以上の場合に"
"は、 末尾の切り詰めが発生している。 データロスが問題となる場合は、 呼び出し側"
"で、 呼び出し前に引き数をチェックするか、 この関数の返り値を検査するかのいず"
"れかをしなければならない。 B<strlcpy>() は glibc  には存在せず、 POSIX による"
"標準化もされていないが、 Linux では I<libbsd> ライブラリ経由で利用できる。"

#. type: Plain text
#: build/C/man3/strcpy.3:233
msgid ""
"If the destination string of a B<strcpy>()  is not large enough, then "
"anything might happen.  Overflowing fixed-length string buffers is a "
"favorite cracker technique for taking complete control of the machine.  Any "
"time a program reads or copies data into a buffer, the program first needs "
"to check that there's enough space.  This may be unnecessary if you can show "
"that overflow is impossible, but be careful: programs can get changed over "
"time, in ways that may make the impossible possible."
msgstr ""
"B<strcpy>()  の受け側の文字列が十分な大きさでない場合、何が起こるかわからな"
"い。 固定長文字列を溢れさせるのは、マシンの制御を掌中に収めるために クラッ"
"カーが好んで使うテクニックである。 プログラムでデータをバッファーに読み込んだ"
"りコピーしたりする場合には、 必ずまず最初に十分な大きさがあるかどうかをチェッ"
"クする必要がある。 プログラマがオーバーフローが不可能だと示せる場合には この"
"チェックは不要かもしれないが、十分注意すること。 長い間には、不可能だったこと"
"が可能になるような方法でプログラムが 変更されることもあるからだ。"

#. type: Plain text
#: build/C/man3/strcpy.3:244
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"

#. type: TH
#: build/C/man3/strdup.3:31
#, no-wrap
msgid "STRDUP"
msgstr "STRDUP"

#. type: Plain text
#: build/C/man3/strdup.3:34
msgid "strdup, strndup, strdupa, strndupa - duplicate a string"
msgstr "strdup, strndup, strdupa, strndupa - 文字列を複製する"

#. type: Plain text
#: build/C/man3/strdup.3:39
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>\n"
msgstr "B<char *strdup(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/strdup.3:43
#, fuzzy, no-wrap
#| msgid "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgid ""
"B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
"B<char *strdupa(const char *>I<s>B<);>\n"
"B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strdup.3:53
msgid "B<strdup>():"
msgstr "B<strdup>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/strdup.3:58
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:61
msgid "B<strndup>():"
msgstr "B<strndup>():"

#. type: Plain text
#: build/C/man3/strdup.3:73
msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgstr "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/strdup.3:86
msgid ""
"The B<strdup>()  function returns a pointer to a new string which is a "
"duplicate of the string I<s>.  Memory for the new string is obtained with "
"B<malloc>(3), and can be freed with B<free>(3)."
msgstr ""
"B<strdup>()  関数は、文字列 I<s>の複製である 新しい文字列へのポインターを返"
"す。 新しい文字列のためのメモリーは B<malloc>(3)  で得ている。 そして、 "
"B<free>(3)  で解放することができる。"

#. type: Plain text
#: build/C/man3/strdup.3:99
msgid ""
"The B<strndup>()  function is similar, but copies at most I<n> bytes.  If "
"I<s> is longer than I<n>, only I<n> bytes are copied, and a terminating null "
"byte (\\(aq\\e0\\(aq) is added."
msgstr ""
"B<strndup>() 関数は同様であるが、最大で I<n> バイトを複製する。\n"
"I<s> が I<n> よりも長い場合、I<n> バイトだけが複製され、\n"
"終端のヌルバイト (\\(aq\\e0\\(aq)) が追加される。"

#. type: Plain text
#: build/C/man3/strdup.3:109
msgid ""
"B<strdupa>()  and B<strndupa>()  are similar, but use B<alloca>(3)  to "
"allocate the buffer.  They are available only when using the GNU GCC suite, "
"and suffer from the same limitations described in B<alloca>(3)."
msgstr ""
"B<strdupa>() と B<strndupa>() も同様だが、バッファーの確保に\n"
"B<alloca>(3) を使用する点が異なる。\n"
"これらが使用できるのは GNU GCC ツール群を使う場合だけであり、\n"
"B<alloca>(3) で説明されているのと同じ制限がある。"

#. type: Plain text
#: build/C/man3/strdup.3:117
msgid ""
"On success, the B<strdup>()  function returns a pointer to the duplicated "
"string.  It returns NULL if insufficient memory was available, with I<errno> "
"set to indicate the cause of the error."
msgstr ""
"成功すると、 B<strdup>() 関数は複製された文字列へのポインターを返す。 十分な"
"メモリーが確保できなかった場合には、 NULL を返し、 I<errno> にエラーの原因を"
"示す値を設定する。"

#. type: SH
#: build/C/man3/strdup.3:117 build/C/man3/strerror.3:229
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/strdup.3:118
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/strdup.3:121
msgid "Insufficient memory available to allocate duplicate string."
msgstr "複製された文字列を割り当てる十分なメモリーが確保できなかった。"

#. type: tbl table
#: build/C/man3/strdup.3:133
#, fuzzy, no-wrap
#| msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgid ""
"B<strdup>(),\n"
"B<strndup>(),\n"
"B<strdupa>(),\n"
msgstr "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"

#. type: tbl table
#: build/C/man3/strdup.3:135
#, fuzzy, no-wrap
#| msgid "B<strndup>():"
msgid "B<strndupa>()"
msgstr "B<strndup>():"

#.  4.3BSD-Reno, not (first) 4.3BSD.
#. type: Plain text
#: build/C/man3/strdup.3:148
msgid ""
"B<strdup>()  conforms to SVr4, 4.3BSD, POSIX.1-2001.  B<strndup>()  conforms "
"to POSIX.1-2008.  B<strdupa>()  and B<strndupa>()  are GNU extensions."
msgstr ""
"B<strdup>()  は SVr4, 4.3BSD, POSIX.1-2001 準拠である。 B<strndup>()  は "
"POSIX.1-2008 準拠である。 B<strdupa>(), B<strndupa>()  は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/strdup.3:156
msgid ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"
msgstr ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"

#. type: TH
#: build/C/man3/strerror.3:39
#, no-wrap
msgid "STRERROR"
msgstr "STRERROR"

#. type: Plain text
#: build/C/man3/strerror.3:42
#, fuzzy
#| msgid ""
#| "strerror, strerror_r, strerror_l - return string describing error number"
msgid ""
"strerror, strerrorname_np, strerrordesc_np, strerror_r, strerror_l - return "
"string describing error number"
msgstr "strerror, strerror_r, strerror_l - エラー番号を説明する文字列を返す。"

#. type: Plain text
#: build/C/man3/strerror.3:49
#, no-wrap
msgid ""
"B<char *strerror(int >I<errnum>B<);>\n"
"B<const char *strerrorname_np(int >I<errnum>B<);>\n"
"B<const char *strerrordesc_np(int >I<errnum>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:52
#, no-wrap
msgid ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"
msgstr ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"

#. type: Plain text
#: build/C/man3/strerror.3:55
#, no-wrap
msgid ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* GNU-specific */\n"
msgstr ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* GNU-specific */\n"

#. type: Plain text
#: build/C/man3/strerror.3:57
#, no-wrap
msgid "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"
msgstr "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"

#. type: Plain text
#: build/C/man3/strerror.3:69
#, fuzzy, no-wrap
#| msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgid ""
"B<strerrorname_np>(),\n"
"B<strerrordesc_np>():\n"
"    _GNU_SOURCE\n"
msgstr "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/strerror.3:71
msgid "B<strerror_r>():"
msgstr "B<strerror_r>():"

#. type: Plain text
#: build/C/man3/strerror.3:73
msgid "The XSI-compliant version is provided if:"
msgstr "次の場合には XSI 準拠のバージョンが提供される:"

#. type: Plain text
#: build/C/man3/strerror.3:75
#, fuzzy
#| msgid ""
#| "(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600) && !"
#| "\\ _GNU_SOURCE"
msgid "(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L) && ! \\ _GNU_SOURCE"
msgstr ""
"(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600) && !\\ "
"_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/strerror.3:77
msgid "Otherwise, the GNU-specific version is provided."
msgstr "それ以外の場合、GNU バージョンが提供される。"

#. type: Plain text
#: build/C/man3/strerror.3:102
msgid ""
"The B<strerror>()  function returns a pointer to a string that describes the "
"error code passed in the argument I<errnum>, possibly using the "
"B<LC_MESSAGES> part of the current locale to select the appropriate "
"language.  (For example, if I<errnum> is B<EINVAL>, the returned description "
"will be \"Invalid argument\".)  This string must not be modified by the "
"application, but may be modified by a subsequent call to B<strerror>()  or "
"B<strerror_l>().  No other library function, including B<perror>(3), will "
"modify this string."
msgstr ""
"B<strerror>() 関数は、引き数 I<errnum> で渡されたエラーコードについての説明が"
"入った文字列へのポインターを返す。 可能であるならば、適切な言語を選択するため"
"に、 現在のロケールの B<LC_MESSAGES> を使う。(例えば、 I<errnum> が "
"B<EINVAL> の場合、説明として \"Invalid argument\" が返される。) この文字列"
"は、アプリケーションで変更してはならないが、 これ以降に行われる "
"B<strerror>() や B<strerror_l>() の呼び出しで変更されても構わない。 "
"B<perror>(3) などの、これ以外のライブラリ関数ではこの文字列は変更されない。"

#. type: Plain text
#: build/C/man3/strerror.3:112
msgid ""
"Like B<strerror>(), the B<strerrordesc_np>()  function returns a pointer to "
"a string that describes the error code passed in the argument I<errnum>, "
"with the difference that the returned string is not translated according to "
"the current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:122
msgid ""
"The B<strerrorname_np>()  function returns a pointer to a string containing "
"the name of the error code passed in the argument I<errnum>.  For example, "
"given B<EPERM> as an argument, this function returns a pointer to the string "
"\"EPERM\"."
msgstr ""

#. type: SS
#: build/C/man3/strerror.3:122
#, no-wrap
msgid "strerror_r()"
msgstr "strerror_r()"

#. type: Plain text
#: build/C/man3/strerror.3:143
#, fuzzy
#| msgid ""
#| "The B<strerror_r>()  function is similar to B<strerror>(), but is thread "
#| "safe.  This function is available in two versions: an XSI-compliant "
#| "version specified in POSIX.1-2001 (available since glibc 2.3.4, but not "
#| "POSIX-compliant until glibc 2.13), and a GNU-specific version (available "
#| "since glibc 2.0).  The XSI-compliant version is provided with the feature "
#| "test macros settings shown in the SYNOPSIS; otherwise the GNU-specific "
#| "version is provided.  If no feature test macros are explicitly defined, "
#| "then (since glibc 2.4)  B<_POSIX_SOURCE> is defined by default with the "
#| "value 200112L, so that the XSI-compliant version of B<strerror_r>()  is "
#| "provided by default."
msgid ""
"The B<strerror_r>()  function is similar to B<strerror>(), but is thread "
"safe.  This function is available in two versions: an XSI-compliant version "
"specified in POSIX.1-2001 (available since glibc 2.3.4, but not POSIX-"
"compliant until glibc 2.13), and a GNU-specific version (available since "
"glibc 2.0).  The XSI-compliant version is provided with the feature test "
"macros settings shown in the SYNOPSIS; otherwise the GNU-specific version is "
"provided.  If no feature test macros are explicitly defined, then (since "
"glibc 2.4)  B<_POSIX_C_SOURCE> is defined by default with the value 200112L, "
"so that the XSI-compliant version of B<strerror_r>()  is provided by default."
msgstr ""
"B<strerror_r>() 関数は B<strerror>() と似ているが、スレッドセーフである。\n"
"この関数には二種類のバージョンが存在し、 POSIX.1-2001 で規定された XSI\n"
"準拠のバージョン (glibc 2.3.4 以降で利用可能だが、glibc 2.13 までは\n"
"POSIX 準拠ではない) と、 GNU 仕様のバージョン (glibc 2.0 以降で利用可能)\n"
"である。 「書式」の節に記載された機能検査マクロの場合には、 XSI 準拠の\n"
"バージョンが提供される。それ以外の場合には GNU 仕様のバージョンが提供さ\n"
"れる。機能検査マクロが一つも明示的に定義されない場合、 (glibc 2.4 以降\n"
"では) デフォルトで B<_POSIX_SOURCE> は値 200112l で定義され、その結果\n"
"XSI 準拠のバージョンの B<strerror_r>() がデフォルトで提供される。"

#. type: Plain text
#: build/C/man3/strerror.3:151
msgid ""
"The XSI-compliant B<strerror_r>()  is preferred for portable applications.  "
"It returns the error string in the user-supplied buffer I<buf> of length "
"I<buflen>."
msgstr ""
"移植性が必要なアプリケーションでは、 XSI 準拠の B<strerror_r>()  を使う方がよ"
"い。 この関数は、ユーザーから提供される長さ I<buflen> のバッファー I<buf> に"
"エラー文字列を返す。"

#. type: Plain text
#: build/C/man3/strerror.3:172
msgid ""
"The GNU-specific B<strerror_r>()  returns a pointer to a string containing "
"the error message.  This may be either a pointer to a string that the "
"function stores in I<buf>, or a pointer to some (immutable) static string "
"(in which case I<buf> is unused).  If the function stores a string in "
"I<buf>, then at most I<buflen> bytes are stored (the string may be truncated "
"if I<buflen> is too small and I<errnum> is unknown).  The string always "
"includes a terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""
"GNU 仕様の B<strerror_r>() は、 エラーメッセージを格納した文字列へのポイン"
"ターを返す。 返り値は、 この関数が I<buf> に格納した文字列へのポインターか、 "
"何らかの (不変な) 静的な文字列へのポインター、 のいずれかとなる (後者の場合"
"は I<buf> は使用されない)。 I<buf> に文字列が格納される場合は、 最大で "
"I<buflen> バイトが格納される (I<buflen> が小さ過ぎたときには文字列は切り詰め"
"られ、 I<errnum> は不定である)。 文字列には必ず終端ヌル文字 (\\(aq\\e0\\(aq) "
"が含まれる。"

#. type: SS
#: build/C/man3/strerror.3:172
#, no-wrap
msgid "strerror_l()"
msgstr "strerror_l()"

#. type: Plain text
#: build/C/man3/strerror.3:187
msgid ""
"B<strerror_l>()  is like B<strerror>(), but maps I<errnum> to a locale-"
"dependent error message in the locale specified by I<locale>.  The behavior "
"of B<strerror_l>()  is undefined if I<locale> is the special locale object "
"B<LC_GLOBAL_LOCALE> or is not a valid locale object handle."
msgstr ""
"B<strerror_l>() は B<strerror>() と同様だが、 I<errnum> を I<locale> で指定さ"
"れたロケールのロケール依存のエラーメッセージにマッピングする。 I<locale> が特"
"別なロケールオブジェクト B<LC_GLOBAL_LOCALE> の場合、もしくは I<locale> が有"
"効なロケールオブジェクトハンドルでない場合は、 B<strerror_l>() の動作は未定義"
"である。"

#. type: Plain text
#: build/C/man3/strerror.3:196
msgid ""
"The B<strerror>(), B<strerror_l>(), and the GNU-specific B<strerror_r>()  "
"functions return the appropriate error description string, or an \"Unknown "
"error nnn\" message if the error number is unknown."
msgstr ""
"関数 B<strerror>(), B<strerror_l>() と GNU 固有の関数 B<strerror_r>() はエ"
"ラー内容を説明する文字列を返す。 エラー番号が未知の場合は \"Unknown error nnn"
"\" という メッセージを返す。"

#. type: Plain text
#: build/C/man3/strerror.3:205
#, fuzzy
#| msgid ""
#| "The B<strerror>(), B<strerror_l>(), and the GNU-specific B<strerror_r>()  "
#| "functions return the appropriate error description string, or an "
#| "\"Unknown error nnn\" message if the error number is unknown."
msgid ""
"On success, B<strerrorname_np>()  and B<strerrordesc_np>()  return the "
"appropriate error description string.  If I<errnum> is an invalid error "
"number, these functions return NULL."
msgstr ""
"関数 B<strerror>(), B<strerror_l>() と GNU 固有の関数 B<strerror_r>() はエ"
"ラー内容を説明する文字列を返す。 エラー番号が未知の場合は \"Unknown error nnn"
"\" という メッセージを返す。"

#. type: Plain text
#: build/C/man3/strerror.3:214
msgid ""
"The XSI-compliant B<strerror_r>()  function returns 0 on success.  On error, "
"a (positive) error number is returned (since glibc 2.13), or -1 is returned "
"and I<errno> is set to indicate the error (glibc versions before 2.13)."
msgstr ""
"XSI 準拠の B<strerror_r>() 関数は成功すると 0 を返す。エラーの場合には、\n"
"(glibc 2.13 以降では) (正の) エラー番号が返され、(バージョン 2.13 より前\n"
"の glibc では) -1 が返され、 I<errno> にエラーを示す値がセットされる。"

#. type: Plain text
#: build/C/man3/strerror.3:229
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that a successful call to "
"B<strerror>()  or B<strerror_l>()  shall leave I<errno> unchanged, and note "
"that, since no function return value is reserved to indicate an error, an "
"application that wishes to check for errors should initialize I<errno> to "
"zero before the call, and then check I<errno> after the call."
msgstr ""
"POSIX.1-2001 と POSIX.1-2008 では、 B<strerror>() や B<strerror_l>() が成功し"
"た場合は I<errno> を変更せずに元のままにしなければならないとされている。関数"
"のどの返り値もエラーを示すために予約されていないので、エラーをチェックしたい"
"アプリケーションは呼び出しを行う前に I<errno> を 0 に初期化し、呼び出しの後"
"で I<errno> をチェックすべき点に注意すること。"

#. type: TP
#: build/C/man3/strerror.3:230
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/strerror.3:235
msgid "The value of I<errnum> is not a valid error number."
msgstr "I<errnum> の値が有効なエラー番号ではない。"

#. type: TP
#: build/C/man3/strerror.3:235
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/strerror.3:238
msgid ""
"Insufficient storage was supplied to contain the error description string."
msgstr "エラーコードを説明する文字列のために、充分な領域が確保できなかった。"

#. type: Plain text
#: build/C/man3/strerror.3:242
msgid "The B<strerror_l>()  function first appeared in glibc 2.6."
msgstr "B<strerror_l>() 関数は glibc 2.6 で初めて登場した。"

#. type: tbl table
#: build/C/man3/strerror.3:252
#, fuzzy, no-wrap
#| msgid "B<strerror_r>():"
msgid "B<strerror>()"
msgstr "B<strerror_r>():"

#. type: tbl table
#: build/C/man3/strerror.3:252
#, no-wrap
msgid "MT-Unsafe race:strerror"
msgstr ""

#. type: tbl table
#: build/C/man3/strerror.3:256
#, fuzzy, no-wrap
#| msgid "B<psignal>(3), B<strerror>(3)"
msgid ""
"B<strerrorname_np>(),\n"
"B<strerrordesc_np>()"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: tbl table
#: build/C/man3/strerror.3:259
#, fuzzy, no-wrap
#| msgid "B<strerror_r>():"
msgid "B<strerror_r>(),\n"
msgstr "B<strerror_r>():"

#. type: tbl table
#: build/C/man3/strerror.3:261
#, fuzzy, no-wrap
#| msgid "B<strerror_r>():"
msgid "B<strerror_l>()"
msgstr "B<strerror_r>():"

#.  FIXME . for later review when Issue 8 is one day released...
#.  A future POSIX.1 may remove strerror_r()
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=508
#. type: Plain text
#: build/C/man3/strerror.3:272
msgid ""
"B<strerror>()  is specified by POSIX.1-2001, POSIX.1-2008, C89, and C99.  "
"B<strerror_r>()  is specified by POSIX.1-2001 and POSIX.1-2008."
msgstr ""
"B<strerror>()  は POSIX.1-2001, POSIX.1-2008, C89, C99 で規定されている。 "
"B<strerror_r>()  は POSIX.1-2001 と POSIX.1-2008 で規定されている。"

#. type: Plain text
#: build/C/man3/strerror.3:275
msgid "B<strerror_l>()  is specified in POSIX.1-2008."
msgstr "B<strerror_l>() は POSIX.1-2008 で規定されている。"

#. type: Plain text
#: build/C/man3/strerror.3:282
#, fuzzy
#| msgid ""
#| "The GNU-specific B<strerror_r>()  function is a nonstandard extension."
msgid ""
"The GNU-specific functions B<strerror_r>(), B<strerrorname_np>(), and "
"B<strerrordesc_np>()  are nonstandard extensions."
msgstr "GNU 仕様の B<strerror_r>()  関数は非標準の拡張である。"

#.  e.g., Solaris 8, HP-UX 11
#.  e.g., FreeBSD 5.4, Tru64 5.1B
#. type: Plain text
#: build/C/man3/strerror.3:302
msgid ""
"POSIX.1-2001 permits B<strerror>()  to set I<errno> if the call encounters "
"an error, but does not specify what value should be returned as the function "
"result in the event of an error.  On some systems, B<strerror>()  returns "
"NULL if the error number is unknown.  On other systems, B<strerror>()  "
"returns a string something like \"Error nnn occurred\" and sets I<errno> to "
"B<EINVAL> if the error number is unknown.  C99 and POSIX.1-2008 require the "
"return value to be non-NULL."
msgstr ""
"POSIX.1-2001 は、 B<strerror>() がエラーに遭遇した場合に I<errno> をセッ\n"
"トすることを認めているが、エラー発生時に関数の結果として どんな値を返す\n"
"べきかを規定してない。 あるシステムでは、 エラー番号が未知の場合、\n"
"B<strerror>() は NULL を返す。 他のシステムでは、 エラー番号が未知の場\n"
"合、 B<strerror>() は \"Error nnn occurred\" といった文字列を返し、\n"
"I<errno> に B<EINVAL> をセットする。 C99 と POSIX.1-2008 では、返り値が\n"
"NULL 以外になることが求められている。"

#. type: Plain text
#: build/C/man3/strerror.3:309
msgid ""
"The GNU C Library uses a buffer of 1024 characters for B<strerror>().  This "
"buffer size therefore should be sufficient to avoid an B<ERANGE> error when "
"calling B<strerror_r>()."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:314
msgid ""
"B<strerrorname_np>()  and B<strerrordesc_np>()  are thread-safe and async-"
"signal-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:321
msgid ""
"B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), "
"B<locale>(7)"
msgstr ""
"B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), "
"B<locale>(7)"

#. type: TH
#: build/C/man3/strfry.3:30
#, no-wrap
msgid "STRFRY"
msgstr "STRFRY"

#. type: Plain text
#: build/C/man3/strfry.3:33
msgid "strfry - randomize a string"
msgstr "strfry - 文字列をランダムに並べ変える"

#. type: Plain text
#: build/C/man3/strfry.3:39
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>\n"
msgstr "B<char *strfry(char *>I<string>B<);>\n"

#. type: Plain text
#: build/C/man3/strfry.3:48
#, fuzzy
#| msgid ""
#| "The B<strfry>()  function randomizes the contents of I<string> by using "
#| "B<rand>(3)  to randomly swap characters in the string.  The result is an "
#| "anagram of I<string>."
msgid ""
"The B<strfry>()  function randomizes the contents of I<string> by randomly "
"swapping characters in the string.  The result is an anagram of I<string>."
msgstr ""
"B<strfry>()  関数は、文字列 I<string> の内容をランダムに並び換える。 並び換え"
"は、 B<rand>(3)  関数を用いて、文字列中の各文字を無作為に 交換することで実現"
"される。結果は、文字列 I<string> のアナグラムである。"

#. type: Plain text
#: build/C/man3/strfry.3:53
msgid "The B<strfry>()  functions returns a pointer to the randomized string."
msgstr ""
"B<strfry>()  関数は、ランダムに並び換えられた文字列へのポインターを返す。"

#. type: tbl table
#: build/C/man3/strfry.3:63
#, fuzzy, no-wrap
#| msgid "B<strfry>(3)"
msgid "B<strfry>()"
msgstr "B<strfry>(3)"

#. type: Plain text
#: build/C/man3/strfry.3:70
msgid "The B<strfry>()  function is unique to the GNU C Library."
msgstr "B<strfry>()  関数は GNU C ライブラリに特有である。"

#. type: Plain text
#: build/C/man3/strfry.3:73
msgid "B<memfrob>(3), B<string>(3)"
msgstr "B<memfrob>(3), B<string>(3)"

#. type: TH
#: build/C/man3/string.3:30
#, no-wrap
msgid "STRING"
msgstr "STRING"

#. type: Plain text
#: build/C/man3/string.3:36
msgid ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - string "
"operations"
msgstr ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - 文字列を操"
"作する関数"

#. type: Plain text
#: build/C/man3/string.3:38
msgid "B<#include E<lt>strings.hE<gt>>"
msgstr "B<#include E<lt>strings.hE<gt>>"

#. type: TP
#: build/C/man3/string.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: build/C/man3/string.3:45
msgid "Compare the strings I<s1> and I<s2> ignoring case."
msgstr "文字列 I<s1> と I<s2> を大文字小文字の違いを無視して比較する。"

#. type: TP
#: build/C/man3/string.3:45
#, no-wrap
msgid "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"

#. type: Plain text
#: build/C/man3/string.3:54
#, fuzzy
#| msgid ""
#| "Compare the first I<n> characters of the strings I<s1> and I<s2> ignoring "
#| "case."
msgid ""
"Compare the first I<n> bytes of the strings I<s1> and I<s2> ignoring case."
msgstr ""
"文字列 I<s1> と I<s2> の最初の I<n> 文字を、大文字小文字の違いを無視して比較"
"する。"

#. type: TP
#: build/C/man3/string.3:54
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *index(const char *>I<s>B<, int >I<c>B<);>"

#. type: Plain text
#: build/C/man3/string.3:60 build/C/man3/string.3:90
msgid ""
"Return a pointer to the first occurrence of the character I<c> in the string "
"I<s>."
msgstr "文字列 I<s> 中に最初に文字 I<c> が 現れた位置へのポインターを返す。"

#. type: TP
#: build/C/man3/string.3:60
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"

#. type: Plain text
#: build/C/man3/string.3:66 build/C/man3/string.3:171
msgid ""
"Return a pointer to the last occurrence of the character I<c> in the string "
"I<s>."
msgstr "文字列 I<s> 中に最後に文字 I<c> が 現れた位置へのポインターを返す。"

#. type: TP
#: build/C/man3/string.3:66
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>"
msgstr "B<#include E<lt>string.hE<gt>>"

#. type: TP
#: build/C/man3/string.3:68
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: build/C/man3/string.3:76
msgid ""
"Copy a string from I<src> to I<dest>, returning a pointer to the end of the "
"resulting string at I<dest>."
msgstr ""
"文字列を I<src> から I<dest> にコピーし、 I<dest> に格納された文字列の末尾へ"
"のポインターを返す。"

#. type: TP
#: build/C/man3/string.3:76
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: build/C/man3/string.3:84
msgid ""
"Append the string I<src> to the string I<dest>, returning a pointer I<dest>."
msgstr ""
"文字列 I<src> を文字列 I<dest> に追加し、 I<dest> へのポインターを返す。"

#. type: TP
#: build/C/man3/string.3:84
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"

#. type: TP
#: build/C/man3/string.3:90
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: build/C/man3/string.3:96
msgid "Compare the strings I<s1> with I<s2>."
msgstr "文字列 I<s1> と I<s2> を比較する。"

#. type: TP
#: build/C/man3/string.3:96
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: build/C/man3/string.3:103
msgid "Compare the strings I<s1> with I<s2> using the current locale."
msgstr "現在のロケールを使用して、文字列 I<s1> を I<s2> と比較する"

#. type: TP
#: build/C/man3/string.3:103
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: build/C/man3/string.3:111
msgid ""
"Copy the string I<src> to I<dest>, returning a pointer to the start of "
"I<dest>."
msgstr ""
"文字列 I<src> を I<dest> にコピーし、 I<dest> の先頭へのポインターを返す。"

#. type: TP
#: build/C/man3/string.3:111
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"

#. type: Plain text
#: build/C/man3/string.3:117
msgid ""
"Calculate the length of the initial segment of the string I<s> which does "
"not contain any of bytes in the string I<reject>,"
msgstr ""
"文字列 I<s> の、文字列 I<reject> に含まれないバイトだけで構成される最初の部分"
"文字列の長さを計算する。"

#. type: TP
#: build/C/man3/string.3:117
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>"
msgstr "B<char *strdup(const char *>I<s>B<);>"

#. type: Plain text
#: build/C/man3/string.3:123
msgid ""
"Return a duplicate of the string I<s> in memory allocated using B<malloc>(3)."
msgstr "文字列 I<s> を、B<malloc>(3) を使って確保したメモリーに複製して返す。"

#. type: TP
#: build/C/man3/string.3:123
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>"
msgstr "B<char *strfry(char *>I<string>B<);>"

#. type: Plain text
#: build/C/man3/string.3:127
msgid "Randomly swap the characters in I<string>."
msgstr "I<string> 中の文字をランダムに並び替える。"

#. type: TP
#: build/C/man3/string.3:127
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>"
msgstr "B<size_t strlen(const char *>I<s>B<);>"

#. type: Plain text
#: build/C/man3/string.3:131
msgid "Return the length of the string I<s>."
msgstr "文字列 I<s> の長さを返す。"

#. type: TP
#: build/C/man3/string.3:131
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: build/C/man3/string.3:141
#, fuzzy
#| msgid ""
#| "Append at most I<n> characters from the string I<src> to the string "
#| "I<dest>, returning a pointer to I<dest>."
msgid ""
"Append at most I<n> bytes from the string I<src> to the string I<dest>, "
"returning a pointer to I<dest>."
msgstr ""
"文字列 I<src> の最大 I<n> 文字を文字列 I<dest> に追加し、I<dest> へのポイン"
"ターを返す。"

#. type: TP
#: build/C/man3/string.3:141
#, no-wrap
msgid "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"

#. type: Plain text
#: build/C/man3/string.3:149
msgid "Compare at most I<n> bytes of the strings I<s1> and I<s2>."
msgstr "文字列 I<s1> と I<s2> を最大 I<n> バイトまで比較する。"

#. type: TP
#: build/C/man3/string.3:149
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: build/C/man3/string.3:159
msgid ""
"Copy at most I<n> bytes from string I<src> to I<dest>, returning a pointer "
"to the start of I<dest>."
msgstr ""
"文字列 I<src> から I<dest> へ最大 I<n> バイトをコピーし、 I<dest> の先頭への"
"ポインターを返す。"

#. type: TP
#: build/C/man3/string.3:159
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"

#. type: Plain text
#: build/C/man3/string.3:165
msgid ""
"Return a pointer to the first occurrence in the string I<s> of one of the "
"bytes in the string I<accept>."
msgstr ""
"文字列 I<accept> に含まれるバイトのいずれかが、文字列 I<s> 内で最初に現れる位"
"置を特定する。"

#. type: TP
#: build/C/man3/string.3:165
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"

#. type: TP
#: build/C/man3/string.3:171
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"

#. type: Plain text
#: build/C/man3/string.3:177
msgid ""
"Extract the initial token in I<stringp> that is delimited by one of the "
"bytes in I<delim>."
msgstr ""
"文字列 I<s> から、I<delim> のいずれかのバイトで区切った最初のトークンを取り出"
"す。"

#. type: TP
#: build/C/man3/string.3:177
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"

#. type: Plain text
#: build/C/man3/string.3:183
msgid ""
"Calculate the length of the starting segment in the string I<s> that "
"consists entirely of bytes in I<accept>."
msgstr ""
"文字列 I<s> 中の I<accept> に含まれる文字だけで構成される最初の部分文字列の長"
"さを計算する。"

#. type: TP
#: build/C/man3/string.3:183
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"

#. type: Plain text
#: build/C/man3/string.3:190
msgid ""
"Find the first occurrence of the substring I<needle> in the string "
"I<haystack>, returning a pointer to the found substring."
msgstr ""
"部分文字列 I<needle> が文字列 I<haystack> 中 で最初に現れる位置を探し、その部"
"分文字列へのポインターを返す。"

#. type: TP
#: build/C/man3/string.3:190
#, no-wrap
msgid "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"
msgstr "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"

#. type: Plain text
#: build/C/man3/string.3:196
msgid ""
"Extract tokens from the string I<s> that are delimited by one of the bytes "
"in I<delim>."
msgstr ""
"文字列 I<s> から、I<delim> のいずれかのバイトで区切ったトークンを取り出す。"

#. type: TP
#: build/C/man3/string.3:196
#, no-wrap
msgid "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: build/C/man3/string.3:204
#, fuzzy
#| msgid ""
#| "Transforms I<src> to the current locale and copies the first I<n> "
#| "characters to I<dest>."
msgid ""
"Transforms I<src> to the current locale and copies the first I<n> bytes to "
"I<dest>."
msgstr ""
"I<src> を現在のロケールに変換し、最初の I<n> 文字を I<dest> にコピーする。"

#. type: Plain text
#: build/C/man3/string.3:208
#, fuzzy
#| msgid ""
#| "The string functions perform string operations on null-terminated "
#| "strings.  See the individual man pages for descriptions of each function."
msgid ""
"The string functions perform operations on null-terminated strings.  See the "
"individual man pages for descriptions of each function."
msgstr ""
"文字列関数は、ヌル終端された文字列に 対して、文字列操作を実行する。 それぞれ"
"の関数の説明については個々のmanページを見よ。"

#. type: Plain text
#: build/C/man3/string.3:233
msgid ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"
msgstr ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"

#. type: TH
#: build/C/man3/strlen.3:30
#, no-wrap
msgid "STRLEN"
msgstr "STRLEN"

#. type: Plain text
#: build/C/man3/strlen.3:33
msgid "strlen - calculate the length of a string"
msgstr "strlen - 文字列の長さを計算する"

#. type: Plain text
#: build/C/man3/strlen.3:38
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>\n"
msgstr "B<size_t strlen(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/strlen.3:45
#, fuzzy
#| msgid ""
#| "The B<strlen>()  function calculates the length of the string I<s>, "
#| "excluding the terminating null byte (\\(aq\\e0\\(aq)."
msgid ""
"The B<strlen>()  function calculates the length of the string pointed to by "
"I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""
"B<strlen>()  関数は文字列 I<s> の長さを計算する。 このとき、終端ヌルバイト "
"(\\(aq\\e0\\(aq) は計算に含まれない。"

#. type: Plain text
#: build/C/man3/strlen.3:50
#, fuzzy
#| msgid ""
#| "The B<strlen>()  function returns the number of bytes in the string I<s>."
msgid ""
"The B<strlen>()  function returns the number of bytes in the string pointed "
"to by I<s>."
msgstr "B<strlen>() 関数は文字列 I<s> のバイト数を返す。"

#. type: tbl table
#: build/C/man3/strlen.3:60
#, fuzzy, no-wrap
#| msgid "B<strlen>(3)"
msgid "B<strlen>()"
msgstr "B<strlen>(3)"

#. type: Plain text
#: build/C/man3/strlen.3:64
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:69
msgid "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"
msgstr "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"

#. type: TH
#: build/C/man3/strnlen.3:13
#, no-wrap
msgid "STRNLEN"
msgstr "STRNLEN"

#. type: Plain text
#: build/C/man3/strnlen.3:16
msgid "strnlen - determine the length of a fixed-size string"
msgstr "strnlen - 固定長の文字列の長さを調べる"

#. type: Plain text
#: build/C/man3/strnlen.3:21
#, no-wrap
msgid "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"
msgstr "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"

#. type: Plain text
#: build/C/man3/strnlen.3:29
msgid "B<strnlen>():"
msgstr "B<strnlen>():"

#. type: Plain text
#: build/C/man3/strnlen.3:58
#, fuzzy
#| msgid ""
#| "The B<strnlen>()  function returns the number of bytes in the string "
#| "pointed to by I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq), "
#| "but at most I<maxlen>.  In doing this, B<strnlen>()  looks only at the "
#| "first I<maxlen> bytes at I<s> and never beyond I<s+maxlen>."
msgid ""
"The B<strnlen>()  function returns the number of bytes in the string pointed "
"to by I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq), but at "
"most I<maxlen>.  In doing this, B<strnlen>()  looks only at the first "
"I<maxlen> characters in the string pointed to by I<s> and never beyond "
"I<s[maxlen-1]>."
msgstr ""
"B<strnlen>() 関数は I<s> が指す文字列の長さをバイト数で返す。 長さには\n"
"終端のヌルバイト (\\(aq\\e0\\(aq) は含まない。 また長さは最大で\n"
"I<maxlen> までであり、 B<strnlen>() は I<s> の最初の I<maxlen> バイト\n"
"のみを検査し I<s+maxlen> より先を検査することはない。"

#. type: Plain text
#: build/C/man3/strnlen.3:71
#, fuzzy
#| msgid ""
#| "The B<strnlen>()  function returns I<strlen(s)>, if that is less than "
#| "I<maxlen>, or I<maxlen> if there is no null byte (\\(aq\\e0\\(aq) among "
#| "the first I<maxlen> bytes pointed to by I<s>."
msgid ""
"The B<strnlen>()  function returns I<strlen(s)>, if that is less than "
"I<maxlen>, or I<maxlen> if there is no null terminating (\\(aq\\e0\\(aq) "
"among the first I<maxlen> characters pointed to by I<s>."
msgstr ""
"B<strnlen>() 関数は I<maxlen> 以下ならば I<strlen(s)> と同じ値を返す。\n"
"I<s> の指す文字列が最大 I<maxlen> バイトまでにヌルバイト\n"
"(\\(aq\\e0\\(aq) 文字を含まない場合には I<maxlen> を返す。"

#. type: tbl table
#: build/C/man3/strnlen.3:81
#, fuzzy, no-wrap
#| msgid "B<strnlen>():"
msgid "B<strnlen>()"
msgstr "B<strnlen>():"

#. type: Plain text
#: build/C/man3/strnlen.3:85
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: build/C/man3/strnlen.3:87
msgid "B<strlen>(3)"
msgstr "B<strlen>(3)"

#. type: TH
#: build/C/man3/strpbrk.3:30
#, no-wrap
msgid "STRPBRK"
msgstr "STRPBRK"

#. type: TH
#: build/C/man3/strpbrk.3:30 build/C/man3/strspn.3:30
#, fuzzy, no-wrap
#| msgid "2015-01-10"
msgid "2015-08-08"
msgstr "2015-01-10"

#. type: Plain text
#: build/C/man3/strpbrk.3:33
msgid "strpbrk - search a string for any of a set of bytes"
msgstr "strpbrk - 文字列からバイト集合に含まれるバイトを探す"

#. type: Plain text
#: build/C/man3/strpbrk.3:38
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: build/C/man3/strpbrk.3:47
msgid ""
"The B<strpbrk>()  function locates the first occurrence in the string I<s> "
"of any of the bytes in the string I<accept>."
msgstr ""
"B<strpbrk>() 関数は、文字列 I<accept> に含まれるバイトのいずれかが、\n"
"文字列 I<s> 内で最初に現れる位置を特定する。"

#. type: Plain text
#: build/C/man3/strpbrk.3:56
msgid ""
"The B<strpbrk>()  function returns a pointer to the byte in I<s> that "
"matches one of the bytes in I<accept>, or NULL if no such byte is found."
msgstr ""
"B<strpbrk>() 関数は、I<s> 内のバイトで、I<accept> に含まれる\n"
"バイトのいずれかに一致したバイトへのポインターを返す。\n"
"I<accept> に含まれるバイトが見つからなかった場合は NULL を返す。"

#. type: tbl table
#: build/C/man3/strpbrk.3:66
#, fuzzy, no-wrap
#| msgid "B<strtok>()"
msgid "B<strpbrk>()"
msgstr "B<strtok>()"

#. type: Plain text
#: build/C/man3/strpbrk.3:81
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"

#. type: TH
#: build/C/man3/strsep.3:33
#, no-wrap
msgid "STRSEP"
msgstr "STRSEP"

#. type: Plain text
#: build/C/man3/strsep.3:36
msgid "strsep - extract token from string"
msgstr "strsep - 文字列からトークンを取り出す"

#. type: Plain text
#: build/C/man3/strsep.3:41
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/strsep.3:53
#, no-wrap
msgid ""
"B<strsep>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:76
msgid ""
"If I<*stringp> is NULL, the B<strsep>()  function returns NULL and does "
"nothing else.  Otherwise, this function finds the first token in the string "
"I<*stringp>, that is delimited by one of the bytes in the string I<delim>.  "
"This token is terminated by overwriting the delimiter with a null byte (\\(aq"
"\\e0\\(aq), and I<*stringp> is updated to point past the token.  In case no "
"delimiter was found, the token is taken to be the entire string I<*stringp>, "
"and I<*stringp> is made NULL."
msgstr ""
"I<*stringp> が NULL の場合、 B<strsep>()  関数は何もせずに NULL を返す。 さも"
"なければ、文字列 I<stringp> を I<delim> に含まれるいずれかのバイトで区切った"
"トークンのうち最初のものを返す。 トークンは、区切り文字をヌルバイト (\\(aq"
"\\e0\\(aq) で上書きすることで 終端される。 I<*stringp> は切り出されたトークン"
"の次の位置を示すように更新される。 区切り文字が見つからない場合、I<*stringp> "
"文字列全体がトークンとして 扱われ、I<*stringp> は NULL となる。"

#. type: Plain text
#: build/C/man3/strsep.3:82
msgid ""
"The B<strsep>()  function returns a pointer to the token, that is, it "
"returns the original value of I<*stringp>."
msgstr ""
"B<strsep>()  関数は、トークンへのポインターを返す。 つまり、元の I<*stringp> "
"の値を返す。"

#. type: tbl table
#: build/C/man3/strsep.3:92
#, fuzzy, no-wrap
#| msgid "B<strstr>(3)"
msgid "B<strsep>()"
msgstr "B<strstr>(3)"

#. type: Plain text
#: build/C/man3/strsep.3:96
msgid "4.4BSD."
msgstr "4.4BSD."

#. type: Plain text
#: build/C/man3/strsep.3:105
msgid ""
"The B<strsep>()  function was introduced as a replacement for B<strtok>(3), "
"since the latter cannot handle empty fields.  However, B<strtok>(3)  "
"conforms to C89/C99 and hence is more portable."
msgstr ""
"B<strsep>()  関数は、 B<strtok>(3)  関数が空のフィールドを 扱えないために、そ"
"の代替品として導入された。 しかしながら、 B<strtok>(3)  関数は C89/C99 に準拠"
"しており、より移植性がある。"

#. type: Plain text
#: build/C/man3/strsep.3:108
msgid "Be cautious when using this function.  If you do use it, note that:"
msgstr ""
"この関数を使う時は注意すること。 もし使うなら、以下のことに注意すること。"

#. type: Plain text
#: build/C/man3/strsep.3:110
msgid "This function modifies its first argument."
msgstr "この関数は最初の引数を変更する。"

#. type: Plain text
#: build/C/man3/strsep.3:112
msgid "This function cannot be used on constant strings."
msgstr "この関数は定数文字列には使えない。"

#. type: Plain text
#: build/C/man3/strsep.3:114
msgid "The identity of the delimiting character is lost."
msgstr "区切り文字自体は失われてしまう。"

#. type: Plain text
#: build/C/man3/strsep.3:124
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"

#. type: TH
#: build/C/man3/strsignal.3:31
#, no-wrap
msgid "STRSIGNAL"
msgstr "STRSIGNAL"

#. type: Plain text
#: build/C/man3/strsignal.3:34
#, fuzzy
#| msgid "strsignal - return string describing signal"
msgid ""
"strsignal, sigdescr_np, sigdescr_np, sys_siglist - return string describing "
"signal"
msgstr "strsignal - シグナルを説明する文字列を返す"

#. type: Plain text
#: build/C/man3/strsignal.3:41
#, no-wrap
msgid ""
"B<char *strsignal(int >I<sig>B<);>\n"
"B<char *sigdescr_np(int >I<sig>B<);>\n"
"B<char *sigabbrev_np(int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:43
#, no-wrap
msgid "B<extern const char * const >I<sys_siglist>B<[];>\n"
msgstr "B<extern const char * const >I<sys_siglist>B<[];>\n"

#. type: Plain text
#: build/C/man3/strsignal.3:52
msgid "B<sigabbrev_np>(), B<sigdescr_np>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:59
msgid "B<strsignal>():"
msgstr "B<strsignal>():"

#. type: TP
#: build/C/man3/strsignal.3:61
#, fuzzy, no-wrap
#| msgid "Before glibc 2.10:"
msgid "From glibc 2.10 to 2.31:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/strsignal.3:74
#, no-wrap
msgid ""
"I<sys_siglist>:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:89
#, fuzzy
#| msgid ""
#| "The B<strsignal>()  function returns a string describing the signal "
#| "number passed in the argument I<sig>.  The string can be used only until "
#| "the next call to B<strsignal>()."
msgid ""
"The B<strsignal>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  The string can be used only until the next "
"call to B<strsignal>().  The string returned by B<strsignal>()  is localized "
"according to the B<LC_MESSAGES> category in the current locale."
msgstr ""
"B<strsignal>()  関数は、引数 I<sig> で渡されたシグナル番号を 説明する文字列を"
"返す。 文字列は、次の B<strsignal>()  が呼ばれるまでの間だけ使用できる。"

#. type: Plain text
#: build/C/man3/strsignal.3:98
#, fuzzy
#| msgid ""
#| "The B<strsignal>()  function returns a string describing the signal "
#| "number passed in the argument I<sig>.  The string can be used only until "
#| "the next call to B<strsignal>()."
msgid ""
"The B<sigdescr_np>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  Unlike B<strsignal>()  this string is not "
"influenced by the current locale."
msgstr ""
"B<strsignal>()  関数は、引数 I<sig> で渡されたシグナル番号を 説明する文字列を"
"返す。 文字列は、次の B<strsignal>()  が呼ばれるまでの間だけ使用できる。"

#. type: Plain text
#: build/C/man3/strsignal.3:106
msgid ""
"The B<sigabbrev_np>()  function returns the abbreviated name of the signal, "
"I<sig>.  For example, given the value B<SIGINT>, it returns the string \"INT"
"\"."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:116
#, fuzzy
#| msgid ""
#| "The array I<sys_siglist> holds the signal description strings indexed by "
#| "signal number.  The B<strsignal>()  function should be used if possible "
#| "instead of this array."
msgid ""
"The (deprecated) array I<sys_siglist> holds the signal description strings "
"indexed by signal number.  The B<strsignal>()  or the B<sigdescr_np>()  "
"function should be used instead of this array; see also VERSIONS."
msgstr ""
"配列 I<sys_siglist> はシグナルを説明する文字列を保持しており、 配列へのアクセ"
"スにはシグナル番号を添え字として用いる事ができる。 出来るだけこの配列の代わり"
"に B<strsignal>()  関数を 使うべきである。"

#. type: Plain text
#: build/C/man3/strsignal.3:123
msgid ""
"The B<strsignal>()  function returns the appropriate description string, or "
"an unknown signal message if the signal number is invalid.  On some systems "
"(but not on Linux), NULL may instead be returned for an invalid signal "
"number."
msgstr ""
"B<strsignal>()  関数は、シグナルの適切な説明を返す。 もしシグナル番号が不正な"
"場合は、未知のシグナル (unknown signal) を示す メッセージを返す。 (Linux はそ"
"うではないが)不正なシグナル番号に対して、 NULL を返すシステムもある。"

#. type: Plain text
#: build/C/man3/strsignal.3:132
#, fuzzy
#| msgid ""
#| "The B<strsignal>()  function returns the appropriate description string, "
#| "or an unknown signal message if the signal number is invalid.  On some "
#| "systems (but not on Linux), NULL may instead be returned for an invalid "
#| "signal number."
msgid ""
"The B<sigdescr_np>()  and B<sigdabbrev_np>()  functions return the "
"appropriate description string.  The returned string is statically allocated "
"and valid for the lifetime of the program.  These functions return NULL for "
"an invalid signal number."
msgstr ""
"B<strsignal>()  関数は、シグナルの適切な説明を返す。 もしシグナル番号が不正な"
"場合は、未知のシグナル (unknown signal) を示す メッセージを返す。 (Linux はそ"
"うではないが)不正なシグナル番号に対して、 NULL を返すシステムもある。"

#. type: Plain text
#: build/C/man3/strsignal.3:137
#, fuzzy
#| msgid "The B<strerror_l>()  function first appeared in glibc 2.6."
msgid "B<sigdescr_np>()  and B<sigdabbrev_np>()  first appeared in glibc 2.32."
msgstr "B<strerror_l>() 関数は glibc 2.6 で初めて登場した。"

#.  glibc commit b1ccfc061feee9ce616444ded8e1cd5acf9fa97f
#. type: Plain text
#: build/C/man3/strsignal.3:143
msgid ""
"Starting with version 2.32, the I<sys_siglist> symbol is no longer exported "
"by glibc."
msgstr ""

#. type: tbl table
#: build/C/man3/strsignal.3:153
#, fuzzy, no-wrap
#| msgid "B<strsignal>():"
msgid "B<strsignal>()"
msgstr "B<strsignal>():"

#. type: tbl table
#: build/C/man3/strsignal.3:153
#, no-wrap
msgid "MT-Unsafe race:strsignal locale"
msgstr ""

#. type: tbl table
#: build/C/man3/strsignal.3:157
#, no-wrap
msgid ""
"B<sigdescr_np>(),\n"
"B<sigabbrev_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:164
#, fuzzy
#| msgid "POSIX.1-2008.  Present on Solaris and the BSDs."
msgid "B<strsignal>(): POSIX.1-2008.  Present on Solaris and the BSDs."
msgstr "POSIX.1-2008.  Solaris と BSD 系にも存在する。"

#. type: Plain text
#: build/C/man3/strsignal.3:169
msgid "B<sigdescr_np>()  and B<sigdabbrev_np>()  are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:172
msgid "I<sys_siglist> is nonstandard, but present on many other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:177
msgid ""
"B<sigdescr_np>()  and B<sigdabbrev_np>()  are thread-safe and async-signal-"
"safe."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:180
msgid "B<psignal>(3), B<strerror>(3)"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: TH
#: build/C/man3/strspn.3:30
#, no-wrap
msgid "STRSPN"
msgstr "STRSPN"

#. type: Plain text
#: build/C/man3/strspn.3:33
msgid "strspn, strcspn - get length of a prefix substring"
msgstr "strspn, strcspn - プレフィックス部分文字列の長さを返す"

#. type: Plain text
#: build/C/man3/strspn.3:38
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: build/C/man3/strspn.3:40
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"

#. type: Plain text
#: build/C/man3/strspn.3:49
msgid ""
"The B<strspn>()  function calculates the length (in bytes) of the initial "
"segment of I<s> which consists entirely of bytes in I<accept>."
msgstr ""
"B<strspn>() 関数は、 I<s> から、I<accept> に含まれる文字だけで\n"
"構成される最初の部分文字列を探し、\n"
"その部分の (バイト単位の) 長さを計算する。"

#. type: Plain text
#: build/C/man3/strspn.3:57
msgid ""
"The B<strcspn>()  function calculates the length of the initial segment of "
"I<s> which consists entirely of bytes not in I<reject>."
msgstr ""
"B<strcspn>() 関数は、 I<s> から、I<reject> に含まれない文字だけで\n"
"構成される最初の部分文字列を探し、\n"
"その部分の (バイト単位の) 長さを計算する。"

#. type: Plain text
#: build/C/man3/strspn.3:66
msgid ""
"The B<strspn>()  function returns the number of bytes in the initial segment "
"of I<s> which consist only of bytes from I<accept>."
msgstr ""
"B<strspn>() 関数は、 I<s> 内の、I<accept> からの文字だけで\n"
"構成される最初の部分文字列のバイト数を返す。"

#. type: Plain text
#: build/C/man3/strspn.3:74
msgid ""
"The B<strcspn>()  function returns the number of bytes in the initial "
"segment of I<s> which are not in the string I<reject>."
msgstr ""
"B<strcspn>() 関数は、I<s> 内の、文字列 I<reject> に含まれない\n"
"文字だけで構成される最初の部分文字列のバイト数を返す。"

#. type: tbl table
#: build/C/man3/strspn.3:85
#, fuzzy, no-wrap
#| msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgid ""
"B<strspn>(),\n"
"B<strcspn>()"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: Plain text
#: build/C/man3/strspn.3:101
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"

#. type: TH
#: build/C/man3/strstr.3:33
#, no-wrap
msgid "STRSTR"
msgstr "STRSTR"

#. type: Plain text
#: build/C/man3/strstr.3:36
msgid "strstr, strcasestr - locate a substring"
msgstr "strstr, strcasestr - 部分文字列の位置を示す"

#. type: Plain text
#: build/C/man3/strstr.3:41
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: build/C/man3/strstr.3:43
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/strstr.3:47
#, no-wrap
msgid "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: build/C/man3/strstr.3:56
msgid ""
"The B<strstr>()  function finds the first occurrence of the substring "
"I<needle> in the string I<haystack>.  The terminating null bytes (\\(aq"
"\\e0\\(aq) are not compared."
msgstr ""
"B<strstr>()  関数は、部分文字列 I<needle> が文字列 I<haystack> 中 で最初に現"
"れる位置を見つける。 文字列を終端ヌルバイト (\\(aq\\e0\\(aq) は比較されない。"

#. type: Plain text
#: build/C/man3/strstr.3:62
msgid ""
"The B<strcasestr>()  function is like B<strstr>(), but ignores the case of "
"both arguments."
msgstr ""
"B<strcasestr>()  関数は B<strstr>()  関数と同様だが、 両方の引数に対して大文"
"字小文字を無視する。"

#. type: Plain text
#: build/C/man3/strstr.3:65
msgid ""
"These functions return a pointer to the beginning of the located substring, "
"or NULL if the substring is not found."
msgstr ""
"これらの関数は、見つかった部分文字列の開始を指すポインターを返し、 もし部分文"
"字列が見つからない場合は NULL を返す。"

#. type: tbl table
#: build/C/man3/strstr.3:75
#, fuzzy, no-wrap
#| msgid "B<strstr>(3)"
msgid "B<strstr>()"
msgstr "B<strstr>(3)"

#. type: tbl table
#: build/C/man3/strstr.3:78
#, fuzzy, no-wrap
#| msgid "B<strstr>(3)"
msgid "B<strcasestr>()"
msgstr "B<strstr>(3)"

#. type: Plain text
#: build/C/man3/strstr.3:83
#, fuzzy
#| msgid "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."
msgid "B<strstr>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."

#. type: Plain text
#: build/C/man3/strstr.3:87
#, fuzzy
#| msgid ""
#| "The GNU-specific B<strerror_r>()  function is a nonstandard extension."
msgid "The B<strcasestr>()  function is a nonstandard extension."
msgstr "GNU 仕様の B<strerror_r>()  関数は非標準の拡張である。"

#. type: Plain text
#: build/C/man3/strstr.3:100
msgid ""
"B<index>(3), B<memchr>(3), B<memmem>(3), B<rindex>(3), B<strcasecmp>(3), "
"B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), "
"B<strtok>(3), B<wcsstr>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<memmem>(3), B<rindex>(3), B<strcasecmp>(3), "
"B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), "
"B<strtok>(3), B<wcsstr>(3)"

#. type: TH
#: build/C/man3/strtok.3:32
#, no-wrap
msgid "STRTOK"
msgstr "STRTOK"

#. type: Plain text
#: build/C/man3/strtok.3:35
msgid "strtok, strtok_r - extract tokens from strings"
msgstr "strtok, strtok_r - 文字列からトークンを取り出す"

#. type: Plain text
#: build/C/man3/strtok.3:40
#, no-wrap
msgid "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/strtok.3:42
#, no-wrap
msgid "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"
msgstr "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"

#. type: Plain text
#: build/C/man3/strtok.3:53
#, fuzzy, no-wrap
#| msgid "B<strtok_r>(): _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgid ""
"B<strtok_r>():\n"
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<strtok_r>(): _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/strtok.3:66
#, fuzzy
#| msgid ""
#| "The B<strtok>()  function breaks a string into a sequence of zero or more "
#| "nonempty tokens.  On the first call to B<strtok>()  the string to be "
#| "parsed should be specified in I<str>.  In each subsequent call that "
#| "should parse the same string, I<str> must be NULL."
msgid ""
"The B<strtok>()  function breaks a string into a sequence of zero or more "
"nonempty tokens.  On the first call to B<strtok>(), the string to be parsed "
"should be specified in I<str>.  In each subsequent call that should parse "
"the same string, I<str> must be NULL."
msgstr ""
"B<strtok>()  関数は文字列を 0 個以上の空でないトークンの列に分割する。 "
"B<strtok>()  を最初に呼び出す際には、解析対象の文字列を I<str> に 指定する。"
"同じ文字列の解析を行うその後の呼び出しでは、 I<str> は NULL にしなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/strtok.3:75
msgid ""
"The I<delim> argument specifies a set of bytes that delimit the tokens in "
"the parsed string.  The caller may specify different strings in I<delim> in "
"successive calls that parse the same string."
msgstr ""
"I<delim> 引き数には、解析対象の文字列をトークンに区切るのに使用する\n"
"バイト集合を指定する。同じ文字列を解析する一連の呼び出しにおいて、\n"
"I<delim> に違う文字列を指定してもよい。"

#. type: Plain text
#: build/C/man3/strtok.3:84
msgid ""
"Each call to B<strtok>()  returns a pointer to a null-terminated string "
"containing the next token.  This string does not include the delimiting "
"byte.  If no more tokens are found, B<strtok>()  returns NULL."
msgstr ""
"B<strtok>() のそれぞれの呼び出しでは、次のトークンを格納したヌル終端\n"
"された文字列へのポインターが返される。この文字列には区切りバイトは含まれ\n"
"ない。これ以上トークンが見つからなかった場合には、NULL が返される。"

#. type: Plain text
#: build/C/man3/strtok.3:104
msgid ""
"A sequence of calls to B<strtok>()  that operate on the same string "
"maintains a pointer that determines the point from which to start searching "
"for the next token.  The first call to B<strtok>()  sets this pointer to "
"point to the first byte of the string.  The start of the next token is "
"determined by scanning forward for the next nondelimiter byte in I<str>.  If "
"such a byte is found, it is taken as the start of the next token.  If no "
"such byte is found, then there are no more tokens, and B<strtok>()  returns "
"NULL.  (A string that is empty or that contains only delimiters will thus "
"cause B<strtok>()  to return NULL on the first call.)"
msgstr ""
"同じ文字列に対して操作を行う B<strtok>() を連続して呼び出す場合、 次のトーク"
"ンを探し始める位置を決めるためのポインターが保持される。 最初の B<strtok> の"
"呼び出しでは、 このポインターは対象の文字列の最初のバイトにセットされる。 次"
"のトークンの先頭は、 I<str> 内で次の区切りバイト以外のバイトを前方に検索して"
"決定される。 区切りバイト以外のバイトが見つからなかった場合は、 トークンはこ"
"れ以上なく、 B<strtok>() は NULL を返す (したがって、 空の文字列や区切りバイ"
"トだけを含む文字列の場合には、 最初の B<strtok>() の呼び出しで NULL が返るこ"
"とになる)。"

#. type: Plain text
#: build/C/man3/strtok.3:117
msgid ""
"The end of each token is found by scanning forward until either the next "
"delimiter byte is found or until the terminating null byte (\\(aq\\e0\\(aq) "
"is encountered.  If a delimiter byte is found, it is overwritten with a null "
"byte to terminate the current token, and B<strtok>()  saves a pointer to the "
"following byte; that pointer will be used as the starting point when "
"searching for the next token.  In this case, B<strtok>()  returns a pointer "
"to the start of the found token."
msgstr ""
"各トークンの末尾は、次の区切りバイトが見つかるか、終端のヌルバイト (\\(aq"
"\\e0\\(aq) に達するまで文字列を前方に検索することで見つかる。 区切りバイトが"
"見つかった場合には、 現在のトークンの終わりを示すために、 見つかった区切りバ"
"イトがヌルバイトで上書きされ、 B<strtok>() はポインターを次のバイトに設定す"
"る。 このポインターは、次のトークンを検索する際の開始点として使用される。 こ"
"の場合、 B<strtok>() は見つかったトークンの先頭へのポインターを返す。"

#. type: Plain text
#: build/C/man3/strtok.3:131
msgid ""
"From the above description, it follows that a sequence of two or more "
"contiguous delimiter bytes in the parsed string is considered to be a single "
"delimiter, and that delimiter bytes at the start or end of the string are "
"ignored.  Put another way: the tokens returned by B<strtok>()  are always "
"nonempty strings.  Thus, for example, given the string \"I<aaa;;bbb,>\", "
"successive calls to B<strtok>()  that specify the delimiter string \"I<;,>\" "
"would return the strings \"I<aaa>\" and \"I<bbb>\", and then a null pointer."
msgstr ""
"上記の説明の通り、 解析対象の文字列に 2 つ以上の区切りバイトが連続している場"
"合には、 一つの区切りバイトとみなされ、 文字列の先頭や末尾にある区切りバイト"
"は無視される。 言い換えると、 B<strtok>() が返すトークンは必ず空でない文字列"
"となる。 したがって、例えば \"I<aaa;;bbb,>\" という文字列が与えられたとする"
"と、 区切り文字列 \"I<;,>\" を指定した一連の B<strtok>() の呼び出しでは、 "
"\"I<aaa>\" と I<bbb>\" が返り、その次にヌルポインターが返る。"

#. type: Plain text
#: build/C/man3/strtok.3:144
#, fuzzy
#| msgid ""
#| "The B<strtok_r>()  function is a reentrant version B<strtok>().  The "
#| "I<saveptr> argument is a pointer to a I<char\\ *> variable that is used "
#| "internally by B<strtok_r>()  in order to maintain context between "
#| "successive calls that parse the same string."
msgid ""
"The B<strtok_r>()  function is a reentrant version of B<strtok>().  The "
"I<saveptr> argument is a pointer to a I<char\\ *> variable that is used "
"internally by B<strtok_r>()  in order to maintain context between successive "
"calls that parse the same string."
msgstr ""
"B<strtok_r>()  関数は B<strtok>()  のリエントラント版である。 I<saveptr> 引き"
"数は I<char\\ *> 変数へのポインターであり、 同じ文字列の解析を行う "
"B<strtok_r>()  の呼び出し間で処理状況を保存するために B<strtok_r>()  内部で使"
"用される。"

#. type: Plain text
#: build/C/man3/strtok.3:157
#, fuzzy
#| msgid ""
#| "On the first call to B<strtok_r>(), I<str> should point to the string to "
#| "be parsed, and the value of I<saveptr> is ignored.  In subsequent calls, "
#| "I<str> should be NULL, and I<saveptr> should be unchanged since the "
#| "previous call."
msgid ""
"On the first call to B<strtok_r>(), I<str> should point to the string to be "
"parsed, and the value of I<*saveptr> is ignored (but see NOTES).  In "
"subsequent calls, I<str> should be NULL, and I<saveptr> (and the buffer that "
"it points to)  should be unchanged since the previous call."
msgstr ""
"B<strtok_r>()  を最初に呼び出す際には、 I<str> は解析対象の文字列を指していな"
"ければならず、 I<saveptr> の値は無視される。それ以降の呼び出しでは、 I<str> "
"は NULL とし、 I<saveptr> は前回の呼び出し以降変更しないようにしなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/strtok.3:163
msgid ""
"Different strings may be parsed concurrently using sequences of calls to "
"B<strtok_r>()  that specify different I<saveptr> arguments."
msgstr ""
"B<strtok_r>()  の呼び出し時に異なる I<saveptr> 引き数を指定することで、 異な"
"る文字列の解析を同時に行うことができる。"

#. type: Plain text
#: build/C/man3/strtok.3:170
msgid ""
"The B<strtok>()  and B<strtok_r>()  functions return a pointer to the next "
"token, or NULL if there are no more tokens."
msgstr ""
"B<strtok>()  と B<strtok_r>()  は次のトークンへのポインターか、 トークンがな"
"ければ NULL を返す。"

#. type: TP
#: build/C/man3/strtok.3:180 build/C/man3/strtok.3:186
#, no-wrap
msgid "B<strtok>()"
msgstr "B<strtok>()"

#. type: tbl table
#: build/C/man3/strtok.3:180
#, no-wrap
msgid "MT-Unsafe race:strtok"
msgstr ""

#. type: TP
#: build/C/man3/strtok.3:183 build/C/man3/strtok.3:189
#, no-wrap
msgid "B<strtok_r>()"
msgstr "B<strtok_r>()"

#. type: Plain text
#: build/C/man3/strtok.3:192
#, fuzzy
#| msgid "POSIX.1-2008."
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2008."

#.  Tru64, according to its manual page
#. type: Plain text
#: build/C/man3/strtok.3:200
msgid ""
"On some implementations, I<*saveptr> is required to be NULL on the first "
"call to B<strtok_r>()  that is being used to parse I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:203
msgid "Be cautious when using these functions.  If you do use them, note that:"
msgstr ""
"これらの関数を使うのは慎重に吟味すること。 使用する場合は、以下の点に注意が必"
"要である。"

#. type: Plain text
#: build/C/man3/strtok.3:205
msgid "These functions modify their first argument."
msgstr "これらの関数はその最初の引数を変更する。"

#. type: Plain text
#: build/C/man3/strtok.3:207
msgid "These functions cannot be used on constant strings."
msgstr "これらの関数は const な文字列では使えない。"

#. type: Plain text
#: build/C/man3/strtok.3:209
msgid "The identity of the delimiting byte is lost."
msgstr "区切りバイト自体は失われてしまう。"

#. type: Plain text
#: build/C/man3/strtok.3:216
msgid ""
"The B<strtok>()  function uses a static buffer while parsing, so it's not "
"thread safe.  Use B<strtok_r>()  if this matters to you."
msgstr ""
"B<strtok>()  関数は文字列の解析に静的バッファーを用いるので、スレッドセーフで"
"ない。 これが問題になる場合は B<strtok_r>()  を用いること。"

#. type: Plain text
#: build/C/man3/strtok.3:225
msgid ""
"The program below uses nested loops that employ B<strtok_r>()  to break a "
"string into a two-level hierarchy of tokens.  The first command-line "
"argument specifies the string to be parsed.  The second argument specifies "
"the delimiter byte(s)  to be used to separate that string into \"major\" "
"tokens.  The third argument specifies the delimiter byte(s)  to be used to "
"separate the \"major\" tokens into subtokens."
msgstr ""
"以下のプログラムは、 B<strtok_r>() を利用するループを入れ子にして使用し、\n"
"文字列を 2 階層のトークンに分割するものである。 1番目のコマンドライン\n"
"引き数には、解析対象の文字列を指定する。 2 番目の引き数には、文字列を\n"
"「大きな」トークンに分割するために 使用する区切りバイトを指定する。\n"
"3 番目の引き数には、「大きな」トークンを細かく分割するために使用する\n"
"区切りバイトを指定する。"

#. type: Plain text
#: build/C/man3/strtok.3:227
msgid "An example of the output produced by this program is the following:"
msgstr "このプログラムの出力例を以下に示す。"

#. type: Plain text
#: build/C/man3/strtok.3:239
#, no-wrap
msgid ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"
msgstr ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"

#. type: Plain text
#: build/C/man3/strtok.3:247
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/strtok.3:253
#, fuzzy, no-wrap
#| msgid ""
#| "int\n"
#| "main(int argc, char *argv[])\n"
#| "{\n"
#| "    char *str1, *str2, *token, *subtoken;\n"
#| "    char *saveptr1, *saveptr2;\n"
#| "    int j;\n"
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
"    int j;\n"

#. type: Plain text
#: build/C/man3/strtok.3:259
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/strtok.3:265
#, fuzzy, no-wrap
#| msgid ""
#| "    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
#| "        token = strtok_r(str1, argv[2], &saveptr1);\n"
#| "        if (token == NULL)\n"
#| "            break;\n"
#| "        printf(\"%d: %s\\en\", j, token);\n"
msgid ""
"    for (int j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"
msgstr ""
"    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"

#. type: Plain text
#: build/C/man3/strtok.3:273
#, no-wrap
msgid ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"
msgstr ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/strtok.3:282
msgid ""
"Another example program using B<strtok>()  can be found in "
"B<getaddrinfo_a>(3)."
msgstr "B<strtok>()  を使った別のプログラム例が B<getaddrinfo_a>(3)  にある。"

#. type: Plain text
#: build/C/man3/strtok.3:293
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"

#. type: TH
#: build/C/man3/strverscmp.3:26
#, no-wrap
msgid "STRVERSCMP"
msgstr "STRVERSCMP"

#. type: Plain text
#: build/C/man3/strverscmp.3:29
msgid "strverscmp - compare two version strings"
msgstr "strverscmp - 2つのバージョン文字列を比較する"

#. type: Plain text
#: build/C/man3/strverscmp.3:35
#, no-wrap
msgid "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#.  classical solution: "rename jan jan0 jan?"
#. type: Plain text
#: build/C/man3/strverscmp.3:52
msgid ""
"Often one has files I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  and it "
"feels wrong when B<ls>(1)  orders them I<jan1>, I<jan10>, ..., I<jan2>, ..., "
"I<jan9>.  In order to rectify this, GNU introduced the I<-v> option to "
"B<ls>(1), which is implemented using B<versionsort>(3), which again uses "
"B<strverscmp>()."
msgstr ""
"I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  といった名前のファイルがある状"
"況はよくあるが、 B<ls>(1)  を実行したときに I<jan1>, I<jan10>, ..., "
"I<jan2>, ..., I<jan9> の順番で表示されるのには違和感がある。 これを修正するた"
"めに、GNU は B<ls>(1)  に I<-v> オプションを導入した。 この機能は "
"B<versionsort>(3)  を使って実装されているが、この中で B<strverscmp>()  が使用"
"されている。"

#. type: Plain text
#: build/C/man3/strverscmp.3:63
msgid ""
"Thus, the task of B<strverscmp>()  is to compare two strings and find the "
"\"right\" order, while B<strcmp>(3)  finds only the lexicographic order.  "
"This function does not use the locale category B<LC_COLLATE>, so is meant "
"mostly for situations where the strings are expected to be in ASCII."
msgstr ""
"このように B<strverscmp>()  の役目は2つの文字列を比較して「正しい」順序を探す"
"ことである。 これに対して B<strcmp>(3)  は辞書順だけで比較した結果を返す。 関"
"数 B<strverscmp>()  はロケールのカテゴリーである B<LC_COLLATE> を使用しな"
"い。 このことから、この関数が主にアスキー文字から成る文字列を 想定しているこ"
"とが分かる。"

#. type: Plain text
#: build/C/man3/strverscmp.3:81
msgid ""
"What this function does is the following.  If both strings are equal, return "
"0.  Otherwise, find the position between two bytes with the property that "
"before it both strings are equal, while directly after it there is a "
"difference.  Find the largest consecutive digit strings containing (or "
"starting at, or ending at) this position.  If one or both of these is empty, "
"then return what B<strcmp>(3)  would have returned (numerical ordering of "
"byte values).  Otherwise, compare both digit strings numerically, where "
"digit strings with one or more leading zeros are interpreted as if they have "
"a decimal point in front (so that in particular digit strings with more "
"leading zeros come before digit strings with fewer leading zeros).  Thus, "
"the ordering is I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, I<1>, I<9>, I<10>."
msgstr ""
"この関数の動作は以下の通りである。 両方の文字列が等しい場合、0 を返す。 それ"
"以外の場合、その直前までは両方の文字列が等しく、 その直後のバイトで両者に違い"
"があるような、バイトの境界を探す。 見つかったバイト境界を含む数字列(数字だけ"
"の文字列)の最長一致検索を行う。 (数字列は境界から始まっていても、境界で終わっ"
"ていてもよい)。 2つの文字列から得られた数字列の一方または両方が空であれば、 "
"B<strcmp>(3)  が返した結果を関数の返り値として返す。 すなわち、バイト値を比較"
"した結果を返す。 それ以外の(数字列が両方とも空でない)場合、両方の数字列を数字"
"順で比較する。 このとき、1つ以上の 0 が先頭にある数字列は、前に小数点がついて"
"いるものと 解釈される。(先頭に 0 が多くある数字列ほど前に来ることになる)  こ"
"の結果、順序は次のようになる: I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, "
"I<1>, I<9>, I<10>"

#. type: Plain text
#: build/C/man3/strverscmp.3:90
msgid ""
"The B<strverscmp>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be earlier than, equal "
"to, or later than I<s2>."
msgstr ""
"関数 B<strverscmp>()  は、ゼロよりも 1)小さい、2)等しい、3)大きいのいずれかの"
"整数を返す。 それぞれは、I<s1> が I<s2> よりも、 1)小さい、2)等しい、3)大き"
"い ことを示す。"

#. type: tbl table
#: build/C/man3/strverscmp.3:100
#, fuzzy, no-wrap
#| msgid "B<strdup>():"
msgid "B<strverscmp>()"
msgstr "B<strdup>():"

#. type: Plain text
#: build/C/man3/strverscmp.3:121
msgid ""
"The program below can be used to demonstrate the behavior of "
"B<strverscmp>().  It uses B<strverscmp>()  to compare the two strings given "
"as its command-line arguments.  An example of its use is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:126
#, no-wrap
msgid ""
"$ B<./a.out jan1 jan10>\n"
"jan1 E<lt> jan10\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:135
#, fuzzy, no-wrap
#| msgid ""
#| "#define _GNU_SOURCE\n"
#| "#include E<lt>string.hE<gt>\n"
#| "#include E<lt>stdio.hE<gt>\n"
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/strverscmp.3:145
#, fuzzy, no-wrap
#| msgid ""
#| "    if (argc != 4) {\n"
#| "        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
#| "                argv[0]);\n"
#| "        exit(EXIT_FAILURE);\n"
#| "    }\n"
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>string1E<gt> E<lt>string2E<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/strverscmp.3:147
#, no-wrap
msgid "    res = strverscmp(argv[1], argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:150
#, no-wrap
msgid ""
"    printf(\"%s %s %s\\en\", argv[1],\n"
"            (res E<lt> 0) ? \"E<lt>\" : (res == 0) ? \"==\" : \"E<gt>\", argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:159
msgid "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"
msgstr "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"

#. type: TH
#: build/C/man3/strxfrm.3:30
#, no-wrap
msgid "STRXFRM"
msgstr "STRXFRM"

#. type: Plain text
#: build/C/man3/strxfrm.3:33
msgid "strxfrm - string transformation"
msgstr "strxfrm - 文字列の変換"

#. type: Plain text
#: build/C/man3/strxfrm.3:38
#, no-wrap
msgid "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strxfrm.3:62
msgid ""
"The B<strxfrm>()  function transforms the I<src> string into a form such "
"that the result of B<strcmp>(3)  on two strings that have been transformed "
"with B<strxfrm>()  is the same as the result of B<strcoll>(3)  on the two "
"strings before their transformation.  The first I<n> bytes of the "
"transformed string are placed in I<dest>.  The transformation is based on "
"the program's current locale for category B<LC_COLLATE>.  (See "
"B<setlocale>(3))."
msgstr ""
"B<strxfrm>() 関数は、文字列 I<src> に対して、次のような変換を行う。\n"
"変換は、ある二つの文字列に対して、それぞれを B<strxfrm>() で変換\n"
"した文字列に対して B<strcmp>(3) を行った結果が、 \n"
"変換を行わずにB<strcoll>(3) を行った結果と同じとなるように行う。\n"
"変換された文字列の先頭から I<n> バイト分が I<dest> に代入される。\n"
"変換は、プログラムの現在のロケールのカテゴリー B<LC_COLLATE> に\n"
"基づいて行われる (B<setlocale>(3) を参照)。"

#. type: Plain text
#: build/C/man3/strxfrm.3:76
msgid ""
"The B<strxfrm>()  function returns the number of bytes required to store the "
"transformed string in I<dest> excluding the terminating null byte (\\(aq"
"\\e0\\(aq).  If the value returned is I<n> or more, the contents of I<dest> "
"are indeterminate."
msgstr ""
"B<strxfrm>()  関数は、変換された文字列を I<dest> に代入するときに 必要なバイ"
"ト数から、終端のヌルバイト (\\(aq\\e0\\(aq) の分を 引いたものを返す。もし返り"
"値が I<n> 以上の場合、 I<dest> の内容は不定となる。"

#. type: tbl table
#: build/C/man3/strxfrm.3:86
#, fuzzy, no-wrap
#| msgid "B<strfry>(3)"
msgid "B<strxfrm>()"
msgstr "B<strfry>(3)"

#. type: Plain text
#: build/C/man3/strxfrm.3:98
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"

#~ msgid "2013-10-21"
#~ msgstr "2013-10-21"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid "The B<bcmp>()  function is thread-safe."
#~ msgstr "B<bcmp>() 関数はスレッドセーフである。"

#~ msgid "2013-10-22"
#~ msgstr "2013-10-22"

#~ msgid "The B<bcopy>()  function is thread-safe."
#~ msgstr "B<bcopy>() 関数はスレッドセーフである。"

#~ msgid "2014-05-28"
#~ msgstr "2014-05-28"

#~ msgid ""
#~ "B<void *memmem(const void *>I<needle>B<, size_t >I<needlelen>B<,>\n"
#~ "B<             const void *>I<haystack>B<, size_t >I<haystacklen>B<);>\n"
#~ msgstr ""
#~ "B<void *memmem(const void *>I<needle>B<, size_t >I<needlelen>B<,>\n"
#~ "B<             const void *>I<haystack>B<, size_t >I<haystacklen>B<);>\n"

#~ msgid "bzero - write zero-valued bytes"
#~ msgstr "bzero - 値 0 のバイトで埋める"

#~ msgid "The B<bzero>()  function is thread-safe."
#~ msgstr "B<bzero>() 関数はスレッドセーフである。"

#~ msgid ""
#~ "_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
#~ "_XOPEN_SOURCE\\ E<gt>=\\ 700 ||"
#~ msgstr ""
#~ "_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
#~ "_XOPEN_SOURCE\\ E<gt>=\\ 700 ||"

#~ msgid "The B<ffs>(), B<ffsl>(), and B<ffsll>()  functions are thread-safe."
#~ msgstr "関数 B<ffs>(), B<ffsl>(), B<ffsll>() はスレッドセーフである。"

#~ msgid "2014-04-01"
#~ msgstr "2014-04-01"

#~ msgid "The B<index>()  and B<rindex>()  functions are thread-safe."
#~ msgstr "関数 B<index>() と B<rindex>() はスレッドセーフである。"

#~ msgid "The B<memccpy>()  function is thread-safe."
#~ msgstr "B<memccpy>() 関数はスレッドセーフである。"

#~ msgid "SVr4, 4.3BSD, POSIX.1-2001."
#~ msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#~ msgid ""
#~ "The B<memchr>()  function conforms to SVr4, 4.3BSD, C89, C99, "
#~ "POSIX.1-2001."
#~ msgstr ""
#~ "B<memchr>()  関数は SVr4, 4.3BSD, C89, C99, POSIX.1-2001 に準拠する。"

#~ msgid "2014-12-31"
#~ msgstr "2014-12-31"

#~ msgid "The B<memcmp>()  function is thread-safe."
#~ msgstr "B<memcmp>() 関数はスレッドセーフである。"

#~ msgid "SVr4, 4.3BSD, C89, C99, POSIX.1-2001."
#~ msgstr "SVr4, 4.3BSD, C89, C99, POSIX.1-2001."

#~ msgid "2014-03-17"
#~ msgstr "2014-03-17"

#~ msgid "The B<memcpy>()  function is thread-safe."
#~ msgstr "B<memcpy>() 関数はスレッドセーフである。"

#~ msgid "The B<memfrob>()  function is thread-safe."
#~ msgstr "B<memfrob>() 関数はスレッドセーフである。"

#~ msgid "2014-08-19"
#~ msgstr "2014-08-19"

#~ msgid "The B<memmem>()  function is thread-safe."
#~ msgstr "B<memmem>() 関数はスレッドセーフである。"

#~ msgid "The B<memmove>()  function is thread-safe."
#~ msgstr "B<memmove>() 関数はスレッドセーフである。"

#~ msgid "2014-03-18"
#~ msgstr "2014-03-18"

#~ msgid "B<#include E<lt>wchar.hE<gt>>\n"
#~ msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#~ msgid "The B<mempcpy>()  and B<wmempcpy>()  functions are thread-safe."
#~ msgstr "関数 B<mempcpy>() と B<wmempcpy>() はスレッドセーフである。"

#~ msgid "The B<memset>()  function is thread-safe."
#~ msgstr "B<memset>() 関数はスレッドセーフである。"

#~ msgid "2014-05-10"
#~ msgstr "2014-05-10"

#~ msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
#~ msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#~ msgid "The B<stpcpy>()  function is thread-safe."
#~ msgstr "B<stpcpy>() 関数はスレッドセーフである。"

#~ msgid "The B<stpncpy>()  function is thread-safe."
#~ msgstr "B<stpncpy>() 関数はスレッドセーフである。"

#~ msgid ""
#~ "The B<strncasecmp>()  function is similar, except it compares the only "
#~ "first I<n> bytes of I<s1>."
#~ msgstr ""
#~ "B<strncasecmp>() 関数も同様であるが、 I<s1> の最初の I<n> バイトだけを\n"
#~ "比較する点だけが異なる。"

#~ msgid "2014-01-20"
#~ msgstr "2014-01-20"

#~ msgid "The B<strcat>()  and B<strncat>()  functions are thread-safe."
#~ msgstr "関数 B<strcat>() と B<strncat>() はスレッドセーフである。"

#~ msgid "SVr4, 4.3BSD, C89, C99."
#~ msgstr "SVr4, 4.3BSD, C89, C99."

#~ msgid ""
#~ "B<strchr>()  and B<strrchr>()  are in SVr4, 4.3BSD, C89, C99.  "
#~ "B<strchrnul>()  is a GNU extension."
#~ msgstr ""
#~ "B<strchr>()  と B<strrchr>()  は SVr4, 4.3BSD, C89, C99 に準拠している。 "
#~ "B<strchrnul>()  は GNU 拡張である。"

#~ msgid ""
#~ "The B<strcmp>()  function compares the two strings I<s1> and I<s2>.  It "
#~ "returns an integer less than, equal to, or greater than zero if I<s1> is "
#~ "found, respectively, to be less than, to match, or be greater than I<s2>."
#~ msgstr ""
#~ "B<strcmp>()  関数は二つの文字列 I<s1> と I<s2> を較べる。 この関数は、 "
#~ "I<s1> が I<s2> に較べて 1)小さい、2)等しい、3)大きい場合に、 ゼロよりも 1)"
#~ "小さい、2)等しい、3)大きい整数を返す。"

#~ msgid "The B<strcmp>()  and B<strncmp>()  functions are thread-safe."
#~ msgstr "関数 B<strcmp>() と B<strncmp>() はスレッドセーフである。"

#~ msgid "2010-09-20"
#~ msgstr "2010-09-20"

#~ msgid "2014-05-21"
#~ msgstr "2014-05-21"

#~ msgid "The B<strcpy>()  and B<strncpy>()  functions are thread-safe."
#~ msgstr "関数 B<strcpy>() と B<strncpy>() はスレッドセーフである。"

#~ msgid "2013-04-19"
#~ msgstr "2013-04-19"

#~ msgid "B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
#~ msgstr "B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"

#~ msgid "B<char *strdupa(const char *>I<s>B<);>\n"
#~ msgstr "B<char *strdupa(const char *>I<s>B<);>\n"

#~ msgid "B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"
#~ msgstr "B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"

#~ msgid ""
#~ "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
#~ "_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
#~ msgstr ""
#~ "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
#~ "_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#~ msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
#~ msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"

#~ msgid "B<char *strerror(int >I<errnum>B<);>\n"
#~ msgstr "B<char *strerror(int >I<errnum>B<);>\n"

#~ msgid "The B<strerror>()  function is not thread-safe."
#~ msgstr "B<strerror>() 関数はスレッドセーフではない。"

#~ msgid "The B<strerror_r>()  function is thread-safe."
#~ msgstr "B<strerror_r>() 関数はスレッドセーフである。"

#~ msgid "2014-01-04"
#~ msgstr "2014-01-04"

#~ msgid "2014-02-25"
#~ msgstr "2014-02-25"

#~ msgid "The B<strlen>()  function is thread-safe."
#~ msgstr "B<strlen>() 関数はスレッドセーフである。"

#~ msgid "The B<strnlen>()  function is thread-safe."
#~ msgstr "B<strnlen>() 関数はスレッドセーフである。"

#~ msgid "The B<strpbrk>()  function is thread-safe."
#~ msgstr "B<strpbrk>() 関数はスレッドセーフである。"

#~ msgid "B<strsep>(): _BSD_SOURCE"
#~ msgstr "B<strsep>(): _BSD_SOURCE"

#~ msgid "The B<strsep>()  function is thread-safe."
#~ msgstr "B<strsep>() 関数はスレッドセーフである。"

#~ msgid "B<char *strsignal(int >I<sig>B<);>\n"
#~ msgstr "B<char *strsignal(int >I<sig>B<);>\n"

#~ msgid "2014-02-28"
#~ msgstr "2014-02-28"

#~ msgid "The B<strspn>()  and B<strcspn>()  functions are thread-safe."
#~ msgstr "関数 B<strspn>() と B<strcspn>() はスレッドセーフである。"

#~ msgid "The B<strstr>()  function is thread-safe."
#~ msgstr "B<strstr>() 関数はスレッドセーフである。"

#~ msgid ""
#~ "The B<strcasestr>()  function is thread-safe with exceptions.  It can be "
#~ "safely used in multithreaded applications, as long as B<setlocale>(3)  is "
#~ "not called to change the locale during its execution."
#~ msgstr ""
#~ "B<strcasestr>() 関数は、例外付きのスレッドセーフである。実行中に "
#~ "B<setlocale>(3) を呼び出してロケールを変更しない限り、マルチスレッドアプリ"
#~ "ケーションで安全に使用することができる。"

#~ msgid ""
#~ "The B<strstr>()  function conforms to C89 and C99.  The B<strcasestr>()  "
#~ "function is a nonstandard extension."
#~ msgstr ""
#~ "B<strstr>()  関数は C89 と C99 に準拠している。 B<strcasestr>()  関数は非"
#~ "標準拡張である。"

#~ msgid "2013-05-19"
#~ msgstr "2013-05-19"

#~ msgid "The B<strtok>()  function is not thread-safe."
#~ msgstr "The B<strtok>() 関数はスレッドセーフではない。"

#~ msgid "The B<strtok_r>()  function is thread-safe."
#~ msgstr "B<strtok_r>() 関数はスレッドセーフである。"

#~ msgid "POSIX.1-2001."
#~ msgstr "POSIX.1-2001."

#~ msgid "2012-05-10"
#~ msgstr "2012-05-10"

#~ msgid ""
#~ "In the I<POSIX> or I<C> locales B<strxfrm>()  is equivalent to copying "
#~ "the string with B<strncpy>(3)."
#~ msgstr ""
#~ "I<POSIX> または I<C> ロケールでは、関数 B<strxfrm>()  は、 関数 "
#~ "B<strncpy>(3)  を使って文字列をコピーするのと同じである。"
