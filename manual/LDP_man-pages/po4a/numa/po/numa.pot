# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-04-30 20:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr ""

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/mbind.2:45 build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "2008-08-15"
msgstr ""

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12 build/C/man2/mbind.2:45 build/C/man2/migrate_pages.2:18 build/C/man2/move_pages.2:18 build/C/man7/numa.7:29 build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12 build/C/man2/mbind.2:45 build/C/man2/migrate_pages.2:18 build/C/man2/move_pages.2:18 build/C/man7/numa.7:29 build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:28 build/C/man2/getcpu.2:13 build/C/man2/mbind.2:46 build/C/man2/migrate_pages.2:19 build/C/man2/move_pages.2:19 build/C/man7/numa.7:30 build/C/man2/set_mempolicy.2:28
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a process"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:30 build/C/man2/getcpu.2:15 build/C/man2/mbind.2:48 build/C/man2/migrate_pages.2:21 build/C/man2/move_pages.2:21 build/C/man2/set_mempolicy.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, unsigned long "
">I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:39 build/C/man2/mbind.2:57 build/C/man2/set_mempolicy.2:38
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:40 build/C/man2/getcpu.2:25 build/C/man2/mbind.2:58 build/C/man2/migrate_pages.2:31 build/C/man2/move_pages.2:30 build/C/man7/numa.7:32 build/C/man2/set_mempolicy.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling process or of a "
"memory address, depending on the setting of I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:50 build/C/man2/set_mempolicy.2:54
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:67
msgid ""
"If I<flags> is specified as 0, then information about the calling process's "
"default policy (as set by B<set_mempolicy>(2))  is returned.  The policy "
"returned [I<mode> and I<nodemask>] may be used to restore the process's "
"policy to its state at the time of the call to B<get_mempolicy>()  using "
"B<set_mempolicy>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:89
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24), "
"the I<mode> argument is ignored and the set of nodes [memories] that the "
"process is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  [in the absence of any I<mode flags>] is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:103
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the "
"policy governing the memory address given in I<addr>.  This policy may be "
"different from the process's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:124
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the "
"policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned long)>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:141
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address "
"I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the process had performed a read [load] access to that "
"address, and return the ID of the node where that page was allocated."
msgstr ""

#.  Note:  code returns next interleave node via 'mode' argument -Lee Schermerhorn
#. type: Plain text
#: build/C/man2/get_mempolicy.2:166
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"process's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  "
"will return in the location pointed to by a non-NULL I<mode> argument, the "
"node ID of the next node that will be used for interleaving of internal "
"kernel pages allocated on behalf of the process.  These allocations include "
"pages for memory mapped files in process memory ranges mapped using the "
"B<mmap>(2)  call with the B<MAP_PRIVATE> flag for read accesses, and in "
"memory ranges mapped with the B<MAP_SHARED> flag for all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:168
msgid "Other flag values are reserved."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:171
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:171 build/C/man2/getcpu.2:61 build/C/man2/mbind.2:309 build/C/man2/migrate_pages.2:88 build/C/man2/move_pages.2:141 build/C/man2/set_mempolicy.2:220
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:178
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:178 build/C/man2/getcpu.2:66 build/C/man2/mbind.2:317 build/C/man2/migrate_pages.2:96 build/C/man2/move_pages.2:150 build/C/man2/set_mempolicy.2:227
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/get_mempolicy.2:179 build/C/man2/getcpu.2:67 build/C/man2/mbind.2:319 build/C/man2/move_pages.2:159 build/C/man2/set_mempolicy.2:228
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:186 build/C/man2/set_mempolicy.2:235
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/get_mempolicy.2:186 build/C/man2/mbind.2:327 build/C/man2/move_pages.2:162 build/C/man2/set_mempolicy.2:235
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:230
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current process policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> "
"specified B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or "
"B<MPOL_F_NODE>.  (And there are other B<EINVAL> cases.)"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:230 build/C/man2/getcpu.2:70 build/C/man2/mbind.2:399 build/C/man2/migrate_pages.2:112 build/C/man2/move_pages.2:190 build/C/man2/set_mempolicy.2:275
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:234
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:234 build/C/man2/getcpu.2:73 build/C/man2/mbind.2:403 build/C/man2/migrate_pages.2:116 build/C/man2/move_pages.2:193 build/C/man7/numa.7:148 build/C/man2/set_mempolicy.2:279
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:236 build/C/man2/mbind.2:405 build/C/man2/migrate_pages.2:118 build/C/man2/move_pages.2:195 build/C/man2/set_mempolicy.2:281
msgid "This system call is Linux-specific."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:236 build/C/man2/getcpu.2:76 build/C/man2/mbind.2:405 build/C/man2/migrate_pages.2:118 build/C/man2/move_pages.2:195 build/C/man7/numa.7:150 build/C/man2/set_mempolicy.2:281
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:239 build/C/man2/mbind.2:408 build/C/man2/migrate_pages.2:121 build/C/man2/move_pages.2:198 build/C/man2/set_mempolicy.2:289
msgid "For information on library support, see B<numa>(7)."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:239 build/C/man2/getcpu.2:139 build/C/man2/mbind.2:457 build/C/man2/migrate_pages.2:148 build/C/man2/move_pages.2:225 build/C/man7/numa.7:183 build/C/man2/set_mempolicy.2:289
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:247
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:247 build/C/man2/getcpu.2:145 build/C/man2/mbind.2:468 build/C/man2/migrate_pages.2:161 build/C/man2/move_pages.2:235 build/C/man7/numa.7:191 build/C/man2/set_mempolicy.2:298
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:254 build/C/man2/getcpu.2:152 build/C/man2/mbind.2:475 build/C/man2/migrate_pages.2:168 build/C/man2/move_pages.2:242 build/C/man7/numa.7:198 build/C/man2/set_mempolicy.2:305
msgid ""
"This page is part of release 3.51 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr ""

#. type: TH
#: build/C/man2/getcpu.2:12
#, no-wrap
msgid "2013-04-03"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:15
msgid "getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:21
#, no-wrap
msgid ""
"B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache "
"*>I<tcache>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:25
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:42
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:46
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:61
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:66
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:70
msgid "Arguments point outside the calling process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:73
msgid "B<getcpu>()  was added in kernel 2.6.19 for x86_64 and i386."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:76
msgid "B<getcpu>()  is Linux specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:82
msgid ""
"Linux makes a best effort to make this call as fast possible.  The intention "
"of B<getcpu>()  is to allow programs to make optimizations with per-CPU data "
"or for NUMA optimization."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:88
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2); or use B<sched_getcpu>(3)  instead."
msgstr ""

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: build/C/man2/getcpu.2:139
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a "
"caller-allocated buffer in thread-local storage that was used to provide a "
"caching mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  "
"calls, at the cost that there was a very small chance that the returned "
"information would be out of date.  The caching mechanism was considered to "
"cause problems when migrating threads between CPUs, and so the argument is "
"now ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:145
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mbind.2:45
#, no-wrap
msgid "MBIND"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:48
msgid "mbind - set memory policy for a memory range"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:51 build/C/man2/migrate_pages.2:24 build/C/man2/move_pages.2:24 build/C/man2/set_mempolicy.2:33
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:55
#, no-wrap
msgid ""
"B<int mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<          unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<          unsigned >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:68
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and "
"zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:90
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a memory "
"mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified "
"policy when the application writes [stores] to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the process policy of the "
"process that causes the page to be allocated.  This may not be the process "
"that called B<mbind>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:98
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the "
"process policy of the process that caused the page to be allocated.  Again, "
"this may not be the process that called B<mbind>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:115
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:126
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages "
"inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:141
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE> or B<MPOL_PREFERRED>.  All policy modes except "
"B<MPOL_DEFAULT> require the caller to specify via the I<nodemask> argument, "
"the node or nodes to which the mode applies."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:149
msgid ""
"The I<mode> argument may also include an optional I<mode flag >.  The "
"supported I<mode flags> are:"
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:149
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:159
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux does not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:159
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:165 build/C/man2/set_mempolicy.2:113
msgid ""
"A nonempty I<nodemask> specifies node ids that are relative to the set of "
"node ids allowed by the process's current cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:193
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits.  "
"The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of "
"I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes.  "
"If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:215
msgid ""
"The B<MPOL_DEFAULT> mode requests that any nondefault policy be removed, "
"restoring default behavior.  When applied to a range of memory via "
"B<mbind>(), this means to use the process policy, which may have been set "
"with B<set_mempolicy>(2).  If the mode of the process policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The "
"system-wide default policy allocates pages on the node of the CPU that "
"triggers the allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and "
"I<maxnode> arguments must be specify the empty set of nodes."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:232
msgid ""
"The B<MPOL_BIND> mode specifies a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest "
"numeric node ID first, until that node contains no free memory.  Allocations "
"will then come from the node with the next highest node ID specified in "
"I<nodemask> and so forth, until none of the specified nodes contain free "
"memory.  Pages will not be allocated from any node not specified in the "
"I<nodemask>."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:245
msgid ""
"The B<MPOL_INTERLEAVE> mode specifies that page allocations be interleaved "
"across the set of nodes specified in I<nodemask>.  This optimizes for "
"bandwidth instead of latency by spreading out pages and memory accesses to "
"those pages across multiple nodes.  To be effective the memory area should "
"be fairly large, at least 1MB or bigger with a fairly uniform access "
"pattern.  Accesses to a single page of the area will still be limited to the "
"memory bandwidth of a single node."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:264
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to other nodes if "
"the preferred nodes is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the memory is allocated on the node of the CPU that "
"triggered the allocation.  This is the only way to specify \"local "
"allocation\" for a range of memory via B<mbind>()."
msgstr ""

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: build/C/man2/mbind.2:280
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call will fail with the error B<EIO> if the "
"existing pages in the memory range don't follow the policy."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:293
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to "
"move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call will fail with the error "
"B<EIO> if some pages could not be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:309
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling process must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call will fail with the error B<EIO> if some pages could "
"not be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:317
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:327
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range."
msgstr ""

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/mbind.2:375
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was "
"less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or, "
"I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one or "
"more node IDs that are greater than the maximum supported node ID.  Or, none "
"of the node IDs specified by I<nodemask> are on-line and allowed by the "
"process's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:375
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:386
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:386 build/C/man2/set_mempolicy.2:272
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:389 build/C/man2/set_mempolicy.2:275
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:389 build/C/man2/migrate_pages.2:97 build/C/man2/move_pages.2:178
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:399
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:403
msgid "The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:413
msgid ""
"NUMA policy is not supported on a memory mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:445
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the process's policy reverts to system default policy "
"or local allocation.  When B<MPOL_DEFAULT> is specified for a range of "
"memory using B<mbind>(), any pages subsequently allocated for that range "
"will use the process's policy, as set by B<set_mempolicy>(2).  This "
"effectively removes the explicit policy from the specified range, \"falling "
"back\" to a possibly nondefault policy.  To select explicit \"local "
"allocation\" for a memory range, specify a I<mode> of B<MPOL_PREFERRED> with "
"an empty set of nodes.  This method will work for B<set_mempolicy>(2), as "
"well."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:449
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:452
msgid "B<MPOL_MF_STRICT> is ignored on huge page mappings."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:457
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:468
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr ""

#. type: TH
#: build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr ""

#. type: TH
#: build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "2012-08-01"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:31 build/C/man2/move_pages.2:30
msgid "Link with I<-lnuma>."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages "
"not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be "
"moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:106
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""

#. type: TP
#: build/C/man2/migrate_pages.2:106 build/C/man2/move_pages.2:187
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#.  FIXME There are other errors
#. type: Plain text
#: build/C/man2/migrate_pages.2:112
msgid "No process matching I<pid> could be found."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:116
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:130
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:142
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:148 build/C/man2/move_pages.2:225
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:158 build/C/man2/move_pages.2:235
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), "
"B<numa_stat>(8)"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:161
msgid "I<Documentation/vm/page_migration> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/move_pages.2:18
#, no-wrap
msgid "MOVE_PAGES"
msgstr ""

#. type: TH
#: build/C/man2/move_pages.2:18
#, no-wrap
msgid "2010-06-11"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:21
msgid "move_pages - move individual pages of a process to another node"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:27
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:43
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:56
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  To move "
"pages in another process, the caller must be privileged (B<CAP_SYS_NICE>)  "
"or the real or effective user ID of the calling process must match the real "
"or saved-set user ID of the target process.  If I<pid> is 0, then "
"B<move_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:64
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""

#.  FIXME what if they are not aligned?
#. type: Plain text
#: build/C/man2/move_pages.2:71
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:84
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:90
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:102
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""

#. type: SH
#: build/C/man2/move_pages.2:102
#, no-wrap
msgid "Page states in the status array"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:106
msgid "The following values can be returned in each element of the I<status> array."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:106
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:109
msgid "Identifies the node on which the page resides."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:109
#, no-wrap
msgid "B<-EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:114
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:114
#, no-wrap
msgid "B<-EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:120
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:120
#, no-wrap
msgid "B<-EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:123
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:123
#, no-wrap
msgid "B<-EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:130
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the file system does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:130
#, no-wrap
msgid "B<-EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:135
msgid ""
"A dirty page cannot be moved.  The file system does not provide a migration "
"function and has no ability to write back pages."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:135
#, no-wrap
msgid "B<-ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:138
msgid "The page is not present."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:138
#, no-wrap
msgid "B<-ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:141
msgid "Unable to allocate memory on target node."
msgstr ""

#.  FIXME Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: build/C/man2/move_pages.2:150
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets "
"I<errno> to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:151
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:154
msgid "Too many pages to move."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:154
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:159
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:162
msgid "Parameter array could not be accessed."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:169
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an "
"attempt was made to migrate pages of a kernel thread."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:169
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:172
msgid "One of the target nodes is not online."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:172
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:178
msgid ""
"No pages were found that require moving.  All pages are either already on "
"the target node, not present, had an invalid address or could not be moved "
"because they were mapped by multiple processes."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:187
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:190
msgid "Process does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:193
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr ""

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:209
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:219
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  "
"and/or the specified process (See B<set_mempolicy>(2)).  That is, memory "
"policy does not constrain the destination nodes used by B<move_pages>()."
msgstr ""

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "NUMA"
msgstr ""

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "2012-08-05"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:32
msgid "numa - overview of Non-Uniform Memory Architecture"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:43
msgid ""
"Non-Uniform Memory Access (NUMA) refers to multiprocessor systems whose "
"memory is divided into multiple memory nodes.  The access time of a memory "
"node depends on the relative locations of the accessing CPU and the accessed "
"node.  (This contrasts with a symmetric multiprocessor system, where the "
"access time for all of the memory is the same for all CPUs.)  Normally, each "
"CPU on a NUMA system has a local memory node whose contents can be accessed "
"faster than the memory in the node local to another CPU or the memory on a "
"bus shared by all CPUs."
msgstr ""

#. type: SS
#: build/C/man7/numa.7:43
#, no-wrap
msgid "NUMA system calls"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:54
msgid ""
"The Linux kernel implements the following NUMA-related system calls: "
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2), B<move_pages>(2), and "
"B<set_mempolicy>(2).  However, applications should normally use the "
"interface provided by I<libnuma>; see \"Library Support\" below."
msgstr ""

#. type: SS
#: build/C/man7/numa.7:54
#, no-wrap
msgid "/proc/[number]/numa_maps (since Linux 2.6.14)"
msgstr ""

#.  See also Changelog-2.6.14
#. type: Plain text
#: build/C/man7/numa.7:58
msgid ""
"This file displays information about a process's NUMA memory policy and "
"allocation."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:62
msgid ""
"Each line contains information about a memory range used by the process, "
"displaying\\(emamong other information\\(emthe effective memory policy for "
"that memory range and on which nodes the pages have been allocated."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:70
msgid ""
"I<numa_maps> is a read-only file.  When I</proc/E<lt>pidE<gt>/numa_maps> is "
"read, the kernel will scan the virtual address space of the process and "
"report how memory is used.  One line is displayed for each unique memory "
"range of the process."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:77
msgid ""
"The first field of each line shows the starting address of the memory "
"range.  This field allows a correlation with the contents of the "
"I</proc/E<lt>pidE<gt>/maps> file, which contains the end address of the "
"range and other information, such as the access permissions and sharing."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:85
msgid ""
"The second field shows the memory policy currently in effect for the memory "
"range.  Note that the effective policy is not necessarily the policy "
"installed by the process for that memory range.  Specifically, if the "
"process installed a \"default\" policy for that range, the effective policy "
"for that range will be the process policy, which may or may not be "
"\"default\"."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:88
msgid ""
"The rest of the line contains information about the pages allocated in the "
"memory range, as follows:"
msgstr ""

#. type: TP
#: build/C/man7/numa.7:88
#, no-wrap
msgid "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:101
msgid ""
"The number of pages allocated on I<E<lt>nodeE<gt>>.  I<E<lt>nr_pagesE<gt>> "
"includes only pages currently mapped by the process.  Page migration and "
"memory reclaim may have temporarily unmapped pages associated with this "
"memory range.  These pages may show up again only after the process has "
"attempted to reference them.  If the memory range represents a shared memory "
"area or file mapping, other processes may currently have additional pages "
"mapped in a corresponding memory range."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:101
#, no-wrap
msgid "I<file=E<lt>filenameE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:107
msgid ""
"The file backing the memory range.  If the file is mapped as private, write "
"accesses may have generated COW (Copy-On-Write) pages in this memory range.  "
"These pages are displayed as anonymous pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:107
#, no-wrap
msgid "I<heap>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:110
msgid "Memory range is used for the heap."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:110
#, no-wrap
msgid "I<stack>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:113
msgid "Memory range is used for the stack."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:113
#, no-wrap
msgid "I<huge>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:117
msgid ""
"Huge memory range.  The page counts shown are huge pages and not regular "
"sized pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:117
#, no-wrap
msgid "I<anon=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:120
msgid "The number of anonymous page in the range."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:120
#, no-wrap
msgid "I<dirty=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:123
msgid "Number of dirty pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:123
#, no-wrap
msgid "I<mapped=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:130
msgid "Total number of mapped pages, if different from I<dirty> and I<anon> pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:130
#, no-wrap
msgid "I<mapmax=E<lt>countE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:136
msgid ""
"Maximum mapcount (number of processes mapping a single page) encountered "
"during the scan.  This may be used as an indicator of the degree of sharing "
"occurring in a given memory range."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:136
#, no-wrap
msgid "I<swapcache=E<lt>countE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:139
msgid "Number of pages that have an associated entry on a swap device."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:139
#, no-wrap
msgid "I<active=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:145
msgid ""
"The number of pages on the active list.  This field is shown only if "
"different from the number of pages in this range.  This means that some "
"inactive pages exist in the memory range that may be removed from memory by "
"the swapper soon."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:145
#, no-wrap
msgid "I<writeback=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:148
msgid "Number of pages that are currently being written out to disk."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:150
msgid "No standards govern NUMA interfaces."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:157
msgid ""
"The Linux NUMA system calls and I</proc> interface are available only if the "
"kernel was configured and built with the B<CONFIG_NUMA> option."
msgstr ""

#. type: SS
#: build/C/man7/numa.7:157
#, no-wrap
msgid "Library support"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:166
msgid ""
"Link with I<-lnuma> to get the system call definitions.  I<libnuma> and the "
"required I<E<lt>numaif.hE<gt>> header are available in the I<numactl> "
"package."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:183
msgid ""
"However, applications should not use these system calls directly.  Instead, "
"the higher level interface provided by the B<numa>(3)  functions in the "
"I<numactl> package is recommended.  The I<numactl> package is available at "
"E<.UR ftp://oss.sgi.com\\:/www\\:/projects\\:/libnuma\\:/download/> E<.UE .> "
"The package is also included in some Linux distributions.  Some "
"distributions include the development library and header in the separate "
"I<numactl-devel> package."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:191
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:30
msgid ""
"set_mempolicy - set default NUMA memory policy for a process and its "
"children"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<int set_mempolicy(int >I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling process, "
"which consists of a policy mode and zero or more nodes, to the values "
"specified by the I<mode>, I<nodemask> and I<maxnode> arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the process.  The process "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"process default policy also controls allocation of any pages for memory "
"mapped files mapped using the B<mmap>(2)  call with the B<MAP_PRIVATE> flag "
"and that are only read [loaded] from by the process and of memory mapped "
"files mapped using the B<mmap>(2)  call with the B<MAP_SHARED> flag, "
"regardless of the access type.  The policy is applied only when a new page "
"is allocated for the process.  For anonymous memory this is when the page is "
"first touched by the application."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:89
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE> or B<MPOL_PREFERRED>.  All modes except B<MPOL_DEFAULT> "
"require the caller to specify via the I<nodemask> argument one or more "
"nodes."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:97
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""

#. type: TP
#: build/C/man2/set_mempolicy.2:97
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:107
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux does will not "
"remap the I<nodemask> when the process moves to a different cpuset context, "
"nor when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: build/C/man2/set_mempolicy.2:107
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:133
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:154
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:165
msgid ""
"The B<MPOL_DEFAULT> mode specifies that any nondefault process memory policy "
"be removed, so that the memory policy \"falls back\" to the system default "
"policy.  The system default policy is \"local allocation\"-- i.e., allocate "
"memory on the node of the CPU that triggered the allocation.  I<nodemask> "
"must be specified as NULL.  If the \"local node\" contains no free memory, "
"the system will attempt to allocate memory from a \"near by\" node."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:182
msgid ""
"The B<MPOL_BIND> mode defines a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest "
"numeric node ID first, until that node contains no free memory.  Allocations "
"will then come from the node with the next highest node ID specified in "
"I<nodemask> and so forth, until none of the specified nodes contain free "
"memory.  Pages will not be allocated from any node not specified in the "
"I<nodemask>."
msgstr ""

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1MB or bigger.
#. type: Plain text
#: build/C/man2/set_mempolicy.2:196
msgid ""
"B<MPOL_INTERLEAVE> interleaves page allocations across the nodes specified "
"in I<nodemask> in numeric node ID order.  This optimizes for bandwidth "
"instead of latency by spreading out pages and memory accesses to those pages "
"across multiple nodes.  However, accesses to a single page will still be "
"limited to the memory bandwidth of a single node."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:213
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to \"near by\" "
"nodes if the preferred node is low on free memory.  If I<nodemask> specifies "
"more than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:220
msgid ""
"The process memory policy is preserved across an B<execve>(2), and is "
"inherited by child processes created using B<fork>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:227
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:272
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are "
"on-line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:279
msgid ""
"The B<set_mempolicy>(), system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:286
msgid ""
"Process policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the process or memory range "
"that is in effect at the time the page is allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:298
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
