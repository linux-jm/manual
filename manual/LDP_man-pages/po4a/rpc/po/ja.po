# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-08-15 19:32+0900\n"
"PO-Revision-Date: 2013-07-16 02:14+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/getrpcent.3:8
#, no-wrap
msgid "GETRPCENT"
msgstr "GETRPCENT"

#. type: TH
#: build/C/man3/getrpcent.3:8
#, no-wrap
msgid "2008-08-19"
msgstr "2008-08-19"

#. type: TH
#: build/C/man3/getrpcent.3:8 build/C/man3/getrpcent_r.3:26
#: build/C/man3/getrpcport.3:8 build/C/man3/key_setsecret.3:9
#: build/C/man3/rpc.3:11 build/C/man5/rpc.5:8 build/C/man3/rtime.3:12
#: build/C/man3/xdr.3:11
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/getrpcent.3:9 build/C/man3/getrpcent_r.3:27
#: build/C/man3/getrpcport.3:9 build/C/man3/key_setsecret.3:10
#: build/C/man3/rpc.3:12 build/C/man5/rpc.5:9 build/C/man3/rtime.3:13
#: build/C/man3/xdr.3:12
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/getrpcent.3:12
msgid ""
"getrpcent, getrpcbyname, getrpcbynumber, setrpcent, endrpcent - get RPC entry"
msgstr ""
"getrpcent, getrpcbyname, getrpcbynumber, setrpcent, endrpcent - RPC エントリ"
"を取得する"

#. type: SH
#: build/C/man3/getrpcent.3:12 build/C/man3/getrpcent_r.3:30
#: build/C/man3/getrpcport.3:11 build/C/man3/key_setsecret.3:13
#: build/C/man5/rpc.5:11 build/C/man3/rtime.3:15
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/getrpcent.3:15 build/C/man3/getrpcent_r.3:33
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getrpcent.3:17
#, no-wrap
msgid "B<struct rpcent *getrpcent(void);>\n"
msgstr "B<struct rpcent *getrpcent(void);>\n"

#. type: Plain text
#: build/C/man3/getrpcent.3:19
#, no-wrap
msgid "B<struct rpcent *getrpcbyname(char *>I<name>B<);>\n"
msgstr "B<struct rpcent *getrpcbyname(char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcent.3:21
#, no-wrap
msgid "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"
msgstr "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcent.3:23
#, no-wrap
msgid "B<void setrpcent(int >I<stayopen>B<);>\n"
msgstr "B<void setrpcent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcent.3:25
#, no-wrap
msgid "B<void endrpcent(void);>\n"
msgstr "B<void endrpcent(void);>\n"

#. type: SH
#: build/C/man3/getrpcent.3:26 build/C/man3/getrpcent_r.3:59
#: build/C/man3/getrpcport.3:16 build/C/man3/key_setsecret.3:27
#: build/C/man5/rpc.5:13 build/C/man3/rtime.3:22
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/getrpcent.3:36
msgid ""
"The B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  functions "
"each return a pointer to an object with the following structure containing "
"the broken-out fields of an entry in the RPC program number data base."
msgstr ""
"B<getrpcent>(), B<getrpcbyname>(), B<getrpcbynumber>() はそれぞれ以下の構造体"
"へのポインタを返す。 この構造体は RPC プログラム番号データベース の各行の"
"フィールドを含んでいる。"

#. type: Plain text
#: build/C/man3/getrpcent.3:44
#, no-wrap
msgid ""
"struct rpcent {\n"
"    char  *r_name;     /* name of server for this RPC program */\n"
"    char **r_aliases;  /* alias list */\n"
"    long   r_number;   /* RPC program number */\n"
"};\n"
msgstr ""
"struct rpcent {\n"
"    char  *r_name;     /* name of server for this RPC program */\n"
"    char **r_aliases;  /* alias list */\n"
"    long   r_number;   /* RPC program number */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getrpcent.3:48
msgid "The members of this structure are:"
msgstr "この構造体のメンバーは以下の通り。"

#. type: TP
#: build/C/man3/getrpcent.3:49
#, no-wrap
msgid "I<r_name>"
msgstr "I<r_name>"

#. type: Plain text
#: build/C/man3/getrpcent.3:52
msgid "The name of the server for this RPC program."
msgstr "この RPC プログラムのサーバの名前"

#. type: TP
#: build/C/man3/getrpcent.3:52
#, no-wrap
msgid "I<r_aliases>"
msgstr "I<r_aliases>"

#. type: Plain text
#: build/C/man3/getrpcent.3:55
msgid "A NULL-terminated list of alternate names for the RPC program."
msgstr "RPC プログラムの別名のリスト。ゼロで終端されている。"

#. type: TP
#: build/C/man3/getrpcent.3:55
#, no-wrap
msgid "I<r_number>"
msgstr "I<r_number>"

#. type: Plain text
#: build/C/man3/getrpcent.3:58
msgid "The RPC program number for this service."
msgstr "このサービスの RPC プログラム番号。"

#. type: Plain text
#: build/C/man3/getrpcent.3:64
msgid ""
"The B<getrpcent>()  function reads the next entry from the database.  A "
"connection is opened to the database if necessary."
msgstr ""
"B<getrpcent>() はファイルの次のエントリを読み込む。必要ならばデータベースへの"
"接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getrpcent.3:76
msgid ""
"The B<setrpcent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getrpc*>()  functions."
msgstr ""
"B<setrpcent>()  はデータベースへの接続をオープンし、 次の読み込みエントリを先"
"頭のエントリに設定する。 I<stayopen> が 0 でない場合、 一つ一つの B<getrpc*>"
"()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getrpcent.3:80
msgid "The B<endrpcent>()  function closes the connection to the database."
msgstr "B<endrpcent>()  はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getrpcent.3:88
msgid ""
"The B<getrpcbyname>()  and B<getrpcbynumber>()  functions sequentially "
"search from the beginning of the file until a matching RPC program name or "
"program number is found, or until end-of-file is encountered."
msgstr ""
"B<getrpcbyname>() と B<getrpcbynumber>() はファイルの最初から一致する RPC プ"
"ログラム名かプログラム番号が 見つかるか、ファイルの最後 (end-of-file) に到達"
"するまで、順番に 探していく。"

#. type: SH
#: build/C/man3/getrpcent.3:88 build/C/man3/getrpcent_r.3:107
#: build/C/man3/key_setsecret.3:59 build/C/man3/rtime.3:36
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/getrpcent.3:98
msgid ""
"On success, B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  "
"return a pointer to a statically allocated I<rpcent> structure.  A NULL "
"pointer is returned on EOF or error."
msgstr ""
"成功すると、 B<getrpcent>(), B<getrpcbyname>(), B<getrpcbynumber>()  は、静的"
"に割り当てられた I<rpcent> 構造体へのポインタを返す。 EOF か エラーに遭遇した"
"場合には NULL ポインタを返す。"

#. type: SH
#: build/C/man3/getrpcent.3:98 build/C/man5/rpc.5:76
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: TP
#: build/C/man3/getrpcent.3:99 build/C/man5/rpc.5:77
#, no-wrap
msgid "I</etc/rpc>"
msgstr "I</etc/rpc>"

#. type: Plain text
#: build/C/man3/getrpcent.3:102
msgid "RPC program number database."
msgstr "RPC プログラム番号データベース"

#. type: SH
#: build/C/man3/getrpcent.3:102 build/C/man3/getrpcent_r.3:130
#: build/C/man3/getrpcport.3:36
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/getrpcent.3:105 build/C/man3/getrpcport.3:39
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系、Solaris や他の多くのシステムに存在する。"

#. type: SH
#: build/C/man3/getrpcent.3:105 build/C/man3/rtime.3:75
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/getrpcent.3:110
msgid ""
"All information is contained in a static area so it must be copied if it is "
"to be saved."
msgstr ""
"全ての情報は静的領域に格納される。 保存するためには全てをコピーする必要があ"
"る。"

#. type: SH
#: build/C/man3/getrpcent.3:110 build/C/man3/getrpcent_r.3:134
#: build/C/man3/key_setsecret.3:68 build/C/man3/rpc.3:1103
#: build/C/man5/rpc.5:80 build/C/man3/rtime.3:126 build/C/man3/xdr.3:542
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/getrpcent.3:115
msgid "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"
msgstr "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"

#. type: SH
#: build/C/man3/getrpcent.3:115 build/C/man3/getrpcent_r.3:137
#: build/C/man3/getrpcport.3:39 build/C/man3/key_setsecret.3:70
#: build/C/man3/rpc.3:1121 build/C/man5/rpc.5:82 build/C/man3/rtime.3:131
#: build/C/man3/xdr.3:555
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/getrpcent.3:122 build/C/man3/getrpcent_r.3:144
#: build/C/man3/getrpcport.3:46 build/C/man3/key_setsecret.3:77
#: build/C/man3/rpc.3:1128 build/C/man5/rpc.5:89 build/C/man3/rtime.3:138
#: build/C/man3/xdr.3:562
#, fuzzy
#| msgid ""
#| "This page is part of release 3.52 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at \\%http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.53 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.52 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/getrpcent_r.3:26
#, no-wrap
msgid "GETRPCENT_R"
msgstr "GETRPCENT_R"

#. type: TH
#: build/C/man3/getrpcent_r.3:26
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: TH
#: build/C/man3/getrpcent_r.3:26 build/C/man3/rtime.3:12
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:30
msgid ""
"getrpcent_r, getrpcbyname_r, getrpcbynumber_r - get RPC entry (reentrant)"
msgstr ""
"getrpcent_r, getrpcbyname_r, getrpcbynumber_r - RPC エントリを\n"
"取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:36
#, no-wrap
msgid ""
"B<int getrpcent_r(struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""
"B<int getrpcent_r(struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:40
#, no-wrap
msgid ""
"B<int getrpcbyname_r(const char *>I<name>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""
"B<int getrpcbyname_r(const char *>I<name>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:44
#, no-wrap
msgid ""
"B<int getrpcbynumber_r(int >I<number>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""
"B<int getrpcbynumber_r(int >I<number>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:49
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7) 参照):"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:55
msgid "B<getrpcent_r>(), B<getrpcbyname_r>(), B<getrpcbynumber_r>():"
msgstr "B<getrpcent_r>(), B<getrpcbyname_r>(), B<getrpcbynumber_r>():"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:57
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:76
msgid ""
"The B<getrpcent_r>(), B<getrpcbyname_r>(), and B<getrpcbynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getrpcent>(3), "
"B<getrpcbyname>(3), and B<getrpcbynumber>(3).  They differ in the way that "
"the I<rpcent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""
"関数 B<getrpcent_r>(), B<getrpcbyname_r>(), B<getrpcbynumber_r>() は、\n"
"それぞれ B<getrpcent>(3), B<getrpcbyname>(3), B<getrpcbynumber>(3) の\n"
"リエントラント版である。\n"
"I<rpcent> 構造体の返し方と、関数呼び出し時の引き数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:82
msgid ""
"Instead of returning a pointer to a statically allocated I<rpcent> structure "
"as the function result, these functions copy the structure into the location "
"pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<rpcent> 構造体\n"
"へのポインタを返すのではなく、 I<rpcent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getrpcent_r.3:99
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<rpcent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<rpcent> 構造体が指す文字列フィールドを\n"
"格納するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:107
msgid ""
"If the function call successfully obtains an RPC record, then I<*result> is "
"set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しで RPC レコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:110
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""
"成功すると、これらの関数は 0 を返す。エラーの場合、「エラー」の節の\n"
"リストにある正のエラー番号のいずれかを返す。"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:118
msgid ""
"On error, record not found (B<getrpcbyname_r>(), B<getrpcbynumber_r>()), or "
"end of input (B<getrpcent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getrpcbyname_r>(),\n"
"B<getrpcbyaddr_r>()) やこれ以上レコードがない場合 (B<getrpcent_r>())、\n"
"I<result> には NULL が設定される。"

#. type: SH
#: build/C/man3/getrpcent_r.3:118 build/C/man3/rtime.3:42
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/getrpcent_r.3:119
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:123
msgid "(B<getrpcent_r>())  No more records in database."
msgstr "(B<getrpcent_r>())  データベースにこれ以上レコードがない。"

#. type: TP
#: build/C/man3/getrpcent_r.3:123
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:130
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""
"I<buf> が小さすぎる。もっと大きなバッファにして \n"
"(または I<buflen> を増やして) 再度呼び出すこと。"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:134
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""
"これらの関数は GNU による拡張である。\n"
"他のシステムにも同様の名前の関数が存在する場合があるが、\n"
"通常は関数の引き数が異なる。"

#. type: Plain text
#: build/C/man3/getrpcent_r.3:137
msgid "B<getrpcent>(3), B<rpc>(5)"
msgstr "B<getrpcent>(3), B<rpc>(5)"

#. type: TH
#: build/C/man3/getrpcport.3:8
#, no-wrap
msgid "GETRPCPORT"
msgstr "GETRPCPORT"

#. type: TH
#: build/C/man3/getrpcport.3:8
#, no-wrap
msgid "2007-12-23"
msgstr "2007-12-23"

#. type: Plain text
#: build/C/man3/getrpcport.3:11
msgid "getrpcport - get RPC port number"
msgstr "getrpcport - RPC ポート番号を取得する"

#. type: Plain text
#: build/C/man3/getrpcport.3:15
#, no-wrap
msgid "B<int getrpcport(char *>I<host>B<, int >I<prognum>B<, int >I<versnum>B<, int >I<proto>B<);>\n"
msgstr "B<int getrpcport(char *>I<host>B<, int >I<prognum>B<, int >I<versnum>B<, int >I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getrpcport.3:36
msgid ""
"B<getrpcport>()  returns the port number for version I<versnum> of the RPC "
"program I<prognum> running on I<host> and using protocol I<proto>.  It "
"returns 0 if it cannot contact the portmapper, or if I<prognum> is not "
"registered.  If I<prognum> is registered but not with version I<versnum>, it "
"will still return a port number (for some version of the program)  "
"indicating that the program is indeed registered.  The version mismatch will "
"be detected upon the first call to the service."
msgstr ""
"B<getrpcport>()  は I<host> 上で I<proto> プロトコルを使用しているバージョン "
"I<versnum> の RPC プログラム I<prognum> のポート番号を返す。 ポートマッパーと"
"連絡が取れない場合や I<prognum> が登録されていない場合には 0 を返す。 "
"I<prognum> が登録されているが、バージョン I<versnum> でない場合にも、そのプロ"
"グラムが実際に登録されていることを示すために (そのプログラムのバージョンの)"
"ポート番号を返す。 バージョンの不一致は最初にそのサービスを呼び出した時に検出"
"される。"

#. type: TH
#: build/C/man3/key_setsecret.3:9
#, no-wrap
msgid "KEY_SETSECRET"
msgstr "KEY_SETSECRET"

#. type: TH
#: build/C/man3/key_setsecret.3:9
#, no-wrap
msgid "2002-07-18"
msgstr "2002-07-18"

#. type: Plain text
#: build/C/man3/key_setsecret.3:13
msgid ""
"key_decryptsession, key_encryptsession, key_setsecret, key_gendes, "
"key_secretkey_is_set - interfaces to rpc keyserver daemon"
msgstr ""
"key_decryptsession, key_encryptsession, key_setsecret, key_gendes, "
"key_secretkey_is_set - rpc 鍵サーバ・デーモンとのインタフェース"

#. type: Plain text
#: build/C/man3/key_setsecret.3:15
msgid "B<#include E<lt>rpc/rpc.hE<gt>>"
msgstr "B<#include E<lt>rpc/rpc.hE<gt>>"

#. type: Plain text
#: build/C/man3/key_setsecret.3:18
msgid ""
"B<int key_decryptsession(const char *>I<remotename>B<,> B<des_block "
"*>I<deskey>B<);>"
msgstr ""
"B<int key_decryptsession(const char *>I<remotename>B<,> B<des_block "
"*>I<deskey>B<);>"

#. type: Plain text
#: build/C/man3/key_setsecret.3:21
msgid ""
"B<int key_encryptsession(const char *>I<remotename>B<,> B<des_block "
"*>I<deskey>B<);>"
msgstr ""
"B<int key_encryptsession(const char *>I<remotename>B<,> B<des_block "
"*>I<deskey>B<);>"

#. type: Plain text
#: build/C/man3/key_setsecret.3:23
msgid "B<int key_gendes(des_block *>I<deskey>B<);>"
msgstr "B<int key_gendes(des_block *>I<deskey>B<);>"

#. type: Plain text
#: build/C/man3/key_setsecret.3:25
msgid "B<int key_setsecret(const char *>I<key>B<);>"
msgstr "B<int key_setsecret(const char *>I<key>B<);>"

#. type: Plain text
#: build/C/man3/key_setsecret.3:27
msgid "B<int key_secretkey_is_set(void);>"
msgstr "B<int key_secretkey_is_set(void);>"

#. type: Plain text
#: build/C/man3/key_setsecret.3:32
msgid ""
"The functions here are used within the RPC's secure authentication mechanism "
"(AUTH_DES).  There should be no need for user programs to use this functions."
msgstr ""
"これらの関数は RPC の安全な認証機構 (AUTH_DES) で使用される。 ユーザ・プログ"
"ラムでこれらの関数を使用する必要はない。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:39
msgid ""
"The function B<key_decryptsession>()  uses the (remote) server netname and "
"takes the DES key for decrypting.  It uses the public key of the server and "
"the secret key associated with the effective UID of the calling process."
msgstr ""
"関数 B<key_decryptsession>()  は(リモート)サーバのネット名を用いて、復号用の "
"DES 鍵を取得する。 サーバの公開鍵と、呼び出し元プロセスの実効 UID に対応する"
"秘密鍵が使用される。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:46
msgid ""
"The function B<key_encryptsession>()  is the inverse of B<key_decryptsession>"
"().  It encrypts the DES keys with the public key of the server and the "
"secret key associated with the effective UID of the calling process."
msgstr ""
"関数 B<key_encryptsession>()  は B<key_decryptsession>()  の逆の処理を行う。 "
"サーバの公開鍵と、呼び出し元プロセスの実効 UID に対応する秘密鍵で DES 鍵を暗"
"号する。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:50
msgid ""
"The function B<key_gendes>()  is used to ask the keyserver for a secure "
"conversation key."
msgstr ""
"関数 B<key_gendes>()  は、鍵サーバに安全な通信を行うための鍵を要求するために"
"使用される。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:54
msgid ""
"The function B<key_setsecret>()  is used to set the key for the effective "
"UID of the calling process."
msgstr ""
"関数 B<key_setsecret>()  は、呼び出し元プロセスの実効 UID に対して鍵を設定す"
"るために使用される。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:59
msgid ""
"The function B<key_secretkey_is_set>()  can be used to determine whether a "
"key has been set for the effective UID of the calling process."
msgstr ""
"関数 B<key_secretkey_is_set>()  は、呼び出し元プロセスの実効 UID に対して鍵が"
"設定されているかどうかを 調べるために使用される。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:61
msgid "These functions return 1 on success and 0 on failure."
msgstr "これらの関数は成功した場合 1 を、失敗した場合 0 を返す。"

#. type: SH
#: build/C/man3/key_setsecret.3:61 build/C/man3/rtime.3:57
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/key_setsecret.3:66
msgid ""
"Note that we talk about two types of encryption here.  One is asymmetric "
"using a public and secret key.  The other is symmetric, the 64-bit DES."
msgstr ""
"ここでは 2 種類の暗号方式が登場することに注意すること。 一つは公開鍵と秘密鍵"
"を使用する非対称鍵暗号であり、 もう一つは対称鍵暗号である 64 ビット DES であ"
"る。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:68
msgid "These routines were part of the Linux/Doors-project, abandoned by now."
msgstr ""
"これらの関数は Linux/Doors-project の成果の一部だったが、 現在までに該当箇所"
"はすべて破棄された。"

#. type: Plain text
#: build/C/man3/key_setsecret.3:70
msgid "B<crypt>(3)"
msgstr "B<crypt>(3)"

#. type: TH
#: build/C/man3/rpc.3:11 build/C/man5/rpc.5:8
#, no-wrap
msgid "RPC"
msgstr "RPC"

#. type: TH
#: build/C/man3/rpc.3:11
#, no-wrap
msgid "2008-07-17"
msgstr "2008-07-17"

#. type: Plain text
#: build/C/man3/rpc.3:14
msgid "rpc - library routines for remote procedure calls"
msgstr "rpc - 遠隔手続き呼び出し(RPC)のためのライブラリ・ルーティン"

#. type: SH
#: build/C/man3/rpc.3:14 build/C/man3/xdr.3:14
#, no-wrap
msgid "SYNOPSIS AND DESCRIPTION"
msgstr "書式と説明"

#.  .LP
#.  We don't have an rpc_secure.3 page at the moment -- MTK, 19 Sep 05
#.  Routines that are used for Secure RPC (DES authentication) are described in
#.  .BR rpc_secure (3).
#.  Secure RPC can be used only if DES encryption is available.
#. type: Plain text
#: build/C/man3/rpc.3:26
msgid ""
"These routines allow C programs to make procedure calls on other machines "
"across the network.  First, the client calls a procedure to send a data "
"packet to the server.  Upon receipt of the packet, the server calls a "
"dispatch routine to perform the requested service, and then sends back a "
"reply.  Finally, the procedure call returns to the client."
msgstr ""
"これらのルーティンは C プログラムでネットワークを通して 他のマシンにアクセス"
"するプロシジャを作成することを可能にする。 最初にクライアントはデータパケット"
"をサーバに送るために プロシジャを呼び出す。 サーバはパケットを受け取ると、配"
"分ルーチンを呼び出して 要求されたサービスに実行し、返答を送り返す。 最後にプ"
"ロシジャ・コールはクライアントへと戻る。"

#. type: Plain text
#: build/C/man3/rpc.3:29
msgid ""
"To take use of these routines, include the header file I<E<lt>rpc/rpc."
"hE<gt>>."
msgstr ""
"これらのルーティンを使用するには、ヘッダファイル I<E<lt>rpc/rpc.hE<gt>> をイ"
"ンクルードすること。"

#. type: Plain text
#: build/C/man3/rpc.3:31
msgid "The prototypes below make use of the following types:"
msgstr "下記のプロトタイプでは次の型を使用している。"

#. type: Plain text
#: build/C/man3/rpc.3:35 build/C/man3/xdr.3:28
#, no-wrap
msgid "B<typedef int >I<bool_t>B<;>\n"
msgstr "B<typedef int >I<bool_t>B<;>\n"

#. type: Plain text
#: build/C/man3/rpc.3:37
#, no-wrap
msgid "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"
msgstr "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:40
#, no-wrap
msgid ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\n"
"B<                                struct sockaddr_in *>I<raddr>B<);>\n"
msgstr ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\n"
"B<                                struct sockaddr_in *>I<raddr>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:50
msgid ""
"See the header files for the declarations of the I<AUTH>, I<CLIENT>, "
"I<SVCXPRT>, and I<XDR> types."
msgstr ""
"型 I<AUTH>, I<CLIENT>, I<SVCXPRT>, I<XDR> の宣言についてはヘッダファイルを参"
"照。"

#. type: Plain text
#: build/C/man3/rpc.3:53
#, no-wrap
msgid "B<void auth_destroy(AUTH *>I<auth>B<);>\n"
msgstr "B<void auth_destroy(AUTH *>I<auth>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:62
msgid ""
"A macro that destroys the authentication information associated with "
"I<auth>.  Destruction usually involves deallocation of private data "
"structures.  The use of I<auth> is undefined after calling B<auth_destroy>()."
msgstr ""
"このマクロは I<auth> に関連付けられた認証情報を破壊する。破壊は通常は私的な"
"データ構造の 破棄を含んでいる。 B<auth_destroy>()  を呼び出した後に I<auth> "
"を使用することは未定義である。"

#. type: Plain text
#: build/C/man3/rpc.3:65
#, no-wrap
msgid "B<AUTH *authnone_create(void);>\n"
msgstr "B<AUTH *authnone_create(void);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:71
msgid ""
"Create and return an RPC authentication handle that passes nonusable "
"authentication information with each remote procedure call.  This is the "
"default authentication used by RPC."
msgstr ""
"各リモート・プロシジャ・コールで使用できない仮の認証情報として渡される RPC 認"
"証ハンドルを作成して返す。 これは RPC で使用されるデフォルトの認証である。"

#. type: Plain text
#: build/C/man3/rpc.3:75
#, no-wrap
msgid ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\n"
"B<                      int >I<len>B<, int *>I<aup_gids>B<);>\n"
msgstr ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\n"
"B<                      int >I<len>B<, int *>I<aup_gids>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:91
msgid ""
"Create and return an RPC authentication handle that contains authentication "
"information.  The parameter I<host> is the name of the machine on which the "
"information was created; I<uid> is the user's user ID; I<gid> is the user's "
"current group ID; I<len> and I<aup_gids> refer to a counted array of groups "
"to which the user belongs.  It is easy to impersonate a user."
msgstr ""
"認証情報を含んだ RPC 認証ハンドルを作成して返す。 I<host> パラメーターは情報"
"が作成されたマシンの名前である。 I<uid> はそのユーザのユーザ E<.SM ID> 、 "
"I<gid> はそのユーザの現在のグループ E<.SM ID> である。 I<len> と I<aup_gids> "
"はそのユーザが所属するグループの配列を参照している。 他のユーザになりすますこ"
"とは簡単である。"

#. type: Plain text
#: build/C/man3/rpc.3:94
#, no-wrap
msgid "B<AUTH *authunix_create_default(void);>\n"
msgstr "B<AUTH *authunix_create_default(void);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:99
msgid "Calls B<authunix_create>()  with the appropriate parameters."
msgstr "適切なパラメーターで B<authunix_create>()  を呼び出す。"

#. type: Plain text
#: build/C/man3/rpc.3:105
#, no-wrap
msgid ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<            unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<            xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<            xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<            unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<            xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<            xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:129
msgid ""
"Call the remote procedure associated with I<prognum>, I<versnum>, and "
"I<procnum> on the machine, I<host>.  The parameter I<in> is the address of "
"the procedure's argument(s), and I<out> is the address of where to place the "
"result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results.  This routine returns "
"zero if it succeeds, or the value of B<enum clnt_stat> cast to an integer if "
"it fails.  The routine B<clnt_perrno>()  is handy for translating failure "
"statuses into messages."
msgstr ""
"マシン I<host> 上で I<prognum>, I<versnum>, I<procnum> に関連付けられたリモー"
"ト・プロシジャを呼び出す。 パラメーター I<in> はプロシジャの引き数のアドレス"
"であり I<out> は結果を格納するアドレスである。 I<inproc> はプロシジャのパラ"
"メーターをエンコードするのに使用され、 I<outproc> は結果をデコードするのに使"
"用される。 このルーティンは成功した場合にはゼロを返す。失敗した場合には "
"B<enum clnt_stat> を整数にキャストした値を返す。 B<clnt_perrno>()  ルーティン"
"が失敗の状態をメッセージに変換するのに使用できる。"

#. type: Plain text
#: build/C/man3/rpc.3:135
msgid ""
"Warning: calling remote procedures with this routine uses UDP/IP as a "
"transport; see B<clntudp_create>()  for restrictions.  You do not have "
"control of timeouts or authentication using this routine."
msgstr ""
"警告: このルーティンでリモート・プロシジャを呼び出すと通信には UDP/IP が使用"
"される。この際の制限については B<clntudp_create>()  を参照すること。このルー"
"ティンを使用して認証や時間切れの制御を することはできない。"

#. type: Plain text
#: build/C/man3/rpc.3:142
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\n"
"B<                     unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<                     xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                     xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                     resultproc_t >I<eachresult>B<);>\n"
msgstr ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\n"
"B<                     unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<                     xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                     xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                     resultproc_t >I<eachresult>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:151
msgid ""
"Like B<callrpc>(), except the call message is broadcast to all locally "
"connected broadcast nets.  Each time it receives a response, this routine "
"calls B<eachresult>(), whose form is:"
msgstr ""
"B<callrpc>()  と同様であるが、メッセージがローカルのブロードキャスト・ネット"
"ワーク 全体へとブロードキャストされる点が異っている。回答を受け取る度に この"
"ルーティンは以下の形式の B<eachresult>()  を呼び出す。"

#. type: Plain text
#: build/C/man3/rpc.3:155
#, no-wrap
msgid "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:172
msgid ""
"where I<out> is the same as I<out> passed to B<clnt_broadcast>(), except "
"that the remote procedure's output is decoded there; I<addr> points to the "
"address of the machine that sent the results.  If B<eachresult>()  returns "
"zero, B<clnt_broadcast>()  waits for more replies; otherwise it returns with "
"appropriate status."
msgstr ""
"ここで I<out> は B<clnt_broadcast>()  に渡される I<out> と同じであるが、リ"
"モート・プロシジャからの出力がデコードされている 点のみが異っている。 "
"I<addr> は結果を送って来たマシンのアドレスを指している。 B<eachresult>()  が"
"ゼロを返した場合、 B<clnt_broadcast>()  はさらなる回答を待つ。そうでなければ"
"適切な状態で終了する。"

#. type: Plain text
#: build/C/man3/rpc.3:176
msgid ""
"Warning: broadcast sockets are limited in size to the maximum transfer unit "
"of the data link.  For ethernet, this value is 1500 bytes."
msgstr ""
"警告: ブロードキャスト・ソケットはデータリンク層の最大転送単位に 制限されてい"
"る。イーサネットの場合、最大値は 1500 バイトである。"

#. type: Plain text
#: build/C/man3/rpc.3:182
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<);>\n"
msgstr ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:201
msgid ""
"A macro that calls the remote procedure I<procnum> associated with the "
"client handle, I<clnt>, which is obtained with an RPC client creation "
"routine such as B<clnt_create>().  The parameter I<in> is the address of the "
"procedure's argument(s), and I<out> is the address of where to place the "
"result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results; I<tout> is the time "
"allowed for results to come back."
msgstr ""
"このマクロはクライアント・ハンドル I<clnt> に関連付けられた I<procnum> リモー"
"ト・プロシジャを呼び出す。 クライアント・ハンドルは B<clnt_create>()  のよう"
"な E<.SM RPC> クライアント作成ルーティンによって得られる。 パタメータ I<in> "
"はプロシジャの引き数のアドレスである。 I<out> はプロシジャの返り値を格納する"
"アドレスである。 I<inproc> はプロシジャのパラメーターをエンコードするのに使用"
"される。 I<outproc> はプロシジャの返り値をデコードするのに使用される。 "
"I<tout> は結果が返されるのを待つ時間である。"

#. type: Plain text
#: build/C/man3/rpc.3:204
#, no-wrap
msgid "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"
msgstr "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:217
msgid ""
"A macro that destroys the client's RPC handle.  Destruction usually involves "
"deallocation of private data structures, including I<clnt> itself.  Use of "
"I<clnt> is undefined after calling B<clnt_destroy>().  If the RPC library "
"opened the associated socket, it will close it also.  Otherwise, the socket "
"remains open."
msgstr ""
"このマクロはクライアントの RPC ハンドルを破壊する。破壊には通常は I<clnt> 自"
"身も含めて私的なデータ構造体の破棄が含まれている。 B<clnt_destroy>()  の呼び"
"出しの後に I<clnt> を使用することは未定義である。 RPC ライブラリが関連するソ"
"ケットをオープンした場合には、 それも閉じられる。それ以外の場合にはソケットは"
"オープンされたままである。"

#. type: Plain text
#: build/C/man3/rpc.3:221
#, no-wrap
msgid ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\n"
"B<                    unsigned long >I<vers>B<, char *>I<proto>B<);>\n"
msgstr ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\n"
"B<                    unsigned long >I<vers>B<, char *>I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:232
msgid ""
"Generic client creation routine.  I<host> identifies the name of the remote "
"host where the server is located.  I<proto> indicates which kind of "
"transport protocol to use.  The currently supported values for this field "
"are \\(lqudp\\(rq and \\(lqtcp\\(rq.  Default timeouts are set, but can be "
"modified using B<clnt_control>()."
msgstr ""
"一般的なクライアントの作成ルーティンである。 I<host> はサーバのあるリモートホ"
"ストの名前を指定する。 I<proto> どのような通信プロトコルを使用するかを指定す"
"る。現在ここに 使用できる値は \\(lqudp\\(rq と \\(lqtcp\\(rq である。 デフォ"
"ルトの時間切れが設定されるが、 B<clnt_control>()  を使用して変更可能である。"

#. type: Plain text
#: build/C/man3/rpc.3:237
msgid ""
"Warning: Using UDP has its shortcomings.  Since UDP-based RPC messages can "
"hold only up to 8 Kbytes of encoded data, this transport cannot be used for "
"procedures that take large arguments or return huge results."
msgstr ""
"警告: UDP を使用した場合には欠点がある。 UDP に基づいた RPC メッセージは 最大"
"でも 8 KByte のエンコードデータしか保持する ことができないため、大きな引き数"
"や巨大な結果を取るプロシジャに は使用することができない。"

#. type: Plain text
#: build/C/man3/rpc.3:240
#, no-wrap
msgid "B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"
msgstr "B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:251
msgid ""
"A macro used to change or retrieve various information about a client "
"object.  I<req> indicates the type of operation, and I<info> is a pointer to "
"the information.  For both UDP and TCP, the supported values of I<req> and "
"their argument types and what they do are:"
msgstr ""
"このマクロは各種クライアントについて情報を変更したり、取得したり するのに使用"
"する。 I<req> は操作の種類を指定する。 I<info> は情報へのポインターである。 "
"UDP と TCP どちらの場合も使用可能な I<req> の値と、その引き数の型、およびその"
"内容は以下の通りである:"

#. type: Plain text
#: build/C/man3/rpc.3:256
#, no-wrap
msgid ""
"B<CLSET_TIMEOUT>  I<struct timeval> // set total timeout\n"
"B<CLGET_TIMEOUT>  I<struct timeval> // get total timeout\n"
msgstr ""
"B<CLSET_TIMEOUT>  I<struct timeval> // 時間切れを設定する\n"
"B<CLGET_TIMEOUT>  I<struct timeval> // 時間切れを取得する\n"

#. type: Plain text
#: build/C/man3/rpc.3:264
msgid ""
"Note: if you set the timeout using B<clnt_control>(), the timeout parameter "
"passed to B<clnt_call>()  will be ignored in all future calls."
msgstr ""
"注意: B<clnt_control>()  を使用して時間切れを設定した場合にはそれ以後は "
"B<clnt_call>()  に渡される時間切れパラメーターは全て無視される。"

#. type: Plain text
#: build/C/man3/rpc.3:268
#, no-wrap
msgid "B<CLGET_SERVER_ADDR>  I<struct sockaddr_in > // get server's address\n"
msgstr "B<CLGET_SERVER_ADDR>  I<struct sockaddr_in > // サーバアドレスを取得する\n"

#. type: Plain text
#: build/C/man3/rpc.3:272
msgid "The following operations are valid for UDP only:"
msgstr "以下の操作は UDP の場合にのみ有効である:"

#. type: Plain text
#: build/C/man3/rpc.3:277
#, no-wrap
msgid ""
"B<CLSET_RETRY_TIMEOUT>  I<struct timeval> // set the retry timeout\n"
"B<CLGET_RETRY_TIMEOUT>  I<struct timeval> // get the retry timeout\n"
msgstr ""
"B<CLSET_RETRY_TIMEOUT>  I<struct timeval> // 再送間隔を設定する\n"
"B<CLGET_RETRY_TIMEOUT>  I<struct timeval> // 再送間隔を取得する\n"

#. type: Plain text
#: build/C/man3/rpc.3:283
msgid ""
"The retry timeout is the time that \"UDP RPC\" waits for the server to reply "
"before retransmitting the request."
msgstr ""
"再送間隔は次に要求を再送する前に \"UDP RPC\" がサーバの回答を待つ時間である。"

#. type: Plain text
#: build/C/man3/rpc.3:286
#, no-wrap
msgid "B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr "B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:297
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the results of an RPC call.  The parameter I<out> is the address of the "
"results, and I<outproc> is the XDR routine describing the results.  This "
"routine returns one if the results were successfully freed, and zero "
"otherwise."
msgstr ""
"このマクロは RPC 呼び出しの結果のデコードの際に RPC/XDR システムによって割当"
"てられたデータを解放する。 パラメーター I<out> は結果のアドレスである。 "
"I<outproc> は結果を記述している XDR ルーティンである。 このルーティンは結果の"
"解放に成功した場合には 1 を返す。 失敗した場合にはゼロを返す。"

#. type: Plain text
#: build/C/man3/rpc.3:300
#, no-wrap
msgid "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"
msgstr "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:305
msgid ""
"A macro that copies the error structure out of the client handle to the "
"structure at address I<errp>."
msgstr ""
"このマクロはクライアント・ハンドルのエラー構造体を I<errp> アドレスで指定され"
"た構造体へコピーする。"

#. type: Plain text
#: build/C/man3/rpc.3:308
#, no-wrap
msgid "B<void clnt_pcreateerror(char *>I<s>B<);>\n"
msgstr "B<void clnt_pcreateerror(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:322
msgid ""
"Print a message to standard error indicating why a client RPC handle could "
"not be created.  The message is prepended with string I<s> and a colon.  "
"Used when a B<clnt_create>(), B<clntraw_create>(), B<clnttcp_create>(), or "
"B<clntudp_create>()  call fails."
msgstr ""
"標準エラー出力に、なぜクライアント RPC ハンドルの作成が できなかったかについ"
"てのメッセージを表示する。 メッセージの前に文字列 I<s> とコロン(:)が表示され"
"る。 B<clnt_create>(), B<clntraw_create>(), B<clnttcp_create>(), "
"B<clntudp_create>()  の呼び出しが失敗した時に使用すること。"

#. type: Plain text
#: build/C/man3/rpc.3:325
#, no-wrap
msgid "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"
msgstr "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:332
msgid ""
"Print a message to standard error corresponding to the condition indicated "
"by I<stat>.  Used after B<callrpc>()."
msgstr ""
"標準エラー出力に I<stat> によって指示されるエラー状態に対応するメッセージを表"
"示する。 B<callrpc>()  の後に使用すること。"

#. type: Plain text
#: build/C/man3/rpc.3:335
#, no-wrap
msgid "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"
msgstr "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:345
msgid ""
"Print a message to standard error indicating why an RPC call failed; I<clnt> "
"is the handle used to do the call.  The message is prepended with string "
"I<s> and a colon.  Used after B<clnt_call>()."
msgstr ""
"標準エラー出力に、なぜ RPC 呼び出しが失敗したかについてのメッセージを表示す"
"る。 I<clnt> はコールに使用したハンドルである。 メッセージの前に文字列 I<s> "
"とコロン(:)が表示される。 B<clnt_call>()  が失敗した後に使用すること。"

#. type: Plain text
#: build/C/man3/rpc.3:348
#, no-wrap
msgid "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"
msgstr "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:353
msgid ""
"Like B<clnt_pcreateerror>(), except that it returns a string instead of "
"printing to the standard error."
msgstr ""
"B<clnt_pcreateerror>()  と同様であるが、標準エラー出力へ表示するかわりに文字"
"列を返す点が異っている。"

#. type: Plain text
#: build/C/man3/rpc.3:355 build/C/man3/rpc.3:395
msgid "Bugs: returns pointer to static data that is overwritten on each call."
msgstr "バグ: 静的な領域へのポインターを返すため、呼び出しごとに上書きされる。"

#. type: Plain text
#: build/C/man3/rpc.3:358
#, no-wrap
msgid "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"
msgstr "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:365
msgid ""
"Take the same arguments as B<clnt_perrno>(), but instead of sending a "
"message to the standard error indicating why an RPC call failed, return a "
"pointer to a string which contains the message.  The string ends with a "
"NEWLINE."
msgstr ""
"B<clnt_perrno>()  と同じ引き数を取るが、なぜ RPC 呼び出しが失敗したかについて"
"のメッセージを標準エラー出力に表示する かわりに、メッセージを格納している文字"
"列へのポインターを返す。 文字列は NEWLINE(改行) で終っている。"

#. type: Plain text
#: build/C/man3/rpc.3:383
msgid ""
"B<clnt_sperrno>()  is used instead of B<clnt_perrno>()  if the program does "
"not have a standard error (as a program running as a server quite likely "
"does not), or if the programmer does not want the message to be output with "
"B<printf>(3), or if a message format different than that supported by "
"B<clnt_perrno>()  is to be used.  Note: unlike B<clnt_sperror>()  and "
"B<clnt_spcreaterror>(), B<clnt_sperrno>()  returns pointer to static data, "
"but the result will not get overwritten on each call."
msgstr ""
"B<clnt_sperrno>()  はプログラムが標準エラー出力を持っていない場合(プログラム"
"がサーバとし て走っている場合にはよくありえる)や、プログラマーがメッセージを "
"B<printf>(3)  で出力することを望まない場合や、メッセージの形式が "
"B<clnt_perrno>()  がサポートするものとは異っている場合などに B<clnt_perrno>"
"()  のかわりに使用される。 注意: B<clnt_sperror>()  や B<clnt_spcreaterror>"
"()  とは違って B<clnt_sperrno>()  は静的データへのポインターを返す。しかし呼"
"び出しごとに上書きされることはない。"

#. type: Plain text
#: build/C/man3/rpc.3:386
#, no-wrap
msgid "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"
msgstr "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:393
msgid ""
"Like B<clnt_perror>(), except that (like B<clnt_sperrno>())  it returns a "
"string instead of printing to standard error."
msgstr ""
"B<clnt_perror>()  と同様であるが、標準エラー出力に表示する代りに "
"(B<clnt_sperrno>()  のように) 文字列へのポインターを返す点が異っている。"

#. type: Plain text
#: build/C/man3/rpc.3:399
#, no-wrap
msgid "B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"
msgstr "B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:412
msgid ""
"This routine creates a toy RPC client for the remote program I<prognum>, "
"version I<versnum>.  The transport used to pass messages to the service is "
"actually a buffer within the process's address space, so the corresponding "
"RPC server should live in the same address space; see B<svcraw_create>().  "
"This allows simulation of RPC and acquisition of RPC overheads, such as "
"round trip times, without any kernel interference.  This routine returns "
"NULL if it fails."
msgstr ""
"このルーティンはリモート・プログラム I<prognum>、 バージョン I<versnum> のた"
"めの擬似 RPC クライアントを作成する。メッセージをサービスに渡すために使用す"
"る 通信は実際にはそのプロセスのアドレス空間にあるバッファーである。 それで、"
"対応する RPC サーバが同じアドレス空間の中にいなければならない。 "
"B<svcraw_create>()  を参照すること。 これにより RPC のシミュレーションや、"
"カーネル・インターフェースに影響されずに 応答時間などの RPC オーバヘッドの獲"
"得ができる。 失敗した場合にはこのルーティンは NULL を返す。"

#. type: Plain text
#: build/C/man3/rpc.3:418
#, no-wrap
msgid ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >I<recvsz>B<);>\n"
msgstr ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >I<recvsz>B<);>\n"

#. The following inline font conversion is necessary for the hyphen indicator
#. type: Plain text
#: build/C/man3/rpc.3:448
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses TCP/IP as a transport.  The remote "
"program is located at Internet address I<*addr>.  If I<addr-E<gt>sin_port> "
"is zero, then it is set to the actual port that the remote program is "
"listening on (the remote B<portmap> service is consulted for this "
"information).  The parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, "
"then this routine opens a new one and sets I<sockp>.  Since TCP-based RPC "
"uses buffered I/O, the user may specify the size of the send and receive "
"buffers with the parameters I<sendsz> and I<recvsz>; values of zero choose "
"suitable defaults.  This routine returns NULL if it fails."
msgstr ""
"このルーティンはリモート・プログラム I<prognum>、 バージョン I<versnum> のた"
"めの RPC クライアントを作成する。クライアントは通信に TCP/IP を使用する。リ"
"モート・プログラムはインターネット・アドレスの I<*addr> にある。 I<addr-"
"E<gt>sin_port> がゼロならば、実際にリモート・プログラムが listen しているポー"
"トが設定される。(この情報のためにリモートの B<portmap> サービスが利用され"
"る。) パラメーター I<sockp> はソケットである。もしこれが B<RPC_ANYSOCK> に設"
"定されている場合は、このルーティンが新しいソケットをオープンして I<sockp> に"
"設定する。 TCP に基づいた RPC はバッファされた I/O を使用するため、ユーザはパ"
"ラメーター I<sendsz> と I<recvsz> を使用して送信バッファと受信バッファのサイ"
"ズを指定することができる。 ゼロを指定した場合には適切なデフォルトが選択され"
"る。 このルーティンは失敗した場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/rpc.3:453
#, no-wrap
msgid ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"
msgstr ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:479
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses use UDP/IP as a transport.  The remote "
"program is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is "
"zero, then it is set to actual port that the remote program is listening on "
"(the remote B<portmap> service is consulted for this information).  The "
"parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine "
"opens a new one and sets I<sockp>.  The UDP transport resends the call "
"message in intervals of I<wait> time until a response is received or until "
"the call times out.  The total time for the call to time out is specified by "
"B<clnt_call>()."
msgstr ""
"このルーティンはリモート・プログラム I<prognum>、 バージョン I<versnum> のた"
"めの RPC クライアントを作成する。クライアントは通信に UDP/IP を使用する。リ"
"モート・プログラムはインターネット・アドレスの I<*addr> にある。 I<addr-"
"E<gt>sin_port> がゼロならば、実際にリモート・プログラムが listen しているポー"
"トが設定される。(この情報のためにリモートの B<portmap> サービスが利用され"
"る。) パラメーター I<sockp> はソケットである。もしこれが B<RPC_ANYSOCK> に設"
"定されている場合は、このルーティンが新しいソケットをオープンして I<sockp> に"
"設定する。 UDP 通信は回答があるか、時間切れが起こるまで B<wait> 間隔で呼び出"
"しメッセージを再送する。時間切れが起こるまでの合計時間は B<clnt_call>()  で指"
"定する。"

#. type: Plain text
#: build/C/man3/rpc.3:483
msgid ""
"Warning: since UDP-based RPC messages can hold only up to 8 Kbytes of "
"encoded data, this transport cannot be used for procedures that take large "
"arguments or return huge results."
msgstr ""
"警告: UDP に基づいた RPC メッセージは最大でも 8 Kbyte までのエンコードされた"
"データしか 保持できないため、この通信は大きな引き数や巨大な結果を取る プロシ"
"ジャには使用できない。"

#. type: Plain text
#: build/C/man3/rpc.3:489
#, no-wrap
msgid ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\n"
"B<            unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<            struct timeval >I<wait>B<, int *>I<sockp>B<,>\n"
"B<            unsigned int >I<sendsize>B<, unsigned int >I<recosize>B<);>\n"
msgstr ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\n"
"B<            unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<            struct timeval >I<wait>B<, int *>I<sockp>B<,>\n"
"B<            unsigned int >I<sendsize>B<, unsigned int >I<recosize>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:515
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, on "
"I<versnum>; the client uses use UDP/IP as a transport.  The remote program "
"is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is zero, "
"then it is set to actual port that the remote program is listening on (the "
"remote B<portmap> service is consulted for this information).  The parameter "
"I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine opens a new "
"one and sets I<sockp>.  The UDP transport resends the call message in "
"intervals of I<wait> time until a response is received or until the call "
"times out.  The total time for the call to time out is specified by "
"B<clnt_call>()."
msgstr ""
"このルーティンはリモート・プログラム I<prognum>、 バージョン I<versnum> のた"
"めの RPC クライアントを作成する。クライアントは通信に UDP/IP を使用する。リ"
"モート・プログラムはインターネット・アドレスの I<*addr> にある。 I<addr-"
"E<gt>sin_port> がゼロならば、実際にリモート・プログラムが listen しているポー"
"トが設定される。(この情報のためにリモートの B<portmap> サービスが利用され"
"る。) パラメーター I<sockp> はソケットである。もしこれが B<RPC_ANYSOCK> に設"
"定されている場合は、このルーティンが新しいソケットをオープンして I<sockp> に"
"設定する。 UDP 通信は回答があるか、時間切れが起こるまで B<wait> 間隔で呼び出"
"しメッセージを再送する。時間切れが起こるまでの合計時間は B<clnt_call>()  で指"
"定する。"

#. type: Plain text
#: build/C/man3/rpc.3:518 build/C/man3/rpc.3:995
msgid ""
"This allows the user to specify the maximum packet size for sending and "
"receiving UDP-based RPC messages."
msgstr ""
"これを使用すると UDP に基づいた RPC メッセージにおいて送信パケットや 受信パ"
"ケットの最大サイズを指定することが可能になる。"

#. type: Plain text
#: build/C/man3/rpc.3:521
#, no-wrap
msgid "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:529
msgid ""
"Stuff the machine's IP address into I<*addr>, without consulting the library "
"routines that deal with I</etc/hosts>.  The port number is always set to "
"B<htons(PMAPPORT)>."
msgstr ""
"このマシンの IP アドレスを I<*addr> に格納する。 I</etc/hosts> を扱うライブラ"
"リ・ルーティンは使用しない。ポート番号は常に B<htons(PMAPPORT)> に設定され"
"る。"

#. type: Plain text
#: build/C/man3/rpc.3:532
#, no-wrap
msgid "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:543
msgid ""
"A user interface to the B<portmap> service, which returns a list of the "
"current RPC program-to-port mappings on the host located at IP address "
"I<*addr>.  This routine can return NULL.  The command I<rpcinfo\\ -p> uses "
"this routine."
msgstr ""
"B<portmap> サービスのためのユーザインターフェースであり、 IP アドレス "
"I<*addr> にあるホストの現在の RPC プログラムからポート番号へのマッピングの一"
"覧を返す。 このルーティンが NULL を返す場合もある。 `B<rpcinfo -p>' コマンド"
"はこのルーティンを使用している。"

#. type: Plain text
#: build/C/man3/rpc.3:548
#, no-wrap
msgid ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned int >I<protocol>B<);>\n"
msgstr ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned int >I<protocol>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:572
msgid ""
"A user interface to the B<portmap> service, which returns the port number on "
"which waits a service that supports program number I<prognum>, version "
"I<versnum>, and speaks the transport protocol associated with I<protocol>.  "
"The value of I<protocol> is most likely B<IPPROTO_UDP> or B<IPPROTO_TCP>.  A "
"return value of zero means that the mapping does not exist or that the RPC "
"system failed to contact the remote B<portmap> service.  In the latter case, "
"the global variable I<rpc_createerr> contains the RPC status."
msgstr ""
"B<portmap> サービスのためのユーザ・インターフェースで、 プログラム番号 "
"I<prognum>、 バージョン I<versnum>、 関連付けられた通信プロトコル "
"I<protocol> をサポートするサービスが待っているポート番号を返す。 I<protocol> "
"の値はほとんどの場合 IPPROTO_UDP か IPPROTO_TCP である。 返り値ゼロはマッピン"
"グが存在しないか、 RPC システムがリモートの B<portmap> サービスの参照に失敗し"
"たことを意味する。後者の場合は大域変数 I<rpc_createerr> が RPC 状態を保持して"
"いる。"

#. type: Plain text
#: build/C/man3/rpc.3:580
#, no-wrap
msgid ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<, unsigned long *>I<portp>B<);>\n"
msgstr ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<, unsigned long *>I<portp>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:600
msgid ""
"A user interface to the B<portmap> service, which instructs B<portmap> on "
"the host at IP address I<*addr> to make an RPC call on your behalf to a "
"procedure on that host.  The parameter I<*portp> will be modified to the "
"program's port number if the procedure succeeds.  The definitions of other "
"parameters are discussed in B<callrpc>()  and B<clnt_call>().  This "
"procedure should be used for a \\(lqping\\(rq and nothing else.  See also "
"B<clnt_broadcast>()."
msgstr ""
"B<portmap> サービスのためのユーザ・インターフェースで、 IP アドレス I<*addr> "
"のホストの B<portmap> を参照して、 RPC 呼び出しを生成し、そのホスト上のプロシ"
"ジャを呼び出す。 パラメーター I<*portp> はプロシジャが成功した場合にはプログ"
"ラムのポート番号に修正される。 他のパラメーターの定義については B<callrpc>"
"()  や B<clnt_call>()  で説明してある。 このプロシジャは \\(lqping\\(rq のみ"
"に使用すべきである。 B<clnt_broadcast>()  も参照すること。"

#. type: Plain text
#: build/C/man3/rpc.3:604
#, no-wrap
msgid ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>\n"
msgstr ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:624
msgid ""
"A user interface to the B<portmap> service, which establishes a mapping "
"between the triple [I<prognum>,I<versnum>,I<protocol>] and I<port> on the "
"machine's B<portmap> service.  The value of I<protocol> is most likely "
"B<IPPROTO_UDP> or B<IPPROTO_TCP>.  This routine returns one if it succeeds, "
"zero otherwise.  Automatically done by B<svc_register>()."
msgstr ""
"B<portmap> サービスのためのユーザ・インターフェースで、 [I<prognum>,"
"I<versnum>,I<protocol>] の組み合わせと I<port> との間のマッピングを、そのマシ"
"ン上の B<portmap> サービスに登録する。 I<protocol> はほとんどの場合 "
"B<IPPROTO_UDP> か B<IPPROTO_TCP> のどちらかである。 このルーティンは成功した"
"場合には 1 を返す。失敗した場合にはゼロを返す。 B<svc_register>()  によって自"
"動的に実行される。"

#. type: Plain text
#: build/C/man3/rpc.3:627
#, no-wrap
msgid "B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"
msgstr "B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:639
msgid ""
"A user interface to the B<portmap> service, which destroys all mapping "
"between the triple [I<prognum>,I<versnum>,I<*>] and B<ports> on the "
"machine's B<portmap> service.  This routine returns one if it succeeds, zero "
"otherwise."
msgstr ""
"B<portmap> サービスのためのユーザ・インターフェースで、 [I<prognum>,"
"I<versnum>,I<*>] の組み合わせと B<ports> の間のマッピングをそのマシン上の "
"B<portmap> サービスから削除する。このルーティンは成功した場合は 1 を返す。 失"
"敗した場合には 0 を返す。"

#. type: Plain text
#: build/C/man3/rpc.3:644
#, no-wrap
msgid ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char *),>\n"
"B<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"
msgstr ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char *),>\n"
"B<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:664
msgid ""
"Register procedure I<procname> with the RPC service package.  If a request "
"arrives for program I<prognum>, version I<versnum>, and procedure "
"I<procnum>, I<procname> is called with a pointer to its parameter(s); "
"I<progname> should return a pointer to its static result(s); I<inproc> is "
"used to decode the parameters while I<outproc> is used to encode the "
"results.  This routine returns zero if the registration succeeded, -1 "
"otherwise."
msgstr ""
"RPC サービスパッケージを使用して I<procname> プロシジャを登録する。プログラ"
"ム I<prognum>、 バージョン I<versnum>、 プロシジャ I<procnum> への要求が届い"
"た場合、 I<procname> がパラメーターへのポインターを持って呼び出される。 "
"I<progname> は静的な結果へのポインターを返す必要がある。 I<inproc> はパラメー"
"ターをデコードするために使用される。 I<outproc> は結果をエンコードするために"
"使用される。 このルーティンは登録に成功した場合にはゼロを返す。 失敗した場合"
"には -1 を返す。"

#. type: Plain text
#: build/C/man3/rpc.3:669
msgid ""
"Warning: remote procedures registered in this form are accessed using the "
"UDP/IP transport; see B<svcudp_create>()  for restrictions."
msgstr ""
"警告: この形式で登録されたリモート・プロシジャは UDP/IP 通信を使用する。制限"
"に関しては B<svcudp_create>()  を参照すること。"

#. type: Plain text
#: build/C/man3/rpc.3:672
#, no-wrap
msgid "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"
msgstr "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"

#. type: Plain text
#: build/C/man3/rpc.3:679
msgid ""
"A global variable whose value is set by any RPC client creation routine that "
"does not succeed.  Use the routine B<clnt_pcreateerror>()  to print the "
"reason why."
msgstr ""
"成功しなかった RPC クライアント生成ルーティンによって設定される大域変数。 "
"B<clnt_pcreateerror>()  ルーティンが理由を表示するために使用する。"

#. type: Plain text
#: build/C/man3/rpc.3:682
#, no-wrap
msgid "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:693
msgid ""
"A macro that destroys the RPC service transport handle, I<xprt>.  "
"Destruction usually involves deallocation of private data structures, "
"including I<xprt> itself.  Use of I<xprt> is undefined after calling this "
"routine."
msgstr ""
"このマクロは通信ハンドル I<xprt> の RPC サービスを破壊する。破壊には通常、 "
"I<xprt> を含めて、私的なデータ構造体の破棄が含まれている。 このルーティンを呼"
"び出した後に I<xprt> を使用することは未定義である。"

#. type: Plain text
#: build/C/man3/rpc.3:696
#, no-wrap
msgid "B<fd_set >I<svc_fdset>B<;>\n"
msgstr "B<fd_set >I<svc_fdset>B<;>\n"

#. type: Plain text
#: build/C/man3/rpc.3:710
msgid ""
"A global variable reflecting the RPC service side's read file descriptor bit "
"mask; it is suitable as a parameter to the B<select>(2)  system call.  This "
"is of interest only if a service implementor does not call B<svc_run>(), but "
"rather does his own asynchronous event processing.  This variable is read-"
"only (do not pass its address to B<select>(2)!), yet it may change after "
"calls to B<svc_getreqset>()  or any creation routines."
msgstr ""
"RPC サービス側のファイル・ディスクリプターのビットマスクを反映した大域変数。 "
"B<select>(2)  システムコールのパラメーターのために利用できる。これは サービス"
"の実装者が B<svc_run>()  を呼び出さなずに、独自の非同期イベント処理を用いる場"
"合にのみ意味がある。 この変数は読み込み専用で (そのまま B<select>(2)  へ渡し"
"てはならない!)、 B<svc_getreqset>()  呼び出しや生成ルーティンの後に変更されて"
"いるかもしれない。"

#. type: Plain text
#: build/C/man3/rpc.3:713
#, no-wrap
msgid "B<int >I<svc_fds>B<;>\n"
msgstr "B<int >I<svc_fds>B<;>\n"

#. type: Plain text
#: build/C/man3/rpc.3:720
msgid ""
"Similar to B<svc_fdset>, but limited to 32 descriptors.  This interface is "
"obsoleted by B<svc_fdset>."
msgstr ""
"B<svc_fdset> に似ているが、32 ディスクリプターに制限されている。 このインター"
"フェースは B<svc_fdset> によって置き換えられた。"

#. type: Plain text
#: build/C/man3/rpc.3:723
#, no-wrap
msgid "B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"
msgstr "B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:730
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the arguments to a service procedure using B<svc_getargs>().  This routine "
"returns 1 if the results were successfully freed, and zero otherwise."
msgstr ""
"このマクロはサービス・プロシジャが B<svc_getargs>()  を使用して引き数をデコー"
"ドした時に RPC/XDR システムによって割り当てられたデータを解放する。 このルー"
"ティンは解放に成功した場合には 1 を返す。 失敗した場合にはゼロを返す。"

#. type: Plain text
#: build/C/man3/rpc.3:733
#, no-wrap
msgid "B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"
msgstr "B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:744
msgid ""
"A macro that decodes the arguments of an RPC request associated with the RPC "
"service transport handle, I<xprt>.  The parameter I<in> is the address where "
"the arguments will be placed; I<inproc> is the XDR routine used to decode "
"the arguments.  This routine returns one if decoding succeeds, and zero "
"otherwise."
msgstr ""
"このマクロは RPC サービス通信ハンドル I<xprt> に関連付けられた RPC 要求の引き"
"数をデコードする。パラメーター I<in> は引き数の格納されたアドレスである。 "
"I<inproc> は引き数をデコードするための XDR ルーティンである。 このルーティン"
"はデコードに成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/rpc.3:747
#, no-wrap
msgid "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:752
msgid ""
"The approved way of getting the network address of the caller of a procedure "
"associated with the RPC service transport handle, I<xprt>."
msgstr ""
"RPC サービス通信ハンドル I<xprt> に関連付けられたプロシジャの呼び出し元のネッ"
"トワーク・アドレスを 取得するための標準的な手段。"

#. type: Plain text
#: build/C/man3/rpc.3:755
#, no-wrap
msgid "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"
msgstr "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:769
msgid ""
"This routine is of interest only if a service implementor does not call "
"B<svc_run>(), but instead implements custom asynchronous event processing.  "
"It is called when the B<select>(2)  system call has determined that an RPC "
"request has arrived on some RPC socket(s); I<rdfds> is the resultant read "
"file descriptor bit mask.  The routine returns when all sockets associated "
"with the value of I<rdfds> have been serviced."
msgstr ""
"このルーティンはサービスの実装者が B<svc_run>()  を呼び出さず、独自の非同期イ"
"ベント処理を実装する場合にのみ意味がある。 これは B<select>(2)  システムコー"
"ルが RPC ソケットに RPC 要求が到着したと返した場合にのみ呼び出される。 "
"I<rdfds> は結果の読み込みファイル・ディスクリプターのビットマスクである。 こ"
"のルーティンは I<rdfds> の値に関連付けられた全てのソケットのサービスが行なわ"
"れた時に 返ってくる。"

#. type: Plain text
#: build/C/man3/rpc.3:772
#, no-wrap
msgid "B<void svc_getreq(int >I<rdfds>B<);>\n"
msgstr "B<void svc_getreq(int >I<rdfds>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:779
msgid ""
"Similar to B<svc_getreqset>(), but limited to 32 descriptors.  This "
"interface is obsoleted by B<svc_getreqset>()."
msgstr ""
"B<svc_getreqset>()  に似ているがディスクリプターの数が 32 に制限されている。 "
"このインターフェースは B<svc_getreqset>()  によって置き換えられた。"

#. type: Plain text
#: build/C/man3/rpc.3:785
#, no-wrap
msgid ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\n"
"B<                    unsigned long >I<versnum>B<,>\n"
"B<                    void (*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\n"
"B<                    unsigned long >I<protocol>B<);>\n"
msgstr ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\n"
"B<                    unsigned long >I<versnum>B<,>\n"
"B<                    void (*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\n"
"B<                    unsigned long >I<protocol>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:815
msgid ""
"Associates I<prognum> and I<versnum> with the service dispatch procedure, "
"I<dispatch>.  If I<protocol> is zero, the service is not registered with the "
"B<portmap> service.  If I<protocol> is nonzero, then a mapping of the triple "
"[I<prognum>,I<versnum>,I<protocol>] to I<xprt-E<gt>xp_port> is established "
"with the local B<portmap> service (generally I<protocol> is zero, "
"B<IPPROTO_UDP> or B<IPPROTO_TCP>).  The procedure I<dispatch> has the "
"following form:"
msgstr ""
"I<prognum> と I<versnum> をサービス配分プロシジャ I<dispatch> で関連付ける。 "
"I<protocol> がゼロの場合、サービスは B<portmap> サービスには登録されない。 "
"I<protocol> がゼロ以外の場合、 [I<prognum>,I<versnum>,I<protocol>] の組み合わ"
"せと I<xprt-E<gt>xp_port> とのマッピングがローカルの B<portmap> サービスに登"
"録される。(一般的に I<protocol> はゼロ、 B<IPPROTO_UDP>、 B<IPPROTO_TCP> のど"
"れかである。)  プロシジャ I<dispatch> は以下の形式である:"

#. type: Plain text
#: build/C/man3/rpc.3:819
#, no-wrap
msgid "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"
msgstr "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"

#. type: Plain text
#: build/C/man3/rpc.3:825
msgid ""
"The B<svc_register>()  routine returns one if it succeeds, and zero "
"otherwise."
msgstr ""
"B<svc_register>()  ルーティンは成功した場合は 1 を返す。失敗した場合はゼロを"
"返す。"

#. type: Plain text
#: build/C/man3/rpc.3:828
#, no-wrap
msgid "B<void svc_run(void);>\n"
msgstr "B<void svc_run(void);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:838
msgid ""
"This routine never returns.  It waits for RPC requests to arrive, and calls "
"the appropriate service procedure using B<svc_getreq>()  when one arrives.  "
"This procedure is usually waiting for a B<select>(2)  system call to return."
msgstr ""
"このルーティンは戻ってこない。これは E<.SM RPC> 要求の到着を待ち、どれかが届"
"いた場合に B<svc_getreq>()  を使用して適切なサービス・プロシジャを呼び出す。 "
"このプロシジャは通常は B<select>(2)  システムコールから返るのを待っている。"

#. type: Plain text
#: build/C/man3/rpc.3:842
#, no-wrap
msgid "B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr "B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:854
msgid ""
"Called by an RPC service's dispatch routine to send the results of a remote "
"procedure call.  The parameter I<xprt> is the request's associated transport "
"handle; I<outproc> is the XDR routine which is used to encode the results; "
"and I<out> is the address of the results.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"RPC サービス配分ルーティンによってリモート・プロシジャ・コールの結果を 返すた"
"めに呼び出される。 パラメーター I<xprt> はその要求に関連付けられた通信ハンド"
"ルである。 I<outproc> は結果をエンコードするために使用する XDR ルーティンであ"
"る。 I<out> は結果のアドレスである。このルーティンは成功した場合は 1 を返"
"す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/rpc.3:857
#, no-wrap
msgid "B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"
msgstr "B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:864
msgid ""
"Remove all mapping of the double [I<prognum>,I<versnum>] to dispatch "
"routines, and of the triple [I<prognum>,I<versnum>,I<*>] to port number."
msgstr ""
"配分ルーティンから [I<prognum>,I<versnum>] および [I<prognum>,I<versnum>,"
"I<*>] の組み合わせからポート番号へのマッピングを全て削除する。"

#. type: Plain text
#: build/C/man3/rpc.3:867
#, no-wrap
msgid "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"
msgstr "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:871
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to an authentication error."
msgstr ""
"認証エラーによりリモート・プロシジャ・コールの実行を拒否された 場合にサービス"
"配分ルーティンによって呼び出される。"

#. type: Plain text
#: build/C/man3/rpc.3:874
#, no-wrap
msgid "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:880
msgid ""
"Called by a service dispatch routine that cannot successfully decode its "
"parameters.  See also B<svc_getargs>()."
msgstr ""
"パラメータのデコードに失敗した場合に サービス配分ルーティンによって呼び出され"
"る。 B<svc_getargs>()  も参照すること。"

#. type: Plain text
#: build/C/man3/rpc.3:883
#, no-wrap
msgid "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:887
msgid ""
"Called by a service dispatch routine that does not implement the procedure "
"number that the caller requests."
msgstr ""
"要求のあったプロシジャ番号が実装されていない場合に サービス配分ルーティンより"
"呼び出される。"

#. type: Plain text
#: build/C/man3/rpc.3:890
#, no-wrap
msgid "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:894
msgid ""
"Called when the desired program is not registered with the RPC package.  "
"Service implementors usually do not need this routine."
msgstr ""
"RPC パッケージに要求されたプログラムが登録されていない場合に呼び出される。 "
"サービスの実装には通常、このルーティンは必要ない。"

#. type: Plain text
#: build/C/man3/rpc.3:897
#, no-wrap
msgid "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:902
msgid ""
"Called when the desired version of a program is not registered with the RPC "
"package.  Service implementors usually do not need this routine."
msgstr ""
"RPC パッケージに要求されたバージョンのプログラムが登録されていない場合に 呼び"
"出される。サービスの実装には通常、このルーティンは必要ない。"

#. type: Plain text
#: build/C/man3/rpc.3:905
#, no-wrap
msgid "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:911
msgid ""
"Called by a service dispatch routine when it detects a system error not "
"covered by any particular protocol.  For example, if a service can no longer "
"allocate storage, it may call this routine."
msgstr ""
"特定のプロトコルによってカバーされていなシステム・エラーが 検出された場合に"
"サービス配分ルーティンによって呼び出される。 例えば、サービスがそれ以上、記憶"
"装置を割り当てることができない場合には このルーティンが呼び出されるかもしれな"
"い。"

#. type: Plain text
#: build/C/man3/rpc.3:914
#, no-wrap
msgid "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:920
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to insufficient authentication parameters.  The routine "
"calls B<svcerr_auth(xprt, AUTH_TOOWEAK)>."
msgstr ""
"認証パラメータが足りないためにリモート・プロシジャ・コールの実行を 拒否された"
"場合にサービス配分ルーティンによって呼び出される。 このルーティンは "
"B<svcerr_auth(xprt, AUTH_TOOWEAK)> を呼び出す。"

#. type: Plain text
#: build/C/man3/rpc.3:924
#, no-wrap
msgid ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\n"
"B<                      unsigned int >I<recvsize>B<);>\n"
msgstr ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\n"
"B<                      unsigned int >I<recvsize>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:934
msgid ""
"Create a service on top of any open descriptor.  Typically, this descriptor "
"is a connected socket for a stream protocol such as TCP.  I<sendsize> and "
"I<recvsize> indicate sizes for the send and receive buffers.  If they are "
"zero, a reasonable default is chosen."
msgstr ""
"任意のオープンされたディスクリプター上にサービスを作成する。 典型的に、ディス"
"クリプターは TCP のようなストリーム・プロトコルで接続されたソケットである。 "
"I<sendsize> と I<recvsize> には送信バッファと受信バッファの大きさを指定する。"
"もしゼロが指定された 場合は適切なデフォルトが選択される。"

#. type: Plain text
#: build/C/man3/rpc.3:937
#, no-wrap
msgid "B<SVCXPRT *svcraw_create(void);>\n"
msgstr "B<SVCXPRT *svcraw_create(void);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:947
msgid ""
"This routine creates a toy RPC service transport, to which it returns a "
"pointer.  The transport is really a buffer within the process's address "
"space, so the corresponding RPC client should live in the same address "
"space; see B<clntraw_create>().  This routine allows simulation of RPC and "
"acquisition of RPC overheads (such as round trip times), without any kernel "
"interference.  This routine returns NULL if it fails."
msgstr ""
"このルーティンは擬似 RPC サービス通信を生成して、そのポインターを返す。 通信"
"は実際にはそのプロセスのアドレス空間にあるバッファなので 対応する RPC クライ"
"アントは同じアドレス空間にいる必要がある。 B<clntraw_create>()  を参照するこ"
"と。 このルーティンで RPC のシミュレーションや、カーネル・インターフェースに"
"影響されずに応答時間などの RPC オーバヘッドを取得ができる。このルーティンは失"
"敗した場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/rpc.3:951
#, no-wrap
msgid ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>\n"
"B<                       unsigned int >I<recv_buf_size>B<);>\n"
msgstr ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>\n"
"B<                       unsigned int >I<recv_buf_size>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:971
msgid ""
"This routine creates a TCP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local TCP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number.  "
"This routine returns NULL if it fails.  Since TCP-based RPC uses buffered I/"
"O, users may specify the size of buffers; values of zero choose suitable "
"defaults."
msgstr ""
"このルーティンは TCP/IP に基づく RPC サービス通信を作成し、それへのポインター"
"を返す。 通信はソケット I<sock> に結びつけられる。 I<sock> は B<RPC_ANYSOCK> "
"でも良い。この場合は新しいソケットが作成される。 もしソケットがローカルな "
"TCP ポートに bind されていない場合は、 このルーティンが適当なポートに bind す"
"る。 補完された場合、I<xprt-E<gt>xp_sock> には通信のソケット・ ディスクリプ"
"ターが、I<xprt-E<gt>xp_port> には通信のポート番号が 設定される。 このルーティ"
"ンは失敗した場合は NULL を返す。 TCP に基づいた RPC はバッファされた I/O を使"
"用するため、 ユーザはバッファの大きさを指定できる。 ゼロを指定した場合は適切"
"なデフォルトが選択される。"

#. type: Plain text
#: build/C/man3/rpc.3:975
#, no-wrap
msgid ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\n"
"B<                          unsigned int >I<recosize>B<);>\n"
msgstr ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\n"
"B<                          unsigned int >I<recosize>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:992
msgid ""
"This routine creates a UDP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local UDP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number.  "
"This routine returns NULL if it fails."
msgstr ""
"このルーティンは UDP/IP に基づいた RPC サービス通信を作成し、 そのポインター"
"を返す。通信はソケット I<sock> に関連付けられる。 I<sock> は B<RPC_ANYSOCK> "
"でも良い。この場合は新しいソケットが作成される。 ソケットがローカルの UDP "
"ポートに bind されていない場合には このルーティンは適当なポートに bind す"
"る。 補完された場合、I<xprt-E<gt>xp_sock> に通信のソケットの ディスクリプター"
"が、I<xprt-E<gt>xp_port> に通信のポート番号が 設定される。このルーティンは失"
"敗した場合には NULL を返す。"

#. type: Plain text
#: build/C/man3/rpc.3:998
#, no-wrap
msgid "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"
msgstr "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1004
msgid ""
"This call is equivalent to I<svcudp_bufcreate(sock,SZ,SZ)> for some default "
"size I<SZ>."
msgstr ""
"送信パケットと受信パケットのサイズを同じデフォルトの値 I<SZ> に指定した "
"I<svcudp_bufcreate(sock,SZ,SZ)> と等価である。"

#. type: Plain text
#: build/C/man3/rpc.3:1007
#, no-wrap
msgid "B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply *>I<ar>B<);>\n"
msgstr "B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply *>I<ar>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1012
msgid ""
"Used for encoding RPC reply messages.  This routine is useful for users who "
"wish to generate RPC-style messages without using the RPC package."
msgstr ""
"RPC 応答メッセージをエンコードするのに使用する。このルーティンは RPC パッケー"
"ジを用いずに RPC-形式のメッセージを作成しようとする場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1015
#, no-wrap
msgid "B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms *>I<aupp>B<);>\n"
msgstr "B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms *>I<aupp>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1021
msgid ""
"Used for describing UNIX credentials.  This routine is useful for users who "
"wish to generate these credentials without using the RPC authentication "
"package."
msgstr ""
"UNIX 形式の証明書を記述するために使用する。このルーティンは RPC 認証パッケー"
"ジを使用せずにこれらの証明書を作成しようとする場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1024
#, no-wrap
msgid "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"
msgstr "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1029
msgid ""
"Used for describing RPC call header messages.  This routine is useful for "
"users who wish to generate RPC-style messages without using the RPC package."
msgstr ""
"RPC 呼び出しのヘッダー・メッセージを記述するために使用する。 このルーティン"
"は RPC パッケージを使用せずに RPC-形式のメッセージを作成しようとする場合に便"
"利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1032
#, no-wrap
msgid "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"
msgstr "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1037
msgid ""
"Used for describing RPC call messages.  This routine is useful for users who "
"wish to generate RPC-style messages without using the RPC package."
msgstr ""
"RPC 呼び出しメッセージを記述するのに使用する。 このルーティンは RPC パッケー"
"ジを使用せずに RPC-形式のメッセージを作成しようとする場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1040
#, no-wrap
msgid "B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"
msgstr "B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1045
msgid ""
"Used for describing RPC authentication information messages.  This routine "
"is useful for users who wish to generate RPC-style messages without using "
"the RPC package."
msgstr ""
"PRC 認証情報メッセージを記述するために使用する。 このルーティンは RPC パッ"
"ケージを使用せずに RPC-形式のメッセージを作成しようとする場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1048
#, no-wrap
msgid "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"
msgstr "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1057
msgid ""
"Used for describing parameters to various B<portmap> procedures, "
"externally.  This routine is useful for users who wish to generate these "
"parameters without using the B<pmap> interface."
msgstr ""
"各種の B<portmap> プロシジャへのパラメーターを外部的に記述するために使用す"
"る。 このルーティンは B<pmap> インターフェースを使用せずに、これらのパラメー"
"ターを 作成したい場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1060
#, no-wrap
msgid "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"
msgstr "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1067
msgid ""
"Used for describing a list of port mappings, externally.  This routine is "
"useful for users who wish to generate these parameters without using the "
"B<pmap> interface."
msgstr ""
"ポートのマッピングのリストを外部的に記述するために使用する。 このルーティン"
"は B<pmap> インターフェースを使用せずに、これらのパラメーターを 作成したい場"
"合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1070
#, no-wrap
msgid "B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply *>I<rr>B<);>\n"
msgstr "B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply *>I<rr>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1075
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC-style messages without using the RPC package."
msgstr ""
"RPC 応答メッセージを記述するために使用する。このルーティンは RPC パッケージを"
"使用せずに、 RPC-形式のメッセージを作成したい場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1078
#, no-wrap
msgid "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"
msgstr "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1083
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC style messages without using the RPC package."
msgstr ""
"RPC 応答メッセージを記述するために使用する。 このルーティンは RPC パッケージ"
"を使用せずに、 RPC 形式のメッセージを作成したい場合に便利である。"

#. type: Plain text
#: build/C/man3/rpc.3:1086
#, no-wrap
msgid "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1093
msgid ""
"After RPC service transport handles are created, they should register "
"themselves with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""
"RPC サービス通信ハンドルを生成した後に、それら自身を RPC サービス・パッケージ"
"に登録する必要がある。 このルーティンは大域変数 I<svc_fds> を修正する。サービ"
"スの実装者は通常、このルーティンは必要ない。"

#. type: Plain text
#: build/C/man3/rpc.3:1096
#, no-wrap
msgid "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: build/C/man3/rpc.3:1103
msgid ""
"Before an RPC service transport handle is destroyed, it should unregister "
"itself with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""
"RPC サービス通信ハンドルを破壊する前に、それを RPC 通信パッケージから登録解除"
"する必要がある。 このルーティンは大域変数 I<svc_fds> を修正する。サービスの実"
"装者は通常、このルーティンは必要ない。"

#.  We don't have an rpc_secure.3 page in the set at the moment -- MTK, 19 Sep 05
#.  .BR rpc_secure (3),
#. type: Plain text
#: build/C/man3/rpc.3:1107
msgid "B<xdr>(3)"
msgstr "B<xdr>(3)"

#. type: Plain text
#: build/C/man3/rpc.3:1109 build/C/man3/xdr.3:546
msgid "The following manuals:"
msgstr "以下のマニュアル:"

#. type: Plain text
#: build/C/man3/rpc.3:1111
msgid "Remote Procedure Calls: Protocol Specification"
msgstr "Remote Procedure Calls: Protocol Specification"

#. type: Plain text
#: build/C/man3/rpc.3:1113
msgid "Remote Procedure Call Programming Guide"
msgstr "Remote Procedure Call Programming Guide"

#. type: Plain text
#: build/C/man3/rpc.3:1115
msgid "rpcgen Programming Guide"
msgstr "rpcgen Programming Guide"

#. type: Plain text
#: build/C/man3/rpc.3:1121
msgid ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."
msgstr ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."

#. type: TH
#: build/C/man5/rpc.5:8
#, no-wrap
msgid "1985-09-26"
msgstr "1985-09-26"

#. type: Plain text
#: build/C/man5/rpc.5:11
msgid "rpc - RPC program number data base"
msgstr "rpc - RPC プログラム番号のデータベース"

#. type: Plain text
#: build/C/man5/rpc.5:13
msgid "B</etc/rpc>"
msgstr "B</etc/rpc>"

#. type: Plain text
#: build/C/man5/rpc.5:19
msgid ""
"The I<rpc> file contains user readable names that can be used in place of "
"RPC program numbers.  Each line has the following information:"
msgstr ""
"I<rpc> ファイルには RPC プログラム番号の代わりに使うことのできる ユーザーに可"
"読な名前が入っている。それぞれの行は以下の情報を含む。"

#. type: Plain text
#: build/C/man5/rpc.5:21
msgid "name of server for the RPC program"
msgstr "RPC プログラムのサーバの名前"

#. type: Plain text
#: build/C/man5/rpc.5:25
msgid "RPC program number"
msgstr "RPC プログラム番号"

#. type: Plain text
#: build/C/man5/rpc.5:29
msgid "aliases"
msgstr "別名"

#. type: Plain text
#: build/C/man5/rpc.5:35
msgid ""
"Items are separated by any number of blanks and/or tab characters.  A \\(aq#"
"\\(aq indicates the beginning of a comment; characters from the \\(aq#\\(aq "
"to the end of the line are not interpreted by routines which search the file."
msgstr ""
"それぞれの項目は任意の個数の空白・タブ (混在可) によって区切られる。 先頭に "
"\\(aq#\\(aq のある行はコメントである。 \\(aq#\\(aq からその行の終了までは、こ"
"のファイルをサーチするルーチンによって 解釈されなくなる。"

#. type: Plain text
#: build/C/man5/rpc.5:38
msgid ""
"Here is an example of the I</etc/rpc> file from the Sun RPC Source "
"distribution."
msgstr ""
"以下に、 Sun RPC のソースパッケージからとってきた I</etc/rpc> ファイルの例を"
"示す。"

#. type: Plain text
#: build/C/man5/rpc.5:73
#, no-wrap
msgid ""
"CW<#\n"
"# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n"
"#\n"
"portmapper      100000  portmap sunrpc\n"
"rstatd          100001  rstat rstat_svc rup perfmeter\n"
"rusersd         100002  rusers\n"
"nfs             100003  nfsprog\n"
"ypserv          100004  ypprog\n"
"mountd          100005  mount showmount\n"
"ypbind          100007\n"
"walld           100008  rwall shutdown\n"
"yppasswdd       100009  yppasswd\n"
"etherstatd      100010  etherstat\n"
"rquotad         100011  rquotaprog quota rquota\n"
"sprayd          100012  spray\n"
"3270_mapper     100013\n"
"rje_mapper      100014\n"
"selection_svc   100015  selnsvc\n"
"database_svc    100016\n"
"rexd            100017  rex\n"
"alis            100018\n"
"sched           100019\n"
"llockmgr        100020\n"
"nlockmgr        100021\n"
"x25.inr         100022\n"
"statmon         100023\n"
"status          100024\n"
"bootparam       100026\n"
"ypupdated       100028  ypupdate\n"
"keyserv         100029  keyserver\n"
"tfsd            100037\n"
"nsed            100038\n"
"nsemntd         100039>\n"
msgstr ""
"CW<#\n"
"# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n"
"#\n"
"portmapper      100000  portmap sunrpc\n"
"rstatd          100001  rstat rstat_svc rup perfmeter\n"
"rusersd         100002  rusers\n"
"nfs             100003  nfsprog\n"
"ypserv          100004  ypprog\n"
"mountd          100005  mount showmount\n"
"ypbind          100007\n"
"walld           100008  rwall shutdown\n"
"yppasswdd       100009  yppasswd\n"
"etherstatd      100010  etherstat\n"
"rquotad         100011  rquotaprog quota rquota\n"
"sprayd          100012  spray\n"
"3270_mapper     100013\n"
"rje_mapper      100014\n"
"selection_svc   100015  selnsvc\n"
"database_svc    100016\n"
"rexd            100017  rex\n"
"alis            100018\n"
"sched           100019\n"
"llockmgr        100020\n"
"nlockmgr        100021\n"
"x25.inr         100022\n"
"statmon         100023\n"
"status          100024\n"
"bootparam       100026\n"
"ypupdated       100028  ypupdate\n"
"keyserv         100029  keyserver\n"
"tfsd            100037\n"
"nsed            100038\n"
"nsemntd         100039>\n"

#. type: Plain text
#: build/C/man5/rpc.5:80
msgid "RPC program number data base"
msgstr "RPC プログラム番号データベース"

#. type: Plain text
#: build/C/man5/rpc.5:82
msgid "B<getrpcent>(3)"
msgstr "B<getrpcent>(3)"

#. type: TH
#: build/C/man3/rtime.3:12
#, no-wrap
msgid "RTIME"
msgstr "RTIME"

#. type: TH
#: build/C/man3/rtime.3:12
#, no-wrap
msgid "2012-08-03"
msgstr "2012-08-03"

#. type: Plain text
#: build/C/man3/rtime.3:15
msgid "rtime - get time from a remote machine"
msgstr "rtime - リモートマシンから時刻を取得する"

#. type: Plain text
#: build/C/man3/rtime.3:18
#, no-wrap
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/rtime.3:21
#, no-wrap
msgid ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>\n"
"B<          struct rpc_timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>\n"
"B<          struct rpc_timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/rtime.3:25
msgid ""
"This function uses the Time Server Protocol as described in RFC\\ 868 to "
"obtain the time from a remote machine."
msgstr ""
"この関数は RFC\\ 868 に記述されているタイムサーバプロトコルを使用し、 リモー"
"トマシンから時刻を取得する。"

#. type: Plain text
#: build/C/man3/rtime.3:31
msgid ""
"The Time Server Protocol gives the time in seconds since 00:00:00 UTC, 1 Jan "
"1900, and this function subtracts the appropriate constant in order to "
"convert the result to seconds since the Epoch, 1970-01-01 00:00:00 +0000 "
"(UTC)."
msgstr ""
"タイムサーバプロトコルは 00:00:00 UTC, 1 Jan 1900 から秒数を提供するので、 こ"
"の関数は適切な定数値を引くことにより、 提供された値を Unix における時刻紀元 "
"(1970-01-01 00:00:00 +0000 (UTC))  から秒数に変換する。"

#. type: Plain text
#: build/C/man3/rtime.3:36
msgid ""
"When I<timeout> is non-NULL, the udp/time socket (port 37) is used.  "
"Otherwise, the tcp/time socket (port 37) is used."
msgstr ""
"I<timeout> が NULL でない場合、udp/time ソケット (ポート 37) が使用される。 "
"それ以外の場合、tcp/time ソケット (ポート 37) が使用される。"

#. type: Plain text
#: build/C/man3/rtime.3:42
msgid ""
"On success, 0 is returned, and the obtained 32-bit time value is stored in "
"I<timep-E<gt>tv_sec>.  In case of error -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は、0 が返されて、得られた 32 ビットの時刻値は I<timep-"
"E<gt>tv_sec> に格納される。 エラーの場合は、-1 が返されて、 I<errno> が適切に"
"設定される。"

#. type: Plain text
#: build/C/man3/rtime.3:51
msgid ""
"All errors for underlying functions (B<sendto>(2), B<poll>(2), B<recvfrom>"
"(2), B<connect>(2), B<read>(2))  can occur.  Moreover:"
msgstr ""
"内部で使用している関数 (B<sendto>(2), B<poll>(2), B<recvfrom>(2), B<connect>"
"(2), B<read>(2))  の全てのエラーが起こる可能性がある。 更に次のエラーが起こる"
"可能性がある:"

#. type: TP
#: build/C/man3/rtime.3:51
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man3/rtime.3:54
msgid "The number of returned bytes is not 4."
msgstr "返されたバイト数が 4 バイトでない。"

#. type: TP
#: build/C/man3/rtime.3:54
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man3/rtime.3:57
msgid "The waiting time as defined in timeout has expired."
msgstr "timeout で定義された待ち時間の期限が切れた。"

#. type: Plain text
#: build/C/man3/rtime.3:59
msgid "Only IPv4 is supported."
msgstr "IPv4 のみがサポートされている。"

#. type: Plain text
#: build/C/man3/rtime.3:66
msgid ""
"Some I<in.timed> versions support only TCP.  Try the example program with "
"I<use_tcp> set to 1."
msgstr ""
"I<in.timed> のバージョンによっては TCP しかサポートしていないものもある。 "
"I<use_tcp> を 1 に設定して、例にあるプログラムを試すこと。"

#. type: Plain text
#: build/C/man3/rtime.3:68
msgid "Libc5 uses the prototype"
msgstr "libc5 はプロトタイプ"

#. type: Plain text
#: build/C/man3/rtime.3:70
msgid "int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);"
msgstr "int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);"

#. type: Plain text
#: build/C/man3/rtime.3:75
msgid ""
"and requires I<E<lt>sys/time.hE<gt>> instead of I<E<lt>rpc/auth_des.hE<gt>>."
msgstr ""
"を使い、 I<E<lt>rpc/auth_des.hE<gt>> の代わりに I<E<lt>sys/time.hE<gt>> を必"
"要とする。"

#. type: Plain text
#: build/C/man3/rtime.3:78
msgid ""
"B<rtime>()  in glibc 2.2.5 and earlier does not work properly on 64-bit "
"machines."
msgstr "glibc 2.2.5 以前の B<rtime>()  は、64 ビットマシンで正確に動作しない。"

#. type: SH
#: build/C/man3/rtime.3:78
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/rtime.3:84
msgid ""
"This example requires that port 37 is up and open.  You may check that the "
"time entry within I</etc/inetd.conf> is not commented out."
msgstr ""
"この例ではポート 37 がアップされてオープンされている必要がある。 I</etc/"
"inetd.conf> の time エントリがコメントアウトされていないことを確認してほし"
"い。"

#. type: Plain text
#: build/C/man3/rtime.3:88
msgid ""
"The program connects to a computer called \"linux\".  Using \"localhost\" "
"does not work.  The result is the localtime of the computer \"linux\"."
msgstr ""
"このプログラムは \"linux\" というコンピュータに接続する。 \"localhost\" を"
"使った場合は動作しない。 結果はコンピュータ \"linux\" のローカル時刻である。"

#. type: Plain text
#: build/C/man3/rtime.3:97
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>rpc/auth_des.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>rpc/auth_des.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: build/C/man3/rtime.3:100
#, no-wrap
msgid ""
"int use_tcp = 0;\n"
"char *servername = \"linux\";\n"
msgstr ""
"int use_tcp = 0;\n"
"char *servername = \"linux\";\n"

#. type: Plain text
#: build/C/man3/rtime.3:109
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sockaddr_in name;\n"
"    struct rpc_timeval time1 = {0,0};\n"
"    struct rpc_timeval timeout = {1,0};\n"
"    struct hostent *hent;\n"
"    int ret;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct sockaddr_in name;\n"
"    struct rpc_timeval time1 = {0,0};\n"
"    struct rpc_timeval timeout = {1,0};\n"
"    struct hostent *hent;\n"
"    int ret;\n"

#. type: Plain text
#: build/C/man3/rtime.3:114
#, no-wrap
msgid ""
"    memset(&name, 0, sizeof(name));\n"
"    sethostent(1);\n"
"    hent = gethostbyname(servername);\n"
"    memcpy(&name.sin_addr, hent-E<gt>h_addr, hent-E<gt>h_length);\n"
msgstr ""
"    memset(&name, 0, sizeof(name));\n"
"    sethostent(1);\n"
"    hent = gethostbyname(servername);\n"
"    memcpy(&name.sin_addr, hent-E<gt>h_addr, hent-E<gt>h_length);\n"

#. type: Plain text
#: build/C/man3/rtime.3:122
#, no-wrap
msgid ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n"
"    if (ret E<lt> 0)\n"
"        perror(\"rtime error\");\n"
"    else {\n"
"\ttime_t t = time1.tv_sec;\n"
"        printf(\"%s\\en\", ctime(&t));\n"
"    }\n"
msgstr ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n"
"    if (ret E<lt> 0)\n"
"        perror(\"rtime error\");\n"
"    else {\n"
"\ttime_t t = time1.tv_sec;\n"
"        printf(\"%s\\en\", ctime(&t));\n"
"    }\n"

#. type: Plain text
#: build/C/man3/rtime.3:125
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#.  .BR netdate (1),
#.  .BR rdate (1),
#. type: Plain text
#: build/C/man3/rtime.3:131
msgid "B<ntpdate>(1), B<inetd>(8)"
msgstr "B<ntpdate>(1), B<inetd>(8)"

#. type: TH
#: build/C/man3/xdr.3:11
#, no-wrap
msgid "XDR"
msgstr "XDR"

#. type: TH
#: build/C/man3/xdr.3:11
#, no-wrap
msgid "2007-12-30"
msgstr "2007-12-30"

#. type: Plain text
#: build/C/man3/xdr.3:14
msgid "xdr - library routines for external data representation"
msgstr "xdr - 外部データ表現(XDR)のためのライブラリ・ルーティン"

#. type: Plain text
#: build/C/man3/xdr.3:20
msgid ""
"These routines allow C programmers to describe arbitrary data structures in "
"a machine-independent fashion.  Data for remote procedure calls are "
"transmitted using these routines."
msgstr ""
"これらのルーティンは C プログラマーがマシン非依存な形式で 任意のデータ構造体"
"を記述することを可能にする。 リモート・プロシジャ・コールのためのデータはこれ"
"らのルーティンを 使用して送信される。"

#. type: Plain text
#: build/C/man3/xdr.3:24
msgid ""
"The prototypes below are declared in I<E<lt>rpc/xdr.hE<gt>> and make use of "
"the following types:"
msgstr ""
"以下に示すプロトタイプ宣言は I<E<lt>rpc/xdr.hE<gt>> で行われており、その中で"
"は次の型が使用される。"

#. type: Plain text
#: build/C/man3/xdr.3:30
#, no-wrap
msgid "B<typedef bool_t (*>I<xdrproc_ti>B<) (XDR *, void *,...);>\n"
msgstr "B<typedef bool_t (*>I<xdrproc_ti>B<) (XDR *, void *,...);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:37
msgid "For the declaration of the I<XDR> type, see I<E<lt>rpc/xdr.hE<gt>>."
msgstr "I<XDR> 型の宣言については、 I<E<lt>rpc/xdr.hE<gt>> を参照。"

#. type: Plain text
#: build/C/man3/xdr.3:42
#, no-wrap
msgid ""
"B<bool_t xdr_array(XDR *>I<xdrs>B<, char **>I<arrp>B<, unsigned int *>I<sizep>B<,>\n"
"B<                 unsigned int >I<maxsize>B<, unsigned int >I<elsize>B<,>\n"
"B<                 xdrproc_t >I<elproc>B<);>\n"
msgstr ""
"B<bool_t xdr_array(XDR *>I<xdrs>B<, char **>I<arrp>B<, unsigned int *>I<sizep>B<,>\n"
"B<                 unsigned int >I<maxsize>B<, unsigned int >I<elsize>B<,>\n"
"B<                 xdrproc_t >I<elproc>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:63
msgid ""
"A filter primitive that translates between variable-length arrays and their "
"corresponding external representations.  The argument I<arrp> is the address "
"of the pointer to the array, while I<sizep> is the address of the element "
"count of the array; this element count cannot exceed I<maxsize>.  The "
"argument I<elsize> is the I<sizeof> each of the array's elements, and "
"I<elproc> is an XDR filter that translates between the array elements' C "
"form, and their external representation.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"可変長の配列とそれに対応する外部表現とを変換する基本フィルター。 引き数 "
"I<arrp> は配列へのポインターのアドレスであり、 I<sizep> は配列の要素数のアド"
"レスである。 これらの要素数は I<maxsize> を超えてはならない。 引き数 "
"I<elsize> は各配列の要素の I<sizeof> であり、 I<elproc> は配列要素を C 形式か"
"らその外部表現に変換するための XDR フィルターである。 このルーティンは成功し"
"た場合には 1 を返す。 失敗した場合にはゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:66
#, no-wrap
msgid "B<bool_t xdr_bool(XDR *>I<xdrs>B<, bool_t *>I<bp>B<);>\n"
msgstr "B<bool_t xdr_bool(XDR *>I<xdrs>B<, bool_t *>I<bp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:74
msgid ""
"A filter primitive that translates between booleans (C integers)  and their "
"external representations.  When encoding data, this filter produces values "
"of either one or zero.  This routine returns one if it succeeds, zero "
"otherwise."
msgstr ""
"真偽値(C の int)とその外部表現とを変換する基本フィルター。 データをエンコード"
"する時、このフィルターは 1 また 0 の値を生成する。 このルーティンは成功した場"
"合には 1 を返す。 失敗した場合には 0 を返す。"

#. type: Plain text
#: build/C/man3/xdr.3:78
#, no-wrap
msgid ""
"B<bool_t xdr_bytes(XDR *>I<xdrs>B<, char **>I<sp>B<, unsigned int *>I<sizep>B<,>\n"
"B<                 unsigned int >I<maxsize>B<);>\n"
msgstr ""
"B<bool_t xdr_bytes(XDR *>I<xdrs>B<, char **>I<sp>B<, unsigned int *>I<sizep>B<,>\n"
"B<                 unsigned int >I<maxsize>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:91
msgid ""
"A filter primitive that translates between counted byte strings and their "
"external representations.  The argument I<sp> is the address of the string "
"pointer.  The length of the string is located at address I<sizep>; strings "
"cannot be longer than I<maxsize>.  This routine returns one if it succeeds, "
"zero otherwise."
msgstr ""
"ある長さのバイト文字列とその外部表現とを変換する基本フィルター。 引き数 "
"I<sp> は文字列ポインターのアドレスである。文字列の長さは I<sizep> のアドレス"
"に置く。文字列は I<maxsize> より長くてはいけない。 このルーティンは成功した場"
"合には 1 を返す。 失敗した場合には 0 を返す。"

#. type: Plain text
#: build/C/man3/xdr.3:94
#, no-wrap
msgid "B<bool_t xdr_char(XDR *>I<xdrs>B<, char *>I<cp>B<);>\n"
msgstr "B<bool_t xdr_char(XDR *>I<xdrs>B<, char *>I<cp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:106
msgid ""
"A filter primitive that translates between C characters and their external "
"representations.  This routine returns one if it succeeds, zero otherwise.  "
"Note: encoded characters are not packed, and occupy 4 bytes each.  For "
"arrays of characters, it is worthwhile to consider B<xdr_bytes>(), "
"B<xdr_opaque>()  or B<xdr_string>()."
msgstr ""
"C の文字(char)とその外部表現との間を変換する基本フィルター。 このルーティンは"
"成功した場合には 1 を返す。 失敗した場合には 0 を返す。 注意: エンコードされ"
"たデータは詰め込まれておらず、それぞれ 4 バイトを 占める。文字の配列の場合に"
"は B<xdr_bytes>(), B<xdr_opaque>(), B<xdr_string>()  などを考慮した方が良い。"

#. type: Plain text
#: build/C/man3/xdr.3:109
#, no-wrap
msgid "B<void xdr_destroy(XDR *>I<xdrs>B<);>\n"
msgstr "B<void xdr_destroy(XDR *>I<xdrs>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:120
msgid ""
"A macro that invokes the destroy routine associated with the XDR stream, "
"I<xdrs>.  Destruction usually involves freeing private data structures "
"associated with the stream.  Using I<xdrs> after invoking B<xdr_destroy>()  "
"is undefined."
msgstr ""
"このマクロは XDR ストリーム I<xdrs> に関連付けられた破壊ルーティンを呼び出"
"す。 破壊には通常、ストリームに関連付けられた私的データ構造体の解放が含まれて"
"いる。 B<xdr_destroy>()  の呼び出しの後に I<xdrs> を使用することは未定義であ"
"る。"

#. type: Plain text
#: build/C/man3/xdr.3:123
#, no-wrap
msgid "B<bool_t xdr_double(XDR *>I<xdrs>B<, double *>I<dp>B<);>\n"
msgstr "B<bool_t xdr_double(XDR *>I<xdrs>B<, double *>I<dp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:129
msgid ""
"A filter primitive that translates between C I<double> precision numbers and "
"their external representations.  This routine returns one if it succeeds, "
"zero otherwise."
msgstr ""
"C の I<倍精度数 (double)> とその外部表現との変換を行なう基本フィルター。 この"
"ルーティンは成功した場合は 1 を返す。 失敗した場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/xdr.3:132
#, no-wrap
msgid "B<bool_t xdr_enum(XDR *>I<xdrs>B<, enum_t *>I<ep>B<);>\n"
msgstr "B<bool_t xdr_enum(XDR *>I<xdrs>B<, enum_t *>I<ep>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:138
msgid ""
"A filter primitive that translates between C I<enum>s (actually integers) "
"and their external representations.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"C の I<enum> (実際には int)とその外部表現との変換を行なう基本フィルター。 こ"
"のルーティンは成功した場合は 1 を返す。 失敗した場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/xdr.3:141
#, no-wrap
msgid "B<bool_t xdr_float(XDR *>I<xdrs>B<, float *>I<fp>B<);>\n"
msgstr "B<bool_t xdr_float(XDR *>I<xdrs>B<, float *>I<fp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:147
msgid ""
"A filter primitive that translates between C I<float>s and their external "
"representations.  This routine returns one if it succeeds, zero otherwise."
msgstr ""
"C の I<浮動小数点数 (float)> とその外部表現との変換を行なう基本フィルター。 "
"このルーティンは成功した場合は 1 を返す。 失敗した場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/xdr.3:150
#, no-wrap
msgid "B<void xdr_free(xdrproc_t >I<proc>B<, char *>I<objp>B<);>\n"
msgstr "B<void xdr_free(xdrproc_t >I<proc>B<, char *>I<objp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:160
msgid ""
"Generic freeing routine.  The first argument is the XDR routine for the "
"object being freed.  The second argument is a pointer to the object itself.  "
"Note: the pointer passed to this routine is I<not> freed, but what it points "
"to I<is> freed (recursively)."
msgstr ""
"汎用解放(free)ルーティン。最初の引き数はオブジェクトを解放するための XDR ルー"
"ティンである。二番目の引き数はそのオブジェクト自身へのポインター である。注"
"意: このルーティンに渡されるポインターは I<解放されない> が、このポインターの"
"指すデータは(再帰的に)  I<解放される>。"

#. type: Plain text
#: build/C/man3/xdr.3:163
#, no-wrap
msgid "B<unsigned int xdr_getpos(XDR *>I<xdrs>B<);>\n"
msgstr "B<unsigned int xdr_getpos(XDR *>I<xdrs>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:173
msgid ""
"A macro that invokes the get-position routine associated with the XDR "
"stream, I<xdrs>.  The routine returns an unsigned integer, which indicates "
"the position of the XDR byte stream.  A desirable feature of XDR streams is "
"that simple arithmetic works with this number, although the XDR stream "
"instances need not guarantee this."
msgstr ""
"このマクロは XDR ストリーム I<xdrs> に関連付けられた位置取得ルーティンを呼び"
"出す。 このルーティンは XDR バイト・ストリームの位置を指示する符号無し整数を"
"返す。 XDR ストリームの機能としてこの数値で単純な算術作業ができることが 期待"
"されてるいる。しかしながら XDR ストリームの実体はこれを保証する必要はない。"

#. type: Plain text
#: build/C/man3/xdr.3:176
#, no-wrap
msgid "B<long *xdr_inline(XDR *>I<xdrs>B<, int >I<len>B<);>\n"
msgstr "B<long *xdr_inline(XDR *>I<xdrs>B<, int >I<len>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:186
msgid ""
"A macro that invokes the inline routine associated with the XDR stream, "
"I<xdrs>.  The routine returns a pointer to a contiguous piece of the "
"stream's buffer; I<len> is the byte length of the desired buffer.  Note: "
"pointer is cast to I<long\\ *>."
msgstr ""
"このマクロは XDR ストリーム I<xdrs> に関連付けられた内部(inline)ルーティンを"
"呼び出す。 ルーティンはストリームのバッファーの連続する断片へのポインターを返"
"す。 I<len> は要求するバッファーのバイト長である。 注意: ポインターは I<long"
"\\ *> にキャストされる。"

#. type: Plain text
#: build/C/man3/xdr.3:193
msgid ""
"Warning: B<xdr_inline>()  may return NULL (0)  if it cannot allocate a "
"contiguous piece of a buffer.  Therefore the behavior may vary among stream "
"instances; it exists for the sake of efficiency."
msgstr ""
"警告: B<xdr_inline>()  はバッファーの連続する断片を割り当てることができなかっ"
"た場合には NULL (0)を返すかもしれない。 どの場合もその動作はストリームの実体"
"によって変化するかもしれない。 これは効率化のために存在している。"

#. type: Plain text
#: build/C/man3/xdr.3:196
#, no-wrap
msgid "B<bool_t xdr_int(XDR *>I<xdrs>B<, int *>I<ip>B<);>\n"
msgstr "B<bool_t xdr_int(XDR *>I<xdrs>B<, int *>I<ip>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:201
msgid ""
"A filter primitive that translates between C integers and their external "
"representations.  This routine returns one if it succeeds, zero otherwise."
msgstr ""
"C の整数(int)とその外部表現とを変換するための基本フィルター。 このルーティン"
"は成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:204
#, no-wrap
msgid "B<bool_t xdr_long(XDR *>I<xdrs>B<, long *>I<lp>B<);>\n"
msgstr "B<bool_t xdr_long(XDR *>I<xdrs>B<, long *>I<lp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:210
msgid ""
"A filter primitive that translates between C I<long> integers and their "
"external representations.  This routine returns one if it succeeds, zero "
"otherwise."
msgstr ""
"C の I<long> 整数とそのその外部表現とを変換するための基本フィルター。 この"
"ルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:214
#, no-wrap
msgid ""
"B<void xdrmem_create(XDR *>I<xdrs>B<, char *>I<addr>B<, unsigned int >I<size>B<,>\n"
"B<                   enum xdr_op >I<op>B<);>\n"
msgstr ""
"B<void xdrmem_create(XDR *>I<xdrs>B<, char *>I<addr>B<, unsigned int >I<size>B<,>\n"
"B<                   enum xdr_op >I<op>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:231
msgid ""
"This routine initializes the XDR stream object pointed to by I<xdrs>.  The "
"stream's data is written to, or read from, a chunk of memory at location "
"I<addr> whose length is no more than I<size> bytes long.  The I<op> "
"determines the direction of the XDR stream (either B<XDR_ENCODE>, "
"B<XDR_DECODE>, or B<XDR_FREE>)."
msgstr ""
"このルーティンは I<xdrs> によって指されている XDR ストリーム・オブジェクトを"
"初期化する。 ストリームのデータは I<addr> 位置にあるメモリーの塊から読み書き"
"される。 その長さはバイト単位で I<size> 超えてはいけない。 I<op> は XDR スト"
"リームの変換方向を決定する (B<XDR_ENCODE>, B<XDR_DECODE>, B<XDR_FREE> のどれ"
"か)。"

#. type: Plain text
#: build/C/man3/xdr.3:234
#, no-wrap
msgid "B<bool_t xdr_opaque(XDR *>I<xdrs>B<, char *>I<cp>B<, unsigned int >I<cnt>B<);>\n"
msgstr "B<bool_t xdr_opaque(XDR *>I<xdrs>B<, char *>I<cp>B<, unsigned int >I<cnt>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:244
msgid ""
"A filter primitive that translates between fixed size opaque data and its "
"external representation.  The argument I<cp> is the address of the opaque "
"object, and I<cnt> is its size in bytes.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"固定長の不明データとその外部表現との変換を行なう基本フィルター。 引き数 "
"I<cp> は不明オブジェクトのアドレスであり I<cnt> はそのバイト単位の大きさであ"
"る。 このルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:248
#, no-wrap
msgid ""
"B<bool_t xdr_pointer(XDR *>I<xdrs>B<, char **>I<objpp>B<,>\n"
"B<                   unsigned int >I<objsize>B<, xdrproc_t >I<xdrobj>B<);>\n"
msgstr ""
"B<bool_t xdr_pointer(XDR *>I<xdrs>B<, char **>I<objpp>B<,>\n"
"B<                   unsigned int >I<objsize>B<, xdrproc_t >I<xdrobj>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:260
msgid ""
"Like B<xdr_reference>()  except that it serializes NULL pointers, whereas "
"B<xdr_reference>()  does not.  Thus, B<xdr_pointer>()  can represent "
"recursive data structures, such as binary trees or linked lists."
msgstr ""
"B<xdr_reference>()  と同様であるが、これが NULL ポインターを番号化するのに対"
"して B<xdr_reference>()  はそうしない点が異なっている。これにより、 "
"B<xdr_pointer>()  は二分木や連結リストのような再帰的なデータ構造体を 表現でき"
"る。"

#. type: Plain text
#: build/C/man3/xdr.3:266
#, no-wrap
msgid ""
"B<void xdrrec_create(XDR *>I<xdrs>B<, unsigned int >I<sendsize>B<,>\n"
"B<                   unsigned int >I<recvsize>B<, char *>I<handle>B<,>\n"
"B<                   int (*>I<readit>B<) (char *, char *, int),>\n"
"B<                   int (*>I<writeit>B<) (char *, char *, int));>\n"
msgstr ""
"B<void xdrrec_create(XDR *>I<xdrs>B<, unsigned int >I<sendsize>B<,>\n"
"B<                   unsigned int >I<recvsize>B<, char *>I<handle>B<,>\n"
"B<                   int (*>I<readit>B<) (char *, char *, int),>\n"
"B<                   int (*>I<writeit>B<) (char *, char *, int));>\n"

#. type: Plain text
#: build/C/man3/xdr.3:293
msgid ""
"This routine initializes the XDR stream object pointed to by I<xdrs>.  The "
"stream's data is written to a buffer of size I<sendsize>; a value of zero "
"indicates the system should use a suitable default.  The stream's data is "
"read from a buffer of size I<recvsize>; it too can be set to a suitable "
"default by passing a zero value.  When a stream's output buffer is full, "
"I<writeit> is called.  Similarly, when a stream's input buffer is empty, "
"I<readit> is called.  The behavior of these two routines is similar to the "
"system calls B<read>(2)  and B<write>(2), except that I<handle> is passed to "
"the former routines as the first argument.  Note: the XDR stream's I<op> "
"field must be set by the caller."
msgstr ""
"このルーティンは I<xdrs> で指された XDR ストリーム・オブジェクトを初期化す"
"る。 ストリームのデータは大きさ I<sendsize> のバッファへ書き込まれる。 "
"I<sendsize> をゼロにすると、システムに適切なデフォルトを使用するように指示す"
"る。 ストリームのデータは大きさ I<recvsize> のバッファから読み込まれる。これ"
"もゼロを渡すことで適切なデフォルトに 設定することができる。 ストリームの出力"
"バッファが一杯の場合は I<writeit> が呼び出される。同様にストリーム入力バッ"
"ファが空の場合には I<readit> が呼び出される。これらの二つのルーティンの動作は"
"システムコールの B<read>(2)  や B<write>(2)  と似ているが、前者のルーティンは"
"最初の引き数として I<handle> が渡される点で異なっている。 注意: XDR ストリー"
"ムの I<op> は呼び出し側で設定しなければならない。"

#. type: Plain text
#: build/C/man3/xdr.3:297
msgid ""
"Warning: this XDR stream implements an intermediate record stream.  "
"Therefore there are additional bytes in the stream to provide record "
"boundary information."
msgstr ""
"警告: この XDR ストリームは中間レコード・ストリームを実装している。 レコード"
"境界の情報を提供するためにストリームには余分なバイトが存在する。"

#. type: Plain text
#: build/C/man3/xdr.3:300
#, no-wrap
msgid "B<bool_t xdrrec_endofrecord(XDR *>I<xdrs>B<, int >I<sendnow>B<);>\n"
msgstr "B<bool_t xdrrec_endofrecord(XDR *>I<xdrs>B<, int >I<sendnow>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:309
msgid ""
"This routine can be invoked only on streams created by B<xdrrec_create>().  "
"The data in the output buffer is marked as a completed record, and the "
"output buffer is optionally written out if I<sendnow> is nonzero.  This "
"routine returns one if it succeeds, zero otherwise."
msgstr ""
"このルーティンは B<xdrrec_create>()  によって作成されたストリームに対してのみ"
"呼び出すことができる。 出力バッファのデータは完全なレコードとして印され、 "
"I<sendnow> がゼロでない場合には出力バッファは書き出される。 このルーティンは"
"成功した場合は 1 を返す。失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:312
#, no-wrap
msgid "B<bool_t xdrrec_eof(XDR *>I<xdrs>B<);>\n"
msgstr "B<bool_t xdrrec_eof(XDR *>I<xdrs>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:319
msgid ""
"This routine can be invoked only on streams created by B<xdrrec_create>().  "
"After consuming the rest of the current record in the stream, this routine "
"returns one if the stream has no more input, zero otherwise."
msgstr ""
"このルーティンは B<xdrrec_create>()  によって作成されたストリームに対してのみ"
"呼び出すことができる。 ストリームの現在のレコードの残りを消費した後に、 スト"
"リームに入力が残っていない場合には 1 を返す。 それ以外の場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:322
#, no-wrap
msgid "B<bool_t xdrrec_skiprecord(XDR *>I<xdrs>B<);>\n"
msgstr "B<bool_t xdrrec_skiprecord(XDR *>I<xdrs>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:330
msgid ""
"This routine can be invoked only on streams created by B<xdrrec_create>().  "
"It tells the XDR implementation that the rest of the current record in the "
"stream's input buffer should be discarded.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"このルーティンは B<xdrrec_create>()  によって作成されたストリームに対してのみ"
"呼び出すことができる。 XDR の実装にそのストリームの入力バッファーの現在のレ"
"コードの残りを 捨てるように伝える。このルーティンは成功した場合は 1 を返す。 "
"失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:334
#, no-wrap
msgid ""
"B<bool_t xdr_reference(XDR *>I<xdrs>B<, char **>I<pp>B<, unsigned int >I<size>B<,>\n"
"B<                     xdrproc_t >I<proc>B<);>\n"
msgstr ""
"B<bool_t xdr_reference(XDR *>I<xdrs>B<, char **>I<pp>B<, unsigned int >I<size>B<,>\n"
"B<                     xdrproc_t >I<proc>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:350
msgid ""
"A primitive that provides pointer chasing within structures.  The argument "
"I<pp> is the address of the pointer; I<size> is the I<sizeof> the structure "
"that I<*pp> points to; and I<proc> is an XDR procedure that filters the "
"structure between its C form and its external representation.  This routine "
"returns one if it succeeds, zero otherwise."
msgstr ""
"構造体へのポインター追跡を提供する基本ルーティン。 引き数 I<pp> はポインター"
"のアドレスである。 I<size> は I<*pp> が指している構造体の I<sizeof> である。 "
"I<proc> はその構造体の C 形式と外部表現との変換を行なう XDR プロシジャであ"
"る。 このルーティンは成功した場合 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:355
msgid ""
"Warning: this routine does not understand NULL pointers.  Use B<xdr_pointer>"
"()  instead."
msgstr ""
"警告: このルーティンは NULL ポインターを理解することができない。かわりに "
"B<xdr_pointer>()  を使用すること。"

#. type: Plain text
#: build/C/man3/xdr.3:358
#, no-wrap
msgid "B<xdr_setpos(XDR *>I<xdrs>B<, unsigned int >I<pos>B<);>\n"
msgstr "B<xdr_setpos(XDR *>I<xdrs>B<, unsigned int >I<pos>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:369
msgid ""
"A macro that invokes the set position routine associated with the XDR stream "
"I<xdrs>.  The argument I<pos> is a position value obtained from B<xdr_getpos>"
"().  This routine returns one if the XDR stream could be repositioned, and "
"zero otherwise."
msgstr ""
"このマクロは XDR ストリーム I<xdrs> に関連付けられた位置設定ルーティンを呼び"
"出す。引き数 I<pos> は B<xdr_getpos>()  によって取得される位置数値である。 こ"
"のルーティンは XDR ストリームの位置の変更ができた場合には 1 を返す。 それ以外"
"の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/xdr.3:373
msgid ""
"Warning: it is difficult to reposition some types of XDR streams, so this "
"routine may fail with one type of stream and succeed with another."
msgstr ""
"警告: ある種の XDR ストリームの場合は位置の変更を行なうことが困難である。 そ"
"れでこのルーティンはある種のストリームの場合には成功し、別の種類の 場合には失"
"敗するかもしれない。"

#. type: Plain text
#: build/C/man3/xdr.3:376
#, no-wrap
msgid "B<bool_t xdr_short(XDR *>I<xdrs>B<, short *>I<sp>B<);>\n"
msgstr "B<bool_t xdr_short(XDR *>I<xdrs>B<, short *>I<sp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:382
msgid ""
"A filter primitive that translates between C I<short> integers and their "
"external representations.  This routine returns one if it succeeds, zero "
"otherwise."
msgstr ""
"C の I<short> 整数とその外部表現との変換を行なう基本フィルター。 このルーティ"
"ンは成功すると 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:385
#, no-wrap
msgid "B<void xdrstdio_create(XDR *>I<xdrs>B<, FILE *>I<file>B<, enum xdr_op >I<op>B<);>\n"
msgstr "B<void xdrstdio_create(XDR *>I<xdrs>B<, FILE *>I<file>B<, enum xdr_op >I<op>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:400
msgid ""
"This routine initializes the XDR stream object pointed to by I<xdrs>.  The "
"XDR stream data is written to, or read from, the I<stdio> stream I<file>.  "
"The argument I<op> determines the direction of the XDR stream (either "
"B<XDR_ENCODE>, B<XDR_DECODE>, or B<XDR_FREE>)."
msgstr ""
"このルーティンは I<xdrs> で指された XDR ストリーム・オブジェクトを初期化す"
"る。 XDR ストリームに読み書きれたデータは I<stdio> ストリーム I<file> が使用"
"される。 I<op> 引き数は XDR ストリームの変換方向を決定する (B<XDR_ENCODE>, "
"B<XDR_DECODE>, B<XDR_FREE> のどれか)。"

#. type: Plain text
#: build/C/man3/xdr.3:407
msgid ""
"Warning: the destroy routine associated with such XDR streams calls B<fflush>"
"(3)  on the I<file> stream, but never B<fclose>(3)."
msgstr ""
"警告: このような XDR ストリームに関連付けられた破壊ルーティンは I<file> スト"
"リームに対して B<fflush>(3)  を呼び出すが B<fclose>(3)  を呼び出すことはな"
"い。"

#. type: Plain text
#: build/C/man3/xdr.3:410
#, no-wrap
msgid "B<bool_t xdr_string(XDR *>I<xdrs>B<, char **>I<sp>B<, unsigned int >I<maxsize>B<);>\n"
msgstr "B<bool_t xdr_string(XDR *>I<xdrs>B<, char **>I<sp>B<, unsigned int >I<maxsize>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:420
msgid ""
"A filter primitive that translates between C strings and their corresponding "
"external representations.  Strings cannot be longer than I<maxsize>.  Note: "
"I<sp> is the address of the string's pointer.  This routine returns one if "
"it succeeds, zero otherwise."
msgstr ""
"C の文字列とそれに対応する外部表現とを変換するための基本フィルター。 文字列"
"は I<maxsize> より長くはできない。 注意: I<sp> は文字列へのポインターのアドレ"
"スである。 このルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返"
"す。"

#. type: Plain text
#: build/C/man3/xdr.3:423
#, no-wrap
msgid "B<bool_t xdr_u_char(XDR *>I<xdrs>B<, unsigned char *>I<ucp>B<);>\n"
msgstr "B<bool_t xdr_u_char(XDR *>I<xdrs>B<, unsigned char *>I<ucp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:429
msgid ""
"A filter primitive that translates between I<unsigned> C characters and "
"their external representations.  This routine returns one if it succeeds, "
"zero otherwise."
msgstr ""
"C の I<符号無し文字 (unsigned char)> とその外部表現とを変換する基本フィル"
"ター。 このルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:432
#, no-wrap
msgid "B<bool_t xdr_u_int(XDR *>I<xdrs>B<, unsigned *>I<up>B<);>\n"
msgstr "B<bool_t xdr_u_int(XDR *>I<xdrs>B<, unsigned *>I<up>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:438
msgid ""
"A filter primitive that translates between C I<unsigned> integers and their "
"external representations.  This routine returns one if it succeeds, zero "
"otherwise."
msgstr ""
"C の I<符号無し整数 (unsigned)> とその外部表現を変換するための基本フィル"
"ター。 このルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:441
#, no-wrap
msgid "B<bool_t xdr_u_long(XDR *>I<xdrs>B<, unsigned long *>I<ulp>B<);>\n"
msgstr "B<bool_t xdr_u_long(XDR *>I<xdrs>B<, unsigned long *>I<ulp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:447
msgid ""
"A filter primitive that translates between C I<unsigned long> integers and "
"their external representations.  This routine returns one if it succeeds, "
"zero otherwise."
msgstr ""
"C の I<unsigned long> 整数とその外部表現を変換するための基本フィルター。 この"
"ルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:450
#, no-wrap
msgid "B<bool_t xdr_u_short(XDR *>I<xdrs>B<, unsigned short *>I<usp>B<);>\n"
msgstr "B<bool_t xdr_u_short(XDR *>I<xdrs>B<, unsigned short *>I<usp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:456
msgid ""
"A filter primitive that translates between C I<unsigned short> integers and "
"their external representations.  This routine returns one if it succeeds, "
"zero otherwise."
msgstr ""
"C の I<unsigned short> 整数とその外部表現を変換するための基本フィルター。 こ"
"のルーティンは成功した場合は 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:461
#, no-wrap
msgid ""
"B<bool_t xdr_union(XDR *>I<xdrs>B<, int *>I<dscmp>B<, char *>I<unp>B<,>\n"
"B<                 struct xdr_discrim *>I<choices>B<,>\n"
"B<                 xdrproc_t >I<defaultarm>B<);     /* may equal NULL */>\n"
msgstr ""
"B<bool_t xdr_union(XDR *>I<xdrs>B<, int *>I<dscmp>B<, char *>I<unp>B<,>\n"
"B<                 struct xdr_discrim *>I<choices>B<,>\n"
"B<                 xdrproc_t >I<defaultarm>B<);     /* may equal NULL */>\n"

#. type: Plain text
#: build/C/man3/xdr.3:495
msgid ""
"A filter primitive that translates between a discriminated C I<union> and "
"its corresponding external representation.  It first translates the "
"discriminant of the union located at I<dscmp>.  This discriminant is always "
"an I<enum_t>.  Next the union located at I<unp> is translated.  The argument "
"I<choices> is a pointer to an array of B<xdr_discrim>()  structures.  Each "
"structure contains an ordered pair of [I<value>,I<proc>].  If the union's "
"discriminant is equal to the associated I<value>, then the I<proc> is called "
"to translate the union.  The end of the B<xdr_discrim>()  structure array is "
"denoted by a routine of value NULL.  If the discriminant is not found in the "
"I<choices> array, then the I<defaultarm> procedure is called (if it is not "
"NULL).  Returns one if it succeeds, zero otherwise."
msgstr ""
"分別可能な C の I<共用体 (union)> とその外部形式とを変換する基本フィルター。 "
"最初に I<dscmp> として与えられた共用体の分別要素が変換される。 この分別要素は"
"常に I<enum_t> である。 次に I<unp> の位置の共用体が変換される。引き数 "
"I<choices> は B<xdr_discrim>()  構造体の配列へのポインターである。各構造体は "
"[I<value>,I<proc>] の順序付きペアを格納している。 もし共用体の分別要素が関連"
"付けられた I<value> と等しい場合には、共用体を変換するために I<proc> が呼び出"
"される。 B<xdr_discrim>()  構造体の配列の最後は、値 NULL のルーティン を指定"
"することで示される。 分別要素が I<choices> 配列の中に見つからなかった場合、 "
"I<defaultarm> が (NULL でなければ) 呼び出される。 成功した場合は 1 を返す。失"
"敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:499
#, no-wrap
msgid ""
"B<bool_t xdr_vector(XDR *>I<xdrs>B<, char *>I<arrp>B<, unsigned int >I<size>B<,>\n"
"B<                  unsigned int >I<elsize>B<, xdrproc_t >I<elproc>B<);>\n"
msgstr ""
"B<bool_t xdr_vector(XDR *>I<xdrs>B<, char *>I<arrp>B<, unsigned int >I<size>B<,>\n"
"B<                  unsigned int >I<elsize>B<, xdrproc_t >I<elproc>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:518
msgid ""
"A filter primitive that translates between fixed-length arrays and their "
"corresponding external representations.  The argument I<arrp> is the address "
"of the pointer to the array, while I<size> is the element count of the "
"array.  The argument I<elsize> is the I<sizeof> each of the array's "
"elements, and I<elproc> is an XDR filter that translates between the array "
"elements' C form, and their external representation.  This routine returns "
"one if it succeeds, zero otherwise."
msgstr ""
"固定長の配列とそれらが対応する外部表現とを変換する基本フィルター。 引き数 "
"I<arrp> は配列へのポインターのアドレスである。一方で I<size> は配列の要素数そ"
"のものである。引き数 I<elsize> は配列の各要素の I<sizeof> で、 I<elproc> は配"
"列の要素を C 形式からその外部表現へと変換する XDR フィルターである。 このルー"
"ティンは成功した場合 1 を返す。 失敗した場合はゼロを返す。"

#. type: Plain text
#: build/C/man3/xdr.3:521
#, no-wrap
msgid "B<bool_t xdr_void(void);>\n"
msgstr "B<bool_t xdr_void(void);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:526
msgid ""
"This routine always returns one.  It may be passed to RPC routines that "
"require a function argument, where nothing is to be done."
msgstr ""
"このルーティンは常に 1 を返す。 これは何も行なわないが、関数引き数が必要な "
"RPC ルーティンに渡すことができる。"

#. type: Plain text
#: build/C/man3/xdr.3:529
#, no-wrap
msgid "B<bool_t xdr_wrapstring(XDR *>I<xdrs>B<, char **>I<sp>B<);>\n"
msgstr "B<bool_t xdr_wrapstring(XDR *>I<xdrs>B<, char **>I<sp>B<);>\n"

#. type: Plain text
#: build/C/man3/xdr.3:542
msgid ""
"A primitive that calls B<xdr_string(xdrs, sp,MAXUN.UNSIGNED );> where "
"B<MAXUN.UNSIGNED> is the maximum value of an unsigned integer.  "
"B<xdr_wrapstring>()  is handy because the RPC package passes a maximum of "
"two XDR routines as arguments, and B<xdr_string>(), one of the most "
"frequently used primitives, requires three.  Returns one if it succeeds, "
"zero otherwise."
msgstr ""
"B<xdr_string(xdrs, sp, \\s-1MAXUN.UNSIGNED\\s0 );> を呼び出す基本ルーティ"
"ン。 ここで B<MAXUN.UNSIGNED> は符号無し整数(unsigned int)の最大値である。 "
"B<xdr_wrapstring>()  は、 RPC パッケージは二つの XDR ルーティンの最大値を引き"
"数として渡すため便利である。 B<xdr_string>()  は最も頻繁に利用される基本ルー"
"ティンであるが三つを要求する。 成功した場合は 1 を返す、失敗した場合はゼロを"
"返す。"

#. type: Plain text
#: build/C/man3/xdr.3:544
msgid "B<rpc>(3)"
msgstr "B<rpc>(3)"

#. type: Plain text
#: build/C/man3/xdr.3:548
msgid "eXternal Data Representation Standard: Protocol Specification"
msgstr "eXternal Data Representation Standard: Protocol Specification"

#. type: Plain text
#: build/C/man3/xdr.3:550
msgid "eXternal Data Representation: Sun Technical Notes"
msgstr "eXternal Data Representation: Sun Technical Notes"

#. type: Plain text
#: build/C/man3/xdr.3:554
msgid ""
"I<XDR: External Data Representation Standard>, RFC\\ 1014, Sun Microsystems, "
"Inc., USC-ISI."
msgstr ""
"I<XDR: External Data Representation Standard>, RFC\\ 1014, Sun Microsystems, "
"Inc., USC-ISI."

#~ msgid "1.5i +0.5i +1.0i +1.0i"
#~ msgstr "1.5i +0.5i +1.0i +1.0i"

#~ msgid "2010-02-25"
#~ msgstr "2010-02-25"
