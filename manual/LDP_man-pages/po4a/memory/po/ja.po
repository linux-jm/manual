# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-13 21:09+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr "ALLOC_HUGEPAGES"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/malloc_get_state.3:25
#: build/C/man3/malloc_usable_size.3:25 build/C/man2/mmap2.2:29
#: build/C/man3/posix_madvise.3:20 build/C/man2/remap_file_pages.2:28
#: build/C/man2/sync_file_range.2:30 build/C/man2/s390_pci_mmio_write.2:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man2/cacheflush.2:25
#: build/C/man2/fallocate.2:11 build/C/man2/madvise.2:35
#: build/C/man3/mallinfo.3:25 build/C/man3/malloc_stats.3:25
#: build/C/man3/malloc_trim.3:25 build/C/man3/mallopt.3:25
#: build/C/man2/mlock.2:26 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29
#: build/C/man2/mprotect.2:33 build/C/man2/mremap.2:30 build/C/man2/msync.2:25
#: build/C/man2/posix_fadvise.2:29 build/C/man3/posix_madvise.3:20
#: build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:28
#: build/C/man3/shm_open.3:25 build/C/man7/shm_overview.7:26
#: build/C/man2/shmctl.2:46 build/C/man2/shmget.2:38 build/C/man2/shmop.2:40
#: build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30
#: build/C/man2/memfd_create.2:21 build/C/man2/membarrier.2:25
#: build/C/man2/pkey_alloc.2:25 build/C/man7/pkeys.7:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/alloca.3:43
#: build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:11
#: build/C/man2/madvise.2:35 build/C/man3/mallinfo.3:25
#: build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_hook.3:10
#: build/C/man3/malloc_info.3:25 build/C/man3/malloc_stats.3:25
#: build/C/man3/malloc_trim.3:25 build/C/man3/malloc_usable_size.3:25
#: build/C/man3/mallopt.3:25 build/C/man3/mcheck.3:25 build/C/man2/mlock.2:26
#: build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:33
#: build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man3/mtrace.3:25
#: build/C/man2/posix_fadvise.2:29 build/C/man3/posix_fallocate.3:25
#: build/C/man3/posix_madvise.3:20 build/C/man3/posix_memalign.3:29
#: build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:28
#: build/C/man3/shm_open.3:25 build/C/man7/shm_overview.7:26
#: build/C/man2/shmctl.2:46 build/C/man2/shmget.2:38 build/C/man2/shmop.2:40
#: build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30
#: build/C/man2/memfd_create.2:21 build/C/man2/s390_pci_mmio_write.2:25
#: build/C/man2/membarrier.2:25 build/C/man2/pkey_alloc.2:25
#: build/C/man7/pkeys.7:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/alloc_hugepages.2:26 build/C/man3/alloca.3:44
#: build/C/man2/cacheflush.2:26 build/C/man2/fallocate.2:12
#: build/C/man2/madvise.2:36 build/C/man3/mallinfo.3:26
#: build/C/man3/malloc_get_state.3:26 build/C/man3/malloc_hook.3:11
#: build/C/man3/malloc_info.3:26 build/C/man3/malloc_stats.3:26
#: build/C/man3/malloc_trim.3:26 build/C/man3/malloc_usable_size.3:26
#: build/C/man3/mallopt.3:26 build/C/man3/mcheck.3:26 build/C/man2/mlock.2:27
#: build/C/man2/mmap.2:41 build/C/man2/mmap2.2:30 build/C/man2/mprotect.2:34
#: build/C/man2/mremap.2:31 build/C/man2/msync.2:26 build/C/man3/mtrace.3:26
#: build/C/man2/posix_fadvise.2:30 build/C/man3/posix_fallocate.3:26
#: build/C/man3/posix_madvise.3:21 build/C/man3/posix_memalign.3:30
#: build/C/man2/readahead.2:29 build/C/man2/remap_file_pages.2:29
#: build/C/man3/shm_open.3:26 build/C/man7/shm_overview.7:27
#: build/C/man2/shmctl.2:47 build/C/man2/shmget.2:39 build/C/man2/shmop.2:41
#: build/C/man2/subpage_prot.2:31 build/C/man2/sync_file_range.2:31
#: build/C/man2/memfd_create.2:22 build/C/man2/s390_pci_mmio_write.2:26
#: build/C/man2/membarrier.2:26 build/C/man2/pkey_alloc.2:26
#: build/C/man7/pkeys.7:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""
"alloc_hugepages, free_hugepages - 大きなサイズのページの割り当てと解放を行う"

#. type: SH
#: build/C/man2/alloc_hugepages.2:28 build/C/man3/alloca.3:46
#: build/C/man2/cacheflush.2:28 build/C/man2/fallocate.2:14
#: build/C/man2/madvise.2:38 build/C/man3/mallinfo.3:28
#: build/C/man3/malloc_get_state.3:28 build/C/man3/malloc_hook.3:15
#: build/C/man3/malloc_info.3:28 build/C/man3/malloc_stats.3:28
#: build/C/man3/malloc_trim.3:28 build/C/man3/malloc_usable_size.3:28
#: build/C/man3/mallopt.3:28 build/C/man3/mcheck.3:28 build/C/man2/mlock.2:29
#: build/C/man2/mmap.2:43 build/C/man2/mmap2.2:32 build/C/man2/mprotect.2:36
#: build/C/man2/mremap.2:33 build/C/man2/msync.2:28 build/C/man3/mtrace.3:28
#: build/C/man2/posix_fadvise.2:32 build/C/man3/posix_fallocate.3:28
#: build/C/man3/posix_madvise.3:23 build/C/man3/posix_memalign.3:32
#: build/C/man2/readahead.2:31 build/C/man2/remap_file_pages.2:31
#: build/C/man3/shm_open.3:28 build/C/man2/shmctl.2:49 build/C/man2/shmget.2:41
#: build/C/man2/shmop.2:43 build/C/man2/subpage_prot.2:33
#: build/C/man2/sync_file_range.2:33 build/C/man2/memfd_create.2:24
#: build/C/man2/s390_pci_mmio_write.2:29 build/C/man2/membarrier.2:28
#: build/C/man2/pkey_alloc.2:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr "B<int free_hugepages(void *>I<addr>B<);>\n"

#. type: SH
#: build/C/man2/alloc_hugepages.2:38 build/C/man3/alloca.3:50
#: build/C/man2/cacheflush.2:38 build/C/man2/fallocate.2:22
#: build/C/man2/madvise.2:59 build/C/man3/mallinfo.3:32
#: build/C/man3/malloc_get_state.3:36 build/C/man3/malloc_hook.3:33
#: build/C/man3/malloc_info.3:34 build/C/man3/malloc_stats.3:32
#: build/C/man3/malloc_trim.3:32 build/C/man3/malloc_usable_size.3:32
#: build/C/man3/mallopt.3:32 build/C/man3/mcheck.3:40 build/C/man2/mlock.2:40
#: build/C/man2/mmap.2:54 build/C/man2/mmap2.2:39 build/C/man2/mprotect.2:47
#: build/C/man2/mremap.2:41 build/C/man2/msync.2:32 build/C/man3/mtrace.3:34
#: build/C/man2/posix_fadvise.2:51 build/C/man3/posix_fallocate.3:46
#: build/C/man3/posix_madvise.3:42 build/C/man3/posix_memalign.3:83
#: build/C/man2/readahead.2:38 build/C/man2/remap_file_pages.2:39
#: build/C/man3/shm_open.3:40 build/C/man7/shm_overview.7:29
#: build/C/man2/shmctl.2:57 build/C/man2/shmget.2:49 build/C/man2/shmop.2:52
#: build/C/man2/subpage_prot.2:41 build/C/man2/sync_file_range.2:41
#: build/C/man2/memfd_create.2:31 build/C/man2/s390_pci_mmio_write.2:38
#: build/C/man2/membarrier.2:38 build/C/man2/pkey_alloc.2:36
#: build/C/man7/pkeys.7:28
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20, "
"the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""
"システムコール B<alloc_hugepages>()  と B<free_hugepages>()  は Linux 2.5.36 "
"で導入され、2.5.54 で再び削除された。 これらのシステムコールは i386 と ia64 "
"のみで (かつ B<CONFIG_HUGETLB_PAGE> を指定してビルドされた場合に) 存在する。 "
"Linux 2.4.20 では syscall 番号が存在するが、 呼び出すとエラー B<ENOSYS> で失"
"敗する。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4\\ KiB)  "
"and huge pages (2 or 4\\ MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr "i386 では、メモリー管理ハードウェアは通常のページ (4\\ KiB) と 大きなサイズのページ (以下、ヒュージページ; 2MiB または 4\\ MiB) を 扱うことができる。 同様に、ia64 もいくつかのサイズのヒュージページを扱うことができる。 これらのシステムコールは、ヒュージページをプロセスのメモリーにマップしたり、 再び解放したりする。 ヒュージページはメモリー内にロックされ、スワップされない。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""
"I<key> 引き数は識別子である。 0 の場合、ページは非公開になり、子プロセスに継"
"承されない。 正の場合、ページは同じ I<key> を使う他のアプリケーションと共有さ"
"れ、子プロセスに継承される。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""
"B<free_hugepages>()  の I<addr> 引き数は、どのページを解放するかを指定する: "
"I<addr> は B<alloc_hugepages>()  の呼び出しの返り値である (全てのユーザーがメ"
"モリーを解放したときに、 そのメモリーは初めて実際に解放される)。 "
"B<alloc_hugepages>()  の I<addr> 引き数はヒントであり、カーネルはそれに従うか"
"もしれないし、 従わないかもしれない。 アドレスは正しく配置されなければならな"
"い。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""
"I<len> 引き数は要求されたセグメントの長さである。 これはヒュージページのサイ"
"ズの倍数にしなければならない。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""
"I<prot> 引き数はセグメントのメモリー保護を指定する。 これは B<PROT_READ>, "
"B<PROT_WRITE>, B<PROT_EXEC> のいずれかである。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is "
"returned when no segment with the given key exists."
msgstr ""
"I<key> が正でない限り、 I<flag> 引き数は無視される。 I<key> が正で、かつ "
"I<flag> が B<IPC_CREAT> であり、かつ指定された I<key> で (セグメントが) 何も"
"存在しない場合、 新しいヒュージページセグメントが作成される。 I<flag> が設定"
"されておらず、かつ指定された I<key> のセグメントが存在しない場合、 B<ENOENT> "
"が返される。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:109 build/C/man3/alloca.3:60
#: build/C/man2/cacheflush.2:57 build/C/man2/fallocate.2:301
#: build/C/man2/madvise.2:455 build/C/man3/malloc_get_state.3:64
#: build/C/man3/malloc_info.3:48 build/C/man3/malloc_trim.3:52
#: build/C/man3/malloc_usable_size.3:40 build/C/man3/mallopt.3:436
#: build/C/man3/mcheck.3:129 build/C/man2/mlock.2:177 build/C/man2/mmap.2:490
#: build/C/man2/mmap2.2:54 build/C/man2/mprotect.2:139
#: build/C/man2/mremap.2:160 build/C/man2/msync.2:71
#: build/C/man2/posix_fadvise.2:127 build/C/man3/posix_fallocate.3:66
#: build/C/man3/posix_madvise.3:83 build/C/man3/posix_memalign.3:142
#: build/C/man2/readahead.2:66 build/C/man2/remap_file_pages.2:138
#: build/C/man3/shm_open.3:170 build/C/man2/shmctl.2:364
#: build/C/man2/shmget.2:215 build/C/man2/shmop.2:167
#: build/C/man2/subpage_prot.2:66 build/C/man2/sync_file_range.2:141
#: build/C/man2/memfd_create.2:158 build/C/man2/s390_pci_mmio_write.2:67
#: build/C/man2/membarrier.2:236 build/C/man2/pkey_alloc.2:70
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and "
"B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"成功した場合、 B<alloc_hugepages>()  は割り当てられた仮想アドレスを返し、 "
"B<free_hugepages>()  は 0 を返す。 失敗した場合、-1 を返し、 I<errno> が適切"
"に設定される。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:118 build/C/man2/cacheflush.2:63
#: build/C/man2/fallocate.2:308 build/C/man2/madvise.2:462
#: build/C/man3/malloc_info.3:55 build/C/man3/malloc_trim.3:57
#: build/C/man3/mallopt.3:441 build/C/man2/mlock.2:183 build/C/man2/mmap.2:509
#: build/C/man2/mmap2.2:61 build/C/man2/mprotect.2:148
#: build/C/man2/mremap.2:168 build/C/man2/msync.2:76
#: build/C/man2/posix_fadvise.2:130 build/C/man3/posix_fallocate.3:72
#: build/C/man3/posix_madvise.3:88 build/C/man3/posix_memalign.3:165
#: build/C/man2/readahead.2:72 build/C/man2/remap_file_pages.2:145
#: build/C/man3/shm_open.3:179 build/C/man2/shmctl.2:388
#: build/C/man2/shmget.2:220 build/C/man2/shmop.2:181
#: build/C/man2/subpage_prot.2:71 build/C/man2/sync_file_range.2:147
#: build/C/man2/memfd_create.2:165 build/C/man2/s390_pci_mmio_write.2:76
#: build/C/man2/membarrier.2:263 build/C/man2/pkey_alloc.2:80
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/alloc_hugepages.2:119 build/C/man2/fallocate.2:415
#: build/C/man2/membarrier.2:278
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr "このシステムコールはカーネルでサポートされていない。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:122
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: TP
#: build/C/man2/alloc_hugepages.2:123
#, no-wrap
msgid "I</proc/sys/vm/nr_hugepages>"
msgstr "I</proc/sys/vm/nr_hugepages>"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:127
msgid "Number of configured hugetlb pages.  This can be read and written."
msgstr "設定された hugetlb ページの数。 このファイルは読み書きできる。"

#. type: TP
#: build/C/man2/alloc_hugepages.2:127
#, no-wrap
msgid "I</proc/meminfo>"
msgstr "I</proc/meminfo>"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:131
msgid ""
"Gives info on the number of configured hugetlb pages and on their size in "
"the three variables HugePages_Total, HugePages_Free, Hugepagesize."
msgstr "設定された hugetlb ページの数と、 3 つの変数 HugePages_Total, HugePages_Free, Hugepagesize の サイズについての情報を提供する。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:131 build/C/man3/alloca.3:77
#: build/C/man2/cacheflush.2:80 build/C/man2/fallocate.2:475
#: build/C/man2/madvise.2:548 build/C/man3/mallinfo.3:148
#: build/C/man3/malloc_get_state.3:103 build/C/man3/malloc_hook.3:82
#: build/C/man3/malloc_info.3:76 build/C/man3/malloc_stats.3:67
#: build/C/man3/malloc_trim.3:74 build/C/man3/malloc_usable_size.3:60
#: build/C/man3/mallopt.3:449 build/C/man3/mcheck.3:166
#: build/C/man2/mlock.2:272 build/C/man2/mmap.2:656 build/C/man2/mmap2.2:77
#: build/C/man2/mprotect.2:215 build/C/man2/mremap.2:261
#: build/C/man2/msync.2:99 build/C/man3/mtrace.3:100
#: build/C/man2/posix_fadvise.2:162 build/C/man3/posix_fallocate.3:126
#: build/C/man3/posix_madvise.3:107 build/C/man3/posix_memalign.3:212
#: build/C/man2/readahead.2:88 build/C/man2/remap_file_pages.2:167
#: build/C/man3/shm_open.3:263 build/C/man2/shmctl.2:462
#: build/C/man2/shmget.2:280 build/C/man2/shmop.2:227
#: build/C/man2/subpage_prot.2:96 build/C/man2/sync_file_range.2:177
#: build/C/man2/memfd_create.2:204 build/C/man2/s390_pci_mmio_write.2:99
#: build/C/man2/membarrier.2:301 build/C/man2/pkey_alloc.2:109
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:134
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""
"このシステムコールは Intel プロセッサ上の Linux に固有のものであり、 移植性が"
"必要なプログラムで使うべきでない。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:134 build/C/man3/alloca.3:85
#: build/C/man2/cacheflush.2:93 build/C/man2/madvise.2:569
#: build/C/man3/malloc_get_state.3:105 build/C/man3/malloc_hook.3:84
#: build/C/man3/malloc_info.3:78 build/C/man3/malloc_stats.3:69
#: build/C/man3/malloc_trim.3:76 build/C/man3/malloc_usable_size.3:62
#: build/C/man3/mcheck.3:168 build/C/man2/mlock.2:302 build/C/man2/mmap.2:674
#: build/C/man2/mmap2.2:79 build/C/man2/mprotect.2:228
#: build/C/man2/mremap.2:267 build/C/man2/msync.2:123 build/C/man3/mtrace.3:102
#: build/C/man2/posix_fadvise.2:171 build/C/man3/posix_fallocate.3:151
#: build/C/man3/posix_madvise.3:109 build/C/man3/posix_memalign.3:252
#: build/C/man2/readahead.2:93 build/C/man2/remap_file_pages.2:171
#: build/C/man3/shm_open.3:273 build/C/man7/shm_overview.7:100
#: build/C/man2/shmctl.2:467 build/C/man2/shmget.2:288 build/C/man2/shmop.2:242
#: build/C/man2/subpage_prot.2:98 build/C/man2/sync_file_range.2:180
#: build/C/man2/memfd_create.2:208 build/C/man2/s390_pci_mmio_write.2:102
#: build/C/man2/membarrier.2:308 build/C/man2/pkey_alloc.2:115
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:142
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs filesystem can be used instead.  Memory backed by "
"huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual filesystem."
msgstr ""
"これらのシステムコールはなくなった。 これらは Linux 2.5.36 から 2.5.54 にのみ"
"存在する。 代わりに今は hugetlbfs ファイルシステムを使うことができる。 (CPU "
"がサポートしている場合) ヒュージページを持つメモリーは、 B<mmap>(2)  を使って"
"この仮想ファイルシステムでファイルをマップすることで取得できる。"

#. .PP
#.  requires CONFIG_HUGETLB_PAGE (under "Processor type and features")
#.  and CONFIG_HUGETLBFS (under "Filesystems").
#.  mount \-t hugetlbfs hugetlbfs /huge
#.  SHM_HUGETLB
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:151
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""
"ヒュージページの最大数は、 B<hugepages=> 起動パラメーターを使って指定できる。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:151 build/C/man3/alloca.3:178
#: build/C/man2/cacheflush.2:161 build/C/man2/fallocate.2:483
#: build/C/man2/madvise.2:596 build/C/man3/mallinfo.3:324
#: build/C/man3/malloc_get_state.3:131 build/C/man3/malloc_hook.3:147
#: build/C/man3/malloc_info.3:272 build/C/man3/malloc_stats.3:79
#: build/C/man3/malloc_trim.3:104 build/C/man3/malloc_usable_size.3:76
#: build/C/man3/mallopt.3:627 build/C/man3/mcheck.3:229
#: build/C/man2/mlock.2:499 build/C/man2/mmap.2:1022 build/C/man2/mmap2.2:101
#: build/C/man2/mprotect.2:373 build/C/man2/mremap.2:369
#: build/C/man2/msync.2:154 build/C/man3/mtrace.3:192
#: build/C/man2/posix_fadvise.2:243 build/C/man3/posix_fallocate.3:193
#: build/C/man3/posix_madvise.3:129 build/C/man3/posix_memalign.3:308
#: build/C/man2/readahead.2:113 build/C/man2/remap_file_pages.2:191
#: build/C/man3/shm_open.3:517 build/C/man7/shm_overview.7:124
#: build/C/man2/shmctl.2:520 build/C/man2/shmget.2:426 build/C/man2/shmop.2:508
#: build/C/man2/subpage_prot.2:134 build/C/man2/sync_file_range.2:224
#: build/C/man2/memfd_create.2:552 build/C/man2/s390_pci_mmio_write.2:108
#: build/C/man2/membarrier.2:471 build/C/man2/pkey_alloc.2:140
#: build/C/man7/pkeys.7:297
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:159 build/C/man3/alloca.3:186
#: build/C/man2/cacheflush.2:169 build/C/man2/fallocate.2:491
#: build/C/man2/madvise.2:604 build/C/man3/mallinfo.3:332
#: build/C/man3/malloc_get_state.3:139 build/C/man3/malloc_hook.3:155
#: build/C/man3/malloc_info.3:280 build/C/man3/malloc_stats.3:87
#: build/C/man3/malloc_trim.3:112 build/C/man3/malloc_usable_size.3:84
#: build/C/man3/mallopt.3:635 build/C/man3/mcheck.3:237
#: build/C/man2/mlock.2:507 build/C/man2/mmap.2:1030 build/C/man2/mmap2.2:109
#: build/C/man2/mprotect.2:381 build/C/man2/mremap.2:377
#: build/C/man2/msync.2:162 build/C/man3/mtrace.3:200
#: build/C/man2/posix_fadvise.2:251 build/C/man3/posix_fallocate.3:201
#: build/C/man3/posix_madvise.3:137 build/C/man3/posix_memalign.3:316
#: build/C/man2/readahead.2:121 build/C/man2/remap_file_pages.2:199
#: build/C/man3/shm_open.3:525 build/C/man7/shm_overview.7:132
#: build/C/man2/shmctl.2:528 build/C/man2/shmget.2:434 build/C/man2/shmop.2:516
#: build/C/man2/subpage_prot.2:142 build/C/man2/sync_file_range.2:232
#: build/C/man2/memfd_create.2:560 build/C/man2/s390_pci_mmio_write.2:116
#: build/C/man2/membarrier.2:479 build/C/man2/pkey_alloc.2:148
#: build/C/man7/pkeys.7:305
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/alloca.3:43
#, no-wrap
msgid "ALLOCA"
msgstr "ALLOCA"

#. type: TH
#: build/C/man3/alloca.3:43 build/C/man2/posix_fadvise.2:29
#: build/C/man2/readahead.2:28
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: build/C/man3/alloca.3:43 build/C/man3/malloc_get_state.3:25
#: build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25
#: build/C/man3/malloc_usable_size.3:25 build/C/man3/mcheck.3:25
#: build/C/man3/mtrace.3:25 build/C/man3/posix_fallocate.3:25
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/alloca.3:46
msgid "alloca - allocate memory that is automatically freed"
msgstr "alloca - 自動的に解放されるメモリーを割り当てる"

#. type: Plain text
#: build/C/man3/alloca.3:48
msgid "B<#include E<lt>alloca.hE<gt>>"
msgstr "B<#include E<lt>alloca.hE<gt>>"

#. type: Plain text
#: build/C/man3/alloca.3:50
msgid "B<void *alloca(size_t >I<size>B<);>"
msgstr "B<void *alloca(size_t >I<size>B<);>"

#. type: Plain text
#: build/C/man3/alloca.3:60
msgid ""
"The B<alloca>()  function allocates I<size> bytes of space in the stack "
"frame of the caller.  This temporary space is automatically freed when the "
"function that called B<alloca>()  returns to its caller."
msgstr ""
"B<alloca>()  関数は、 I<size> バイトの領域を呼出元のスタックフレームに割り付"
"ける。 この一時的な領域は、 B<alloca>()  を呼び出した関数が呼出元に返るときに"
"自動的に解放される。"

#. type: Plain text
#: build/C/man3/alloca.3:65
msgid ""
"The B<alloca>()  function returns a pointer to the beginning of the "
"allocated space.  If the allocation causes stack overflow, program behavior "
"is undefined."
msgstr ""
"B<alloca>()  関数は、割り付けた領域の始まりを指すポインターを返す。 割り付け"
"によってスタックオーバーフローが起った場合の プログラムの動作は定義されていな"
"い。"

#. type: SH
#: build/C/man3/alloca.3:65 build/C/man3/mallinfo.3:122
#: build/C/man3/malloc_get_state.3:89 build/C/man3/malloc_info.3:63
#: build/C/man3/malloc_stats.3:54 build/C/man3/malloc_trim.3:61
#: build/C/man3/malloc_usable_size.3:48 build/C/man3/mcheck.3:145
#: build/C/man2/mmap.2:643 build/C/man3/mtrace.3:78
#: build/C/man3/posix_fallocate.3:114 build/C/man3/posix_memalign.3:190
#: build/C/man3/shm_open.3:249
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/alloca.3:68 build/C/man3/mallinfo.3:125
#: build/C/man3/malloc_get_state.3:92 build/C/man3/malloc_info.3:66
#: build/C/man3/malloc_stats.3:57 build/C/man3/malloc_trim.3:64
#: build/C/man3/malloc_usable_size.3:51 build/C/man3/mcheck.3:148
#: build/C/man2/mmap.2:646 build/C/man3/mtrace.3:81
#: build/C/man3/posix_fallocate.3:117 build/C/man3/posix_memalign.3:193
#: build/C/man3/shm_open.3:252
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/alloca.3:72 build/C/man3/mallinfo.3:129
#: build/C/man3/malloc_get_state.3:96 build/C/man3/malloc_info.3:70
#: build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:68
#: build/C/man3/malloc_usable_size.3:55 build/C/man3/mcheck.3:152
#: build/C/man2/mmap.2:650 build/C/man3/mtrace.3:85
#: build/C/man3/posix_fallocate.3:121 build/C/man3/posix_memalign.3:197
#: build/C/man3/shm_open.3:256
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/alloca.3:72 build/C/man3/mallinfo.3:129
#: build/C/man3/malloc_get_state.3:96 build/C/man3/malloc_info.3:70
#: build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:68
#: build/C/man3/malloc_usable_size.3:55 build/C/man3/mcheck.3:152
#: build/C/man2/mmap.2:650 build/C/man3/mtrace.3:85
#: build/C/man3/posix_fallocate.3:121 build/C/man3/posix_memalign.3:197
#: build/C/man3/shm_open.3:256
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/alloca.3:72 build/C/man3/mallinfo.3:129
#: build/C/man3/malloc_get_state.3:96 build/C/man3/malloc_info.3:70
#: build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:68
#: build/C/man3/malloc_usable_size.3:55 build/C/man3/mcheck.3:152
#: build/C/man2/mmap.2:650 build/C/man3/mtrace.3:85
#: build/C/man3/posix_fallocate.3:121 build/C/man3/posix_memalign.3:197
#: build/C/man3/shm_open.3:256
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/alloca.3:75
#, no-wrap
msgid "B<alloca>()"
msgstr "B<alloca>()"

#. type: tbl table
#: build/C/man3/alloca.3:75 build/C/man3/mallinfo.3:132
#: build/C/man3/malloc_get_state.3:100 build/C/man3/malloc_info.3:73
#: build/C/man3/malloc_stats.3:64 build/C/man3/malloc_trim.3:71
#: build/C/man3/malloc_usable_size.3:58 build/C/man3/mcheck.3:159
#: build/C/man2/mmap.2:654 build/C/man3/mtrace.3:89
#: build/C/man3/posix_fallocate.3:124 build/C/man3/posix_memalign.3:204
#: build/C/man3/posix_memalign.3:209 build/C/man3/shm_open.3:260
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/alloca.3:75 build/C/man3/malloc_get_state.3:100
#: build/C/man3/malloc_info.3:73 build/C/man3/malloc_stats.3:64
#: build/C/man3/malloc_trim.3:71 build/C/man3/malloc_usable_size.3:58
#: build/C/man2/mmap.2:654 build/C/man3/posix_memalign.3:204
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/alloca.3:79
msgid "This function is not in POSIX.1."
msgstr "この関数は POSIX.1 にはない。"

#. type: Plain text
#: build/C/man3/alloca.3:85
msgid ""
"There is evidence that the B<alloca>()  function appeared in 32V, PWB, "
"PWB.2, 3BSD, and 4BSD.  There is a man page for it in 4.3BSD.  Linux uses "
"the GNU version."
msgstr ""
"32V, PWB, PWB.2, 3BSD, 4BSD に B<alloca>()  関数が登場した証拠がある。 "
"4.3BSD には、マニュアルページがある。 Linux は、GNU 版を使っている。 この関数"
"は POSIX.1-2001 にはない。"

#. type: Plain text
#: build/C/man3/alloca.3:100
msgid ""
"The B<alloca>()  function is machine- and compiler-dependent.  For certain "
"applications, its use can improve efficiency compared to the use of "
"B<malloc>(3)  plus B<free>(3).  In certain cases, it can also simplify "
"memory deallocation in applications that use B<longjmp>(3)  or "
"B<siglongjmp>(3).  Otherwise, its use is discouraged."
msgstr ""
"B<alloca>()  関数は、機種とコンパイラに依存する。 特定のアプリケーションで"
"は、この関数を使うと B<malloc>(3)  と B<free>(3)  を組み合わせて使った場合に"
"比べて効率を改善することができる。 特定の場合では、この関数を使うことで、 "
"B<longjmp>(3)  や B<siglongjmp>(3)  を使うアプリケーションでのメモリーの開放"
"を簡単にすることができる。 それ以外の場合では、この関数の使用は推奨されない。"

#. type: Plain text
#: build/C/man3/alloca.3:109
msgid ""
"Because the space allocated by B<alloca>()  is allocated within the stack "
"frame, that space is automatically freed if the function return is jumped "
"over by a call to B<longjmp>(3)  or B<siglongjmp>(3)."
msgstr "B<alloca>() により割り当てられる空間はスタックフレームから割り当てられるので、 関数の戻り先が B<longjmp>(3) や B<siglongjmp>(3) の呼び出しによりジャンプした場合には、 割り当てられた空間は自動的に解放される。"

#. type: Plain text
#: build/C/man3/alloca.3:116
msgid ""
"The space allocated by B<alloca>()  is I<not> automatically deallocated if "
"the pointer that refers to it simply goes out of scope."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:121
msgid "Do not attempt to B<free>(3)  space allocated by B<alloca>()!"
msgstr ""
"B<alloca>()  で割り当てられた空間を B<free>(3)  しようとすることのないよう"
"に！"

#. type: SS
#: build/C/man3/alloca.3:121
#, no-wrap
msgid "Notes on the GNU version"
msgstr "GNU 版についての注意"

#. type: Plain text
#: build/C/man3/alloca.3:143
msgid ""
"Normally, B<gcc>(1)  translates calls to B<alloca>()  with inlined code.  "
"This is not done when either the I<-ansi>, I<-std=c89>, I<-std=c99>, or the "
"I<-std=c11> option is given B<and> the header I<E<lt>alloca.hE<gt>> is not "
"included.  Otherwise, (without an -ansi or -std=c* option) the glibc version "
"of I<E<lt>stdlib.hE<gt>> includes I<E<lt>alloca.hE<gt>> and that contains "
"the lines:"
msgstr ""
"通常 B<gcc>(1) は B<alloca>()  の呼び出しをインラインコードに変換する。 I<-"
"ansi>, I<-std=c89>, I<-std=c99>, I<-std=c11> のいずれかのオプションが指定さ"
"れ、B<かつ> I<E<lt>alloca.hE<gt>> がインクルードされていない場合、 この変換は"
"行われない。 それ以外の場合 (-ansi オプションも -std=c* オプションも指定され"
"ない場合) には、 glibc 版の I<E<lt>stdlib.hE<gt>> は I<E<lt>alloca.hE<gt>> を"
"インクルードするが、このファイルには以下の行が含まれており、"

#. type: Plain text
#: build/C/man3/alloca.3:149
#, no-wrap
msgid ""
"#ifdef  __GNUC__\n"
"#define alloca(size)   __builtin_alloca (size)\n"
"#endif\n"
msgstr ""
"#ifdef  __GNUC__\n"
"#define alloca(size)   __builtin_alloca (size)\n"
"#endif\n"

#. type: Plain text
#: build/C/man3/alloca.3:153
msgid "with messy consequences if one has a private version of this function."
msgstr "独自版の __builtin_alloca (size) 関数がある場合、厄介な結果になる。"

#. type: Plain text
#: build/C/man3/alloca.3:157
msgid ""
"The fact that the code is inlined means that it is impossible to take the "
"address of this function, or to change its behavior by linking with a "
"different library."
msgstr ""
"このコードはインライン化されているので、 この関数のアドレスを取得したり、 他"
"のライブラリをリンクして動作を変更することはできない。"

#. type: Plain text
#: build/C/man3/alloca.3:161
msgid ""
"The inlined code often consists of a single instruction adjusting the stack "
"pointer, and does not check for stack overflow.  Thus, there is no NULL "
"error return."
msgstr ""
"通常このインラインコードはスタックポインターを移動する 1 つの命令 "
"(instruction) から構成されており、 スタックオーバーフローをチェックしない。 "
"よって NULL エラーが返されることはない。"

#. type: SH
#: build/C/man3/alloca.3:161 build/C/man2/cacheflush.2:146
#: build/C/man3/mallinfo.3:152 build/C/man3/mallopt.3:463
#: build/C/man2/mlock.2:443 build/C/man2/mmap.2:866 build/C/man2/mremap.2:333
#: build/C/man3/mtrace.3:124 build/C/man2/posix_fadvise.2:231
#: build/C/man2/readahead.2:98 build/C/man2/shmget.2:408
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/alloca.3:166
msgid ""
"There is no error indication if the stack frame cannot be extended.  "
"(However, after a failed allocation, the program is likely to receive a "
"B<SIGSEGV> signal if it attempts to access the unallocated space.)"
msgstr ""
"スタックフレームが拡張できなかった場合、エラー通知は行われない。 (しかしなが"
"ら、割り当てに失敗した後で、プログラムが割り当てられなかった 空間にアクセスし"
"ようとした場合に B<SIGSEGV> シグナルを受信することだろう。)"

#. type: Plain text
#: build/C/man3/alloca.3:174
msgid ""
"On many systems B<alloca>()  cannot be used inside the list of arguments of "
"a function call, because the stack space reserved by B<alloca>()  would "
"appear on the stack in the middle of the space for the function arguments."
msgstr ""
"多くのシステムにおいて、関数コールの引き数のリスト内では B<alloca>()  が使え"
"ない。 これは、 B<alloca>()  によって予約されるスタック領域が、 関数引き数に"
"使われるスタック領域の中に現れてしまうためである。"

#. type: SH
#: build/C/man3/alloca.3:174 build/C/man2/fallocate.2:478
#: build/C/man2/madvise.2:586 build/C/man3/mallinfo.3:315
#: build/C/man3/malloc_get_state.3:128 build/C/man3/malloc_hook.3:142
#: build/C/man3/malloc_info.3:266 build/C/man3/malloc_stats.3:73
#: build/C/man3/malloc_trim.3:100 build/C/man3/malloc_usable_size.3:74
#: build/C/man3/mallopt.3:613 build/C/man3/mcheck.3:225
#: build/C/man2/mlock.2:491 build/C/man2/mmap.2:994 build/C/man2/mmap2.2:95
#: build/C/man2/mprotect.2:369 build/C/man2/mremap.2:354
#: build/C/man2/msync.2:150 build/C/man3/mtrace.3:187
#: build/C/man2/posix_fadvise.2:236 build/C/man3/posix_fallocate.3:188
#: build/C/man3/posix_madvise.3:126 build/C/man3/posix_memalign.3:303
#: build/C/man2/readahead.2:107 build/C/man2/remap_file_pages.2:184
#: build/C/man3/shm_open.3:505 build/C/man7/shm_overview.7:111
#: build/C/man2/shmctl.2:513 build/C/man2/shmget.2:417 build/C/man2/shmop.2:500
#: build/C/man2/subpage_prot.2:128 build/C/man2/sync_file_range.2:219
#: build/C/man2/memfd_create.2:546 build/C/man2/s390_pci_mmio_write.2:106
#: build/C/man2/pkey_alloc.2:137 build/C/man7/pkeys.7:292
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/alloca.3:178
msgid "B<brk>(2), B<longjmp>(3), B<malloc>(3)"
msgstr "B<brk>(2), B<longjmp>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/cacheflush.2:25
#, no-wrap
msgid "CACHEFLUSH"
msgstr "CACHEFLUSH"

#. type: TH
#: build/C/man2/cacheflush.2:25 build/C/man2/mmap.2:40
#: build/C/man3/posix_memalign.3:29 build/C/man2/shmctl.2:46
#: build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man2/cacheflush.2:28
msgid "cacheflush - flush contents of instruction and/or data cache"
msgstr "cacheflush - 命令キャッシュやデータキャッシュの内容をフラッシュする"

#. type: Plain text
#: build/C/man2/cacheflush.2:31
#, no-wrap
msgid "B<#include E<lt>asm/cachectl.hE<gt>>\n"
msgstr "B<#include E<lt>asm/cachectl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/cacheflush.2:33
#, no-wrap
msgid "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"
msgstr "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"

#. type: Plain text
#: build/C/man2/cacheflush.2:38
msgid ""
"I<Note>: On some architectures, there is no glibc wrapper for this system "
"call; see NOTES."
msgstr "I<注>: いくつかのアーキテクチャーでは、このシステムコールには glibc のラッパー関数は存在しない。「注意」の節を参照。"

#. type: Plain text
#: build/C/man2/cacheflush.2:47
msgid ""
"B<cacheflush>()  flushes the contents of the indicated cache(s) for the user "
"addresses in the range I<addr> to I<(addr+nbytes-1)>.  I<cache> may be one "
"of:"
msgstr ""
"B<cacheflush>()  は I<addr> から I<(addr+nbytes-1)> の範囲のユーザーアドレス"
"に対応する 指定されたキャッシュをフラッシュする。 I<cache> には以下のいずれか"
"を指定する:"

#. type: TP
#: build/C/man2/cacheflush.2:47
#, no-wrap
msgid "B<ICACHE>"
msgstr "B<ICACHE>"

#. type: Plain text
#: build/C/man2/cacheflush.2:50
msgid "Flush the instruction cache."
msgstr "命令 (instruction) キャッシュをフラッシュする。"

#. type: TP
#: build/C/man2/cacheflush.2:50
#, no-wrap
msgid "B<DCACHE>"
msgstr "B<DCACHE>"

#. type: Plain text
#: build/C/man2/cacheflush.2:53
msgid "Write back to memory and invalidate the affected valid cache lines."
msgstr "変更があったキャッシュラインをメモリーに書き戻し、無効にする。"

#. type: TP
#: build/C/man2/cacheflush.2:53
#, no-wrap
msgid "B<BCACHE>"
msgstr "B<BCACHE>"

#. type: Plain text
#: build/C/man2/cacheflush.2:57
msgid "Same as B<(ICACHE|DCACHE)>."
msgstr "B<(ICACHE|DCACHE)> と同じ。"

#. type: Plain text
#: build/C/man2/cacheflush.2:63
msgid ""
"B<cacheflush>()  returns 0 on success or -1 on error.  If errors are "
"detected, I<errno> will indicate the error."
msgstr ""
"B<cacheflush>()  は成功した場合は 0 を、失敗した場合は -1 を返す。エラーが検"
"出された場合は I<errno> にエラーが指示される。"

#. type: TP
#: build/C/man2/cacheflush.2:64 build/C/man2/mmap2.2:62
#: build/C/man2/mremap.2:175 build/C/man2/shmctl.2:397
#: build/C/man2/subpage_prot.2:72 build/C/man2/memfd_create.2:166
#: build/C/man2/s390_pci_mmio_write.2:77 build/C/man2/s390_pci_mmio_write.2:82
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/cacheflush.2:71
msgid ""
"Some or all of the address range I<addr> to I<(addr+nbytes-1)> is not "
"accessible."
msgstr ""
"I<addr> から I<(addr+nbytes-1)> の範囲のアドレスの全てまたは一部が アクセス可"
"能ではない。"

#. type: TP
#: build/C/man2/cacheflush.2:71 build/C/man2/fallocate.2:327
#: build/C/man2/fallocate.2:339 build/C/man2/fallocate.2:349
#: build/C/man2/fallocate.2:357 build/C/man2/fallocate.2:369
#: build/C/man2/fallocate.2:381 build/C/man2/madvise.2:475
#: build/C/man2/madvise.2:483 build/C/man2/madvise.2:487
#: build/C/man2/madvise.2:497 build/C/man2/madvise.2:506
#: build/C/man3/malloc_info.3:56 build/C/man2/mlock.2:219
#: build/C/man2/mlock.2:226 build/C/man2/mlock.2:247 build/C/man2/mlock.2:253
#: build/C/man2/mmap.2:548 build/C/man2/mmap.2:556 build/C/man2/mmap.2:561
#: build/C/man2/mmap2.2:65 build/C/man2/mprotect.2:158
#: build/C/man2/mprotect.2:162 build/C/man2/mprotect.2:167
#: build/C/man2/mprotect.2:175 build/C/man2/mprotect.2:179
#: build/C/man2/mremap.2:184 build/C/man2/msync.2:83
#: build/C/man2/posix_fadvise.2:134 build/C/man3/posix_fallocate.3:84
#: build/C/man3/posix_madvise.3:89 build/C/man3/posix_madvise.3:95
#: build/C/man3/posix_memalign.3:166 build/C/man2/readahead.2:77
#: build/C/man2/remap_file_pages.2:146 build/C/man2/remap_file_pages.2:153
#: build/C/man3/shm_open.3:212 build/C/man2/shmctl.2:411
#: build/C/man2/shmget.2:239 build/C/man2/shmget.2:247 build/C/man2/shmop.2:196
#: build/C/man2/shmop.2:219 build/C/man2/subpage_prot.2:77
#: build/C/man2/sync_file_range.2:152 build/C/man2/memfd_create.2:171
#: build/C/man2/memfd_create.2:175 build/C/man2/memfd_create.2:182
#: build/C/man2/s390_pci_mmio_write.2:86 build/C/man2/membarrier.2:264
#: build/C/man2/pkey_alloc.2:81
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/cacheflush.2:80
msgid ""
"I<cache> is not one of B<ICACHE>, B<DCACHE>, or B<BCACHE> (but see BUGS)."
msgstr "I<cache> パラメーターが B<ICACHE>, B<DCACHE>, B<BCACHE> のどれでもない (ただし「バグ」を参照)。"

#. type: Plain text
#: build/C/man2/cacheflush.2:86
msgid ""
"Historically, this system call was available on all MIPS UNIX variants "
"including RISC/os, IRIX, Ultrix, NetBSD, OpenBSD, and FreeBSD (and also on "
"some non-UNIX MIPS operating systems), so that the existence of this call in "
"MIPS operating systems is a de-facto standard."
msgstr ""

#. type: SS
#: build/C/man2/cacheflush.2:86
#, no-wrap
msgid "Caveat"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:93
msgid ""
"B<cacheflush>()  should not be used in programs intended to be portable.  On "
"Linux, this call first appeared on the MIPS architecture, but nowadays, "
"Linux provides a B<cacheflush>()  system call on some other architectures, "
"but with different arguments."
msgstr ""

#. type: SS
#: build/C/man2/cacheflush.2:94 build/C/man2/posix_fadvise.2:199
#, no-wrap
msgid "Architecture-specific variants"
msgstr "アーキテクチャー固有の派生バージョン"

#. type: Plain text
#: build/C/man2/cacheflush.2:99
msgid ""
"Glibc provides a wrapper for this system call, with the prototype shown in "
"SYNOPSIS, for the following architectures: ARC, CSKY, MIPS, and NIOS2."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:102
msgid ""
"On some other architectures, Linux provides this system call, with different "
"arguments:"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:102
#, no-wrap
msgid "M68K:"
msgstr "M68K:"

#. type: Plain text
#: build/C/man2/cacheflush.2:107
#, no-wrap
msgid ""
"B<int cacheflush(unsigned long >I<addr>B<, int >I<scope>B<, int >I<cache>B<,>\n"
"B<               unsigned long >I<len>B<);>\n"
msgstr ""
"B<int cacheflush(unsigned long >I<addr>B<, int >I<scope>B<, int >I<cache>B<,>\n"
"B<               unsigned long >I<len>B<);>\n"

#. type: TP
#: build/C/man2/cacheflush.2:108
#, no-wrap
msgid "SH:"
msgstr "SH:"

#. type: Plain text
#: build/C/man2/cacheflush.2:112
#, no-wrap
msgid "B<int cacheflush(unsigned long >I<addr>B<, unsigned long >I<len>B<, int >I<op>B<);>\n"
msgstr "B<int cacheflush(unsigned long >I<addr>B<, unsigned long >I<len>B<, int >I<op>B<);>\n"

#. type: TP
#: build/C/man2/cacheflush.2:113
#, no-wrap
msgid "NDS32:"
msgstr "NDS32:"

#. type: Plain text
#: build/C/man2/cacheflush.2:117
#, no-wrap
msgid "B<int cacheflush(unsigned int >I<start>B<, unsigned int >I<end>B<, int >I<cache>B<);>\n"
msgstr "B<int cacheflush(unsigned int >I<start>B<, unsigned int >I<end>B<, int >I<cache>B<);>\n"

#. type: Plain text
#: build/C/man2/cacheflush.2:122
msgid ""
"On the above architectures, glibc does not provide a wrapper for this system "
"call; call it using B<syscall>(2)."
msgstr ""

#. type: SS
#: build/C/man2/cacheflush.2:122
#, no-wrap
msgid "GCC alternative"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:128
msgid ""
"Unless you need the finer grained control that this system call provides, "
"you probably want to use the GCC built-in function "
"B<__builtin___clear_cache>(), which provides a portable interface across "
"platforms supported by GCC and compatible compilers:"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:132
#, no-wrap
msgid "B<void __builtin___clear_cache(void *>I<begin>B<, void *>I<end>B<);>\n"
msgstr "B<void __builtin___clear_cache(void *>I<begin>B<, void *>I<end>B<);>\n"

#. type: Plain text
#: build/C/man2/cacheflush.2:138
msgid ""
"On platforms that don't require instruction cache flushes, "
"B<__builtin___clear_cache>()  has no effect."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:146
msgid ""
"I<Note>: On some GCC-compatible compilers, the prototype for this built-in "
"function uses I<char *> instead of I<void *> for the parameters."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:153
msgid ""
"Linux kernels older than version 2.6.11 ignore the I<addr> and I<nbytes> "
"arguments, making this function fairly expensive.  Therefore, the whole "
"cache is always flushed."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:161
msgid ""
"This function always behaves as if B<BCACHE> has been passed for the "
"I<cache> argument and does not do any error checking on the I<cache> "
"argument."
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr "FALLOCATE"

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "2019-11-19"
msgstr "2019-11-19"

#. type: Plain text
#: build/C/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr "fallocate - ファイル空間の操作"

#. type: Plain text
#: build/C/man2/fallocate.2:18 build/C/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/fallocate.2:21
#, no-wrap
msgid "B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr "B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""
"このシステムコールは、移植性のない、Linux 固有のシステムコールである。 移植性"
"が必要な場合は、ファイルに対してディスク空間を確実に確保するために、 POSIX.1 "
"で規定された方法である B<posix_fallocate>(3)  を使うこと。"

#. type: Plain text
#: build/C/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""
"B<fallocate>()  を使うと、 I<fd> が参照するファイルに割り当てられたディスク空"
"間を直接操作できる。 操作対象は、 I<offset> から始まる長さ I<len> バイトの領"
"域である。"

#. type: Plain text
#: build/C/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""
"I<mode> 引き数は、指定された領域に対して実行する操作を指定する。\n"
"サポートされている操作の詳細は以下のサブセクションで説明する。"

#. type: SS
#: build/C/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr "ディスク領域の割り当て"

#. type: Plain text
#: build/C/man2/fallocate.2:65
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"the disk space within the range specified by I<offset> and I<len>.  The file "
"size (as reported by B<stat>(2))  will be changed if I<offset>+I<len> is "
"greater than the file size.  Any subregion within the range specified by "
"I<offset> and I<len> that did not contain data before the call will be "
"initialized to zero.  This default behavior closely resembles the behavior "
"of the B<posix_fallocate>(3)  library function, and is intended as a method "
"of optimally implementing that function."
msgstr ""
"B<fallocate>() のデフォルトの動作 (つまり I<mode> が 0 の場合) は、 "
"I<offset> と I<len> で指定された範囲のディスク領域の割り当てを行う。 "
"I<offset>+I<len> がファイルサイズよりも大きかった場合、 (B<stat>(2) で報告さ"
"れる) ファイルサイズが変更される。 I<offset> と I<len> で指定される範囲のサブ"
"領域で、 呼び出し前にデータを保持していなかった場合、そのサブ領域は 0 で初期"
"化される。 このデフォルトの動作は、 ライブラリ関数 B<posix_fallocate>(3) の動"
"作と非常に似ている。 これは、 このシステムコールが B<posix_fallocate>(3) を最"
"適に実装する手段を提供することを目的としているからである。"

#. type: Plain text
#: build/C/man2/fallocate.2:71
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""
"呼び出しが成功した場合、\n"
"I<offset> と I<len> で指定された範囲へのそれ以降の書き込みでは、\n"
"ディスクの領域不足での書き込み失敗が起こらないことが保証される。"

#. type: Plain text
#: build/C/man2/fallocate.2:82
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if I<offset>"
"+I<len> is greater than the file size.  Preallocating zeroed blocks beyond "
"the end of the file in this manner is useful for optimizing append workloads."
msgstr ""
"B<FALLOC_FL_KEEP_SIZE> フラグが I<mode> に指定された場合、このシステムコー"
"ル\n"
"の動作は似ているが、 I<offset>+I<len> がファイルサイズよりも大きい場合で\n"
"あってもファイルサイズは変更されない点が異なる。この場合のファイルの末尾\n"
"よりも後ろの前もって割り当てられた 0 で埋められたブロックは、ファイルへの\n"
"追記を最適化したい場合に役に立つ。"

#. type: Plain text
#: build/C/man2/fallocate.2:92
msgid ""
"If the B<FALLOC_FL_UNSHARE> flag is specified in I<mode>, shared file data "
"extents will be made private to the file to guarantee that a subsequent "
"write will not fail due to lack of space.  Typically, this will be done by "
"performing a copy-on-write operation on all shared data in the file.  This "
"flag may not be supported by all filesystems."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:96
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""
"割り当てはブロックサイズ単位で行われるため、 B<fallocate>() は指定されたよ"
"り\n"
"も大きなディスク領域を割り当てることがある。"

#. type: SS
#: build/C/man2/fallocate.2:96
#, no-wrap
msgid "Deallocating file space"
msgstr "ファイル空間の割り当て解除"

#. type: Plain text
#: build/C/man2/fallocate.2:111
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified "
"range, partial filesystem blocks are zeroed, and whole filesystem blocks are "
"removed from the file.  After a successful call, subsequent reads from this "
"range will return zeros."
msgstr ""
"B<FALLOC_FL_PUNCH_HOLE> フラグ (Linux 2.6.38 以降で利用可能) を I<mode> に指"
"定すると、 I<offset> で始まる I<len> バイトの領域の空間を解放する (ホールを作"
"成する)。 指定された範囲のうち、 部分的に使用しているファイルシステムブロック"
"は 0 で埋められ、 全体を使用しているファイルシステムブロックはそのファイルか"
"ら削除される。 呼び出しが成功すると、 これ以降のこの範囲からの読み出しでは 0 "
"を返す。"

#. type: Plain text
#: build/C/man2/fallocate.2:122
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in "
"I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""
"B<FALLOC_FL_PUNCH_HOLE> フラグは B<FALLOC_FL_KEEP_SIZE> と論理和 (OR) をとっ"
"て I<mode> に指定しなければならない。 つまり、 ファイル末尾の punch off を"
"行った場合でも、 (B<stat>(2) で報告される) ファイルサイズが変化しない。"

#. type: Plain text
#: build/C/man2/fallocate.2:127
msgid ""
"Not all filesystems support B<FALLOC_FL_PUNCH_HOLE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""
"すべてのファイルシステムで B<FALLOC_FL_PUNCH_HOLE> がサポートされているわけで"
"はない。 ファイルシステムがこの操作をサポートしていない場合は、 エラーが返"
"る。 この操作は少なくとも以下のファイルシステムでサポートされている。"

#. type: IP
#: build/C/man2/fallocate.2:127 build/C/man2/fallocate.2:129
#: build/C/man2/fallocate.2:132 build/C/man2/fallocate.2:134
#: build/C/man2/fallocate.2:138 build/C/man2/fallocate.2:237
#: build/C/man2/fallocate.2:240 build/C/man2/fallocate.2:243
#: build/C/man2/fallocate.2:246 build/C/man3/mallopt.3:297
#: build/C/man3/mallopt.3:303 build/C/man2/mremap.2:189
#: build/C/man2/mremap.2:192 build/C/man2/mremap.2:201
#: build/C/man2/mremap.2:204 build/C/man2/mremap.2:209
#: build/C/man2/mremap.2:218 build/C/man2/mremap.2:224
#: build/C/man2/mremap.2:231 build/C/man2/mremap.2:237
#: build/C/man2/mremap.2:240 build/C/man2/mremap.2:250
#: build/C/man2/mremap.2:255 build/C/man2/mremap.2:311
#: build/C/man2/mremap.2:320 build/C/man3/posix_fallocate.3:160
#: build/C/man3/posix_fallocate.3:162 build/C/man3/posix_fallocate.3:165
#: build/C/man3/posix_fallocate.3:169 build/C/man2/memfd_create.2:299
#: build/C/man2/memfd_create.2:309 build/C/man2/memfd_create.2:317
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/fallocate.2:129
msgid "XFS (since Linux 2.6.38)"
msgstr "XFS (Linux 2.6.38 以降)"

#.  commit a4bb6b64e39abc0e41ca077725f2a72c868e7622
#. type: Plain text
#: build/C/man2/fallocate.2:132
msgid "ext4 (since Linux 3.0)"
msgstr "ext4 (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man2/fallocate.2:134
msgid "Btrfs (since Linux 3.7)"
msgstr "Btrfs (Linux 3.7 以降)"

#.  commit 83e4fa9c16e4af7122e31be3eca5d57881d236fe
#. type: Plain text
#: build/C/man2/fallocate.2:138
msgid "B<tmpfs>(5)  (since Linux 3.5)"
msgstr "B<tmpfs>(5)  (Linux 3.5 以降)"

#.  commit 4e56a6411fbce6f859566e17298114c2434391a4
#. type: Plain text
#: build/C/man2/fallocate.2:142
msgid "B<gfs2>(5)  (since Linux 4.16)"
msgstr "B<gfs2>(5)  (Linux 4.16 以降)"

#. type: SS
#: build/C/man2/fallocate.2:142
#, no-wrap
msgid "Collapsing file space"
msgstr "ファイル空間の一部削除"

#.  commit 00f5e61998dd17f5375d9dfc01331f104b83f841
#. type: Plain text
#: build/C/man2/fallocate.2:162
msgid ""
"Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux 3.15) "
"in I<mode> removes a byte range from a file, without leaving a hole.  The "
"byte range to be collapsed starts at I<offset> and continues for I<len> "
"bytes.  At the completion of the operation, the contents of the file "
"starting at the location I<offset+len> will be appended at the location "
"I<offset>, and the file will be I<len> bytes smaller."
msgstr ""
"B<FALLOC_FL_COLLAPSE_RANGE> フラグ (Linux 3.15 以降で利用可能) を I<mode> に"
"指定すると、 指定したバイト範囲をファイルから削除する。 その際、ホールを残さ"
"ない。 削除されるバイト範囲は I<offset> から始まる I<len> バイトの範囲であ"
"る。 操作が完了すると、 ファイルの I<offset+len> の位置から始まる内容が "
"I<offset> の位置に見えるようになり、 ファイルのサイズは I<len> バイトだけ小さ"
"くなる。"

#. type: Plain text
#: build/C/man2/fallocate.2:176
msgid ""
"A filesystem may place limitations on the granularity of the operation, in "
"order to ensure efficient implementation.  Typically, I<offset> and I<len> "
"must be a multiple of the filesystem logical block size, which varies "
"according to the filesystem type and configuration.  If a filesystem has "
"such a requirement, B<fallocate>()  fails with the error B<EINVAL> if this "
"requirement is violated."
msgstr ""
"効率的に動作する実装にするため、ファイルシステムはこの操作の粒度に制限を設け"
"ることがある。 通常は I<offset> と I<len> はファイルシステムの論理ブロックサ"
"イズの倍数でなければならない。 論理ブロックサイズはファイルシステムの種類や設"
"定により様々である。 ファイルシステムにこのような要求条件がある場合、 その要"
"求条件が満たされていなければ、 B<fallocate> はエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/fallocate.2:185
msgid ""
"If the region specified by I<offset> plus I<len> reaches or passes the end "
"of file, an error is returned; instead, use B<ftruncate>(2)  to truncate a "
"file."
msgstr ""
"I<offset> と I<len> で指定された範囲がファイルの末尾かそれより先まで達してい"
"る場合、 エラーが返される。 代わりに、ファイルの切り詰めを行う "
"B<ftruncate>(2) を使用すること。"

#. type: Plain text
#: build/C/man2/fallocate.2:190
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""
"B<FALLOC_FL_COLLAPSE_RANGE> と他のフラグを同時に I<mode> に指定することはでき"
"ない。"

#.  commit 9eb79482a97152930b113b51dff530aba9e28c8e
#.  commit e1d8fb88a64c1f8094b9f6c3b6d2d9e6719c970d
#. type: Plain text
#: build/C/man2/fallocate.2:198
msgid ""
"As at Linux 3.15, B<FALLOC_FL_COLLAPSE_RANGE> is supported by ext4 (only for "
"extent-based files)  and XFS."
msgstr ""
"Linux 3.15 時点では B<FALLOC_FL_COLLAPSE_RANGE> は ext4 (エクステントベースの"
"ファイル) と XFS でサポートされている。"

#. type: SS
#: build/C/man2/fallocate.2:198
#, no-wrap
msgid "Zeroing file space"
msgstr "ファイル空間のゼロ埋め"

#.  commit 409332b65d3ed8cfa7a8030f1e9d52f372219642
#. type: Plain text
#: build/C/man2/fallocate.2:214
msgid ""
"Specifying the B<FALLOC_FL_ZERO_RANGE> flag (available since Linux 3.15)  in "
"I<mode> zeros space in the byte range starting at I<offset> and continuing "
"for I<len> bytes.  Within the specified range, blocks are preallocated for "
"the regions that span the holes in the file.  After a successful call, "
"subsequent reads from this range will return zeros."
msgstr "B<FALLOC_FL_ZERO_RANGE> フラグ (Linux 3.15 以降で利用可能) を I<mode> に指定すると、 I<offset> で始まる I<len> バイト範囲の空間をゼロ埋めする。 指定された範囲の中では、ブロックは、そのファイル内のホールが広がる領域にあらかじめ割り当てられたものである。 呼び出しが成功すると、 これ以降のこの範囲からの読み出しでは 0 を返す。"

#. type: Plain text
#: build/C/man2/fallocate.2:220
msgid ""
"Zeroing is done within the filesystem preferably by converting the range "
"into unwritten extents.  This approach means that the specified range will "
"not be physically zeroed out on the device (except for partial blocks at the "
"either end of the range), and I/O is (otherwise) required only to update "
"metadata."
msgstr ""
"ゼロ埋めは、ファイルシステム内部では、指定された範囲を書き込みを伴わないエク"
"ステントに変換する方法をできるだけ使って行われる。 この方法は、指定された範囲"
"について物理的にゼロ埋めしたデータがデバイスに書き込まれるのではないことを意"
"味する (例外は指定された範囲の端の部分的に使用しているブロックである)。 (これ"
"以外で) I/O が必要なのはメタデータの更新だけである。"

#. type: Plain text
#: build/C/man2/fallocate.2:232
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is additionally specified in I<mode>, the "
"behavior of the call is similar, but the file size will not be changed even "
"if I<offset>+I<len> is greater than the file size.  This behavior is the "
"same as when preallocating space with B<FALLOC_FL_KEEP_SIZE> specified."
msgstr ""
"B<FALLOC_FL_KEEP_SIZE> フラグが I<mode> に追加で指定された場合、 このシステム"
"コールの動作は似ているが、 I<offset>+I<len> がファイルサイズよりも大きい場合"
"であってもファイルサイズは変更されない点が異なる。 この動作は "
"B<FALLOC_FL_KEEP_SIZE> を指定してスペースを前もって割り当てた場合と同じであ"
"る。"

#. type: Plain text
#: build/C/man2/fallocate.2:237
msgid ""
"Not all filesystems support B<FALLOC_FL_ZERO_RANGE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""
"すべてのファイルシステムで B<FALLOC_FL_ZERO_RANGE> がサポートされているわけで"
"はない。 ファイルシステムがこの操作をサポートしていない場合は、 エラーが返"
"る。 この操作は少なくとも以下のファイルシステムでサポートされている。"

#.  commit 376ba313147b4172f3e8cf620b9fb591f3e8cdfa
#. type: Plain text
#: build/C/man2/fallocate.2:240
msgid "XFS (since Linux 3.15)"
msgstr "XFS (Linux 3.15 以降)"

#.  commit b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
#. type: Plain text
#: build/C/man2/fallocate.2:243
msgid "ext4, for extent-based files (since Linux 3.15)"
msgstr "ext4 のエクステントベースのファイル (Linux 3.15 以降)"

#.  commit 30175628bf7f521e9ee31ac98fa6d6fe7441a556
#. type: Plain text
#: build/C/man2/fallocate.2:246
msgid "SMB3 (since Linux 3.17)"
msgstr "SMB3 (Linux 3.17 以降)"

#.  commit f27451f229966874a8793995b8e6b74326d125df
#. type: Plain text
#: build/C/man2/fallocate.2:249
msgid "Btrfs (since Linux 4.16)"
msgstr "Btrfs (Linux 4.16 以降)"

#. type: SS
#: build/C/man2/fallocate.2:249
#, fuzzy, no-wrap
#| msgid "Zeroing file space"
msgid "Increasing file space"
msgstr "ファイル空間のゼロ埋め"

#.  commit dd46c787788d5bf5b974729d43e4c405814a4c7d
#. type: Plain text
#: build/C/man2/fallocate.2:272
#, fuzzy
#| msgid ""
#| "Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux "
#| "3.15) in I<mode> removes a byte range from a file, without leaving a "
#| "hole.  The byte range to be collapsed starts at I<offset> and continues "
#| "for I<len> bytes.  At the completion of the operation, the contents of "
#| "the file starting at the location I<offset+len> will be appended at the "
#| "location I<offset>, and the file will be I<len> bytes smaller."
msgid ""
"Specifying the B<FALLOC_FL_INSERT_RANGE> flag (available since Linux 4.1)  "
"in I<mode> increases the file space by inserting a hole within the file size "
"without overwriting any existing data.  The hole will start at I<offset> and "
"continue for I<len> bytes.  When inserting the hole inside file, the "
"contents of the file starting at I<offset> will be shifted upward (i.e., to "
"a higher file offset) by I<len> bytes.  Inserting a hole inside a file "
"increases the file size by I<len> bytes."
msgstr ""
"B<FALLOC_FL_COLLAPSE_RANGE> フラグ (Linux 3.15 以降で利用可能) を I<mode> に"
"指定すると、 指定したバイト範囲をファイルから削除する。 その際、ホールを残さ"
"ない。 削除されるバイト範囲は I<offset> から始まる I<len> バイトの範囲であ"
"る。 操作が完了すると、 ファイルの I<offset+len> の位置から始まる内容が "
"I<offset> の位置に見えるようになり、 ファイルのサイズは I<len> バイトだけ小さ"
"くなる。"

#. type: Plain text
#: build/C/man2/fallocate.2:286
msgid ""
"This mode has the same limitations as B<FALLOC_FL_COLLAPSE_RANGE> regarding "
"the granularity of the operation.  If the granularity requirements are not "
"met, B<fallocate>()  fails with the error B<EINVAL>.  If the I<offset> is "
"equal to or greater than the end of file, an error is returned.  For such "
"operations (i.e., inserting a hole at the end of file), B<ftruncate>(2)  "
"should be used."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:291
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_INSERT_RANGE>."
msgstr "B<FALLOC_FL_INSERT_RANGE> と他のフラグを同時に I<mode> に指定することはできない。"

#.  commit a904b1ca5751faf5ece8600e18cd3b674afcca1b
#.  commit 331573febb6a224bc50322e3670da326cb7f4cfc
#.  f2fs also has support since Linux 4.2
#.      commit f62185d0e283e9d311e3ac1020f159d95f0aab39
#. type: Plain text
#: build/C/man2/fallocate.2:301
msgid ""
"B<FALLOC_FL_INSERT_RANGE> requires filesystem support.  Filesystems that "
"support this operation include XFS (since Linux 4.1)  and ext4 (since Linux "
"4.2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:308
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功の場合、 B<fallocate>() は 0 を返す。 エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/fallocate.2:309 build/C/man2/madvise.2:472
#: build/C/man2/mmap.2:532 build/C/man2/posix_fadvise.2:131
#: build/C/man3/posix_fallocate.3:73 build/C/man2/readahead.2:73
#: build/C/man2/sync_file_range.2:148
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/fallocate.2:313 build/C/man3/posix_fallocate.3:77
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""
"I<fd> が有効なファイルディスクリプターでないか、 書き込み用としてオープンされ"
"ていない。"

#. type: TP
#: build/C/man2/fallocate.2:313 build/C/man2/fallocate.2:317
#: build/C/man3/posix_fallocate.3:77
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/fallocate.2:317
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr "I<offset + len> がファイルサイズの最大値よりも大きい。"

#. type: Plain text
#: build/C/man2/fallocate.2:323
#, fuzzy
#| msgid ""
#| "I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by "
#| "I<offset> plus I<len> reaches or passes the end of the file."
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE>, and the current file size+I<len> "
"exceeds the maximum file size."
msgstr ""
"I<mode> が B<FALLOC_FL_COLLAPSE_RANGE> で、 I<offset> と I<len> で指定された"
"範囲がファイルの末尾かそれより先まで達している。"

#. type: TP
#: build/C/man2/fallocate.2:323 build/C/man3/posix_fallocate.3:81
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/fallocate.2:327
msgid "A signal was caught during execution; see B<signal>(7)."
msgstr "実行中にシグナルが捕捉された。 B<signal>(7) 参照。"

#.  FIXME . (raise a kernel bug) Probably the len==0 case should be
#.  a no-op, rather than an error. That would be consistent with
#.  similar APIs for the len==0 case.
#.  See "Re: [PATCH] fallocate.2: add FALLOC_FL_PUNCH_HOLE flag definition"
#.  21 Sep 2012
#.  http://thread.gmane.org/gmane.linux.file-systems/48331/focus=1193526
#. type: Plain text
#: build/C/man2/fallocate.2:339
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr "I<offset> が 0 未満だったか、 I<len> が 0 以下だった。"

#. type: Plain text
#: build/C/man2/fallocate.2:349
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by I<offset> "
"plus I<len> reaches or passes the end of the file."
msgstr ""
"I<mode> が B<FALLOC_FL_COLLAPSE_RANGE> で、 I<offset> と I<len> で指定された"
"範囲がファイルの末尾かそれより先まで達している。"

#. type: Plain text
#: build/C/man2/fallocate.2:357
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE> and the range specified by I<offset> "
"reaches or passes the end of the file."
msgstr "I<mode> が B<FALLOC_FL_INSERT_RANGE> で、 I<offset> と I<len> で指定された範囲がファイルの末尾かそれより先まで達している。"

#. type: Plain text
#: build/C/man2/fallocate.2:369
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, but "
"either I<offset> or I<len> is not a multiple of the filesystem block size."
msgstr "I<mode> が B<FALLOC_FL_COLLAPSE_RANGE> か B<FALLOC_FL_INSERT_RANGE> だが、 I<offset> か I<len> のいずれかがファイルシステムのブロックサイズの倍数ではない。"

#. type: Plain text
#: build/C/man2/fallocate.2:381
#, fuzzy
#| msgid ""
#| "I<mode> contains both B<FALLOC_FL_COLLAPSE_RANGE> and other flags; no "
#| "other flags are permitted with B<FALLOC_FL_COLLAPSE_RANGE>."
msgid ""
"I<mode> contains one of B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and also other flags; no other flags are permitted "
"with B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>."
msgstr ""
"I<mode> に B<FALLOC_FL_COLLAPSE_RANGE> と他のフラグの両方が指定されている。 "
"B<FALLOC_FL_COLLAPSE_RANGE> と他のフラグを一緒に使うことができない。"

#.  There was an inconsistency in 3.15-rc1, that should be resolved so that all
#.  filesystems use this error for this case. (Tytso says ex4 will change.)
#.  http://thread.gmane.org/gmane.comp.file-systems.xfs.general/60485/focus=5521
#.  From: Michael Kerrisk (man-pages <mtk.manpages@...>
#.  Subject: Re: [PATCH v5 10/10] manpage: update FALLOC_FL_COLLAPSE_RANGE flag in fallocate
#.  Newsgroups: gmane.linux.man, gmane.linux.file-systems
#.  Date: 2014-04-17 13:40:05 GMT
#. type: Plain text
#: build/C/man2/fallocate.2:400
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_ZERO_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE>, but the file referred to by I<fd> is not a "
"regular file."
msgstr "I<mode> が B<FALLOC_FL_COLLAPSE_RANGE> か B<FALLOC_FL_ZERO_RANGE> か B<FALLOC_FL_INSERT_RANGE> だが、 I<fd> が参照しているファイルが通常のファイルではない。"

#. type: TP
#: build/C/man2/fallocate.2:400 build/C/man2/madvise.2:518
#: build/C/man2/sync_file_range.2:160
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/fallocate.2:403
msgid "An I/O error occurred while reading from or writing to a filesystem."
msgstr "ファイルシステムとの読み書き中に入出力エラーが発生した。"

#. type: TP
#: build/C/man2/fallocate.2:403 build/C/man2/mmap.2:577
#: build/C/man3/posix_fallocate.3:91 build/C/man2/s390_pci_mmio_write.2:91
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/fallocate.2:410
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""
"I<fd> が通常のファイルかディレクトリを参照していない (I<fd> がパイプや FIFO "
"を参照している場合、別のエラーが発生する)。"

#. type: TP
#: build/C/man2/fallocate.2:410 build/C/man3/posix_fallocate.3:95
#: build/C/man2/shmget.2:265 build/C/man2/sync_file_range.2:166
#: build/C/man2/pkey_alloc.2:88
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/fallocate.2:415 build/C/man3/posix_fallocate.3:100
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr "I<fd> が参照するファイルを含むデバイスに十分な空き領域がない。"

#. type: Plain text
#: build/C/man2/fallocate.2:419
msgid "This kernel does not implement B<fallocate>()."
msgstr "このカーネルでは B<fallocate>() は実装されていない。"

#. type: TP
#: build/C/man2/fallocate.2:419 build/C/man3/posix_fallocate.3:100
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/fallocate.2:428
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the filesystem containing "
"the file referred to by I<fd>."
msgstr ""
"I<fd> が参照するファイルを含むファイルシステムが 指定された操作を\n"
"サポートしていない。 I<fd> が参照するファイルを含むファイルシステムが\n"
"I<mode> をサポートしていない。"

#. type: TP
#: build/C/man2/fallocate.2:428 build/C/man2/fallocate.2:434
#: build/C/man2/fallocate.2:449 build/C/man2/madvise.2:533
#: build/C/man2/mlock.2:204 build/C/man2/mlock.2:264 build/C/man2/mmap.2:612
#: build/C/man2/mmap.2:621 build/C/man2/shmctl.2:438 build/C/man2/shmget.2:273
#: build/C/man2/membarrier.2:283
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/fallocate.2:434
msgid "The file referred to by I<fd> is marked immutable (see B<chattr>(1))."
msgstr ""
"I<fd> が参照するファイルに変更不可 (immutable) の属性が付いている "
"(B<chattr>(1) 参照)。"

#. type: Plain text
#: build/C/man2/fallocate.2:449
msgid ""
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> or B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and the file referred to by I<fd> is marked append-"
"only (see B<chattr>(1))."
msgstr "I<mode> に B<FALLOC_FL_PUNCH_HOLE> か B<FALLOC_FL_COLLAPSE_RANGE> か B<FALLOC_FL_INSERT_RANGE> が指定されたが、 I<fd> が参照するファイルに追加のみ (append-only) の属性が付いている (B<chattr>(1) 参照)。"

#. type: Plain text
#: build/C/man2/fallocate.2:453 build/C/man2/mmap.2:625
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr "操作が file seal により禁止されている。 B<fcntl>(2) 参照。"

#. type: TP
#: build/C/man2/fallocate.2:453 build/C/man2/posix_fadvise.2:137
#: build/C/man3/posix_fallocate.3:107 build/C/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: build/C/man2/fallocate.2:457
msgid "I<fd> refers to a pipe or FIFO."
msgstr "I<fd> がパイプか FIFO を参照している。"

#. type: TP
#: build/C/man2/fallocate.2:457 build/C/man2/mmap.2:625
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man2/fallocate.2:467
msgid ""
"I<mode> specifies B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, "
"but the file referred to by I<fd> is currently being executed."
msgstr "I<mode> に B<FALLOC_FL_COLLAPSE_RANGE> か B<FALLOC_FL_INSERT_RANGE> が指定されたが、 I<fd> が参照するファイルは現在実行中である。"

#. type: SH
#: build/C/man2/fallocate.2:467 build/C/man2/madvise.2:541
#: build/C/man3/malloc_info.3:60 build/C/man3/mcheck.3:134
#: build/C/man2/mlock.2:268 build/C/man2/mmap2.2:74 build/C/man2/mprotect.2:211
#: build/C/man2/posix_fadvise.2:147 build/C/man3/posix_fallocate.3:111
#: build/C/man3/posix_madvise.3:103 build/C/man3/posix_memalign.3:175
#: build/C/man2/readahead.2:83 build/C/man2/remap_file_pages.2:162
#: build/C/man3/shm_open.3:247 build/C/man2/subpage_prot.2:90
#: build/C/man2/sync_file_range.2:174 build/C/man2/memfd_create.2:199
#: build/C/man2/s390_pci_mmio_write.2:97 build/C/man2/membarrier.2:287
#: build/C/man2/pkey_alloc.2:103
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: build/C/man2/fallocate.2:475
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""
"B<fallocate>()  はカーネル 2.6.23 以降の Linux で利用可能である。 glibc での"
"対応はバージョン 3.10 以降で行われている。 B<FALLOC_FL_*> が glibc のヘッダー"
"ファイルで定義されているのは、バージョン 2.18 以降のみである。"

#. type: Plain text
#: build/C/man2/fallocate.2:478
msgid "B<fallocate>()  is Linux-specific."
msgstr "B<fallocate>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/fallocate.2:483
msgid ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr "MADVISE"

#. type: TH
#: build/C/man2/madvise.2:35 build/C/man2/mlock.2:26 build/C/man2/shmget.2:38
#: build/C/man2/shmop.2:40
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr "madvise - メモリー利用に関するアドバイスを与える"

#. type: Plain text
#: build/C/man2/madvise.2:40 build/C/man2/msync.2:30 build/C/man3/shm_open.3:30
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: build/C/man2/madvise.2:42
msgid ""
"B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""
"B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"

#. type: Plain text
#: build/C/man2/madvise.2:46 build/C/man2/posix_fadvise.2:44
#: build/C/man3/posix_fallocate.3:39 build/C/man3/posix_madvise.3:33
#: build/C/man3/posix_memalign.3:49
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/madvise.2:49
msgid "B<madvise>():"
msgstr "B<madvise>():"

#. type: TP
#: build/C/man2/madvise.2:51
#, no-wrap
msgid "Since glibc 2.19:"
msgstr "glibc 2.19 以降:"

#. type: Plain text
#: build/C/man2/madvise.2:54
msgid "_DEFAULT_SOURCE"
msgstr "_DEFAULT_SOURCE"

#. type: TP
#: build/C/man2/madvise.2:54
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr "glibc 2.19 以前:"

#. type: Plain text
#: build/C/man2/madvise.2:57
msgid "_BSD_SOURCE"
msgstr "_BSD_SOURCE"

#. type: Plain text
#: build/C/man2/madvise.2:70
msgid ""
"The B<madvise>()  system call is used to give advice or directions to the "
"kernel about the address range beginning at address I<addr> and with size "
"I<length> bytes In most cases, the goal of such advice is to improve system "
"or application performance."
msgstr ""

#
#.  ======================================================================
#. type: Plain text
#: build/C/man2/madvise.2:83
msgid ""
"Initially, the system call supported a set of \"conventional\" I<advice> "
"values, which are also available on several other implementations.  (Note, "
"though, that B<madvise>()  is not specified in POSIX.)  Subsequently, a "
"number of Linux-specific I<advice> values have been added."
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:83
#, no-wrap
msgid "Conventional advice values"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:102
#, fuzzy
#| msgid ""
#| "The B<madvise>()  system call advises the kernel about how to handle "
#| "paging input/output in the address range beginning at address I<addr> and "
#| "with size I<length> bytes.  It allows an application to tell the kernel "
#| "how it expects to use some mapped or shared memory areas, so that the "
#| "kernel can choose appropriate read-ahead and caching techniques.  This "
#| "call does not influence the semantics of the application (except in the "
#| "case of B<MADV_DONTNEED>), but may influence its performance.  The kernel "
#| "is free to ignore the advice."
msgid ""
"The I<advice> values listed below allow an application to tell the kernel "
"how it expects to use some mapped or shared memory areas, so that the kernel "
"can choose appropriate read-ahead and caching techniques.  These I<advice> "
"values do not influence the semantics of the application (except in the case "
"of B<MADV_DONTNEED>), but may influence its performance.  All of the "
"I<advice> values listed here have analogs in the POSIX-specified "
"B<posix_madvise>(3)  function, and the values have the same meanings, with "
"the exception of B<MADV_DONTNEED>."
msgstr ""
"B<madvise>()  システムコールは、アドレス I<addr> からはじまる I<length> バイ"
"トのメモリーブロックのページング入出力をどう扱えば良いか、 カーネルにアドバイ"
"スする。 これを用いると、 アプリケーションからカーネルに、 マップされたメモ"
"リーや共有メモリーをどのように扱ってほしいか伝えることができ、 カーネルはそれ"
"に応じて先読みやキャッシュなどの適切な手法を選択できる。 このコールはアプリ"
"ケーションの動作そのものには影響しない (B<MADV_DONTNEED> の場合は別) が、 性"
"能には影響しうる。 なおこのアドバイスを受け入れるかどうかはカーネルに任され"
"る。"

#. type: Plain text
#: build/C/man2/madvise.2:106
msgid ""
"The advice is indicated in the I<advice> argument, which is one of the "
"following:"
msgstr "アドバイスは引き数 I<advice> により指定する。以下のいずれかを指定できる。"

#. type: TP
#: build/C/man2/madvise.2:106
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr "B<MADV_NORMAL>"

#. type: Plain text
#: build/C/man2/madvise.2:110
msgid "No special treatment.  This is the default."
msgstr "特別な扱いは行わない。これがデフォルトである。"

#. type: TP
#: build/C/man2/madvise.2:110
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr "B<MADV_RANDOM>"

#. type: Plain text
#: build/C/man2/madvise.2:114
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""
"ページ参照はランダムな順序で行われそうだ。 (したがって、先読みはあまり効果が"
"なさそうだ。)"

#. type: TP
#: build/C/man2/madvise.2:114
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr "B<MADV_SEQUENTIAL>"

#. type: Plain text
#: build/C/man2/madvise.2:119
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""
"ページ参照はシーケンシャルな順序で行われそうだ。 (したがって与えた範囲のペー"
"ジは積極的に先読みしておくと良いだろう。 またアクセスが終わったら速やかに解放"
"して良い。)"

#. type: TP
#: build/C/man2/madvise.2:119
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr "B<MADV_WILLNEED>"

#. type: Plain text
#: build/C/man2/madvise.2:123
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""
"近い将来にアクセスされそうだ。 (したがってこれらのページを今のうちに先読みし"
"ておくといいだろう。)"

#. type: TP
#: build/C/man2/madvise.2:123
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr "B<MADV_DONTNEED>"

#. type: Plain text
#: build/C/man2/madvise.2:128
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:139
msgid ""
"After a successful B<MADV_DONTNEED> operation, the semantics of memory "
"access in the specified region are changed: subsequent accesses of pages in "
"the range will succeed, but will result in either repopulating the memory "
"contents from the up-to-date contents of the underlying mapped file (for "
"shared file mappings, shared anonymous mappings, and shmem-based techniques "
"such as System V shared memory segments)  or zero-fill-on-demand pages for "
"anonymous private mappings."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:146
msgid ""
"Note that, when applied to shared mappings, B<MADV_DONTNEED> might not lead "
"to immediate freeing of the pages in the range.  The kernel is free to delay "
"freeing the pages until an appropriate moment.  The resident set size (RSS) "
"of the calling process will be immediately reduced however."
msgstr ""

#
#.  http://lwn.net/Articles/162860/
#.  ======================================================================
#. type: Plain text
#: build/C/man2/madvise.2:161
msgid ""
"B<MADV_DONTNEED> cannot be applied to locked pages, Huge TLB pages, or "
"B<VM_PFNMAP> pages.  (Pages marked with the kernel-internal B<VM_PFNMAP> "
"flag are special memory areas that are not managed by the virtual memory "
"subsystem.  Such pages are typically created by device drivers that map the "
"pages into user space.)"
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:161
#, no-wrap
msgid "Linux-specific advice values"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:170
msgid ""
"The following Linux-specific I<advice> values have no counterparts in the "
"POSIX-specified B<posix_madvise>(3), and may or may not have counterparts in "
"the B<madvise>()  interface available on other implementations.  Note that "
"some of these operations change the semantics of memory accesses."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:170
#, no-wrap
msgid "B<MADV_REMOVE> (since Linux 2.6.16)"
msgstr "B<MADV_REMOVE> (Linux 2.6.16 以降)"

#.  commit f6b3ec238d12c8cc6cc71490c6e3127988460349
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: build/C/man2/madvise.2:184
msgid ""
"Free up a given range of pages and its associated backing store.  This is "
"equivalent to punching a hole in the corresponding byte range of the backing "
"store (see B<fallocate>(2)).  Subsequent accesses in the specified address "
"range will see bytes containing zero."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:189
msgid ""
"The specified address range must be mapped shared and writable.  This flag "
"cannot be applied to locked pages, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#.  commit 3f31d07571eeea18a7d34db9af21d2285b807a17
#. type: Plain text
#: build/C/man2/madvise.2:205
msgid ""
"In the initial implementation, only B<tmpfs>(5)  was supported "
"B<MADV_REMOVE>; but since Linux 3.5, any filesystem which supports the "
"B<fallocate>(2)  B<FALLOC_FL_PUNCH_HOLE> mode also supports B<MADV_REMOVE>.  "
"Hugetlbfs fails with the error B<EINVAL> and other filesystems fail with the "
"error B<EOPNOTSUPP>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_DONTFORK> (since Linux 2.6.16)"
msgstr "B<MADV_DONTFORK> (Linux 2.6.16 以降)"

#.  commit f822566165dd46ff5de9bf895cfa6c51f53bb0c4
#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: build/C/man2/madvise.2:237
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing "
"the physical location of a page if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page.)"
msgstr ""
"B<fork>(2)  が行われた後、指定された範囲のページを子プロセスが利用できないよ"
"うにする。 この機能は、書き込み時コピー (copy-on-write) 方式で、 B<fork>(2)  "
"の後で親プロセスがページに書き込みを行った場合に ページの物理位置が変化しない"
"ようにするのに有効である (ページの再配置はハードウェアがそのページに DMA 転送"
"を行うような場合に 問題を起こすことがある)。"

#. type: TP
#: build/C/man2/madvise.2:237
#, no-wrap
msgid "B<MADV_DOFORK> (since Linux 2.6.16)"
msgstr "B<MADV_DOFORK> (Linux 2.6.16 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:243
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby "
"a mapping is inherited across B<fork>(2)."
msgstr ""
"B<MADV_DONTFORK> の影響を取り消し、デフォルトの動作に戻す。 つまり、 "
"B<fork>(2)  の前後でマッピングは継承されるようになる。"

#. type: TP
#: build/C/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_HWPOISON> (since Linux 2.6.32)"
msgstr "B<MADV_HWPOISON> (Linux 2.6.32 以降)"

#.  commit 9893e49d64a4874ea67849ee2cfbf3f3d6817573
#. type: Plain text
#: build/C/man2/madvise.2:258
#, fuzzy
#| msgid ""
#| "Poison a page and handle it like a hardware memory corruption.  This "
#| "operation is available only for privileged (B<CAP_SYS_ADMIN>)  "
#| "processes.  This operation may result in the calling process receiving a "
#| "B<SIGBUS> and the page being unmapped.  This feature is intended for "
#| "testing of memory error-handling code; it is available only if the kernel "
#| "was configured with B<CONFIG_MEMORY_FAILURE>."
msgid ""
"Poison the pages in the range specified by I<addr> and I<length> and handle "
"subsequent references to those pages like a hardware memory corruption.  "
"This operation is available only for privileged (B<CAP_SYS_ADMIN>)  "
"processes.  This operation may result in the calling process receiving a "
"B<SIGBUS> and the page being unmapped."
msgstr ""
"ページに毒入れを行い、ハードウェアメモリーの破損のようにそのページを取り扱"
"う。 この操作は特権 (B<CAP_SYS_ADMIN> を持った) プロセスだけが利用できる。 こ"
"の操作の結果、呼び出したプロセスは B<SIGBUS> を受け取り、そのページはアンマッ"
"プされる。 この機能はメモリーのエラー処理コードをテストするためのものであ"
"る。 カーネルで B<CONFIG_MEMORY_FAILURE> が有効になっている場合にのみ利用可能"
"である。"

#. type: Plain text
#: build/C/man2/madvise.2:262 build/C/man2/madvise.2:319
msgid ""
"This feature is intended for testing of memory error-handling code; it is "
"available only if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:262
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr "B<MADV_MERGEABLE> (Linux 2.6.32 以降)"

#.  commit f8af4da3b4c14e7267c4ffb952079af3912c51c5
#. type: Plain text
#: build/C/man2/madvise.2:276
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by "
"I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM merges only private anonymous pages (see B<mmap>(2))."
msgstr "Kernel Samepage Merging (KSM; カーネルによる同じページの統合) を I<addr> と I<length> で指定された領域に対して有効にする。 カーネルは、 統合可能の印がついたユーザーメモリーの領域を定期的にスキャンし、内容が全く同じページを探す。 内容が全く同じページがあれば、それらのページは書き込み保護 (write-protected) がかかった一つのページで置き換えられる (プロセスが後でページの内容を更新しようとした際には自動的にページのコピーが行われる)。 KSM はプライベートな無名ページ (anonymous pages) だけを統合する (B<mmap>(2) 参照)。"

#. type: Plain text
#: build/C/man2/madvise.2:283
msgid ""
"The KSM feature is intended for applications that generate many instances of "
"the same data (e.g., virtualization systems such as KVM).  It can consume a "
"lot of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/ksm.rst> for more details."
msgstr "KSM 機能は、 同じデータのインスタンスを大量に生成するアプリケーション (KVM などの仮想化システム) での利用を想定している。 この機能はプロセッシング能力を大量に消費する場合があり、注意して使用すること。 詳細は Linux カーネルソースファイル I<Documentation/vm/ksm.txt> を参照。"

#. type: Plain text
#: build/C/man2/madvise.2:290
#, fuzzy
#| msgid ""
#| "B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE> was specified in I<advice>, but "
#| "the kernel was not configured with B<CONFIG_KSM>."
msgid ""
"The B<MADV_MERGEABLE> and B<MADV_UNMERGEABLE> operations are available only "
"if the kernel was configured with B<CONFIG_KSM>."
msgstr ""
"I<advice> に B<MADV_MERGEABLE> か B<MADV_UNMERGEABLE> が指定されたが、 カーネ"
"ルの設定が B<CONFIG_KSM> が有効になっていなかった。"

#. type: TP
#: build/C/man2/madvise.2:290
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr "B<MADV_UNMERGEABLE> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:299
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""
"指定されたアドレス範囲に関して、それ以前に行われた B<MADV_MERGEABLE> 操作の効"
"果を取り消す。 KSM は、  I<addr> と I<length> で指定されたアドレス範囲の統合"
"済みのすべてのページの統合解除を行う。"

#. type: TP
#: build/C/man2/madvise.2:299
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (since Linux 2.6.33)"
msgstr "B<MADV_SOFT_OFFLINE> (Linux 2.6.33 以降)"

#.  commit afcf938ee0aac4ef95b1a23bac704c6fbeb26de6
#. type: Plain text
#: build/C/man2/madvise.2:315
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The "
"memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process."
msgstr "I<addr> と I<length> で指定された範囲のページをソフトオフラインにする。 指定された範囲の各ページのメモリーの内容は保持され (すなわち、次にアクセスされた際に、同じ内容が見えるが、新しい物理ページフレームになる)、 元のフレームはオフラインになる (すなわち、 そのフレームは使用される、通常のメモリー管理からは取り除かれる)。 B<MADV_SOFT_OFFLINE> 操作の影響は呼び出したプロセスには見えない (つまり呼び出したプロセスの動作は変化しない)。"

#. type: TP
#: build/C/man2/madvise.2:319
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr "B<MADV_HUGEPAGE> (Linux 2.6.38 以降)"

#.  commit 0af4e98b6b095c74588af04872f83d333c958c32
#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: build/C/man2/madvise.2:335
#, fuzzy
#| msgid ""
#| "Enables Transparent Huge Pages (THP) for pages in the range specified by "
#| "I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
#| "private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
#| "the areas marked as huge page candidates to replace them with huge "
#| "pages.  The kernel will also allocate huge pages directly when the region "
#| "is naturally aligned to the huge page size (see B<posix_memalign>(2)).  "
#| "This feature is primarily aimed at applications that use large mappings "
#| "of data and access large regions of that memory at a time (e.g., "
#| "virtualization systems such as QEMU).  It can very easily waste memory (e."
#| "g., a 2MB mapping that only ever accesses 1 byte will result in 2MB of "
#| "wired memory instead of one 4KB page).  See the Linux kernel source file "
#| "I<Documentation/vm/transhuge.txt> for more details.  The B<MADV_HUGEPAGE> "
#| "and B<MADV_NOHUGEPAGE> operations are available only if the kernel was "
#| "configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgid ""
"Enable Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2))."
msgstr ""
"Transparent Huge Pages (THP) を I<addr> と I<length> で指定された領域に対して"
"有効にする。 現在のところ、Transparent Huge Pages はプライベートな無名ページ "
"(anonymous pages) についてのみ機能する。 カーネルは定期的にヒュージページ "
"(huge page) 候補の印がついたページをスキャンし、ヒュージページと置き換える。 "
"また、カーネルはその領域がヒュージページのサイズに合っている場合、ヒュージ"
"ページを直接割り当てる (B<posix_memalign>(2) 参照)。 この機能は、大きなデータ"
"マッピングを使用し、一度にそのメモリーの大きな範囲にアクセスするようなアプリ"
"ケーション (例えば QEMU のような仮想化システム) で使うことを主に想定されてい"
"る。 この機能は非常に簡単にメモリーを浪費してしまう (例えば、1 バイトしかアク"
"セスしない 2MB のマッピングが、 4KB ページではなく 2MB の実際のメモリーを使っ"
"てしまう)。 詳細は Linux カーネルソースファイル I<Documentation/vm/transhuge."
"txt> を参照。 B<MADV_HUGEPAGE> と B<MADV_NOHUGEPAGE> は、 カーネルで "
"B<CONFIG_TRANSPARENT_HUGEPAGE> オプションを有効になっている場合にのみ利用でき"
"る。"

#. type: Plain text
#: build/C/man2/madvise.2:344
msgid ""
"This feature is primarily aimed at applications that use large mappings of "
"data and access large regions of that memory at a time (e.g., virtualization "
"systems such as QEMU).  It can very easily waste memory (e.g., a 2\\ MB "
"mapping that only ever accesses 1 byte will result in 2\\ MB of wired memory "
"instead of one 4\\ KB page).  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/transhuge.rst> for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:361
msgid ""
"Most common kernels configurations provide B<MADV_HUGEPAGE>-style behavior "
"by default, and thus B<MADV_HUGEPAGE> is normally not necessary.  It is "
"mostly intended for embedded systems, where B<MADV_HUGEPAGE>-style behavior "
"may not be enabled by default in the kernel.  On such systems, this flag can "
"be used in order to selectively enable THP.  Whenever B<MADV_HUGEPAGE> is "
"used, it should always be in regions of memory with an access pattern that "
"the developer knows in advance won't risk to increase the memory footprint "
"of the application when transparent hugepages are enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:368
#, fuzzy
#| msgid ""
#| "B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE> was specified in I<advice>, but "
#| "the kernel was not configured with B<CONFIG_KSM>."
msgid ""
"The B<MADV_HUGEPAGE> and B<MADV_NOHUGEPAGE> operations are available only if "
"the kernel was configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""
"I<advice> に B<MADV_MERGEABLE> か B<MADV_UNMERGEABLE> が指定されたが、 カーネ"
"ルの設定が B<CONFIG_KSM> が有効になっていなかった。"

#. type: TP
#: build/C/man2/madvise.2:368
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr "B<MADV_NOHUGEPAGE> (Linux 2.6.38 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:375
#, fuzzy
#| msgid ""
#| "Ensures that memory in the address range specified by I<addr> and "
#| "I<length> will not be collapsed into huge pages."
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be backed by transparent hugepages."
msgstr ""
"I<addr> と I<length> で指定されたアドレス範囲のメモリーがヒュージページに組み"
"込まれないようにする。"

#. type: TP
#: build/C/man2/madvise.2:375
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr "B<MADV_DONTDUMP> (Linux 3.4 以降)"

#.  commit 909af768e88867016f427264ae39d27a57b6a8ed
#.  commit accb61fe7bb0f5c2a4102239e4981650f9048519
#. type: Plain text
#: build/C/man2/madvise.2:391
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the I</"
"proc/[pid]/coredump_filter> file (see B<core>(5))."
msgstr "コアダンプから I<addr> と I<length> で指定された範囲のページを除外する。 これは、 コアダンプに含めても役に立たないことが分かっている大きなメモリー領域があるアプリケーションで有用である。 B<MADV_DONTDUMP> の効果は I</proc/[pid]/coredump_filter> ファイル経由で設定されたビットマスクよりも優先される (B<core>(5) 参照)。"

#. type: TP
#: build/C/man2/madvise.2:391
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr "B<MADV_DODUMP> (Linux 3.4 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:395
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr "以前の B<MADV_DONTDUMP> の効果を取り消す。"

#. type: TP
#: build/C/man2/madvise.2:395
#, no-wrap
msgid "B<MADV_FREE> (since Linux 4.5)"
msgstr "B<MADV_FREE> (Linux 4.5 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:417
msgid ""
"The application no longer requires the pages in the range specified by "
"I<addr> and I<len>.  The kernel can thus free these pages, but the freeing "
"could be delayed until memory pressure occurs.  For each of the pages that "
"has been marked to be freed but has not yet been freed, the free operation "
"will be canceled if the caller writes into the page.  After a successful "
"B<MADV_FREE> operation, any stale data (i.e., dirty, unwritten pages) will "
"be lost when the kernel frees the pages.  However, subsequent writes to "
"pages in the range will succeed and then kernel cannot free those dirtied "
"pages, so that the caller can always see just written data.  If there is no "
"subsequent write, the kernel can free the pages at any time.  Once pages in "
"the range have been freed, the caller will see zero-fill-on-demand pages "
"upon subsequent page references."
msgstr ""

#.  commit 93e06c7a645343d222c9a838834a51042eebbbf7
#. type: Plain text
#: build/C/man2/madvise.2:428
msgid ""
"The B<MADV_FREE> operation can be applied only to private anonymous pages "
"(see B<mmap>(2)).  In Linux before version 4.12, when freeing pages on a "
"swapless system, the pages in the given range are freed instantly, "
"regardless of memory pressure."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:428
#, no-wrap
msgid "B<MADV_WIPEONFORK> (since Linux 4.14)"
msgstr "B<MADV_WIPEONFORK> (Linux 4.14 以降)"

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: build/C/man2/madvise.2:437
msgid ""
"Present the child process with zero-filled memory in this range after a "
"B<fork>(2).  This is useful in forking servers in order to ensure that "
"sensitive per-process data (for example, PRNG seeds, cryptographic secrets, "
"and so on)  is not handed to child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:442
msgid ""
"The B<MADV_WIPEONFORK> operation can be applied only to private anonymous "
"pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:450
msgid ""
"Within the child created by B<fork>(2), the B<MADV_WIPEONFORK> setting "
"remains in place on the specified address range.  This setting is cleared "
"during B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:450
#, no-wrap
msgid "B<MADV_KEEPONFORK> (since Linux 4.14)"
msgstr "B<MADV_KEEPONFORK> (Linux 4.14 以降)"

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: build/C/man2/madvise.2:455
msgid "Undo the effect of an earlier B<MADV_WIPEONFORK>."
msgstr "以前の B<MADV_WIPEONFORK> の効果を取り消す。"

#. type: Plain text
#: build/C/man2/madvise.2:462
msgid ""
"On success, B<madvise>()  returns zero.  On error, it returns -1 and "
"I<errno> is set appropriately."
msgstr ""
"B<madvise>()  は成功すると 0 を返す。 エラーが起こると -1 を返し、 I<errno> "
"を適切な値に設定する。"

#. type: TP
#: build/C/man2/madvise.2:463 build/C/man2/mmap.2:510
#: build/C/man2/mprotect.2:149 build/C/man3/shm_open.3:186
#: build/C/man3/shm_open.3:191 build/C/man2/shmctl.2:389
#: build/C/man2/shmget.2:224 build/C/man2/shmop.2:187
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/madvise.2:469
msgid ""
"I<advice> is B<MADV_REMOVE>, but the specified address range is not a shared "
"writable mapping."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:469 build/C/man2/mlock.2:216 build/C/man2/mmap.2:528
#: build/C/man2/mremap.2:169
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/madvise.2:472
msgid "A kernel resource was temporarily unavailable."
msgstr "何らかのカーネルリソースが一時的に利用できなかった。"

#. type: Plain text
#: build/C/man2/madvise.2:475
msgid "The map exists, but the area maps something that isn't a file."
msgstr "指定したマップは存在するが、ファイルではないところをマップしている。"

#.  .I length
#.  is zero,
#. type: Plain text
#: build/C/man2/madvise.2:483
msgid "I<addr> is not page-aligned or I<length> is negative."
msgstr "I<addr> がページ境界ではない、または I<length> が負である。"

#. type: Plain text
#: build/C/man2/madvise.2:487
msgid "I<advice> is not a valid."
msgstr "I<advice> が有効でない。"

#. type: Plain text
#: build/C/man2/madvise.2:497
msgid ""
"I<advice> is B<MADV_DONTNEED> or B<MADV_REMOVE> and the specified address "
"range includes locked, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:506
msgid ""
"I<advice> is B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE>, but the kernel was "
"not configured with B<CONFIG_KSM>."
msgstr "I<advice> が B<MADV_MERGEABLE> か B<MADV_UNMERGEABLE> だが、 カーネルの設定が B<CONFIG_KSM> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/madvise.2:518
msgid ""
"I<advice> is B<MADV_FREE> or B<MADV_WIPEONFORK> but the specified address "
"range includes file, Huge TLB, B<MAP_SHARED>, or B<VM_PFNMAP> ranges."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:524
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""
"(B<MADV_WILLNEED> の場合) この範囲のページングを行うと、 プロセスの RSS "
"(resident set size) の最大値を越えてしまう。"

#. type: TP
#: build/C/man2/madvise.2:524 build/C/man2/madvise.2:529
#: build/C/man2/mlock.2:184 build/C/man2/mlock.2:192 build/C/man2/mlock.2:231
#: build/C/man2/mlock.2:235 build/C/man2/mmap.2:581 build/C/man2/mmap.2:584
#: build/C/man2/mmap.2:592 build/C/man2/mprotect.2:186
#: build/C/man2/mprotect.2:189 build/C/man2/mprotect.2:199
#: build/C/man2/mremap.2:245 build/C/man2/msync.2:96
#: build/C/man3/posix_madvise.3:99 build/C/man3/posix_memalign.3:172
#: build/C/man2/shmctl.2:422 build/C/man2/shmget.2:262 build/C/man2/shmop.2:210
#: build/C/man2/subpage_prot.2:87 build/C/man2/sync_file_range.2:163
#: build/C/man2/memfd_create.2:196 build/C/man2/s390_pci_mmio_write.2:94
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/madvise.2:529
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr "(B<MADV_WILLNEED> の場合) メモリーが足りず、ページングに失敗した。"

#. type: Plain text
#: build/C/man2/madvise.2:533
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""
"指定した範囲のアドレスが、現在マップされていない。 あるいはプロセスのアドレス"
"空間の内部にない。"

#. type: Plain text
#: build/C/man2/madvise.2:541
msgid ""
"I<advice> is B<MADV_HWPOISON>, but the caller does not have the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: build/C/man2/madvise.2:548
msgid ""
"Since Linux 3.18, support for this system call is optional, depending on the "
"setting of the B<CONFIG_ADVISE_SYSCALLS> configuration option."
msgstr ""
"Linux 3.18 以降では、このシステムコールのサポートは任意となり、利用できるかは"
"カーネルが B<CONFIG_ADVISE_SYSCALLS> オプションを有効にしてコンパイルされてい"
"るかに依存する。"

#. type: Plain text
#: build/C/man2/madvise.2:558
msgid ""
"B<madvise>()  is not specified by any standards.  Versions of this system "
"call, implementing a wide variety of I<advice> values, exist on many other "
"implementations.  Other implementations typically implement at least the "
"flags listed above under I<Conventional advice flags>, albeit with some "
"variation in semantics."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:569
#, fuzzy
#| msgid ""
#| "POSIX.1b.  POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
#| "B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, and so on, with a behavior "
#| "close to that described here.  There is a similar B<posix_fadvise>(2)  "
#| "for file access."
msgid ""
"POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, B<POSIX_MADV_SEQUENTIAL>, "
"B<POSIX_MADV_WILLNEED>, and B<POSIX_MADV_DONTNEED>, and so on, with behavior "
"close to the similarly named flags listed above."
msgstr ""
"POSIX.1b.  POSIX.1-2001 では、 B<posix_madvise>(3)  を B<POSIX_MADV_NORMAL>, "
"B<POSIX_MADV_RANDOM> などの定数とともに記述していた (それぞれの振る舞いはここ"
"で述べたものに近い)。 ファイルアクセスに対しても B<posix_fadvise>(2)  という"
"類似の関数が存在する。"

#. type: SS
#: build/C/man2/madvise.2:570 build/C/man2/mlock.2:400
#: build/C/man2/shmget.2:402
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/madvise.2:586
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""
"Linux の実装では I<addr> のアドレスはページ境界の値でなければならない。また "
"I<length> は 0 であっても構わない。 また Linux 版の B<madvise>()  では、指定"
"されたアドレス範囲にマップされていない部分があると、 これらを無視して残りの部"
"分にアドバイスを適用する (しかしシステムコールに対してはちゃんと B<ENOMEM> を"
"返す)。"

#. type: Plain text
#: build/C/man2/madvise.2:596
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"
msgstr "B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"

#. type: TH
#: build/C/man3/mallinfo.3:25
#, no-wrap
msgid "MALLINFO"
msgstr "MALLINFO"

#. type: TH
#: build/C/man3/mallinfo.3:25 build/C/man3/malloc_hook.3:10
#: build/C/man3/malloc_info.3:25 build/C/man2/mprotect.2:33
#: build/C/man3/mtrace.3:25 build/C/man3/posix_fallocate.3:25
#: build/C/man3/shm_open.3:25 build/C/man2/memfd_create.2:21
#: build/C/man2/membarrier.2:25
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man3/mallinfo.3:28
msgid "mallinfo - obtain memory allocation information"
msgstr "mallinfo - メモリー割り当て情報を取得する"

#. type: Plain text
#: build/C/man3/mallinfo.3:30 build/C/man3/malloc_stats.3:30
#: build/C/man3/malloc_trim.3:30 build/C/man3/malloc_usable_size.3:30
#: build/C/man3/mallopt.3:30
msgid "B<#include E<lt>malloc.hE<gt>>"
msgstr "B<#include E<lt>malloc.hE<gt>>"

#. type: Plain text
#: build/C/man3/mallinfo.3:32
msgid "B<struct mallinfo mallinfo(void);>"
msgstr "B<struct mallinfo mallinfo(void);>"

#. type: Plain text
#: build/C/man3/mallinfo.3:39
msgid ""
"The B<mallinfo>()  function returns a copy of a structure containing "
"information about memory allocations performed by B<malloc>(3)  and related "
"functions."
msgstr "B<mallinfo>() 関数は、 B<malloc>(3) や一連の関数により実行されたメモリー割り当てに関する情報を格納した構造体のコピーを返す。"

#. type: Plain text
#: build/C/man3/mallinfo.3:45
msgid ""
"Note that not all allocations are visible to B<mallinfo>(); see BUGS and "
"consider using B<malloc_info>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:47
msgid "The returned structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:62
#, no-wrap
msgid ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* See below */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"
msgstr ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* See below */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:68
msgid ""
"The fields of the I<mallinfo> structure contain the following information:"
msgstr "I<mallinfo> 構造体の各フィールドには以下の情報が格納される。"

#. type: TP
#: build/C/man3/mallinfo.3:68
#, no-wrap
msgid "I<arena>"
msgstr "I<arena>"

#. type: Plain text
#: build/C/man3/mallinfo.3:74
msgid ""
"The total amount of memory allocated by means other than B<mmap>(2)  (i.e., "
"memory allocated on the heap).  This figure includes both in-use blocks and "
"blocks on the free list."
msgstr ""
"B<mmap>(2) 以外の手段で割り当てられた総メモリー量 (例えばヒープに割り当てられ"
"たメモリー) 。 この数字には使用中のブロックやフリーリスト上のブロックも含まれ"
"る。"

#. type: TP
#: build/C/man3/mallinfo.3:74
#, no-wrap
msgid "I<ordblks>"
msgstr "I<ordblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:77
msgid "The number of ordinary (i.e., non-fastbin) free blocks."
msgstr "通常の (つまり fastbin ではない) 未使用ブロック数。"

#. type: TP
#: build/C/man3/mallinfo.3:77
#, no-wrap
msgid "I<smblks>"
msgstr "I<smblks>"

#.  the glibc info page wrongly says this field is unused
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=26746
#. type: Plain text
#: build/C/man3/mallinfo.3:83
msgid "The number of fastbin free blocks (see B<mallopt>(3))."
msgstr "fastbin 未使用ブロック数 (B<mallopt>(3) 参照)。"

#. type: TP
#: build/C/man3/mallinfo.3:83
#, no-wrap
msgid "I<hblks>"
msgstr "I<hblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:91
msgid ""
"The number of blocks currently allocated using B<mmap>(2).  (See the "
"discussion of B<M_MMAP_THRESHOLD> in B<mallopt>(3).)"
msgstr ""
"B<mmap>(2) を使って現在割り当てられているブロック数 (B<mallopt>(3) の "
"B<M_MMAP_THRESHOLD> の議論を参照)。"

#. type: TP
#: build/C/man3/mallinfo.3:91
#, no-wrap
msgid "I<hblkhd>"
msgstr "I<hblkhd>"

#. type: Plain text
#: build/C/man3/mallinfo.3:95
msgid "The number of bytes in blocks currently allocated using B<mmap>(2)."
msgstr "B<mmap>(2) を使って現在割り当てられているブロックのバイト数。"

#. type: TP
#: build/C/man3/mallinfo.3:95
#, no-wrap
msgid "I<usmblks>"
msgstr "I<usmblks>"

#.  It seems to have been zero since at least as far back as glibc 2.15
#. type: Plain text
#: build/C/man3/mallinfo.3:102
#, fuzzy
#| msgid ""
#| "The \"highwater mark\" for allocated space\\(emthat is, the maximum "
#| "amount of space that was ever allocated.  This field is maintained only "
#| "in nonthreading environments."
msgid ""
"This field is unused, and is always 0.  Historically, it was the \"highwater "
"mark\" for allocated space\\(emthat is, the maximum amount of space that was "
"ever allocated (in bytes); this field was maintained only in nonthreading "
"environments."
msgstr ""
"割り当てた空間の最高点 (\"highwater mark\")、 つまり、 これまでの中での最大の"
"割り当て量。 このフィールドはスレッド化されていない環境でのみ収集される。"

#. type: TP
#: build/C/man3/mallinfo.3:102
#, no-wrap
msgid "I<fsmblks>"
msgstr "I<fsmblks>"

#.  the glibc info page wrongly says this field is unused
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=26746
#. type: Plain text
#: build/C/man3/mallinfo.3:107
msgid "The total number of bytes in fastbin free blocks."
msgstr "fastbin フリーブロックの総バイト数。"

#. type: TP
#: build/C/man3/mallinfo.3:107
#, no-wrap
msgid "I<uordblks>"
msgstr "I<uordblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:110
msgid "The total number of bytes used by in-use allocations."
msgstr "使用中の割り当てメモリーで使われているバイト数。"

#. type: TP
#: build/C/man3/mallinfo.3:110
#, no-wrap
msgid "I<fordblks>"
msgstr "I<fordblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:113
msgid "The total number of bytes in free blocks."
msgstr "フリーブロックの総バイト数。"

#. type: TP
#: build/C/man3/mallinfo.3:113
#, no-wrap
msgid "I<keepcost>"
msgstr "I<keepcost>"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallinfo.3:122
msgid ""
"The total amount of releasable free space at the top of the heap.  This is "
"the maximum number of bytes that could ideally (i.e., ignoring page "
"alignment restrictions, and so on) be released by B<malloc_trim>(3)."
msgstr ""
"ヒープの一番上にある解放可能な未使用の空間の大きさ。 この値は "
"B<malloc_trim>(3) で理想的な場合に解放できる最大のバイト数である (理想的とい"
"うのは、 ページ境界の制限などを無視した場合である。"

#. type: tbl table
#: build/C/man3/mallinfo.3:132
#, no-wrap
msgid "B<mallinfo>()"
msgstr "B<mallinfo>()"

#. type: tbl table
#: build/C/man3/mallinfo.3:132
#, no-wrap
msgid "MT-Unsafe init const:mallopt"
msgstr "MT-Unsafe init const:mallopt"

#. type: Plain text
#: build/C/man3/mallinfo.3:148
msgid ""
"B<mallinfo>()  would access some global internal objects.  If modify them "
"with non-atomically, may get inconsistent results.  The identifier "
"I<mallopt> in I<const:mallopt> mean that B<mallopt>()  would modify the "
"global internal objects with atomics, that make sure B<mallinfo>()  is safe "
"enough, others modify with non-atomically maybe not."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:152
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, and was specified in the SVID."
msgstr ""
"この関数は POSIX や C 標準では規定されていない。 多くの System V 由来のシステ"
"ムに同様の関数が存在し、 SVID では同様の関数が規定されていた。 "

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=208
#.  See the 24 Aug 2011 mail by Paul Pluzhnikov:
#.      "[patch] Fix mallinfo() to accumulate results for all arenas"
#.  on libc-alpha@sourceware.org
#. type: Plain text
#: build/C/man3/mallinfo.3:164
msgid ""
"B<Information is returned for only the main memory allocation area.> "
"Allocations in other arenas are excluded.  See B<malloc_stats>(3)  and "
"B<malloc_info>(3)  for alternatives that include information about other "
"arenas."
msgstr ""
"B<これらの情報はメインのメモリー割り当て領域に対するもののみである。> 他の領"
"域の割り当ては対象にならない。 他の領域の情報も取得できる別の手段については "
"B<malloc_stats>(3) や B<malloc_info>(3) を参照。"

#. type: Plain text
#: build/C/man3/mallinfo.3:172
msgid ""
"The fields of the I<mallinfo> structure are typed as I<int>.  However, "
"because some internal bookkeeping values may be of type I<long>, the "
"reported values may wrap around zero and thus be inaccurate."
msgstr ""
"I<mallinfo> 構造体の各フィールドは I<int> 型である。 しかし、 いくつかの内部"
"管理用の値は I<long> 型の場合もあるので、 報告される値が一周してしまい、 不正"
"確になる可能性がある。"

#. type: SH
#: build/C/man3/mallinfo.3:172 build/C/man3/malloc_hook.3:94
#: build/C/man3/malloc_info.3:97 build/C/man3/mallopt.3:513
#: build/C/man3/mcheck.3:180 build/C/man2/mmap.2:910
#: build/C/man2/mprotect.2:286 build/C/man3/mtrace.3:130
#: build/C/man3/shm_open.3:287 build/C/man2/shmget.2:414
#: build/C/man2/shmop.2:293 build/C/man2/memfd_create.2:344
#: build/C/man2/membarrier.2:328 build/C/man2/pkey_alloc.2:134
#: build/C/man7/pkeys.7:165
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/mallinfo.3:178
msgid ""
"The program below employs B<mallinfo>()  to retrieve memory allocation "
"statistics before and after allocating and freeing some blocks of memory.  "
"The statistics are displayed on standard output."
msgstr ""
"以下のプログラムは B<mallinfo>() を利用して、 メモリーブロックの割り当て、解"
"放のそれぞれ前後でメモリー割り当ての統計情報を取得する。 統計情報は標準出力に"
"表示される。"

#. type: Plain text
#: build/C/man3/mallinfo.3:182
msgid ""
"The first two command-line arguments specify the number and size of blocks "
"to be allocated with B<malloc>(3)."
msgstr ""
"最初の 2 つのコマンドライン引き数は B<malloc>(3) で割り当てるブロック数とサイ"
"ズを指定する。"

#. type: Plain text
#: build/C/man3/mallinfo.3:196
msgid ""
"The remaining three arguments specify which of the allocated blocks should "
"be freed with B<free>(3).  These three arguments are optional, and specify "
"(in order): the step size to be used in the loop that frees blocks (the "
"default is 1, meaning free all blocks in the range); the ordinal position of "
"the first block to be freed (default 0, meaning the first allocated block); "
"and a number one greater than the ordinal position of the last block to be "
"freed (default is one greater than the maximum block number).  If these "
"three arguments are omitted, then the defaults cause all allocated blocks to "
"be freed."
msgstr ""
"残りの 3 つの引き数は、どの割り当てられたブロックを B<free>(3) で解放すべきか"
"を指定する。 これらの 3 つの引き数の指定は任意で、 最初のものから順に以下の情"
"報を指定する。 1 つ目の引き数は、 ブロックを解放するループで使用するステップ"
"サイズを指定する (デフォルト値は 1 で、 1 は指定した範囲のすべてのブロックを"
"解放することを意味する)。 2 つ目の引き数は、 解放する先頭ブロックの場所番号を"
"指定する (デフォルト値は 0 で、 0 は先頭の割り当て済みブロックを意味する)。 "
"3 つ目の引き数は、 解放する最終ブロックの場所番号よりひとつ大きい値を指定す"
"る (デフォルト値は最大ブロック番号よりもひとつ大きい値である)。 これらの 3 つ"
"の引き数が省略された場合、 デフォルトではすべての割り当てられたブロックが解放"
"される。"

#. type: Plain text
#: build/C/man3/mallinfo.3:200
msgid ""
"In the following example run of the program, 1000 allocations of 100 bytes "
"are performed, and then every second allocated block is freed:"
msgstr ""
"以下のプログラムの実行例では、 100 バイトの割り当てを 1000 回実行し、 割り当"
"てたブロックの 2 つに 1 つを解放する。"

#. type: Plain text
#: build/C/man3/mallinfo.3:215
#, no-wrap
msgid ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"
msgstr ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:227
#, no-wrap
msgid ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:239
#, no-wrap
msgid ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"

#. type: SS
#: build/C/man3/mallinfo.3:241 build/C/man3/malloc_info.3:180
#: build/C/man3/mallopt.3:579 build/C/man3/mcheck.3:197 build/C/man2/mmap.2:921
#: build/C/man2/mprotect.2:304 build/C/man7/pkeys.7:183
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/mallinfo.3:247
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:252
#, no-wrap
msgid ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"
msgstr ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:254
#, no-wrap
msgid "    mi = mallinfo();\n"
msgstr "    mi = mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:266
#, no-wrap
msgid ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", mi.keepcost);\n"
"}\n"
msgstr ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", mi.keepcost);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:274
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:280
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s num-blocks block-size [free-step \"\n"
"                \"[start-free [end-free]]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s num-blocks block-size [free-step \"\n"
"                \"[start-free [end-free]]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:286
#, no-wrap
msgid ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"
msgstr ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:289
#, no-wrap
msgid ""
"    printf(\"============== Before allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""
"    printf(\"============== Before allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:295
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS) {\n"
"            fprintf(stderr, \"Too many allocations\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    for (int j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS) {\n"
"            fprintf(stderr, \"Too many allocations\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:302
#, no-wrap
msgid ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:305
#, no-wrap
msgid ""
"    printf(\"\\en============== After allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""
"    printf(\"\\en============== After allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:308
#, no-wrap
msgid ""
"    for (int j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"
msgstr ""
"    for (int j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:311
#, no-wrap
msgid ""
"    printf(\"\\en============== After freeing blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""
"    printf(\"\\en============== After freeing blocks ==============\\en\");\n"
"    display_mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:314 build/C/man3/malloc_info.3:265
#: build/C/man3/mallopt.3:612 build/C/man3/mcheck.3:224 build/C/man2/mmap.2:993
#: build/C/man3/shm_open.3:423 build/C/man3/shm_open.3:503
#: build/C/man2/shmop.2:435 build/C/man2/shmop.2:498
#: build/C/man2/memfd_create.2:493 build/C/man2/memfd_create.2:545
#: build/C/man2/membarrier.2:380 build/C/man2/membarrier.2:469
#: build/C/man7/pkeys.7:291
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:324
msgid ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"
msgstr ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_get_state.3:25
#, no-wrap
msgid "MALLOC_GET_STATE"
msgstr "MALLOC_GET_STATE"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:28
msgid ""
"malloc_get_state, malloc_set_state - record and restore state of malloc "
"implementation"
msgstr "malloc_get_state, malloc_set_state - malloc 実装の状態を保存/復元する"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:31 build/C/man3/malloc_hook.3:18
#: build/C/man3/malloc_info.3:31 build/C/man3/posix_memalign.3:41
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr "B<#include E<lt>malloc.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:33
#, no-wrap
msgid "B<void *malloc_get_state(void);>\n"
msgstr "B<void *malloc_get_state(void);>\n"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:35
#, no-wrap
msgid "B<int malloc_set_state(void *>I<state>B<);>\n"
msgstr "B<int malloc_set_state(void *>I<state>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:39
msgid "I<Note>: these function are removed in glibc version 2.25."
msgstr "I<注意>: これらの関数は glibc バージョン 2.25 で削除された。"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:56
msgid ""
"The B<malloc_get_state>()  function records the current state of all "
"B<malloc>(3)  internal bookkeeping variables (but not the actual contents of "
"the heap or the state of B<malloc_hook>(3)  functions pointers).  The state "
"is recorded in a system-dependent opaque data structure dynamically "
"allocated via B<malloc>(3), and a pointer to that data structure is returned "
"as the function result.  (It is the caller's responsibility to B<free>(3)  "
"this memory.)"
msgstr ""
"B<malloc_get_state>() 関数は B<malloc>(3) 内部のすべての管理用変数を記録する "
"(ただし、 ヒープの実際の内容と B<malloc_hook>(3) 関数ポインターの状態は記録さ"
"れない)。 状態は B<malloc>(3) で動的に確保されたシステム依存の opaque な (内"
"部構造は分からない) データ構造体に記録され、 関数の結果としてそのデータ構造体"
"へのポインターが返される (このメモリーは呼び出し元が責任をもって B<free>(3) "
"する必要がある)。"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:64
msgid ""
"The B<malloc_set_state>()  function restores the state of all B<malloc>(3)  "
"internal bookkeeping variables to the values recorded in the opaque data "
"structure pointed to by I<state>."
msgstr ""
"B<malloc_set_state>() 関数は、 B<malloc>(3) 内部のすべての管理用変数を "
"I<state> が指す opaque なデータ構造体から復元する。"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:71
msgid ""
"On success, B<malloc_get_state>()  returns a pointer to a newly allocated "
"opaque data structure.  On error (for example, memory could not be allocated "
"for the data structure), B<malloc_get_state>()  returns NULL."
msgstr ""
"成功すると、 B<malloc_get_state>() は新しく割り当てられたデータ構造体へのポイ"
"ンターを返す。 エラーの場合 (例えば、データ構造体に必要なメモリーが割り当てら"
"れなかったなど)、 B<malloc_get_state>() は NULL を返す。"

#.  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
#.  /* Must fail if the major version is too high. */
#.  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
#. type: Plain text
#: build/C/man3/malloc_get_state.3:89
msgid ""
"On success, B<malloc_set_state>()  returns 0.  If the implementation detects "
"that I<state> does not point to a correctly formed data structure, "
"B<malloc_set_state>()  returns -1.  If the implementation detects that the "
"version of the data structure referred to by I<state> is a more recent "
"version than this implementation knows about, B<malloc_set_state>()  returns "
"-2."
msgstr ""
"成功すると、 B<malloc_set_state>() は 0 を返す。 実装が I<state> が正しく作成"
"されたデータ構造体を指していないと検出した場合、 B<malloc_set_state>() は -1 "
"を返す。 I<state> が参照するデータ構造体のバージョンがこの実装が認識するバー"
"ジョンよりも新しいと実装が検出した場合、 B<malloc_set_state>() は -2 を返す。"

#. type: tbl table
#: build/C/man3/malloc_get_state.3:100
#, no-wrap
msgid ""
"B<malloc_get_state>(),\n"
"B<malloc_set_state>()"
msgstr ""
"B<malloc_get_state>(),\n"
"B<malloc_set_state>()"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:105 build/C/man3/malloc_hook.3:84
#: build/C/man3/mcheck.3:168 build/C/man3/mtrace.3:102
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:111
msgid ""
"These functions are useful when using this B<malloc>(3)  implementation as "
"part of a shared library, and the heap contents are saved/restored via some "
"other method.  This technique is used by GNU Emacs to implement its \"dumping"
"\" function."
msgstr ""
"これらの関数が役に立つのは、 この B<malloc>(3) の実装が共有ライブラリの一部と"
"して使用され、 ヒープの内容が何か他の方法で保存/復元される場合である。 この手"
"法は GNU Emacs が「ダンプ」関数 (\"dumping\" function) を実装するのに使用され"
"ている。"

#.  i.e., calls __malloc_check_init()
#.  i.e., malloc checking is not already in use
#.  and the caller requested malloc checking
#. type: Plain text
#: build/C/man3/malloc_get_state.3:128
msgid ""
"Hook function pointers are never saved or restored by these functions, with "
"two exceptions: if malloc checking (see B<mallopt>(3))  was in use when "
"B<malloc_get_state>()  was called, then B<malloc_set_state>()  resets malloc "
"checking hooks if possible; if malloc checking was not in use in the "
"recorded state, but the caller has requested malloc checking, then the hooks "
"are reset to 0."
msgstr ""
"これらの関数がフック関数ポインターの保存と復元を行うことはない。 ただし、 2 "
"つ例外がある。 B<malloc_get_state>() が呼び出された際に malloc チェック "
"(B<mallopt>(3) 参照) が使用中の場合、 B<malloc_set_state>() は可能なら "
"malloc チェックフックをリセットする。 また、 保存された状態の malloc チェック"
"が使用中でないが、 呼び出し元が malloc チェックを要求していた場合、 フックは "
"0 にリセットされる。"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:131
msgid "B<malloc>(3), B<mallopt>(3)"
msgstr "B<malloc>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_hook.3:10
#, no-wrap
msgid "MALLOC_HOOK"
msgstr "MALLOC_HOOK"

#. type: Plain text
#: build/C/man3/malloc_hook.3:15
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc デバッグ用の変数"

#. type: Plain text
#: build/C/man3/malloc_hook.3:20
#, no-wrap
msgid "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:23
#, no-wrap
msgid "B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr "B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:26
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:30
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr "B<void (*__malloc_initialize_hook)(void);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:32
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr "B<void (*__after_morecore_hook)(void);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:43
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), "
"B<realloc>(3), and B<free>(3)  by specifying appropriate hook functions.  "
"You can use these hooks to help you debug programs that use dynamic memory "
"allocation, for example."
msgstr ""
"GNU C ライブラリでは、適切なフック関数 (hook function) を指定することで "
"B<malloc>(3), B<realloc>(3), B<free>(3)  の動作を変更することができる。例え"
"ば、動的にメモリー割り当てを行う プログラムのデバッグにこれらのフックを使うこ"
"とができる。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:50
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called "
"once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr ""
"変数 B<__malloc_initialize_hook> は malloc の実装が初期化される際に一度だけ呼"
"ばれる関数へのポインターである。 この変数は書き換え可能 (weak) であり、アプリ"
"ケーション内で 以下のような定義で上書きできる:"

#. type: Plain text
#: build/C/man3/malloc_hook.3:54
#, no-wrap
msgid "void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr "void (*__malloc_initialize_hook)(void) = my_init_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:60
msgid ""
"Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr ""
"なお、関数 I<my_init_hook>()  で全てのフックの初期化をすることができる。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:76
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr ""
"B<__malloc_hook>, B<__realloc_hook>, B<__memalign_hook>, B<__free_hook> で指"
"される 4 つの関数は、各々 B<malloc>(3), B<realloc>(3), B<memalign>(3), "
"B<free>(3)  とよく似たプロトタイプを持っているが、 一番最後の引き数 "
"I<caller> をとる点が異なる。 引き数 I<caller> には、 B<malloc>(3)  などの呼び"
"出し元 (caller) のアドレスが格納される。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:82
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr ""
"変数 B<__after_morecore_hook> は、領域の追加要求があり B<sbrk>(2)  が呼ばれた"
"後で毎回呼び出される関数へのポインターである。"

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: build/C/man3/malloc_hook.3:94
#, fuzzy
#| msgid ""
#| "The use of these hook functions is not safe in multithreaded programs, "
#| "and they are now deprecated.  Programmers should instead preempt calls to "
#| "the relevant functions by defining and exporting functions such as "
#| "\"malloc\" and \"free\"."
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  From glibc 2.24 onwards, the "
"B<__malloc_initialize_hook> variable has been removed from the API.  "
"Programmers should instead preempt calls to the relevant functions by "
"defining and exporting functions such as \"malloc\" and \"free\"."
msgstr ""
"マルチスレッドプログラムでは、 これらのフック関数の使用は安全ではなく、 今で"
"は非推奨である。 プログラマは、 \"malloc\" や \"free\" のような関数を定義して"
"公開して、 関連する関数を呼び出すようにすべきである。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:96
msgid "Here is a short example of how to use these variables."
msgstr "これらの変数の使い方の簡単な例を以下に示す。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:100
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:104
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr ""
"/* 使おうとするフックのプロトタイプ宣言 */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:107
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr ""
"/* 元々のフックを保存するための変数 */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:110
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr ""
"/* C ライブラリから呼ばれる初期化フックを上書きする */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:117
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:122
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:125
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr ""
"    /* 元々のフックを全て戻す */\n"
"    __malloc_hook = old_malloc_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:128
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr ""
"    /* malloc の再帰的呼び出し */\n"
"    result = malloc(size);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:131
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr ""
"    /* 現在設定されているフック (underlying hook) を保存する */\n"
"    old_malloc_hook = __malloc_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:135
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%zu) called from %p returns %p\\en\",\n"
"            size, caller, result);\n"
msgstr ""
"    /* printf() は malloc() を呼び出す可能性があるので\n"
"        ここでもガードを行う (元々のフックのままにしておく) */\n"
"    printf(\"malloc(%zu) called from %p returns %p\\en\",\n"
"            size, caller, result);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:138
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr ""
"    /* ユーザーが使おうとするフックを再設定する */\n"
"    __malloc_hook = my_malloc_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:141
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr ""
"    return result;\n"
"}\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:147
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"

#. type: TH
#: build/C/man3/malloc_info.3:25
#, no-wrap
msgid "MALLOC_INFO"
msgstr "MALLOC_INFO"

#. type: Plain text
#: build/C/man3/malloc_info.3:28
msgid "malloc_info - export malloc state to a stream"
msgstr "malloc_info - malloc の状態をストリームに出力する"

#. type: Plain text
#: build/C/man3/malloc_info.3:33
#, no-wrap
msgid "B<int malloc_info(int >I<options>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int malloc_info(int >I<options>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:44
msgid ""
"The B<malloc_info>()  function exports an XML string that describes the "
"current state of the memory-allocation implementation in the caller.  The "
"string is printed on the file stream I<stream>.  The exported string "
"includes information about all arenas (see B<malloc>(3))."
msgstr ""
"B<malloc_info>() 関数は、 呼び出し元のメモリー割り当て実装の現在の状態を表す "
"XML 文字列を出力する。 文字列は、 ファイルストリーム I<stream> に出力され"
"る。 出力された文字列には、 全ての割り当て領域の情報が含まれる (B<malloc>(3) "
"参照)。"

#. type: Plain text
#: build/C/man3/malloc_info.3:48
msgid "As currently implemented, I<options> must be zero."
msgstr "現在の実装では、 I<options> は 0 でなければならない。"

#. type: Plain text
#: build/C/man3/malloc_info.3:55
msgid ""
"On success, B<malloc_info>()  returns 0; on error, it returns -1, with "
"I<errno> set to indicate the cause."
msgstr ""
"B<malloc_info>() は、成功すると 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/malloc_info.3:60
msgid "I<options> was nonzero."
msgstr "I<options> が 0 でなかった。"

#. type: Plain text
#: build/C/man3/malloc_info.3:63
msgid "B<malloc_info>()  was added to glibc in version 2.10."
msgstr "B<malloc_info>() は glibc バージョン 2.10 で追加された。"

#. type: tbl table
#: build/C/man3/malloc_info.3:73
#, no-wrap
msgid "B<malloc_info>()"
msgstr "B<malloc_info>()"

#. type: Plain text
#: build/C/man3/malloc_info.3:78 build/C/man3/malloc_stats.3:69
#: build/C/man3/malloc_trim.3:76 build/C/man3/malloc_usable_size.3:62
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/malloc_info.3:84
msgid ""
"The memory-allocation information is provided as an XML string (rather than "
"a C structure)  because the information may change over time (according to "
"changes in the underlying implementation).  The output XML string includes a "
"version field."
msgstr ""
"メモリー割り当て情報は (C の構造体ではなく) XML 文字列として提供される。 これ"
"は、 この情報は時間をたつと (内部で使用している実装によって) 変わる可能性があ"
"るからである。 出力される XML 文字列にはバージョンフィールドが付いている。"

#. type: Plain text
#: build/C/man3/malloc_info.3:90
msgid ""
"The B<open_memstream>(3)  function can be used to send the output of "
"B<malloc_info>()  directly into a buffer in memory, rather than to a file."
msgstr ""
"B<open_memstream>(3) 関数を使うと、 B<malloc_info>() の出力を、 ファイルでは"
"なくメモリー内のバッファーに直接送ることができる。"

#. type: Plain text
#: build/C/man3/malloc_info.3:97
msgid ""
"The B<malloc_info>()  function is designed to address deficiencies in "
"B<malloc_stats>(3)  and B<mallinfo>(3)."
msgstr ""
"B<malloc_info>() 関数は、 B<malloc_stats>(3) と B<mallinfo>(3) の不備を解決す"
"るために設定された。"

#. type: Plain text
#: build/C/man3/malloc_info.3:108
msgid ""
"The program below takes up to four command-line arguments, of which the "
"first three are mandatory.  The first argument specifies the number of "
"threads that the program should create.  All of the threads, including the "
"main thread, allocate the number of blocks of memory specified by the second "
"argument.  The third argument controls the size of the blocks to be "
"allocated.  The main thread creates blocks of this size, the second thread "
"created by the program allocates blocks of twice this size, the third thread "
"allocates blocks of three times this size, and so on."
msgstr ""
"以下のプログラムは最大で 4 つのコマンドライン引数を取り、 最初の 3 つは必須で"
"ある。 最初の引数は、このプログラムが生成するスレッド数を指定する。 メインス"
"レッドを含む全てのスレッドが第 2 引数で指定した数のメモリーブロックの割り当て"
"を行う。 第 3 引数は割り当てるブロックのサイズを制御する。 メインスレッドはこ"
"のサイズのブロックを作成し、 このプログラムが生成する 2 番目のスレッドはこの"
"サイズの 2 倍のサイズのブロックを、 3 番目のスレッドはこのサイズの 3 倍のサイ"
"ズのブロックを割り当て、 以下同様である。"

#. type: Plain text
#: build/C/man3/malloc_info.3:115
msgid ""
"The program calls B<malloc_info>()  twice to display the memory-allocation "
"state.  The first call takes place before any threads are created or memory "
"allocated.  The second call is performed after all threads have allocated "
"memory."
msgstr ""
"このプログラムは B<malloc_info>() を 2 回呼び出し、メモリー割り当て状態を表示"
"する。 最初の呼び出しはスレッドの生成もメモリーの割り当ても行われる前に実行さ"
"れる。 2 回目の呼び出しは全てのスレッドがメモリー割り当てを行った後に実行され"
"る。"

#. type: Plain text
#: build/C/man3/malloc_info.3:123
msgid ""
"In the following example, the command-line arguments specify the creation of "
"one additional thread, and both the main thread and the additional thread "
"allocate 10000 blocks of memory.  After the blocks of memory have been "
"allocated, B<malloc_info>()  shows the state of two allocation arenas."
msgstr ""
"以下の例では、 コマンドライン引数で、 追加でスレッドを一つ生成し、メインス"
"レッドと追加のスレッドの両方が 10000 個のメモリーブロックを割り当てるように指"
"定している。 メモリーブロックの割り当て後の B<malloc_info>() では、 2 つの割"
"り当て領域の状態が表示されている。"

#. type: Plain text
#: build/C/man3/malloc_info.3:148
#, no-wrap
msgid ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:178
#, no-wrap
msgid ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:187
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:190
#, no-wrap
msgid ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"
msgstr ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:193 build/C/man3/shm_open.3:324
#: build/C/man2/shmop.2:349 build/C/man2/memfd_create.2:421
#: build/C/man2/memfd_create.2:507
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:198
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int tn = (int) arg;\n"
msgstr ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int tn = (int) arg;\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:201
#, no-wrap
msgid ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread (including\n"
"       the main thread) allocates a different amount of memory */\n"
msgstr ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread (including\n"
"       the main thread) allocates a different amount of memory */\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:205
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"
msgstr ""
"    for (int j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:209
#, no-wrap
msgid ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sleepTime;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sleepTime;\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:221
#, no-wrap
msgid ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:226
#, no-wrap
msgid ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
msgstr ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:230
#, no-wrap
msgid ""
"    pthread_t *thr = calloc(numThreads, sizeof(*thr));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""
"    pthread_t *thr = calloc(numThreads, sizeof(*thr));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:233
#, no-wrap
msgid ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:235
#, no-wrap
msgid "    /* Create threads that allocate different amounts of memory */\n"
msgstr "    /* Create threads that allocate different amounts of memory */\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:241
#, no-wrap
msgid ""
"    for (int tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"
msgstr ""
"    for (int tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:246
#, no-wrap
msgid ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"
msgstr ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:250
#, no-wrap
msgid ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"
msgstr ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:252
#, no-wrap
msgid "    /* The main thread also allocates some memory */\n"
msgstr "    /* The main thread also allocates some memory */\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:256
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""
"    for (int j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:259
#, no-wrap
msgid ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"
msgstr ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:262
#, no-wrap
msgid ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:272
msgid ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"
msgstr ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"

#. type: TH
#: build/C/man3/malloc_stats.3:25
#, no-wrap
msgid "MALLOC_STATS"
msgstr "MALLOC_STATS"

#. type: TH
#: build/C/man3/malloc_stats.3:25 build/C/man3/malloc_trim.3:25
#: build/C/man7/shm_overview.7:26
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man3/malloc_stats.3:28
msgid "malloc_stats - print memory allocation statistics"
msgstr "malloc_stats - メモリー割り当ての統計を表示する"

#. type: Plain text
#: build/C/man3/malloc_stats.3:32
msgid "B<void malloc_stats(void);>"
msgstr "B<void malloc_stats(void);>"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_stats.3:54
msgid ""
"The B<malloc_stats>()  function prints (on standard error) statistics about "
"memory allocated by B<malloc>(3)  and related functions.  For each arena "
"(allocation area), this function prints the total amount of memory allocated "
"and the total number of bytes consumed by in-use allocations.  (These two "
"values correspond to the I<arena> and I<uordblks> fields retrieved by "
"B<mallinfo>(3).)  In addition, the function prints the sum of these two "
"statistics for all arenas, and the maximum number of blocks and bytes that "
"were ever simultaneously allocated using B<mmap>(2)."
msgstr ""
"B<malloc_stats>() 関数は B<malloc>(3) や関連する関数により割り当てられたメモ"
"リーに関する統計を (標準エラーに) 出力する。 各領域 (割り当てエリア) につい"
"て、 この関数は割り当てられているメモリーの総量と現在の割り当てが使用している"
"総バイト数を出力する (これらの二つの値は B<mallinfo>(3) で取得できる "
"I<arena> と I<uordblks> フィールドに対応している)。 また、この関数は、 すべて"
"の領域のこれら二つの統計情報の合計値と、 B<mmap>(2) を使って同時に割り当てら"
"れたブロック数とバイト数の最大値を表示する。"

#. type: tbl table
#: build/C/man3/malloc_stats.3:64
#, no-wrap
msgid "B<malloc_stats>()"
msgstr "B<malloc_stats>()"

#. type: Plain text
#: build/C/man3/malloc_stats.3:73
msgid ""
"More detailed information about memory allocations in the main arena can be "
"obtained using B<mallinfo>(3)."
msgstr ""
"B<mallinfo>(3) を使用すると、 メイン領域のメモリー割り当てに関するより詳細な"
"情報を取得できる。"

#. type: Plain text
#: build/C/man3/malloc_stats.3:79
msgid ""
"B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"
msgstr ""
"B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_trim.3:25
#, no-wrap
msgid "MALLOC_TRIM"
msgstr "MALLOC_TRIM"

#. type: Plain text
#: build/C/man3/malloc_trim.3:28
msgid "malloc_trim - release free memory from the heap"
msgstr "malloc_trim - ヒープから未使用メモリーを解放する"

#. type: Plain text
#: build/C/man3/malloc_trim.3:32
msgid "B<int malloc_trim(size_t >I<pad>B<);>"
msgstr "B<int malloc_trim(size_t >I<pad>B<);>"

#. type: Plain text
#: build/C/man3/malloc_trim.3:41
msgid ""
"The B<malloc_trim>()  function attempts to release free memory from the heap "
"(by calling B<sbrk>(2)  or B<madvise>(2)  with suitable arguments)."
msgstr "B<malloc_trim>() 関数は (適切な引き数で B<sbrk>(2) や B<madvise>(2) を呼び出して) ヒープの未使用メモリーの解放を試みる。"

#. type: Plain text
#: build/C/man3/malloc_trim.3:52
msgid ""
"The I<pad> argument specifies the amount of free space to leave untrimmed at "
"the top of the heap.  If this argument is 0, only the minimum amount of "
"memory is maintained at the top of the heap (i.e., one page or less).  A "
"nonzero argument can be used to maintain some trailing space at the top of "
"the heap in order to allow future allocations to be made without having to "
"extend the heap with B<sbrk>(2)."
msgstr ""
"I<pad> 引き数は、 ヒープの一番上から切り詰める際に残す未使用領域の量を指定す"
"る。 この引き数が 0 の場合、 ヒープの一番上の最小量のメモリーだけを維持でき"
"る (つまり 1 ページかそれ未満)。 0 以外の引き数を指定すると、 ヒープの一番上"
"にある程度の量の未使用領域を残し、 将来の割り当てを B<sbrk>(2) でヒープを拡張"
"せずに行えるようにできる。"

#. type: Plain text
#: build/C/man3/malloc_trim.3:57
msgid ""
"The B<malloc_trim>()  function returns 1 if memory was actually released "
"back to the system, or 0 if it was not possible to release any memory."
msgstr ""
"B<malloc_trim>() 関数はメモリーが実際に解放されシステムに戻された場合に 1 を"
"返し、 どのメモリーも解放できなかった場合は 0 を返す。"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_trim.3:61
msgid "No errors are defined."
msgstr "エラーは定義されていない。"

#. type: tbl table
#: build/C/man3/malloc_trim.3:71
#, no-wrap
msgid "B<malloc_trim>()"
msgstr "B<malloc_trim>()"

#. type: Plain text
#: build/C/man3/malloc_trim.3:85
msgid ""
"This function is automatically called by B<free>(3)  in certain "
"circumstances; see the discussion of B<M_TOP_PAD> and B<M_TRIM_THRESHOLD> in "
"B<mallopt>(3)."
msgstr ""
"この関数は、 特定の状況では B<free>(3) により自動的に呼び出される。 "
"B<mallopt>(3) の B<M_TOP_PAD> と B<M_TRIM_THRESHOLD> の議論を参照。"

#. type: Plain text
#: build/C/man3/malloc_trim.3:91
msgid ""
"Only the main heap (using B<sbrk>(2))  honors the I<pad> argument; thread "
"heaps do not."
msgstr ""

#.  See commit 68631c8eb92ff38d9da1ae34f6aa048539b199cc
#.  (dated 2007-12-16) which adds iteration over all
#.  arenas and frees all pages in chunks which are free.
#. type: Plain text
#: build/C/man3/malloc_trim.3:97
msgid ""
"Since glibc 2.8 this function frees memory in all arenas and in all chunks "
"with whole free pages."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:100
#, fuzzy
#| msgid ""
#| "The B<malloc_trim>()  function attempts to release free memory at the top "
#| "of the heap (by calling B<sbrk>(2)  with a suitable argument)."
msgid ""
"Before glibc 2.8 this function only freed memory at the top of the heap in "
"the main arena."
msgstr ""
"B<malloc_trim>() 関数は (適切な引き数で B<sbrk>(2) を呼び出して) ヒープの一番"
"上の未使用メモリーの解放を試みる。"

#. type: Plain text
#: build/C/man3/malloc_trim.3:104
msgid "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"
msgstr "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_usable_size.3:25
#, no-wrap
msgid "MALLOC_USABLE_SIZE"
msgstr "MALLOC_USABLE_SIZE"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:28
msgid "malloc_usable_size - obtain size of block of memory allocated from heap"
msgstr ""
"malloc_usable_size - ヒープから確保したメモリーブロックのサイズを取得する"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:32
msgid "B<size_t malloc_usable_size (void *>I<ptr>B<);>"
msgstr "B<size_t malloc_usable_size (void *>I<ptr>B<);>"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:40
msgid ""
"The B<malloc_usable_size>()  function returns the number of usable bytes in "
"the block pointed to by I<ptr>, a pointer to a block of memory allocated by "
"B<malloc>(3)  or a related function."
msgstr ""
"B<malloc_usable_size>() 関数は、 I<ptr> が指すブロックで使用可能なバイト数を"
"返す。 I<ptr> は、B<malloc>(3) や同様の関数で割り当てられたメモリーブロックへ"
"のポインターである。"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:48
msgid ""
"B<malloc_usable_size>()  returns the number of usable bytes in the block of "
"allocated memory pointed to by I<ptr>.  If I<ptr> is NULL, 0 is returned."
msgstr ""
"B<malloc_usable_size>() は I<ptr> が指す割り当て済みメモリーブロックで使用可"
"能なバイト数を返す。 I<ptr> が NULL の場合、 0 が返される。"

#. type: tbl table
#: build/C/man3/malloc_usable_size.3:58
#, no-wrap
msgid "B<malloc_usable_size>()"
msgstr "B<malloc_usable_size>()"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:72
msgid ""
"The value returned by B<malloc_usable_size>()  may be greater than the "
"requested size of the allocation because of alignment and minimum size "
"constraints.  Although the excess bytes can be overwritten by the "
"application without ill effects, this is not good programming practice: the "
"number of excess bytes in an allocation depends on the underlying "
"implementation."
msgstr ""
"B<malloc_usable_size>() が返す値は、 要求された割り当てサイズよりも大きい場合"
"がある。 これは、メモリーアラインメントと最小サイズの制約のためである。 この"
"超過バイトをアプリケーションは悪影響なしで上書きすることができるが、 これを行"
"うのはプログラミングマナーとしてはよいこととは言えない。 アプリケーションの超"
"過バイトの量は、内部の実装に依存する。"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:74
msgid "The main use of this function is for debugging and introspection."
msgstr "この関数の主な使用目的はデバッグと内部調査である。"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:76
msgid "B<malloc>(3)"
msgstr "B<malloc>(3)"

#. type: TH
#: build/C/man3/mallopt.3:25
#, no-wrap
msgid "MALLOPT"
msgstr "MALLOPT"

#. type: TH
#: build/C/man3/mallopt.3:25 build/C/man3/mcheck.3:25 build/C/man2/mremap.2:30
#: build/C/man2/msync.2:25 build/C/man2/pkey_alloc.2:25 build/C/man7/pkeys.7:25
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/mallopt.3:28
msgid "mallopt - set memory allocation parameters"
msgstr "mallopt - メモリー割り当てパラメーターを設定する"

#. type: Plain text
#: build/C/man3/mallopt.3:32
msgid "B<int mallopt(int >I<param>B<, int >I<value>B<);>"
msgstr "B<int mallopt(int >I<param>B<, int >I<value>B<);>"

#. type: Plain text
#: build/C/man3/mallopt.3:43
msgid ""
"The B<mallopt>()  function adjusts parameters that control the behavior of "
"the memory-allocation functions (see B<malloc>(3)).  The I<param> argument "
"specifies the parameter to be modified, and I<value> specifies the new value "
"for that parameter."
msgstr ""
"B<mallopt>() 関数は、メモリー割り当て関数 (B<malloc>(3) を参照) の動作を\n"
"制御するパラメーターの調整を行う。\n"
"I<param> 引き数で変更するパラメーターを指定し、\n"
"I<value> 引き数でそのパラメーターの新しい値を指定する。"

#. type: Plain text
#: build/C/man3/mallopt.3:46
msgid "The following values can be specified for I<param>:"
msgstr "I<param> には以下の値を指定することができる。"

#. type: TP
#: build/C/man3/mallopt.3:46
#, no-wrap
msgid "B<M_ARENA_MAX>"
msgstr "B<M_ARENA_MAX>"

#. type: Plain text
#: build/C/man3/mallopt.3:58
msgid ""
"If this parameter has a nonzero value, it defines a hard limit on the "
"maximum number of arenas that can be created.  An arena represents a pool of "
"memory that can be used by B<malloc>(3)  (and similar) calls to service "
"allocation requests.  Arenas are thread safe and therefore may have multiple "
"concurrent memory requests.  The trade-off is between the number of threads "
"and the number of arenas.  The more arenas you have, the lower the per-"
"thread contention, but the higher the memory usage."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:63
msgid ""
"The default value of this parameter is 0, meaning that the limit on the "
"number of arenas is determined according to the setting of B<M_ARENA_TEST>."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:69
msgid ""
"This parameter has been available since glibc 2.10 via B<--enable-"
"experimental-malloc>, and since glibc 2.15 by default.  In some versions of "
"the allocator there was no limit on the number of created arenas (e.g., "
"CentOS 5, RHEL 5)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:77
msgid ""
"When employing newer glibc versions, applications may in some cases exhibit "
"high contention when accessing arenas.  In these cases, it may be beneficial "
"to increase B<M_ARENA_MAX> to match the number of threads.  This is similar "
"in behavior to strategies taken by tcmalloc and jemalloc (e.g., per-thread "
"allocation pools)."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:77
#, no-wrap
msgid "B<M_ARENA_TEST>"
msgstr "B<M_ARENA_TEST>"

#. type: Plain text
#: build/C/man3/mallopt.3:85
msgid ""
"This parameter specifies a value, in number of arenas created, at which "
"point the system configuration will be examined to determine a hard limit on "
"the number of created arenas.  (See B<M_ARENA_MAX> for the definition of an "
"arena.)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:90
msgid ""
"The computation of the arena hard limit is implementation-defined and is "
"usually calculated as a multiple of the number of available CPUs.  Once the "
"hard limit is computed, the result is final and constrains the total number "
"of arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:96
msgid ""
"The default value for the B<M_ARENA_TEST> parameter is 2 on systems where "
"I<sizeof(long)> is 4; otherwise the default value is 8."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:100
msgid ""
"This parameter has been available since glibc 2.10 via B<--enable-"
"experimental-malloc>, and since glibc 2.15 by default."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:106
msgid ""
"The value of B<M_ARENA_TEST> is not used when B<M_ARENA_MAX> has a nonzero "
"value."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:106
#, no-wrap
msgid "B<M_CHECK_ACTION>"
msgstr "B<M_CHECK_ACTION>"

#. type: Plain text
#: build/C/man3/mallopt.3:112
msgid ""
"Setting this parameter controls how glibc responds when various kinds of "
"programming errors are detected (e.g., freeing the same pointer twice).  The "
"3 least significant bits (2, 1, and 0) of the value assigned to this "
"parameter determine the glibc behavior, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:113
#, no-wrap
msgid "Bit 0"
msgstr "Bit 0"

#. type: Plain text
#: build/C/man3/mallopt.3:123
msgid ""
"If this bit is set, then print a one-line message on I<stderr> that provides "
"details about the error.  The message starts with the string \"***\\ glibc "
"detected\\ ***\", followed by the program name, the name of the memory-"
"allocation function in which the error was detected, a brief description of "
"the error, and the memory address where the error was detected."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:123
#, no-wrap
msgid "Bit 1"
msgstr "Bit 1"

#. type: Plain text
#: build/C/man3/mallopt.3:138
msgid ""
"If this bit is set, then, after printing any error message specified by bit "
"0, the program is terminated by calling B<abort>(3).  In glibc versions "
"since 2.4, if bit 0 is also set, then, between printing the error message "
"and aborting, the program also prints a stack trace in the manner of "
"B<backtrace>(3), and prints the process's memory mapping in the style of I</"
"proc/[pid]/maps> (see B<proc>(5))."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:138
#, no-wrap
msgid "Bit 2 (since glibc 2.4)"
msgstr "Bit 2 (glibc 2.4 以降)"

#. type: Plain text
#: build/C/man3/mallopt.3:145
msgid ""
"This bit has an effect only if bit 0 is also set.  If this bit is set, then "
"the one-line message describing the error is simplified to contain just the "
"name of the function where the error was detected and the brief description "
"of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:150
msgid "The remaining bits in I<value> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:154
msgid ""
"Combining the above details, the following numeric values are meaningful for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:155
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man3/mallopt.3:157
msgid "Ignore error conditions; continue execution (with undefined results)."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:157
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man3/mallopt.3:159
msgid "Print a detailed error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:159
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man3/mallopt.3:161
msgid "Abort the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:161
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: build/C/man3/mallopt.3:164
msgid ""
"Print detailed error message, stack trace, and memory mappings, and abort "
"the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:164
#, no-wrap
msgid "5"
msgstr "5"

#. type: Plain text
#: build/C/man3/mallopt.3:166
msgid "Print a simple error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:166
#, no-wrap
msgid "7"
msgstr "7"

#. type: Plain text
#: build/C/man3/mallopt.3:169
msgid ""
"Print simple error message, stack trace, and memory mappings, and abort the "
"program."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:175
msgid ""
"Since glibc 2.3.4, the default value for the B<M_CHECK_ACTION> parameter is "
"3.  In glibc version 2.3.3 and earlier, the default value is 1."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:180
msgid ""
"Using a nonzero B<M_CHECK_ACTION> value can be useful because otherwise a "
"crash may happen much later, and the true cause of the problem is then very "
"hard to track down."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:180
#, no-wrap
msgid "B<M_MMAP_MAX>"
msgstr "B<M_MMAP_MAX>"

#.  The following text adapted from comments in the glibc source:
#. type: Plain text
#: build/C/man3/mallopt.3:190
msgid ""
"This parameter specifies the maximum number of allocation requests that may "
"be simultaneously serviced using B<mmap>(2).  This parameter exists because "
"some systems have a limited number of internal tables for use by B<mmap>(2), "
"and using more than a few of them may degrade performance."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:197
msgid ""
"The default value is 65,536, a value which has no special significance and "
"which serves only as a safeguard.  Setting this parameter to 0 disables the "
"use of B<mmap>(2)  for servicing large allocation requests."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:197
#, no-wrap
msgid "B<M_MMAP_THRESHOLD>"
msgstr "B<M_MMAP_THRESHOLD>"

#. type: Plain text
#: build/C/man3/mallopt.3:206
msgid ""
"For allocations greater than or equal to the limit specified (in bytes) by "
"B<M_MMAP_THRESHOLD> that can't be satisfied from the free list, the memory-"
"allocation functions employ B<mmap>(2)  instead of increasing the program "
"break using B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:226
msgid ""
"Allocating memory using B<mmap>(2)  has the significant advantage that the "
"allocated memory blocks can always be independently released back to the "
"system.  (By contrast, the heap can be trimmed only if memory is freed at "
"the top end.)  On the other hand, there are some disadvantages to the use of "
"B<mmap>(2): deallocated space is not placed on the free list for reuse by "
"later allocations; memory may be wasted because B<mmap>(2)  allocations must "
"be page-aligned; and the kernel must perform the expensive task of zeroing "
"out memory allocated via B<mmap>(2).  Balancing these factors leads to a "
"default setting of 128*1024 for the B<M_MMAP_THRESHOLD> parameter."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:233
msgid ""
"The lower limit for this parameter is 0.  The upper limit is "
"B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 on 32-bit systems or "
"I<4*1024*1024*sizeof(long)> on 64-bit systems."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:251
msgid ""
"I<Note:> Nowadays, glibc uses a dynamic mmap threshold by default.  The "
"initial value of the threshold is 128*1024, but when blocks larger than the "
"current threshold and less than or equal to B<DEFAULT_MMAP_THRESHOLD_MAX> "
"are freed, the threshold is adjusted upward to the size of the freed block.  "
"When dynamic mmap thresholding is in effect, the threshold for trimming the "
"heap is also dynamically adjusted to be twice the dynamic mmap threshold.  "
"Dynamic adjustment of the mmap threshold is disabled if any of the "
"B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD>, or B<M_MMAP_MAX> "
"parameters is set."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:251
#, no-wrap
msgid "B<M_MXFAST> (since glibc 2.3)"
msgstr "B<M_MXFAST> (glibc 2.3 以降)"

#.  The following text adapted from comments in the glibc sources:
#. type: Plain text
#: build/C/man3/mallopt.3:263
msgid ""
"Set the upper limit for memory allocation requests that are satisfied using "
"\"fastbins\".  (The measurement unit for this parameter is bytes.)  Fastbins "
"are storage areas that hold deallocated blocks of memory of the same size "
"without merging adjacent free blocks.  Subsequent reallocation of blocks of "
"the same size can be handled very quickly by allocating from the fastbin, "
"although memory fragmentation and the overall memory footprint of the "
"program can increase."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:272
msgid ""
"The default value for this parameter is I<64*sizeof(size_t)/4> (i.e., 64 on "
"32-bit architectures).  The range for this parameter is 0 to "
"I<80*sizeof(size_t)/4>.  Setting B<M_MXFAST> to 0 disables the use of "
"fastbins."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:272
#, no-wrap
msgid "B<M_PERTURB> (since glibc 2.4)"
msgstr "B<M_PERTURB> (glibc 2.4 以降)"

#. type: Plain text
#: build/C/man3/mallopt.3:287
msgid ""
"If this parameter is set to a nonzero value, then bytes of allocated memory "
"(other than allocations via B<calloc>(3))  are initialized to the complement "
"of the value in the least significant byte of I<value>, and when allocated "
"memory is released using B<free>(3), the freed bytes are set to the least "
"significant byte of I<value>.  This can be useful for detecting errors where "
"programs incorrectly rely on allocated memory being initialized to zero, or "
"reuse values in memory that has already been freed."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:289
msgid "The default value for this parameter is 0."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:289
#, no-wrap
msgid "B<M_TOP_PAD>"
msgstr "B<M_TOP_PAD>"

#. type: Plain text
#: build/C/man3/mallopt.3:296
msgid ""
"This parameter defines the amount of padding to employ when calling "
"B<sbrk>(2)  to modify the program break.  (The measurement unit for this "
"parameter is bytes.)  This parameter has an effect in the following "
"circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:303
msgid ""
"When the program break is increased, then B<M_TOP_PAD> bytes are added to "
"the B<sbrk>(2)  request."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:309
msgid ""
"When the heap is trimmed as a consequence of calling B<free>(3)  (see the "
"discussion of B<M_TRIM_THRESHOLD>)  this much free space is preserved at the "
"top of the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:313
msgid ""
"In either case, the amount of padding is always rounded to a system page "
"boundary."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:320
msgid ""
"Modifying B<M_TOP_PAD> is a trade-off between increasing the number of "
"system calls (when the parameter is set low)  and wasting unused memory at "
"the top of the heap (when the parameter is set high)."
msgstr ""

#.  DEFAULT_TOP_PAD in glibc source
#. type: Plain text
#: build/C/man3/mallopt.3:323
msgid "The default value for this parameter is 128*1024."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:323
#, no-wrap
msgid "B<M_TRIM_THRESHOLD>"
msgstr "B<M_TRIM_THRESHOLD>"

#. type: Plain text
#: build/C/man3/mallopt.3:339
msgid ""
"When the amount of contiguous free memory at the top of the heap grows "
"sufficiently large, B<free>(3)  employs B<sbrk>(2)  to release this memory "
"back to the system.  (This can be useful in programs that continue to "
"execute for a long period after freeing a significant amount of memory.)  "
"The B<M_TRIM_THRESHOLD> parameter specifies the minimum size (in bytes) that "
"this block of memory must reach before B<sbrk>(2)  is used to trim the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:344
msgid ""
"The default value for this parameter is 128*1024.  Setting "
"B<M_TRIM_THRESHOLD> to -1 disables trimming completely."
msgstr ""

#
#
#
#. type: Plain text
#: build/C/man3/mallopt.3:352
msgid ""
"Modifying B<M_TRIM_THRESHOLD> is a trade-off between increasing the number "
"of system calls (when the parameter is set low)  and wasting unused memory "
"at the top of the heap (when the parameter is set high)."
msgstr ""

#. type: SS
#: build/C/man3/mallopt.3:352
#, no-wrap
msgid "Environment variables"
msgstr "環境変数"

#. type: Plain text
#: build/C/man3/mallopt.3:367
msgid ""
"A number of environment variables can be defined to modify some of the same "
"parameters as are controlled by B<mallopt>().  Using these variables has the "
"advantage that the source code of the program need not be changed.  To be "
"effective, these variables must be defined before the first call to a memory-"
"allocation function.  (If the same parameters are adjusted via B<mallopt>(), "
"then the B<mallopt>()  settings take precedence.)  For security reasons, "
"these variables are ignored in set-user-ID and set-group-ID programs."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:370
msgid ""
"The environment variables are as follows (note the trailing underscore at "
"the end of the name of some variables):"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:370
#, no-wrap
msgid "B<MALLOC_ARENA_MAX>"
msgstr "B<MALLOC_ARENA_MAX>"

#. type: Plain text
#: build/C/man3/mallopt.3:375
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:375
#, no-wrap
msgid "B<MALLOC_ARENA_TEST>"
msgstr "B<MALLOC_ARENA_TEST>"

#. type: Plain text
#: build/C/man3/mallopt.3:380
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_TEST>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:380
#, no-wrap
msgid "B<MALLOC_CHECK_>"
msgstr "B<MALLOC_CHECK_>"

#.  On glibc 2.12/x86, a simple malloc()+free() loop is about 70% slower
#.  when MALLOC_CHECK_ was set.
#. type: Plain text
#: build/C/man3/mallopt.3:397
msgid ""
"This environment variable controls the same parameter as B<mallopt>()  "
"B<M_CHECK_ACTION>.  If this variable is set to a nonzero value, then a "
"special implementation of the memory-allocation functions is used.  (This is "
"accomplished using the B<malloc_hook>(3)  feature.)  This implementation "
"performs additional error checking, but is slower than the standard set of "
"memory-allocation functions.  (This implementation does not detect all "
"possible errors; memory leaks can still occur.)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:402
msgid ""
"The value assigned to this environment variable should be a single digit, "
"whose meaning is as described for B<M_CHECK_ACTION>.  Any characters beyond "
"the initial digit are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:411
msgid ""
"For security reasons, the effect of B<MALLOC_CHECK_> is disabled by default "
"for set-user-ID and set-group-ID programs.  However, if the file I</etc/suid-"
"debug> exists (the content of the file is irrelevant), then B<MALLOC_CHECK_> "
"also has an effect for set-user-ID and set-group-ID programs."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:411
#, no-wrap
msgid "B<MALLOC_MMAP_MAX_>"
msgstr "B<MALLOC_MMAP_MAX_>"

#. type: Plain text
#: build/C/man3/mallopt.3:416
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:416
#, no-wrap
msgid "B<MALLOC_MMAP_THRESHOLD_>"
msgstr "B<MALLOC_MMAP_THRESHOLD_>"

#. type: Plain text
#: build/C/man3/mallopt.3:421
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:421
#, no-wrap
msgid "B<MALLOC_PERTURB_>"
msgstr "B<MALLOC_PERTURB_>"

#. type: Plain text
#: build/C/man3/mallopt.3:426
msgid "Controls the same parameter as B<mallopt>()  B<M_PERTURB>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:426
#, no-wrap
msgid "B<MALLOC_TRIM_THRESHOLD_>"
msgstr "B<MALLOC_TRIM_THRESHOLD_>"

#. type: Plain text
#: build/C/man3/mallopt.3:431
msgid "Controls the same parameter as B<mallopt>()  B<M_TRIM_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:431
#, no-wrap
msgid "B<MALLOC_TOP_PAD_>"
msgstr "B<MALLOC_TOP_PAD_>"

#. type: Plain text
#: build/C/man3/mallopt.3:436
msgid "Controls the same parameter as B<mallopt>()  B<M_TOP_PAD>."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:441
msgid "On success, B<mallopt>()  returns 1.  On error, it returns 0."
msgstr "B<mallopt>()  は成功すると 1 を返す。エラーの場合は 0 を返す。"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallopt.3:449
msgid "On error, I<errno> is I<not> set."
msgstr "エラーの場合、I<errno> は設定I<されない>。"

#.  .SH NOTES
#. type: Plain text
#: build/C/man3/mallopt.3:463
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, but the range of values for "
"I<param> varies across systems.  The SVID defined options B<M_MXFAST>, "
"B<M_NLBLKS>, B<M_GRAIN>, and B<M_KEEP>, but only the first of these is "
"implemented in glibc."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:467
msgid "Specifying an invalid value for I<param> does not generate an error."
msgstr ""

#.  FIXME . This looks buggy:
#.  setting the M_MXFAST limit rounds up:    (s + SIZE_SZ) & ~MALLOC_ALIGN_MASK)
#.  malloc requests are rounded up:
#.     (req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12129
#. type: Plain text
#: build/C/man3/mallopt.3:475
msgid ""
"A calculation error within the glibc implementation means that a call of the "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:479
#, no-wrap
msgid "mallopt(M_MXFAST, n)\n"
msgstr "mallopt(M_MXFAST, n)\n"

#.  Bins are multiples of 2 * sizeof(size_t) + sizeof(size_t)
#. type: Plain text
#: build/C/man3/mallopt.3:492
msgid ""
"does not result in fastbins being employed for all allocations of size up to "
"I<n>.  To ensure desired results, I<n> should be rounded up to the next "
"multiple greater than or equal to I<(2k+1)*sizeof(size_t)>, where I<k> is an "
"integer."
msgstr ""

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12140
#. type: Plain text
#: build/C/man3/mallopt.3:513
msgid ""
"If B<mallopt>()  is used to set B<M_PERTURB>, then, as expected, the bytes "
"of allocated memory are initialized to the complement of the byte in "
"I<value>, and when that memory is freed, the bytes of the region are "
"initialized to the byte specified in I<value>.  However, there is an off-by-"
"I<sizeof(size_t)> error in the implementation: instead of initializing "
"precisely the block of memory being freed by the call I<free(p)>, the block "
"starting at I<p+sizeof(size_t)> is initialized."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:522
msgid ""
"The program below demonstrates the use of B<M_CHECK_ACTION>.  If the program "
"is supplied with an (integer) command-line argument, then that argument is "
"used to set the B<M_CHECK_ACTION> parameter.  The program then allocates a "
"block of memory, and frees it twice (an error)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:526
msgid ""
"The following shell session shows what happens when we run this program "
"under glibc, with the default value for B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:546
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"
msgstr ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"

#. type: Plain text
#: build/C/man3/mallopt.3:551
msgid ""
"The following runs show the results when employing other values for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:564
#, no-wrap
msgid ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"
msgstr ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"

#. type: Plain text
#: build/C/man3/mallopt.3:570
msgid ""
"The next run shows how to set the same parameter using the B<MALLOC_CHECK_> "
"environment variable:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:577
#, no-wrap
msgid ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"
msgstr ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"

#. type: Plain text
#: build/C/man3/mallopt.3:585
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mallopt.3:590 build/C/man3/mcheck.3:208
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"

#. type: Plain text
#: build/C/man3/mallopt.3:597
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallopt.3:603
#, no-wrap
msgid ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallopt.3:606
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"
msgstr ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"

#. type: Plain text
#: build/C/man3/mallopt.3:609
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"
msgstr ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"

#. type: Plain text
#: build/C/man3/mallopt.3:627
msgid ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"
msgstr ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"

#. type: TH
#: build/C/man3/mcheck.3:25
#, no-wrap
msgid "MCHECK"
msgstr "MCHECK"

#. type: Plain text
#: build/C/man3/mcheck.3:28
msgid ""
"mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency checking"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:31
#, no-wrap
msgid "B<#include E<lt>mcheck.hE<gt>>\n"
msgstr "B<#include E<lt>mcheck.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:33
#, no-wrap
msgid "B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr "B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:35
#, no-wrap
msgid "B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr "B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:37
#, no-wrap
msgid "B<void mcheck_check_all(void);>\n"
msgstr "B<void mcheck_check_all(void);>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:39
#, no-wrap
msgid "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"
msgstr "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:51
msgid ""
"The B<mcheck>()  function installs a set of debugging hooks for the "
"B<malloc>(3)  family of memory-allocation functions.  These hooks cause "
"certain consistency checks to be performed on the state of the heap.  The "
"checks can detect application errors such as freeing a block of memory more "
"than once or corrupting the bookkeeping data structures that immediately "
"precede a block of allocated memory."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:63
msgid ""
"To be effective, the B<mcheck>()  function must be called before the first "
"call to B<malloc>(3)  or a related function.  In cases where this is "
"difficult to ensure, linking the program with I<-lmcheck> inserts an "
"implicit call to B<mcheck>()  (with a NULL argument)  before the first call "
"to a memory-allocation function."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:71
msgid ""
"The B<mcheck_pedantic>()  function is similar to B<mcheck>(), but performs "
"checks on all allocated blocks whenever one of the memory-allocation "
"functions is called.  This can be very slow!"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:78
msgid ""
"The B<mcheck_check_all>()  function causes an immediate check on all "
"allocated blocks.  This call is effective only if B<mcheck>()  is called "
"beforehand."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:91
msgid ""
"If the system detects an inconsistency in the heap, the caller-supplied "
"function pointed to by I<abortfunc> is invoked with a single argument, "
"I<mstatus>, that indicates what type of inconsistency was detected.  If "
"I<abortfunc> is NULL, a default function prints an error message on "
"I<stderr> and calls B<abort>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:103
msgid ""
"The B<mprobe>()  function performs a consistency check on the block of "
"allocated memory pointed to by I<ptr>.  The B<mcheck>()  function should be "
"called beforehand (otherwise B<mprobe>()  returns B<MCHECK_DISABLED>)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:111
msgid ""
"The following list describes the values returned by B<mprobe>()  or passed "
"as the I<mstatus> argument when I<abortfunc> is invoked:"
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:111
#, no-wrap
msgid "B<MCHECK_DISABLED> (B<mprobe>() only)"
msgstr "B<MCHECK_DISABLED> (B<mprobe>() のみ)"

#. type: Plain text
#: build/C/man3/mcheck.3:116
msgid ""
"B<mcheck>()  was not called before the first memory allocation function was "
"called.  Consistency checking is not possible."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:116
#, no-wrap
msgid "B<MCHECK_OK> (B<mprobe>() only)"
msgstr "B<MCHECK_OK> (B<mprobe>() のみ)"

#. type: Plain text
#: build/C/man3/mcheck.3:119
msgid "No inconsistency detected."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:119
#, no-wrap
msgid "B<MCHECK_HEAD>"
msgstr "B<MCHECK_HEAD>"

#. type: Plain text
#: build/C/man3/mcheck.3:122
msgid "Memory preceding an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:122
#, no-wrap
msgid "B<MCHECK_TAIL>"
msgstr "B<MCHECK_TAIL>"

#. type: Plain text
#: build/C/man3/mcheck.3:125
msgid "Memory following an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:125
#, no-wrap
msgid "B<MCHECK_FREE>"
msgstr "B<MCHECK_FREE>"

#. type: Plain text
#: build/C/man3/mcheck.3:129
msgid "A block of memory was freed twice."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:134
msgid ""
"B<mcheck>()  and B<mcheck_pedantic>()  return 0 on success, or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:145
msgid ""
"The B<mcheck_pedantic>()  and B<mcheck_check_all>()  functions are available "
"since glibc 2.2.  The B<mcheck>()  and B<mprobe>()  functions are present "
"since at least glibc 2.0"
msgstr ""

#. type: tbl table
#: build/C/man3/mcheck.3:156
#, no-wrap
msgid ""
"B<mcheck>(),\n"
"B<mcheck_pedantic>(),\n"
msgstr ""
"B<mcheck>(),\n"
"B<mcheck_pedantic>(),\n"

#. type: tbl table
#: build/C/man3/mcheck.3:156 build/C/man3/mcheck.3:161
#: build/C/man3/posix_memalign.3:200 build/C/man3/posix_memalign.3:202
#: build/C/man3/posix_memalign.3:207
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/mcheck.3:159
#, no-wrap
msgid ""
"B<mcheck_check_all>(),\n"
"B<mprobe>()"
msgstr ""
"B<mcheck_check_all>(),\n"
"B<mprobe>()"

#. type: tbl table
#: build/C/man3/mcheck.3:161
#, no-wrap
msgid "MT-Unsafe race:mcheck\n"
msgstr "MT-Unsafe race:mcheck\n"

#. type: tbl table
#: build/C/man3/mcheck.3:163
#, no-wrap
msgid "const:malloc_hooks"
msgstr "const:malloc_hooks"

#.  But is MALLOC_CHECK_ slower?
#. type: Plain text
#: build/C/man3/mcheck.3:180
msgid ""
"Linking a program with I<-lmcheck> and using the B<MALLOC_CHECK_> "
"environment variable (described in B<mallopt>(3))  cause the same kinds of "
"errors to be detected.  But, using B<MALLOC_CHECK_> does not require the "
"application to be relinked."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:186
msgid ""
"The program below calls B<mcheck>()  with a NULL argument and then frees the "
"same block of memory twice.  The following shell session demonstrates what "
"happens when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:191
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"About to free\n"
msgstr ""
"$B< ./a.out>\n"
"About to free\n"

#. type: Plain text
#: build/C/man3/mcheck.3:195
#, no-wrap
msgid ""
"About to free a second time\n"
"block freed twice\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:203
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:211
#, no-wrap
msgid ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"
msgstr ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"

#. type: Plain text
#: build/C/man3/mcheck.3:214
#, no-wrap
msgid ""
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mcheck.3:216
#, no-wrap
msgid "    p = malloc(1000);\n"
msgstr "    p = malloc(1000);\n"

#. type: Plain text
#: build/C/man3/mcheck.3:221
#, no-wrap
msgid ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"
msgstr ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"

#. type: Plain text
#: build/C/man3/mcheck.3:229
msgid "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"
msgstr "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"

#. type: TH
#: build/C/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr "MLOCK"

#. type: Plain text
#: build/C/man2/mlock.2:29
msgid "mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory"
msgstr "mlock, mlock2, munlock, mlockall, munlockall - メモリーのロックとロック解除を行う"

#. type: Plain text
#: build/C/man2/mlock.2:32 build/C/man2/mmap.2:46 build/C/man2/mmap2.2:35
#: build/C/man2/mprotect.2:39 build/C/man3/posix_madvise.3:26
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mlock.2:36
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man2/mlock.2:39
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"

#. type: Plain text
#: build/C/man2/mlock.2:48
msgid ""
"B<mlock>(), B<mlock2>(), and B<mlockall>()  lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area."
msgstr "B<mlock>() と B<mlockall>() は、呼び出し元プロセスの仮想アドレス空間の一部または全部を RAM 上にロックし、メモリーがスワップエリアにページングされるのを防ぐ。"

#. type: Plain text
#: build/C/man2/mlock.2:56
msgid ""
"B<munlock>()  and B<munlockall>()  perform the converse operation, unlocking "
"part or all of the calling process's virtual address space, so that pages in "
"the specified virtual address range may once more to be swapped out if "
"required by the kernel memory manager."
msgstr "B<munlock>()  と B<munlockall>()  は逆の操作で、それぞれ呼び出し元プロセスの仮想アドレス空間の一部または全部を ロック解除する。つまり、指定された仮想アドレス範囲のページは カーネルメモリーマネージャーから要求されればスワップアウトするようになる。 メモリーのロックとロック解除はページ単位で行われる。"

#. type: Plain text
#: build/C/man2/mlock.2:58
msgid "Memory locking and unlocking are performed in units of whole pages."
msgstr "メモリーのロックとロック解除はページ単位で行われる。"

#. type: SS
#: build/C/man2/mlock.2:58
#, no-wrap
msgid "mlock(), mlock2(), and munlock()"
msgstr "mlock(), mlock2(), munlock()"

#. type: Plain text
#: build/C/man2/mlock.2:68
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""
"B<mlock>()  は I<addr> から始まる長さ I<len> バイトのアドレス範囲のページを"
"ロックする。 呼び出しが成功した場合には、 指定されたアドレス範囲を含む全ての"
"ページは RAM に残り続けることが保証される。 これらのページは後でロック解除さ"
"れるまで RAM に残り続けることが保証される。"

#.  commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
#.  commit de60f5f10c58d4f34b68622442c0e04180367f3f
#.  commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
#. type: Plain text
#: build/C/man2/mlock.2:82
#, fuzzy
#| msgid ""
#| "B<mlock>()  locks pages in the address range starting at I<addr> and "
#| "continuing for I<len> bytes.  All pages that contain a part of the "
#| "specified address range are guaranteed to be resident in RAM when the "
#| "call returns successfully; the pages are guaranteed to stay in RAM until "
#| "later unlocked."
msgid ""
"B<mlock2>()  also locks pages in the specified range starting at I<addr> and "
"continuing for I<len> bytes.  However, the state of the pages contained in "
"that range after the call returns successfully will depend on the value in "
"the I<flags> argument."
msgstr ""
"B<mlock>()  は I<addr> から始まる長さ I<len> バイトのアドレス範囲のページを"
"ロックする。 呼び出しが成功した場合には、 指定されたアドレス範囲を含む全ての"
"ページは RAM に残り続けることが保証される。 これらのページは後でロック解除さ"
"れるまで RAM に残り続けることが保証される。"

#. type: Plain text
#: build/C/man2/mlock.2:86
#, fuzzy
#| msgid ""
#| "The I<flags> argument is constructed as the bitwise OR of one or more of "
#| "the following constants:"
msgid "The I<flags> argument can be either 0 or the following constant:"
msgstr "I<flags> 引数は以下の内容の一つまたは複数のビット OR から構成される:"

#. type: TP
#: build/C/man2/mlock.2:86
#, no-wrap
msgid "B<MLOCK_ONFAULT>"
msgstr "B<MLOCK_ONFAULT>"

#. type: Plain text
#: build/C/man2/mlock.2:91
msgid ""
"Lock pages that are currently resident and mark the entire range so that the "
"remaining nonresident pages are locked when they are populated by a page "
"fault."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:98
msgid "If I<flags> is 0, B<mlock2>()  behaves exactly the same as B<mlock>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:107
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""
"B<munlock>()  は、 I<addr> から始まる長さ I<len> バイトのアドレス範囲のページ"
"のロックを解除する。 この呼び出しを行った後は、カーネルが、指定されたメモリー"
"範囲を含む 全てのページを外部のスワップ空間に移動できるようになる。"

#. type: SS
#: build/C/man2/mlock.2:107
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr "mlockall() と munlockall()"

#. type: Plain text
#: build/C/man2/mlock.2:117
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and memory-"
"mapped files.  All mapped pages are guaranteed to be resident in RAM when "
"the call returns successfully; the pages are guaranteed to stay in RAM until "
"later unlocked."
msgstr ""
"B<mlockall>()  は呼び出し元プロセスのアドレス空間にマップされている全てのペー"
"ジを ロックする。これにはコード、データ、スタックの 各セグメント、共有ライブ"
"ラリ、カーネルのユーザー空間データ、 共有メモリー、メモリーマップされたファイ"
"ルが含まれる。 システムコールが成功した場合には全てのマップされたページは "
"RAM に 残ることを保証される。 これらのページは後でロック解除されるまで RAM に"
"残り続けることが保証される。"

#. type: Plain text
#: build/C/man2/mlock.2:122
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr "I<flags> 引数は以下の内容の一つまたは複数のビット OR から構成される:"

#. type: TP
#: build/C/man2/mlock.2:122
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr "B<MCL_CURRENT>"

#. type: Plain text
#: build/C/man2/mlock.2:126
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""
"現在、プロセスのアドレス空間にマップされている全てのページをロックする。"

#. type: TP
#: build/C/man2/mlock.2:126
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr "B<MCL_FUTURE>"

#. type: Plain text
#: build/C/man2/mlock.2:133
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be, for instance, new pages required by "
"a growing heap and stack as well as new memory-mapped files or shared memory "
"regions."
msgstr ""
"将来、プロセスのアドレス空間にマップされる全てのページをロックする。 例えば、"
"ヒープ (heap) やスタックの成長により新しく必要になったページだけで なく、新し"
"くメモリーマップされたファイルや共有メモリー領域もロックされる。"

#. type: TP
#: build/C/man2/mlock.2:133
#, no-wrap
msgid "B<MCL_ONFAULT> (since Linux 4.4)"
msgstr "B<MCL_ONFAULT> (Linux 4.4 以降)"

#. type: Plain text
#: build/C/man2/mlock.2:160
msgid ""
"Used together with B<MCL_CURRENT>, B<MCL_FUTURE>, or both.  Mark all current "
"(with B<MCL_CURRENT>)  or future (with B<MCL_FUTURE>)  mappings to lock "
"pages when they are faulted in.  When used with B<MCL_CURRENT>, all present "
"pages are locked, but B<mlockall>()  will not fault in non-present pages.  "
"When used with B<MCL_FUTURE>, all future mappings will be marked to lock "
"pages when they are faulted in, but they will not be populated by the lock "
"when the mapping is created.  B<MCL_ONFAULT> must be used with either "
"B<MCL_CURRENT> or B<MCL_FUTURE> or both."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:173
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number "
"of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""
"B<MCL_FUTURE> が指定されていると、以後のシステムコール (例えば、 B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3))  は、ロックするバイト数が許可された最大値 (下記参"
"照) を超えた場合に 失敗する可能性がある。 同様に、スタックの成長も失敗する可"
"能性がある。 その場合、カーネルはスタックの拡張を拒否し、 B<SIGSEGV> をプロセ"
"スに送る。"

#. type: Plain text
#: build/C/man2/mlock.2:177
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""
"B<munlockall>()  は、呼び出し元プロセスのアドレス空間にマッピングされている "
"全てのページをロック解除する。"

#. type: Plain text
#: build/C/man2/mlock.2:183
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""
"成功した場合は、これらのシステムコールはゼロを返す。 エラーの場合は -1 が返さ"
"れ、 I<errno> が適切に設定され、プロセスのアドレス空間におけるロックは変更さ"
"れない。"

#. type: Plain text
#: build/C/man2/mlock.2:192
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""
"(Linux 2.6.9 以降) 呼び出し元は非ゼロの ソフト資源制限 B<RLIMIT_MEMLOCK> を持"
"つが、制限が許可している以上のメモリーをロックしようとした。 この制限は、プロ"
"セスが特権 (B<CAP_IPC_LOCK>)  を持っている場合は適用されない。"

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: build/C/man2/mlock.2:204
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""
"(Linux 2.4 以前) 呼び出し元プロセスが RAM の半分以上をロックしようとした。"

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: build/C/man2/mlock.2:210
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""
"呼び出し側が特権を持っていないが、\n"
"要求された操作を実行するには特権 (B<CAP_IPC_LOCK>) が必要である。"

#. type: Plain text
#: build/C/man2/mlock.2:216
#, fuzzy
#| msgid "For B<mlock>()  and B<munlock>():"
msgid "For B<mlock>(), B<mlock2>(), and B<munlock>():"
msgstr "B<mlock>()  と B<munlock>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:219
msgid "Some or all of the specified address range could not be locked."
msgstr "指定されたアドレス範囲の一部または全てをロックすることができなかった。"

#. type: Plain text
#: build/C/man2/mlock.2:226
msgid ""
"The result of the addition I<addr>+I<len> was less than I<addr> (e.g., the "
"addition may have resulted in an overflow)."
msgstr "I<addr>+I<len> の加算の結果が I<addr> よりも小さかった (例えば、加算でオーバーフローが発生したなど)。"

#. type: Plain text
#: build/C/man2/mlock.2:231
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""
"(Linux ではこの意味で使われない)  I<addr> がページサイズの倍数ではない。"

#. type: Plain text
#: build/C/man2/mlock.2:235
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""
"指定されたアドレス範囲がプロセスのアドレス空間にマップされたページと 一致しな"
"い。"

#.  I.e., the number of VMAs would exceed the 64kB maximum
#. type: Plain text
#: build/C/man2/mlock.2:244
msgid ""
"Locking or unlocking a region would result in the total number of mappings "
"with distinct attributes (e.g., locked versus unlocked)  exceeding the "
"allowed maximum.  (For example, unlocking a range in the middle of a "
"currently locked mapping would result in three mappings: two locked mappings "
"at each end and an unlocked mapping in the middle.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:247
#, fuzzy
#| msgid "For B<mlockall>():"
msgid "For B<mlock2>():"
msgstr "B<mlockall>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:250
msgid "Unknown I<flags> were specified."
msgstr "未知の I<flags> が指定された。"

#. type: Plain text
#: build/C/man2/mlock.2:253
msgid "For B<mlockall>():"
msgstr "B<mlockall>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:261
msgid ""
"Unknown I<flags> were specified or B<MCL_ONFAULT> was specified without "
"either B<MCL_FUTURE> or B<MCL_CURRENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:264
msgid "For B<munlockall>():"
msgstr "B<munlockall>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:268
msgid ""
"(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""
"(Linux 2.6.8 以前) 呼び出し元が権限 (B<CAP_IPC_LOCK>)  を持っていない。"

#. type: Plain text
#: build/C/man2/mlock.2:272
#, fuzzy
#| msgid ""
#| "The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
#| "support was added in version 2.3.3."
msgid ""
"B<mlock2>()  is available since Linux 4.4; glibc support was added in "
"version 2.27."
msgstr ""
"B<remap_file_pages>()  システムコールは Linux 2.5.46 で登場した。 glibc での"
"サポートは glibc バージョン 2.3.3 で追加された。"

#.  SVr4 documents an additional error condition EMFILE.
#. type: Plain text
#: build/C/man2/mlock.2:274 build/C/man2/shmctl.2:467 build/C/man2/shmget.2:283
#: build/C/man2/shmop.2:230
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#. type: Plain text
#: build/C/man2/mlock.2:277
msgid "B<mlock2>()  is Linux specific."
msgstr "B<mlock2>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/mlock.2:289
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""
"B<mlock>()  と B<munlock>()  が使用可能な POSIX システムでは "
"B<_POSIX_MEMLOCK_RANGE> が I<E<lt>unistd.hE<gt>> で定義されている。 また、"
"ページあたりのバイト数は、 I<E<lt>limits.hE<gt>> で定義される定数 "
"B<PAGESIZE> から (定義されている場合)、もしくは I<sysconf(_SC_PAGESIZE)> を呼"
"び出すことで決定できる。"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mlock.2:302
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<mlockall>()  と B<munlockall>()  が利用可能な POSIX システムでは、 "
"B<_POSIX_MEMLOCK> は I<E<lt>unistd.hE<gt>> で 0 より大きい値に定義されている "
"(B<sysconf>(3)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/mlock.2:320
msgid ""
"Memory locking has two main applications: real-time algorithms and high-"
"security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""
"メモリーのロックの用途としては主に二つある: リアルタイム アルゴリズムと高いセ"
"キュリティの必要なデータ処理である。リアルタイムの アプリケーションは決定的な"
"タイミングやスケジューリングを必要とするが、 ページングは予期しないプログラム"
"の実行遅延をもたらす主要な要因となる。 リアルタイムのアプリケーションはたいて"
"いは B<sched_setscheduler>(2)  でリアルタイムスケジューラに変更される。 暗号"
"やセキュリティのソフトウェアはしばしばパスワードや秘密鍵のデータの ような重要"
"なバイト列を扱う。ページングの結果、これらの秘密が スワップ用の固定媒体に転送"
"されるかもしれない。そして、セキュリティ ソフトウェアが RAM 上の秘密を削除し"
"て終了したずっと後になっても、 このスワップされたデータには敵がアクセスできる"
"可能性がある (しかし、ラップトップといくつかのデスクトップコンピュータの サス"
"ペンドモードはシステムの RAM の内容をメモリーのロックに関わらず ディスクに保"
"存することに注意)。"

#. type: Plain text
#: build/C/man2/mlock.2:333
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the time-"
"critical section, so that no page fault can be caused by function calls.  "
"This can be achieved by calling a function that allocates a sufficiently "
"large automatic variable (an array) and writes to the memory occupied by "
"this array in order to touch these stack pages.  This way, enough pages will "
"be mapped for the stack and can be locked into RAM.  The dummy writes ensure "
"that not even copy-on-write page faults can occur in the critical section."
msgstr ""
"リアルタイムプロセスが B<mlockall>()  を使ってページフォールトによる遅延を防"
"ごうとする場合、 関数呼び出しによってページフォールトが発生しないように、 時"
"間制限の厳しい部分 (time-critical section) に入る前に 十分な量のロックされた"
"スタックを確保しておく必要がある。 これを実現するには、十分な大きさの自動変"
"数 (の配列) を確保し、 これらのスタック用のページがメモリー上に確保されるよう"
"にこの配列に 書き込みを行う関数を用意し、これを呼び出せばよい。こうすること"
"で、 十分な量のページがスタックにマッピングされ、RAM にロックされる。 ダミー"
"の書き込みを行うことによって、 時間制限の厳しい部分 (critical section) 内では"
"書き込み時コピーによる ページフォールトさえも発生しないことが保証される。"

#. type: Plain text
#: build/C/man2/mlock.2:348
#, fuzzy
#| msgid ""
#| "Memory locks are not inherited by a child created via B<fork>(2)  and are "
#| "automatically removed (unlocked) during an B<execve>(2)  or when the "
#| "process terminates.  The B<mlockall>()  B<MCL_FUTURE> setting is not "
#| "inherited by a child created via B<fork>(2)  and is cleared during an "
#| "B<execve>(2)."
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates.  The B<mlockall>()  B<MCL_FUTURE> and B<MCL_FUTURE | "
"MCL_ONFAULT> settings are not inherited by a child created via B<fork>(2)  "
"and are cleared during an B<execve>(2)."
msgstr ""
"メモリーロックは B<fork>(2)  で作成された子プロセスには継承されず、 "
"B<execve>(2)  が呼ばれたり、プロセスが終了した場合は 自動的に削除される (ロッ"
"ク解除される)。 B<mlockall>() の B<MCL_FUTURE> 設定は B<fork>(2) で作成された"
"子プロセスには継承されず、 B<execve>(2) の中でクリアされる。"

#. type: Plain text
#: build/C/man2/mlock.2:362
msgid ""
"Note that B<fork>(2)  will prepare the address space for a copy-on-write "
"operation.  The consequence is that any write access that follows will cause "
"a page fault that in turn may cause high latencies for a real-time process.  "
"Therefore, it is crucial not to invoke B<fork>(2)  after an B<mlockall>()  "
"or B<mlock>()  operation\\(emnot even from a thread which runs at a low "
"priority within a process which also has a thread running at elevated "
"priority."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:366
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""
"あるアドレス範囲に対するメモリーロックは、そのアドレス範囲が B<munmap>(2)  に"
"よってアンマップされた場合は削除される。"

#. type: Plain text
#: build/C/man2/mlock.2:380
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>(), B<mlock2>(), or B<mlockall>()  will be "
"unlocked by a single call to B<munlock>()  for the corresponding range or by "
"B<munlockall>().  Pages which are mapped to several locations or by several "
"processes stay locked into RAM as long as they are locked at least at one "
"location or by at least one process."
msgstr "メモリーのロックは累積しない。 すなわち複数回 B<mlock>(), B<mlock2>(), B<mlockall>()  を呼び出してロックされたページでも、 対応する範囲に対して B<munlock>()  を 1 回呼び出したり B<munlockall>()  を呼び出したりするだけでロック解除される。 複数の場所や複数のプロセスにマップされているページは、少なくとも一つの場所、 一つのプロセスでロックされている限りは RAM に残り続ける。"

#. type: Plain text
#: build/C/man2/mlock.2:389
msgid ""
"If a call to B<mlockall>()  which uses the B<MCL_FUTURE> flag is followed by "
"another call that does not specify this flag, the changes made by the "
"B<MCL_FUTURE> call will be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:400
msgid ""
"The B<mlock2>()  B<MLOCK_ONFAULT> flag and the B<mlockall>()  B<MCL_ONFAULT> "
"flag allow efficient memory locking for applications that deal with large "
"mappings where only a (small) portion of pages in the mapping are touched.  "
"In such cases, locking all of the pages in a mapping would incur a "
"significant penalty for memory locking."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:416
msgid ""
"Under Linux, B<mlock>(), B<mlock2>(), and B<munlock>()  automatically round "
"I<addr> down to the nearest page boundary.  However, the POSIX.1 "
"specification of B<mlock>()  and B<munlock>()  allows an implementation to "
"require that I<addr> is page aligned, so portable applications should ensure "
"this."
msgstr "Linux では、 B<mlock>(), B<mlock2>(), B<munlock>() は自動的に I<addr> を端数切り捨てにより一番近いページ境界へと丸める。 しかし POSIX.1 仕様の B<mlock>() と B<munlock>() は I<addr> がページ境界に合っていることを要求する実装も許している。 そのため移植性を意図したアプリケーションではきちんと境界に合わせた方が良い。"

#. type: Plain text
#: build/C/man2/mlock.2:430
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/[pid]/status> file shows "
"how many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlock2>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr "Linux 固有の I</proc/[pid]/status> ファイルの I<VmLck> フィールドには、 B<mlock>(), B<mlock2>(), B<mlockall>() および B<mmap>(2) B<MAP_LOCKED> を使って、 ID が I<PID> のプロセスがロックしているメモリー量 (キロバイト単位) が表示される。"

#. type: SS
#: build/C/man2/mlock.2:430
#, no-wrap
msgid "Limits and permissions"
msgstr "制限と権限"

#. type: Plain text
#: build/C/man2/mlock.2:437
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""
"Linux 2.6.8 以前では、メモリーをロックするためには特権 (B<CAP_IPC_LOCK>)  が"
"必要で、 ソフト資源制限 B<RLIMIT_MEMLOCK> はプロセスがどれだけのメモリーを"
"ロックできるかの制限を定義する。"

#. type: Plain text
#: build/C/man2/mlock.2:443
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""
"Linux 2.6.9 以降では、特権を持つプロセスがロックできるメモリー量は無制限とな"
"り、 代わりにソフト資源制限 B<RLIMIT_MEMLOCK> は特権を持たないプロセスがロッ"
"クできるメモリー量の制限を定義する。"

#.  commit 0cf2f6f6dc605e587d2c1120f295934c77e810e8
#. type: Plain text
#: build/C/man2/mlock.2:466
msgid ""
"In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory "
"for unprivileged processes (i.e., without B<CAP_IPC_LOCK>)  meant that if "
"the region specified by I<addr> and I<len> overlapped an existing lock, then "
"the already locked bytes in the overlapping region were counted twice when "
"checking against the limit.  Such double accounting could incorrectly "
"calculate a \"total locked memory\" value for the process that exceeded the "
"B<RLIMIT_MEMLOCK> limit, with the result that B<mlock>()  and B<mlock2>()  "
"would fail on requests that should have succeeded.  This bug was fixed in "
"Linux 4.9."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:474
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""
"2.4.17 までの 2.4 シリーズの Linux カーネルには、 B<mlockall>()  "
"B<MCL_FUTURE> フラグが B<fork>(2)  で継承されると言うバグがある。 これはカー"
"ネル 2.4.18 で修正された。"

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: build/C/man2/mlock.2:491
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""
"カーネル 2.6.9 以降では、特権を持ったプロセスが I<mlockall(MCL_FUTURE)> を呼"
"び出した後で、特権をなくした場合 (例えば、 実効 UID を 0 以外の値に変更するな"
"どにより、 B<CAP_IPC_LOCK> ケーパビリティを失った場合)、リソース上限 "
"B<RLIMIT_MEMLOCK> に達すると、それ以降のメモリー割り当て (例えば B<mmap>(2), "
"B<brk>(2))  は失敗する。"

#. type: Plain text
#: build/C/man2/mlock.2:499
msgid ""
"B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), "
"B<proc>(5), B<capabilities>(7)"
msgstr "B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), B<capabilities>(7)"

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr "MMAP"

#. type: Plain text
#: build/C/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr "mmap, munmap - ファイルやデバイスをメモリーにマップ/アンマップする"

#. type: Plain text
#: build/C/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: build/C/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr "機能検査マクロの要件に関する情報は「注意」の節を参照。"

#. type: Plain text
#: build/C/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping (which must be "
"greater than 0)."
msgstr "B<mmap>()  は、新しいマッピングを呼び出し元プロセスの仮想アドレス空間に作成する。 新しいマッピングの開始アドレスは I<addr> で指定される。マッピングの長さは I<length> 引き数で指定される (正の値でなければならない)。"

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: build/C/man2/mmap.2:83
#, fuzzy
#| msgid ""
#| "If I<addr> is NULL, then the kernel chooses the address at which to "
#| "create the mapping; this is the most portable method of creating a new "
#| "mapping.  If I<addr> is not NULL, then the kernel takes it as a hint "
#| "about where to place the mapping; on Linux, the mapping will be created "
#| "at a nearby page boundary.  The address of the new mapping is returned as "
#| "the result of the call."
msgid ""
"If I<addr> is NULL, then the kernel chooses the (page-aligned) address at "
"which to create the mapping; this is the most portable method of creating a "
"new mapping.  If I<addr> is not NULL, then the kernel takes it as a hint "
"about where to place the mapping; on Linux, the kernel will pick a nearby "
"page boundary (but always above or equal to the value specified by I</proc/"
"sys/vm/mmap_min_addr>)  and attempt to create the mapping there.  If another "
"mapping already exists there, the kernel picks a new address that may or may "
"not depend on the hint.  The address of the new mapping is returned as the "
"result of the call."
msgstr ""
"I<addr> が NULL の場合、カーネルがマッピングを作成するアドレスを選択する。 こ"
"の方法は最も移植性のある新しいマッピングの作成方法である。 I<addr> が NULL で"
"ない場合、カーネルはマッピングをどこに配置するかのヒントとして I<addr> を使用"
"する。Linux では、マッピングはすぐ近くのページ境界に作成される。 新しいマッピ"
"ングのアドレスは、呼び出しの返り値として返される。"

#. type: Plain text
#: build/C/man2/mmap.2:95
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""
"ファイルマッピングの内容は、 ファイルディスクリプター I<fd> で参照されるファ"
"イル (もしくは他のオブジェクト) のオフセット I<offset> から開始される "
"I<length> バイトのデータで初期化される (ファイルマッピングは無名マッピングの"
"反対語である。 B<MAP_ANONYMOUS> を参照)。 I<offset> は "
"I<sysconf(_SC_PAGE_SIZE)> が返すページサイズの倍数でなければならない。"

#. type: Plain text
#: build/C/man2/mmap.2:101
msgid ""
"After the B<mmap>()  call has returned, the file descriptor, I<fd>, can be "
"closed immediately without invalidating the mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:109
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""
"引き数 I<prot> には、マッピングのメモリー保護をどのように行なうかを指定する "
"(ファイルのオープンモードと矛盾してはいけない)。 I<prot> には、 B<PROT_NONE> "
"か、以下のフラグをひとつ以上ビット毎の論理和 (OR) をとったものを 指定できる。"

#. type: TP
#: build/C/man2/mmap.2:109 build/C/man2/mprotect.2:73
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr "B<PROT_EXEC>"

#. type: Plain text
#: build/C/man2/mmap.2:112
msgid "Pages may be executed."
msgstr "ページは実行可能である。"

#. type: TP
#: build/C/man2/mmap.2:112 build/C/man2/mprotect.2:67
#, no-wrap
msgid "B<PROT_READ>"
msgstr "B<PROT_READ>"

#. type: Plain text
#: build/C/man2/mmap.2:115
msgid "Pages may be read."
msgstr "ページは読み込み可能である。"

#. type: TP
#: build/C/man2/mmap.2:115 build/C/man2/mprotect.2:70
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr "B<PROT_WRITE>"

#. type: Plain text
#: build/C/man2/mmap.2:118
msgid "Pages may be written."
msgstr "ページに書き込み可能である。"

#. type: TP
#: build/C/man2/mmap.2:118 build/C/man2/mprotect.2:64
#, no-wrap
msgid "B<PROT_NONE>"
msgstr "B<PROT_NONE>"

#. type: Plain text
#: build/C/man2/mmap.2:122
msgid "Pages may not be accessed."
msgstr "ページにはアクセスできない。"

#. type: SS
#: build/C/man2/mmap.2:122
#, no-wrap
msgid "The flags argument"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:131
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""
"I<flags> 引き数により、マッピングに対する更新が同じ領域をマッピングしている "
"他のプロセスに見えるか、更新がマッピング元のファイルを通じて 伝えられるか、が"
"決定される。この動作は、以下の値のいずれか一つだけ (複数は指定できない) を "
"I<flags> に含めることで指定する。"

#. type: TP
#: build/C/man2/mmap.2:131
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr "B<MAP_SHARED>"

#. type: Plain text
#: build/C/man2/mmap.2:140
#, fuzzy
#| msgid ""
#| "Share this mapping.  Updates to the mapping are visible to other "
#| "processes that map this file, and are carried through to the underlying "
#| "file.  The file may not actually be updated until B<msync>(2)  or "
#| "B<munmap>()  is called."
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"mapping the same region, and (in the case of file-backed mappings)  are "
"carried through to the underlying file.  (To precisely control when updates "
"are carried through to the underlying file requires the use of B<msync>(2).)"
msgstr ""
"このマッピングを共有する。 マッピングに対する更新はこのファイルをマッピングし"
"ている他のプロセス から見える。更新はマッピング元のファイルを通じて伝えられ"
"る。 ただし、ファイルの実際の更新は B<msync>(2)  または B<munmap>()  が呼ばれ"
"るまで行われないこともある。"

#. type: TP
#: build/C/man2/mmap.2:140
#, no-wrap
msgid "B<MAP_SHARED_VALIDATE> (since Linux 4.15)"
msgstr "B<MAP_SHARED_VALIDATE> (Linux 4.15 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:157
msgid ""
"This flag provides the same behavior as B<MAP_SHARED> except that "
"B<MAP_SHARED> mappings ignore unknown flags in I<flags>.  By contrast, when "
"creating a mapping using B<MAP_SHARED_VALIDATE>, the kernel verifies all "
"passed flags are known and fails the mapping with the error B<EOPNOTSUPP> "
"for unknown flags.  This mapping type is also required to be able to use "
"some mapping flags (e.g., B<MAP_SYNC>)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:157
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr "B<MAP_PRIVATE>"

#. type: Plain text
#: build/C/man2/mmap.2:166
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""
"プライベートな copy-on-write (書き込み時コピー) マップを生成する。 マッピング"
"に対する更新は同じファイルをマッピングしている他のプロセス には見えず、更新が"
"マッピング元のファイルを通じて伝えられることもない。 B<mmap>()  の呼び出し後"
"にマッピング元のファイルに対して行われた変更が、 マップ領域に反映されるかどう"
"かは規定されていない。"

#. type: Plain text
#: build/C/man2/mmap.2:174
msgid ""
"Both B<MAP_SHARED> and B<MAP_PRIVATE> are described in POSIX.1-2001 and "
"POSIX.1-2008.  B<MAP_SHARED_VALIDATE> is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:177
msgid ""
"In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""
"さらに、以下の値のうち 0 個以上をビット毎の論理和 (OR) で I<flags> に指定する"
"ことができる。"

#. type: TP
#: build/C/man2/mmap.2:177
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr "B<MAP_32BIT> (Linux 2.4.20, 2.6 以降)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: build/C/man2/mmap.2:193
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2\\ GB of memory, "
"so as to improve context-switch performance on some early 64-bit "
"processors.  Modern x86-64 processors no longer have this performance "
"problem, so use of this flag is not required on those systems.  The "
"B<MAP_32BIT> flag is ignored when B<MAP_FIXED> is set."
msgstr "マッピングをプロセスのアドレス空間の先頭 2 ギガバイト以内に配置する。 このフラグがサポートされているのは x86-64 アーキテクチャー上の 64 ビットプログラムのみである。 このフラグが追加されたのは、スレッドのスタックをメモリーの先頭 2\\ GB 以内の どこかに割り当てることで、初期のいくつかの 64 ビットプロセッサにおける コンテキストスイッチの性能問題を改善するためである。 最近の x86-64 プロセッサではこの性能問題はもはや存在せず、 そのようなシステムではこのフラグを使用する必要はない。 B<MAP_FIXED> がセットされている場合は、 B<MAP_32BIT> フラグは無視される。"

#. type: TP
#: build/C/man2/mmap.2:193
#, no-wrap
msgid "B<MAP_ANON>"
msgstr "B<MAP_ANON>"

#. type: Plain text
#: build/C/man2/mmap.2:198
msgid ""
"Synonym for B<MAP_ANONYMOUS>; provided for compatibility with other "
"implementations."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:198
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr "B<MAP_ANONYMOUS>"

#.  See the pgoff overflow check in do_mmap().
#.  See the offset check in sys_mmap in arch/x86/kernel/sys_x86_64.c.
#. type: Plain text
#: build/C/man2/mmap.2:223
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> argument is ignored; however, some implementations require "
"I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  is specified, and "
"portable applications should ensure this.  The I<offset> argument should be "
"zero.  The use of B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is "
"supported on Linux only since kernel 2.4."
msgstr "マッピングはどのファイルとも関連付けされない。 マッピングの内容は 0 で初期化される。 引き数 I<fd> は無視される。 ただし、実装によっては B<MAP_ANONYMOUS> (もしくは B<MAP_ANON>)  が指定された場合、 I<fd> を -1 にする必要があり、 移植性が必要なアプリケーションでは必ず I<fd> を -1 にすべきである。 I<offset> 引き数は 0 にすべきである。 B<MAP_ANONYMOUS> と B<MAP_SHARED> を組み合わせての利用は カーネル 2.4 以降の Linux でのみサポートされている。"

#. type: TP
#: build/C/man2/mmap.2:223
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr "B<MAP_DENYWRITE>"

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: build/C/man2/mmap.2:231
msgid ""
"This flag is ignored.  (Long ago\\(emLinux 2.0 and earlier\\(emit signaled "
"that attempts to write to the underlying file should fail with B<ETXTBSY>.  "
"But this was a source of denial-of-service attacks.)"
msgstr "このフラグは無視される (ずっと前は \\(em Linux 2.0 以前 \\(em 、マップ元のファイルへの書き込みを行おうとすると、エラー B<ETXTBSY> で失敗するようにシグナルが設定されていたが、これは denial-of-service (サービス拒否) 攻撃の原因となった)。"

#. type: TP
#: build/C/man2/mmap.2:231
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr "B<MAP_EXECUTABLE>"

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: build/C/man2/mmap.2:239
msgid "This flag is ignored."
msgstr "このフラグは無視される。"

#. type: TP
#: build/C/man2/mmap.2:239
#, no-wrap
msgid "B<MAP_FILE>"
msgstr "B<MAP_FILE>"

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: build/C/man2/mmap.2:245
msgid "Compatibility flag.  Ignored."
msgstr "互換性のためのフラグ。無視される。"

#. type: TP
#: build/C/man2/mmap.2:245
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr "B<MAP_FIXED>"

#. type: Plain text
#: build/C/man2/mmap.2:263
#, fuzzy
#| msgid ""
#| "Don't interpret I<addr> as a hint: place the mapping at exactly that "
#| "address.  I<addr> must be a multiple of the page size.  If the memory "
#| "region specified by I<addr> and I<len> overlaps pages of any existing "
#| "mapping(s), then the overlapped part of the existing mapping(s) will be "
#| "discarded.  If the specified address cannot be used, B<mmap>()  will "
#| "fail.  Because requiring a fixed address for a mapping is less portable, "
#| "the use of this option is discouraged."
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be suitably aligned: for most architectures a "
"multiple of the page size is sufficient; however, some architectures may "
"impose additional restrictions.  If the memory region specified by I<addr> "
"and I<len> overlaps pages of any existing mapping(s), then the overlapped "
"part of the existing mapping(s) will be discarded.  If the specified address "
"cannot be used, B<mmap>()  will fail."
msgstr ""
"I<addr> をアドレスのヒントとして使用するのではなく、 I<addr> で指定されたアド"
"レスをそのまま使用してマッピングを配置する。 I<addr> はページサイズの倍数でな"
"ければならない。 I<addr> と I<len> で指定されたメモリー領域が既存のマッピング"
"のページと重なる場合、 既存のマッピングの重なった部分は捨てられる。 もし指定"
"されたアドレスが使用できない場合、 B<mmap>()  は失敗する。 マッピングに対して"
"固定アドレスを要求するのは移植性の面で劣るので、 このオプションは使用しないこ"
"とを推奨する。"

#. type: Plain text
#: build/C/man2/mmap.2:271
msgid ""
"Software that aspires to be portable should use the B<MAP_FIXED> flag with "
"care, keeping in mind that the exact layout of a process's memory mappings "
"is allowed to change significantly between kernel versions, C library "
"versions, and operating system releases.  I<Carefully read the discussion of "
"this flag in NOTES!>"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:271
#, no-wrap
msgid "B<MAP_FIXED_NOREPLACE> (since Linux 4.17)"
msgstr "B<MAP_FIXED_NOREPLACE> (Linux 4.17 以降)"

#.  commit a4ff8e8620d3f4f50ac4b41e8067b7d395056843
#. type: Plain text
#: build/C/man2/mmap.2:287
msgid ""
"This flag provides behavior that is similar to B<MAP_FIXED> with respect to "
"the I<addr> enforcement, but differs in that B<MAP_FIXED_NOREPLACE> never "
"clobbers a preexisting mapped range.  If the requested range would collide "
"with an existing mapping, then this call fails with the error B<EEXIST.> "
"This flag can therefore be used as a way to atomically (with respect to "
"other threads) attempt to map an address range: one thread will succeed; all "
"others will report failure."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:297
msgid ""
"Note that older kernels which do not recognize the B<MAP_FIXED_NOREPLACE> "
"flag will typically (upon detecting a collision with a preexisting mapping)  "
"fall back to a \"non-B<MAP_FIXED>\" type of behavior: they will return an "
"address that is different from the requested address.  Therefore, backward-"
"compatible software should check the returned address against the requested "
"address."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:297
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr "B<MAP_GROWSDOWN>"

#. type: Plain text
#: build/C/man2/mmap.2:311
msgid ""
"This flag is used for stacks.  It indicates to the kernel virtual memory "
"system that the mapping should extend downward in memory.  The return "
"address is one page lower than the memory area that is actually created in "
"the process's virtual address space.  Touching an address in the \"guard\" "
"page below the mapping will cause the mapping to grow by a page.  This "
"growth can be repeated until the mapping grows to within a page of the high "
"end of the next lower mapping, at which point touching the \"guard\" page "
"will result in a B<SIGSEGV> signal."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:311
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr "B<MAP_HUGETLB> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:317
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information, as "
"well as NOTES, below."
msgstr "\"huge page\" を使ってマッピングを割り当てる。詳しい情報は、Linux カーネルソースの I<Documentation/admin-guide/vm/hugetlbpage.txt> を参照。下記の「注意」も参照。"

#. type: TP
#: build/C/man2/mmap.2:317
#, no-wrap
msgid "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (since Linux 3.8)"
msgstr "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (Linux 3.8 以降)"

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: build/C/man2/mmap.2:324
msgid ""
"Used in conjunction with B<MAP_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:334
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<MAP_HUGE_SHIFT>.  (A value of zero in this bit field provides the default "
"huge page size; the default huge page size can be discovered via the "
"I<Hugepagesize> field exposed by I</proc/meminfo>.)  Thus, the above two "
"constants are defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:339
#, no-wrap
msgid ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:345
msgid ""
"The range of huge page sizes that are supported by the system can be "
"discovered by listing the subdirectories in I</sys/kernel/mm/hugepages>."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:345
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr "B<MAP_LOCKED> (Linux 2.5.37 以降)"

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: build/C/man2/mmap.2:366
msgid ""
"Mark the mapped region to be locked in the same way as B<mlock>(2).  This "
"implementation will try to populate (prefault) the whole range but the "
"B<mmap>()  call doesn't fail with B<ENOMEM> if this fails.  Therefore major "
"faults might happen later on.  So the semantic is not as strong as "
"B<mlock>(2).  One should use B<mmap>()  plus B<mlock>(2)  when major faults "
"are not acceptable after the initialization of the mapping.  The "
"B<MAP_LOCKED> flag is ignored in older kernels."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:366
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr "B<MAP_NONBLOCK> (Linux 2.5.46 以降)"

#.  commit 54cb8821de07f2ffcd28c380ce9b93d5784b40d7
#. type: Plain text
#: build/C/man2/mmap.2:383
msgid ""
"This flag is meaningful only in conjunction with B<MAP_POPULATE>.  Don't "
"perform read-ahead: create page tables entries only for pages that are "
"already present in RAM.  Since Linux 2.6.23, this flag causes "
"B<MAP_POPULATE> to do nothing.  One day, the combination of B<MAP_POPULATE> "
"and B<MAP_NONBLOCK> may be reimplemented."
msgstr "このフラグは B<MAP_POPULATE> と組み合わせた場合のみ意味を持つ。 read-ahead (前もって読み込むこと) を実行しない。 単に、すでに RAM 上に存在するページに対してのみページテーブルエントリーを作成する。 Linux 2.6.23 以降では、このフラグは B<MAP_POPULATE> に何の影響も与えない。 いつか B<MAP_POPULATE> と B<MAP_NONBLOCK> を組み合わせた場合の動作は実装し直されるかもしれない。"

#. type: TP
#: build/C/man2/mmap.2:383
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr "B<MAP_NORESERVE>"

#. type: Plain text
#: build/C/man2/mmap.2:398
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5).  In kernels before 2.6, this flag had "
"effect only for private writable mappings."
msgstr ""
"このマッピングに対するスワップ空間の予約を行わない。 スワップ空間を予約した場"
"合は、このマッピングの変更が必ず可能なことが 保証される。予約を行わなかった場"
"合、物理メモリーに空きがないと 書き込み時に B<SIGSEGV> エラーを受け取ることが"
"ある。 B<proc>(5)  の I</proc/sys/vm/overcommit_memory> ファイルについての議"
"論も参照。 バージョン 2.6 より前のカーネルでは、このフラグは書き込み可能な プ"
"ライベートマッピングについてのみ効果があった。"

#. type: TP
#: build/C/man2/mmap.2:398
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr "B<MAP_POPULATE> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:405
#, fuzzy
#| msgid ""
#| "Populate (prefault) page tables for a mapping.  For a file mapping, this "
#| "causes read-ahead on the file.  Later accesses to the mapping will not be "
#| "blocked by page faults.  B<MAP_POPULATE> is supported for private "
#| "mappings only since Linux 2.6.23."
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  This will help to reduce blocking on page "
"faults later.  B<MAP_POPULATE> is supported for private mappings only since "
"Linux 2.6.23."
msgstr ""
"マッピング用のページテーブルを配置 (populate) する ファイルマッピングの場合に"
"は、これによりファイルが先読み (read-ahead)  が行われる。この以後は、マッピン"
"グに対するアクセスがページフォールトで ブロックされることがなくなる。 Linux "
"2.6.23 以降でのみプライベートマッピングについて B<MAP_POPULATE> がサポートさ"
"れている。"

#. type: TP
#: build/C/man2/mmap.2:405
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr "B<MAP_STACK> (Linux 2.6.27 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:409
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack."
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: build/C/man2/mmap.2:425
msgid ""
"This flag is currently a no-op on Linux.  However, by employing this flag, "
"applications can ensure that they transparently obtain support if the flag "
"is implemented in the future.  Thus, it is used in the glibc threading "
"implementation to allow for the fact that some architectures may (later) "
"require special treatment for stack allocations.  A further reason to employ "
"this flag is portability: B<MAP_STACK> exists (and has an effect) on some "
"other systems (e.g., some of the BSDs)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:425
#, no-wrap
msgid "B<MAP_SYNC> (since Linux 4.15)"
msgstr "B<MAP_SYNC> (Linux 4.15 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:438
msgid ""
"This flag is available only with the B<MAP_SHARED_VALIDATE> mapping type; "
"mappings of type B<MAP_SHARED> will silently ignore this flag.  This flag is "
"supported only for files supporting DAX (direct mapping of persistent "
"memory).  For other files, creating a mapping with this flag results in an "
"B<EOPNOTSUPP> error."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:446
msgid ""
"Shared file mappings with this flag provide the guarantee that while some "
"memory is mapped writable in the address space of the process, it will be "
"visible in the same file at the same offset even after the system crashes or "
"is rebooted.  In conjunction with the use of appropriate CPU instructions, "
"this provides users of such mappings with a more efficient way of making "
"data modifications persistent."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:446
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr "B<MAP_UNINITIALIZED> (Linux 2.6.33 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:456
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices (i."
"e., devices where one has complete control of the contents of user memory)."
msgstr ""
"無名ページ (anonymous page) のクリアを行わない。このフラグは組み込みデバイ"
"ス\n"
"での性能向上を目的に作られてものである。カーネルの設定で\n"
"B<CONFIG_MMAP_ALLOW_UNINITIALIZED> オプションが有効になっている場合のみ、\n"
"このフラグは効果を持つ。\n"
"セキュリティ面の考慮から、このオプションは通常組み込みデバイス (すなわち、\n"
"ユーザーメモリーの内容を完全に制御化におけるデバイス) においてのみ有効にされ"
"る。"

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX may add MAP_ANON in the future
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=850
#. type: Plain text
#: build/C/man2/mmap.2:468
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001 and "
"POSIX.1-2008.  However, most systems also support B<MAP_ANONYMOUS> (or its "
"synonym B<MAP_ANON>)."
msgstr "上記のフラグの中では、 B<MAP_FIXED> だけが POSIX.1-2001 と POSIX.1-2008 で規定されている。 しかしながら、ほとんどのシステムで B<MAP_ANONYMOUS> (またはその同義語である B<MAP_ANON>)  もサポートされている。"

#. type: SS
#: build/C/man2/mmap.2:468
#, no-wrap
msgid "munmap()"
msgstr "munmap()"

#. type: Plain text
#: build/C/man2/mmap.2:478
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""
"システムコール B<munmap>()  は指定されたアドレス範囲のマップを消去し、 これ以"
"降のその範囲内へのメモリー参照は不正となる。 この領域は、プロセスが終了したと"
"きにも自動的にアンマップされる。 一方、ファイルディスクリプターをクローズして"
"も、この領域はアンマップされない。"

#. type: Plain text
#: build/C/man2/mmap.2:490
#, fuzzy
#| msgid ""
#| "The address I<addr> must be a multiple of the page size.  All pages "
#| "containing a part of the indicated range are unmapped, and subsequent "
#| "references to these pages will generate B<SIGSEGV>.  It is not an error "
#| "if the indicated range does not contain any mapped pages."
msgid ""
"The address I<addr> must be a multiple of the page size (but I<length> need "
"not be).  All pages containing a part of the indicated range are unmapped, "
"and subsequent references to these pages will generate B<SIGSEGV>.  It is "
"not an error if the indicated range does not contain any mapped pages."
msgstr ""
"I<addr> アドレスはページサイズの整数倍でなければならない。指定された範囲の一"
"部分を 含む全てのページはアンマップされ、これ以降にこれらのページへの参照があ"
"ると B<SIGSEGV> が発生する。 指定した範囲内にマップされたページが一つも含まれ"
"ていない場合でも エラーにならない。"

#. type: Plain text
#: build/C/man2/mmap.2:501
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set to indicate the cause of the error."
msgstr "成功した場合は B<mremap>() はマッピングされた領域へのポインターを返す。 エラーの場合は B<MAP_FAILED> (すなわち I<(void\\ *)\\ -1>) が返され、 I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man2/mmap.2:509
msgid ""
"On success, B<munmap>()  returns 0.  On failure, it returns -1, and I<errno> "
"is set to indicate the cause of the error (probably to B<EINVAL>)."
msgstr "B<munmap>()  は、成功すると 0 を返す。 エラーの場合、-1 を返し、 I<errno> にエラーの原因を示す値を設定する (多くの場合 B<EINVAL> である)。"

#. type: Plain text
#: build/C/man2/mmap.2:528
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""
"以下のいずれかの場合。 ファイルディスクリプターの参照先が通常のファイルではな"
"い (non-regular file) 。 ファイルマッピングを要求したが I<fd> は読み込み用に"
"オープンされていない。 B<MAP_SHARED> を要求して B<PROT_WRITE> をセットしたが "
"I<fd> は読み書きモード (B<O_RDWR>)  でオープンされていない、 B<PROT_WRITE> を"
"セットしたが、ファイルは追加 (append) 専用である。"

#. type: Plain text
#: build/C/man2/mmap.2:532
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""
"ファイルがロックされている。またはロックされているメモリーが多すぎる "
"(B<setrlimit>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/mmap.2:538
msgid ""
"I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""
"I<fd> が有効なファイルディスクリプター (file descriptor) ではない (かつ "
"B<MAP_ANONYMOUS> がセットされていない)。"

#. type: TP
#: build/C/man2/mmap.2:538 build/C/man3/shm_open.3:201
#: build/C/man2/shmget.2:230
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/mmap.2:548
msgid ""
"B<MAP_FIXED_NOREPLACE> was specified in I<flags>, and the range covered by "
"I<addr> and I<length> clashes with an existing mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:556
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""
"I<addr> か I<length> か I<offset> が適切でない (例えば、大きすぎるとか、ペー"
"ジ境界にアラインメントされていない)。"

#. type: Plain text
#: build/C/man2/mmap.2:561
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr "(Linux 2.6.12 以降)  I<length> が 0 であった。"

#. type: Plain text
#: build/C/man2/mmap.2:569
msgid ""
"I<flags> contained none of B<MAP_PRIVATE>, B<MAP_SHARED> or "
"B<MAP_SHARED_VALIDATE>."
msgstr "I<flags> に B<MAP_PRIVATE>, B<MAP_SHARED>, B<MAP_SHARED_VALIDATE> のいずれもが含まれていなかった。"

#. type: TP
#: build/C/man2/mmap.2:569 build/C/man3/shm_open.3:228
#: build/C/man2/shmget.2:253 build/C/man2/memfd_create.2:193
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/mmap.2:577 build/C/man3/shm_open.3:231
#: build/C/man2/shmget.2:257 build/C/man2/memfd_create.2:196
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "システム全体でオープンされているファイルの総数が上限に達した。"

#. type: Plain text
#: build/C/man2/mmap.2:581
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr ""
"指定されたファイルが置かれているファイルシステムがメモリーマッピングをサポー"
"ト していない。"

#. type: Plain text
#: build/C/man2/mmap.2:584
msgid "No memory is available."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:592
msgid ""
"The process's maximum number of mappings would have been exceeded.  This "
"error can also occur for B<munmap>(), when unmapping a region in the middle "
"of an existing mapping, since this results in two smaller mappings on either "
"side of the region being unmapped."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:600
msgid ""
"(since Linux 4.7)  The process's B<RLIMIT_DATA> limit, described in "
"B<getrlimit>(2), would have been exceeded."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:600 build/C/man2/shmctl.2:433
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: build/C/man2/mmap.2:612
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""
"32 ビットアーキテクチャーで large file 拡張を使っている場合 (つまり 64 ビット"
"の I<off_t> を使う場合)、 I<length> で使うページ数と I<offset> で使うページ数"
"を足した値は I<unsigned long> (32 ビット) を超えてしまう (オーバーフローして"
"しまう) 場合がある。"

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: build/C/man2/mmap.2:621
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr ""
"I<prot> 引き数は B<PROT_EXEC> を行うように指定されているが、 no-exec でマウン"
"トされたファイルシステム上のファイルに マップ領域が対応している。"

#. type: Plain text
#: build/C/man2/mmap.2:631
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""
"B<MAP_DENYWRITE> がセットされているが I<fd> で指定されているオブジェクトは書"
"き込み用に開かれている。"

#. type: Plain text
#: build/C/man2/mmap.2:633
msgid "Use of a mapped region can result in these signals:"
msgstr "マップ領域を利用する際に、以下のシグナルが発生することがある:"

#. type: TP
#: build/C/man2/mmap.2:633
#, no-wrap
msgid "B<SIGSEGV>"
msgstr "B<SIGSEGV>"

#. type: Plain text
#: build/C/man2/mmap.2:636
msgid "Attempted write into a region mapped as read-only."
msgstr "読み込み専用で mmap された領域へ書き込みを行おうとした。"

#. type: TP
#: build/C/man2/mmap.2:636
#, no-wrap
msgid "B<SIGBUS>"
msgstr "B<SIGBUS>"

#. type: Plain text
#: build/C/man2/mmap.2:643
msgid ""
"Attempted access to a page of the buffer that lies beyond the end of the "
"mapped file.  For an explanation of the treatment of the bytes in the page "
"that corresponds to the end of a mapped file that is not a multiple of the "
"page size, see NOTES."
msgstr ""

#. type: tbl table
#: build/C/man2/mmap.2:654
#, no-wrap
msgid ""
"B<mmap>(),\n"
"B<munmap>()"
msgstr ""
"B<mmap>(),\n"
"B<munmap>()"

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: build/C/man2/mmap.2:660
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mmap.2:674
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2), and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<mmap>(), B<msync>(2)  B<munmap>()  が利用可能な POSIX システムでは、 "
"B<_POSIX_MAPPED_FILES> は E<lt>unistd.hE<gt> で 0 より大きな値に定義される "
"(B<sysconf>(3)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/mmap.2:680
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""
"B<mmap>()  によってマップされたメモリーの属性は B<fork>(2)  の際に継承され"
"る。"

#. type: Plain text
#: build/C/man2/mmap.2:690
#, fuzzy
#| msgid ""
#| "A file is mapped in multiples of the page size.  For a file that is not a "
#| "multiple of the page size, the remaining memory is zeroed when mapped, "
#| "and writes to that region are not written out to the file.  The effect of "
#| "changing the size of the underlying file of a mapping on the pages that "
#| "correspond to added or removed regions of the file is unspecified."
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining bytes in the partial page at the "
"end of the mapping are zeroed when mapped, and modifications to that region "
"are not written out to the file.  The effect of changing the size of the "
"underlying file of a mapping on the pages that correspond to added or "
"removed regions of the file is unspecified."
msgstr ""
"ファイルはページサイズの整数倍の領域にマップされる。サイズがページサイズの 整"
"数倍でないファイルの場合、マップ時に残りの領域は 0 で埋められ、この領域へ 書"
"きこみを行ってもファイルに書き出されることはない。マッピングを行った元 ファイ"
"ルのサイズを変更した場合、元ファイルの追加されたり削除された領域に対応 する"
"マップされたページに対してどのような影響があるかは規定されていない。"

#. type: Plain text
#: build/C/man2/mmap.2:703
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""
"(i386 などの) いくつかのアーキテクチャーでは、 B<PROT_WRITE> をセットすると、"
"暗黙のうちに B<PROT_READ> がセットされる。 B<PROT_READ> をセットした際に暗黙"
"のうちに B<PROT_EXEC> がセットされるかどうかは、アーキテクチャー依存である。 "
"移植性を考慮したプログラムでは、 新規にマップした領域でコードを実行したい場合"
"は、常に B<PROT_EXEC> をセットすべきである。"

#. type: Plain text
#: build/C/man2/mmap.2:718
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 (NULL)."
msgstr ""
"マッピングを作成する移植性のある方法は、 I<addr> に 0 (NULL) を指定し、 "
"I<flags> から B<MAP_FIXED> を外すことである。 この場合、システムがマッピング"
"用のアドレスの選択を行う。 アドレスは既存のマッピングと衝突しないように、 か"
"つ 0 にならないように選択される。 B<MAP_FIXED> フラグが指定され、かつ "
"I<addr> が 0 (NULL)  の場合には、マップされるアドレスが 0 (NULL) になる。"

#. type: Plain text
#: build/C/man2/mmap.2:751
#, fuzzy
#| msgid ""
#| "Certain I<flags> constants are defined only if either B<_BSD_SOURCE> or "
#| "B<_SVID_SOURCE> is defined.  (Requiring B<_GNU_SOURCE> also suffices, and "
#| "requiring that macro specifically would have been more logical, since "
#| "these flags are all Linux-specific.)  The relevant flags are: "
#| "B<MAP_32BIT>, B<MAP_ANONYMOUS> (and the synonym B<MAP_ANON>), "
#| "B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, "
#| "B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, "
#| "B<MAP_POPULATE>, and B<MAP_STACK>."
msgid ""
"Certain I<flags> constants are defined only if suitable feature test macros "
"are defined (possibly by default): B<_DEFAULT_SOURCE> with glibc 2.19 or "
"later; or B<_BSD_SOURCE> or B<_SVID_SOURCE> in glibc 2.19 and earlier.  "
"(Employing B<_GNU_SOURCE> also suffices, and requiring that macro "
"specifically would have been more logical, since these flags are all Linux-"
"specific.)  The relevant flags are: B<MAP_32BIT>, B<MAP_ANONYMOUS> (and the "
"synonym B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, "
"B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, "
"B<MAP_NORESERVE>, B<MAP_POPULATE>, and B<MAP_STACK>."
msgstr ""
"特定の I<flags> 定数は B<_BSD_SOURCE> か B<_SVID_SOURCE> のいずれかが定義され"
"た場合にのみ定義される。 (B<_GNU_SOURCE> も定義されている必要がある。これらの"
"フラグはすべて Linux 固有のものなので、 特に B<_GNU_SOURCE> を必要とする点は"
"もっと論理的に決められるべきであった。) 関係するフラグは B<MAP_32BIT>, "
"B<MAP_ANONYMOUS> (とその同義語の B<MAP_ANON>), B<MAP_DENYWRITE>, "
"B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, "
"B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE>, "
"B<MAP_STACK> である。"

#. type: Plain text
#: build/C/man2/mmap.2:756
msgid ""
"An application can determine which pages of a mapping are currently resident "
"in the buffer/page cache using B<mincore>(2)."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:756
#, no-wrap
msgid "Using MAP_FIXED safely"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:768
msgid ""
"The only safe use for B<MAP_FIXED> is where the address range specified by "
"I<addr> and I<length> was previously reserved using another mapping; "
"otherwise, the use of B<MAP_FIXED> is hazardous because it forcibly removes "
"preexisting mappings, making it easy for a multithreaded process to corrupt "
"its own address space."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:796
msgid ""
"For example, suppose that thread A looks through I</proc/E<lt>pidE<gt>/maps> "
"in order to locate an unused address range that it can map using "
"B<MAP_FIXED>, while thread B simultaneously acquires part or all of that "
"same address range.  When thread A subsequently employs B<mmap(MAP_FIXED)>, "
"it will effectively clobber the mapping that thread B created.  In this "
"scenario, thread B need not create a mapping directly; simply making a "
"library call that, internally, uses B<dlopen>(3)  to load some other shared "
"library, will suffice.  The B<dlopen>(3)  call will map the library into the "
"process's address space.  Furthermore, almost any library call may be "
"implemented in a way that adds memory mappings to the address space, either "
"with this technique, or by simply allocating memory.  Examples include "
"B<brk>(2), B<malloc>(3), B<pthread_create>(3), and the PAM libraries E<.UR "
"http://www.linux-pam.org> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:803
msgid ""
"Since Linux 4.17, a multithreaded program can use the B<MAP_FIXED_NOREPLACE> "
"flag to avoid the hazard described above when attempting to create a mapping "
"at a fixed address that has not been reserved by a preexisting mapping."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:803
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr "ファイルと関連付けられたマッピングに対するタイムスタンプの更新"

#. type: Plain text
#: build/C/man2/mmap.2:810
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""
"ファイルと関連付けられたマッピングの場合、マッピングされたファイルの "
"I<st_atime> フィールドは、 B<mmap>()  されてからアンマップ (unmap) されるまで"
"の間に更新されることがある。 それまでに更新が行われていなければ、マップされた"
"ページへの最初の参照があった 際に更新される。"

#. type: Plain text
#: build/C/man2/mmap.2:828
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""
"B<PROT_WRITE> と B<MAP_SHARED> の両方を指定してマップされたファイルの場合、書"
"き込みがあると、 I<st_ctime> と I<st_mtime> の両フィールドは、マップされた領"
"域への書き込みより後で、 B<MS_SYNC> または B<MS_ASYNC> フラグを指定して "
"B<msync>(2)  が呼ばれる前までに更新される。"

#. type: SS
#: build/C/man2/mmap.2:828
#, no-wrap
msgid "Huge page (Huge TLB) mappings"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:835
msgid ""
"For mappings that employ huge pages, the requirements for the arguments of "
"B<mmap>()  and B<munmap>()  differ somewhat from the requirements for "
"mappings that use the native system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:843
msgid ""
"For B<mmap>(), I<offset> must be a multiple of the underlying huge page "
"size.  The system automatically aligns I<length> to be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:851
msgid ""
"For B<munmap>(), I<addr>, and I<length> must both be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:851 build/C/man2/posix_fadvise.2:189
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: build/C/man2/mmap.2:866
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by "
"B<mmap2>(2), and nowadays the glibc B<mmap>()  wrapper function invokes "
"B<mmap2>(2)  with a suitably adjusted value for I<offset>."
msgstr ""
"このページでは glibc の B<mmap>() のラッパー関数が提供するインターフェース"
"に\n"
"ついて説明している。元々は、この関数は同じ名前のシステムコールを起動してい"
"た。\n"
"カーネル 2.4 以降、このシステムコールは B<mmap2>(2) に取って代わられ、現在\n"
"では、 glibc の B<mmap>() のラッパー関数は I<offset> を適切に調整してから\n"
"B<mmap2>(2) を起動する。"

#. type: Plain text
#: build/C/man2/mmap.2:871
msgid ""
"On Linux, there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""
"Linux においては、上記の B<MAP_NORESERVE> で述べられているような保証はない。 "
"デフォルトでは、システムがメモリーを使い切った場合には、 どのプロセスがいつ強"
"制終了されるか分からないからである。"

#. type: Plain text
#: build/C/man2/mmap.2:878
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""
"2.6.7 より前のカーネルでは、 I<prot> に B<PROT_NONE> が指定された場合にの"
"み、 B<MAP_POPULATE> フラグが効力を持つ。"

#. type: Plain text
#: build/C/man2/mmap.2:893
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""
"SUSv3 では、 I<length> が 0 の場合、 B<mmap>()  は失敗すると規定されている。"
"しかしながら、2.6.12 より前のカーネルでは、 この場合に B<mmap>()  は成功して"
"いた (マッピングは作成されず、 I<addr> が返されていた)。 カーネル 2.6.12 以降"
"では、 B<mmap>()  はエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/mmap.2:910
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on B<tmpfs>(5)  (for "
"example, when using the POSIX shared memory interface documented in "
"B<shm_overview>(7))."
msgstr "POSIX では、 システムはオブジェクト末尾の部分ページを常に 0 で埋め、 末尾より後ろのオブジェクトを決して変更してはならない、と規定している。 Linux では、 オブジェクト末尾より後ろの部分ページにデータを書き込んだ場合、 そのファイルをクローズしてアンマップした後であってもページキャッシュにデータが残り続け、 データがファイル自体に書き込まれていなくても、 それ以降のマッピングで変更された内容が見える可能性がある。 いくつかの場合では、 アンマップを行う前に B<msync>(2) を呼び出すことで、 この状況を修正することができる。 しかし、 これは B<tmpfs>(5) では機能しない (例えば、 B<shm_overview>(7) で説明されている POSIX 共有メモリーインターフェースを使った場合)。"

#.  FIXME . Add an example here that uses an anonymous shared region for
#.  IPC between parent and child.
#. type: Plain text
#: build/C/man2/mmap.2:921
msgid ""
"The following program prints part of the file specified in its first command-"
"line argument to standard output.  The range of bytes to be printed is "
"specified via offset and length values in the second and third command-line "
"arguments.  The program creates a memory mapping of the required pages of "
"the file and then uses B<write>(2)  to output the desired bytes."
msgstr ""
"以下のプログラムは、一番目のコマンドライン引き数で指定された ファイルの一部を"
"標準出力に表示する。 表示する範囲は、二番目、三番目のコマンドライン引き数で渡"
"される オフセットと長さで指定される。 このプログラムは、指定されたファイルの"
"必要なページのメモリー マッピングを作成し、 B<write>(2)  を使って所望のバイト"
"を出力する。"

#. type: Plain text
#: build/C/man2/mmap.2:929
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/mmap.2:932 build/C/man2/mprotect.2:317
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/mmap.2:942
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/mmap.2:947
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:951
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:954
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:958
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & \\(ti(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & \\(ti(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"

#. type: Plain text
#: build/C/man2/mmap.2:963
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:969
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"

#. type: Plain text
#: build/C/man2/mmap.2:973
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:978
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:983
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:987
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:990
#, no-wrap
msgid ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"
msgstr ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"

#. type: Plain text
#: build/C/man2/mmap.2:1010
msgid ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"
msgstr "B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), B<shm_open>(3), B<shm_overview>(7)"

#. type: Plain text
#: build/C/man2/mmap.2:1017
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""
"B<proc>(5) の I</proc/[pid]/maps>, I</proc/[pid]/map_files>, I</proc/[pid]/"
"smaps> の説明。"

#. type: Plain text
#: build/C/man2/mmap.2:1022 build/C/man2/msync.2:154
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."
msgstr "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr "MMAP2"

#. type: Plain text
#: build/C/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr "mmap2 - ファイルやデバイスをメモリーにマップする"

#. type: Plain text
#: build/C/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<            int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"

#. type: Plain text
#: build/C/man2/mmap2.2:43
msgid ""
"This is probably not the system call that you are interested in; instead, "
"see B<mmap>(2), which describes the glibc wrapper function that invokes this "
"system call."
msgstr ""
"これはおそらくあなたが興味のあるシステムコールではないだろう。代わりに\n"
"B<mmap>(2) を見るとよい。そのページにはこのシステムコールを起動する glibc "
"の\n"
"ラッパー関数についての説明がある。"

#. type: Plain text
#: build/C/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in 4096-"
"byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""
"B<mmap2>() システムコールは B<mmap>(2) と同じインターフェースを提供する。た"
"だ\n"
"し、最後の引き数には、ファイルのオフセットを (B<mmap>(2) が行っている、バイ"
"ト\n"
"単位ではなく) 4096 バイトを単位として指定する。 これにより、32 ビットの\n"
"I<off_t> を使うアプリケーションで (2^44 バイトまでの) 大きなファイルをマッ"
"プ\n"
"できるようになる。"

#. type: Plain text
#: build/C/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<mmap2>()  はマップされた領域へのポインターを返す。 エラーの"
"場合は -1 が返されて、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/mmap2.2:65
msgid "Problem with getting the data from user space."
msgstr "ユーザー空間からデータを取得するときに問題があった。"

#. type: Plain text
#: build/C/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset\\ *\\ "
"4096> is not a multiple of the system page size."
msgstr ""
"(ページサイズが 4096 バイトでないプラットフォームにおいて)  I<offset\\ *\\ "
"4096> がシステムのページサイズの倍数ではない。"

#. type: Plain text
#: build/C/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr "B<mmap2>() は B<mmap>(2) に載っているエラーを返すこともある。"

#. type: Plain text
#: build/C/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr "B<mmap2>()  は、Linux 2.3.31 以降で使用可能である。"

#. type: Plain text
#: build/C/man2/mmap2.2:79 build/C/man2/subpage_prot.2:98
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/mmap2.2:86
msgid ""
"On architectures where this system call is present, the glibc B<mmap>()  "
"wrapper function invokes this system call rather than the B<mmap>(2)  system "
"call."
msgstr ""
"このシステムコールが存在するアーキテクチャーでは、glibc の B<mmap>()  のラッ"
"パー関数は、 B<mmap>(2)  システムコールではなく、このシステムコール "
"(B<mmap2>(2))  を起動する。"

#. type: Plain text
#: build/C/man2/mmap2.2:88
msgid "This system call does not exist on x86-64."
msgstr "このシステムコールは x86-64 には存在しない。"

#.  ia64 can have page sizes ranging from 4 kB to 64 kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: build/C/man2/mmap2.2:95
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""
"ia64 では、 I<offset> の単位は、実際にはシステムのページサイズであり、 4096 "
"バイトではない。"

#. type: Plain text
#: build/C/man2/mmap2.2:101
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""
"B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"

#. type: TH
#: build/C/man2/mprotect.2:33
#, no-wrap
msgid "MPROTECT"
msgstr "MPROTECT"

#. type: Plain text
#: build/C/man2/mprotect.2:36
msgid "mprotect, pkey_mprotect - set protection on a region of memory"
msgstr "mprotect, pkey_mprotect - メモリー領域の保護を設定する"

#. type: Plain text
#: build/C/man2/mprotect.2:41
#, no-wrap
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"

#. type: Plain text
#: build/C/man2/mprotect.2:44 build/C/man2/pkey_alloc.2:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mprotect.2:46
#, no-wrap
msgid "B<int pkey_mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<, int >I<pkey>B<);>\n"
msgstr "B<int pkey_mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<, int >I<pkey>B<);>\n"

#. type: Plain text
#: build/C/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes the access protections for the calling process's "
"memory pages containing any part of the address range in the interval "
"[I<addr>,\\ I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""
"B<mprotect>()  は、区間 [I<addr>,\\ I<addr>+I<len>-1] のアドレス範囲を含む 呼"
"び出し元のプロセスのメモリーページのアクセス保護を変更する。 I<addr> はページ"
"境界に一致していなければならない。"

#. type: Plain text
#: build/C/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protections, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""
"呼び出し元のプロセスがアクセス保護に違反するようなメモリーアクセスを 行おうと"
"すると、カーネルはシグナル B<SIGSEGV> をそのプロセスに対して生成する。"

#. type: Plain text
#: build/C/man2/mprotect.2:64
#, fuzzy
#| msgid ""
#| "I<prot> is either B<PROT_NONE> or a bitwise-or of the other values in the "
#| "following list:"
msgid ""
"I<prot> is a combination of the following access flags: B<PROT_NONE> or a "
"bitwise-or of the other values in the following list:"
msgstr ""
"I<prot> には、 B<PROT_NONE> か、以下のリストの B<PROT_NONE> 以外の値をビット"
"毎の論理和 (bitwize-or) で指定する:"

#. type: Plain text
#: build/C/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr "そのメモリーには全くアクセスできない。"

#. type: Plain text
#: build/C/man2/mprotect.2:70
msgid "The memory can be read."
msgstr "そのメモリーを読み取ることができる。"

#. type: Plain text
#: build/C/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr "そのメモリーを変更できる。"

#. type: Plain text
#: build/C/man2/mprotect.2:76
msgid "The memory can be executed."
msgstr "そのメモリーは実行可能である。"

#. type: TP
#: build/C/man2/mprotect.2:76
#, no-wrap
msgid "B<PROT_SEM> (since Linux 2.5.7)"
msgstr "B<PROT_SEM> (Linux 2.5.7 以降)"

#. type: Plain text
#: build/C/man2/mprotect.2:85
msgid ""
"The memory can be used for atomic operations.  This flag was introduced as "
"part of the B<futex>(2)  implementation (in order to guarantee the ability "
"to perform atomic operations required by commands such as B<FUTEX_WAIT>), "
"but is not currently used in on any architecture."
msgstr ""

#. type: TP
#: build/C/man2/mprotect.2:85
#, no-wrap
msgid "B<PROT_SAO> (since Linux 2.6.26)"
msgstr "B<PROT_SAO> (Linux 2.6.26 以降)"

#.  commit aba46c5027cb59d98052231b36efcbbde9c77a1d
#.  commit ef3d3246a0d06be622867d21af25f997aeeb105f
#. type: Plain text
#: build/C/man2/mprotect.2:94
msgid ""
"The memory should have strong access ordering.  This feature is specific to "
"the PowerPC architecture (version 2.06 of the architecture specification "
"adds the SAO CPU feature, and it is available on POWER 7 or PowerPC A2, for "
"example)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:98
msgid ""
"Additionally (since Linux 2.6.0), I<prot> can have one of the following "
"flags set:"
msgstr ""

#.  mm/mmap.c:
#. 	vm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |
#. 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
#.  And calc_vm_flag_bits converts only GROWSDOWN/DENYWRITE/LOCKED.
#. type: TP
#: build/C/man2/mprotect.2:98
#, no-wrap
msgid "B<PROT_GROWSUP>"
msgstr "B<PROT_GROWSUP>"

#.  The VMA is one that was marked with VM_GROWSUP by the kernel
#.  when the stack was created. Note that (unlike VM_GROWSDOWN),
#.  there is no mmap() flag (analogous to MAP_GROWSDOWN) for
#.  creating a VMA that is marked VM_GROWSUP.
#. type: Plain text
#: build/C/man2/mprotect.2:113
msgid ""
"Apply the protection mode up to the end of a mapping that grows upwards.  "
"(Such mappings are created for the stack area on architectures\\(emfor "
"example, HP-PARISC\\(emthat have an upwardly growing stack.)"
msgstr ""

#. type: TP
#: build/C/man2/mprotect.2:113
#, no-wrap
msgid "B<PROT_GROWSDOWN>"
msgstr "B<PROT_GROWSDOWN>"

#. type: Plain text
#: build/C/man2/mprotect.2:120
msgid ""
"Apply the protection mode down to the beginning of a mapping that grows "
"downward (which should be a stack segment or a segment mapped with the "
"B<MAP_GROWSDOWN> flag set)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:139
msgid ""
"Like B<mprotect>(), B<pkey_mprotect>()  changes the protection on the pages "
"specified by I<addr> and I<len>.  The I<pkey> argument specifies the "
"protection key (see B<pkeys>(7))  to assign to the memory.  The protection "
"key must be allocated with B<pkey_alloc>(2)  before it is passed to "
"B<pkey_mprotect>().  For an example of the use of this system call, see "
"B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:148
msgid ""
"On success, B<mprotect>()  and B<pkey_mprotect>()  return zero.  On error, "
"these system calls return -1, and I<errno> is set appropriately."
msgstr "成功した場合、 B<mprotect>() と B<pkey_mprotect>() は 0 を返す。エラーの場合、これらのシステムコールは -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/mprotect.2:158
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""
"指定されたアクセスをメモリーに設定することができない。 これは、例えば ファイ"
"ルを読み取り専用で B<mmap>(2)  しており、その領域に対して B<mprotect>()  を呼"
"び出して B<PROT_WRITE> に設定しようとした場合に発生する。"

#. type: Plain text
#: build/C/man2/mprotect.2:162
msgid ""
"I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""
"I<addr> が有効なポインターでないか、 システムのページサイズの倍数でない。"

#. type: Plain text
#: build/C/man2/mprotect.2:167
msgid ""
"(B<pkey_mprotect>())  I<pkey> has not been allocated with B<pkey_alloc>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:175
msgid "Both B<PROT_GROWSUP> and B<PROT_GROWSDOWN> were specified in I<prot>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:179
msgid "Invalid flags specified in I<prot>."
msgstr "無効なフラグが I<prot> に指定された。"

#. type: Plain text
#: build/C/man2/mprotect.2:186
msgid ""
"(PowerPC architecture)  B<PROT_SAO> was specified in I<prot>, but SAO "
"hardware feature is not available."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:189
msgid "Internal kernel structures could not be allocated."
msgstr "カーネル内部の構造体を割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/mprotect.2:199
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced "
"for these cases.)"
msgstr ""
"[I<addr>, I<addr>+I<len>-1] という範囲のアドレスがプロセスのアドレス空間とし"
"て不正であるか、 その範囲のアドレスがマップされていない 1 つ以上のページを指"
"している (カーネル 2.4.19 より前では、この状況でエラー B<EFAULT> が間違って生"
"成されていた)。"

#.  I.e., the number of VMAs would exceed the 64 kB maximum
#. type: Plain text
#: build/C/man2/mprotect.2:211
msgid ""
"Changing the protection of a memory region would result in the total number "
"of mappings with distinct attributes (e.g., read versus read/write "
"protection)  exceeding the allowed maximum.  (For example, making the "
"protection of a range B<PROT_READ> in the middle of a region currently "
"protected as B<PROT_READ|PROT_WRITE> would result in three mappings: two "
"read/write mappings at each end and a read-only mapping in the middle.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:215
msgid ""
"B<pkey_mprotect>()  first appeared in Linux 4.9; library support was added "
"in glibc 2.27."
msgstr "B<pkey_mprotect>() は Linux 4.9 で登場した。 ライブラリでのサポートは glibc 2.27 で追加された。"

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: build/C/man2/mprotect.2:225
msgid ""
"B<mprotect>(): POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX says that the "
"behavior of B<mprotect>()  is unspecified if it is applied to a region of "
"memory that was not obtained via B<mmap>(2)."
msgstr "B<mprotect>(): POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX では、 B<mmap>(2)  経由で獲得していないメモリー領域に対して B<mprotect>()  を行った場合の B<mprotect>()  の動作は未定義であるとされている。"

#. type: Plain text
#: build/C/man2/mprotect.2:228
msgid "B<pkey_mprotect>()  is a nonportable Linux extension."
msgstr "B<pkey_mprotect>() は非標準の Linux による拡張である。"

#. type: Plain text
#: build/C/man2/mprotect.2:235
msgid ""
"On Linux, it is always permissible to call B<mprotect>()  on any address in "
"a process's address space (except for the kernel vsyscall area).  In "
"particular, it can be used to change existing code mappings to be writable."
msgstr ""
"Linux では、(カーネル vsyscall 領域以外の)  任意のプロセスアドレス空間に対し"
"て B<mprotect>()  を呼び出すことが、常に許されている。 これは特に既存のコード"
"マッピングを書き込み可能にするために使われる。"

#. type: Plain text
#: build/C/man2/mprotect.2:249
#, fuzzy
#| msgid ""
#| "Whether B<PROT_EXEC> has any effect different from B<PROT_READ> is "
#| "architecture- and kernel version-dependent.  On some hardware "
#| "architectures (e.g., i386), B<PROT_WRITE> implies B<PROT_READ>."
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> depends on "
"processor architecture, kernel version, and process state.  If "
"B<READ_IMPLIES_EXEC> is set in the process's personality flags (see "
"B<personality>(2)), specifying B<PROT_READ> will implicitly add B<PROT_EXEC>."
msgstr ""
"B<PROT_EXEC> が B<PROT_READ> と異なる影響を持つか否かは、アーキテクチャーと"
"カーネルのバージョンに依存する。 (i386 などの) いくつかのアーキテクチャーで"
"は、 B<PROT_WRITE> をセットすると、暗黙のうちに B<PROT_READ> がセットされる。"

#. type: Plain text
#: build/C/man2/mprotect.2:254
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:263
msgid ""
"POSIX.1 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can allow write access only if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr "POSIX.1 では、 I<prot> で指定されていないアクセスを許可する実装を認めている。 ただし、最低限、 B<PROT_WRITE> がセットされている場合にのみ書き込みアクセスが許可され、 B<PROT_NONE> がセットされている場合にはアクセスは許可されない点だけは 満たす必要がある。"

#. type: Plain text
#: build/C/man2/mprotect.2:276
msgid ""
"Applications should be careful when mixing use of B<mprotect>()  and "
"B<pkey_mprotect>().  On x86, when B<mprotect>()  is used with I<prot> set to "
"B<PROT_EXEC> a pkey may be allocated and set on the memory implicitly by the "
"kernel, but only when the pkey was 0 previously."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:286
msgid ""
"On systems that do not support protection keys in hardware, "
"B<pkey_mprotect>()  may still be used, but I<pkey> must be set to -1.  When "
"called this way, the operation of B<pkey_mprotect>()  is equivalent to "
"B<mprotect>()."
msgstr ""

#.  sigaction.2 refers to this example
#. type: Plain text
#: build/C/man2/mprotect.2:293
msgid ""
"The program below demonstrates the use of B<mprotect>().  The program "
"allocates four pages of memory, makes the third of these pages read-only, "
"and then executes a loop that walks upward through the allocated region "
"modifying bytes."
msgstr "以下のプログラムは、 B<mprotect>() の使用方法を示すものである。このプログラムは、メモリーページを 4つ確保し、そのうち 3番目のページを 読み込み専用に設定する。その後で、確保した領域のアドレスの小さい方から 大きな方に向かって順番にバイト値を変更するループを実行する。"

#. type: Plain text
#: build/C/man2/mprotect.2:296
msgid ""
"An example of what we might see when running the program is the following:"
msgstr "プログラムを実行した場合の一例を以下に示す。"

#. type: Plain text
#: build/C/man2/mprotect.2:302
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"

#. type: Plain text
#: build/C/man2/mprotect.2:314
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"

#. type: Plain text
#: build/C/man2/mprotect.2:319
#, no-wrap
msgid "static char *buffer;\n"
msgstr "static char *buffer;\n"

#. type: Plain text
#: build/C/man2/mprotect.2:328
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:332
#, no-wrap
msgid ""
"    printf(\"Got SIGSEGV at address: %p\\en\", si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    printf(\"Got SIGSEGV at address: %p\\en\", si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/mprotect.2:338
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"

#. type: Plain text
#: build/C/man2/mprotect.2:344
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:348
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:351
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"

#. type: Plain text
#: build/C/man2/mprotect.2:355
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:357
#, no-wrap
msgid "    printf(\"Start of region:        %p\\en\", buffer);\n"
msgstr "    printf(\"Start of region:        %p\\en\", buffer);\n"

#. type: Plain text
#: build/C/man2/mprotect.2:361
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:364
#, no-wrap
msgid ""
"    for (char *p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""
"    for (char *p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"

#. type: Plain text
#: build/C/man2/mprotect.2:368
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/mprotect.2:373
msgid "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"
msgstr "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"

#. type: TH
#: build/C/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr "MREMAP"

#. type: Plain text
#: build/C/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr "mremap - 仮想メモリーアドレスを再マッピングする"

#. type: Plain text
#: build/C/man2/mremap.2:37 build/C/man2/remap_file_pages.2:35
#: build/C/man2/memfd_create.2:28
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mremap.2:40
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"
msgstr ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"

#. type: Plain text
#: build/C/man2/mremap.2:46
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""
"B<mremap>()  は既存のメモリーマッピングの拡張 (または縮小) を行う。 同時に移"
"動されることもある (I<flags> 引き数と利用可能な仮想アドレス空間によって決ま"
"る)。"

#. type: Plain text
#: build/C/man2/mremap.2:60
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the "
"requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""
"I<old_address> は拡張 (または縮小) しようとする仮想メモリーブロック の元のア"
"ドレスである。I<old_address> はページ境界に合っていなければ ならない点に注意"
"すること。I<old_size> は元の仮想メモリーブロックの サイズである。 "
"I<new_size> は要求する変更後の仮想メモリーブロックのサイズである。 5 番目の引"
"き数として I<new_address> を指定することができる。下記の B<MREMAP_FIXED> の説"
"明を参照のこと。"

#. type: Plain text
#: build/C/man2/mremap.2:76
msgid ""
"If the value of I<old_size> is zero, and I<old_address> refers to a "
"shareable mapping (see B<mmap>(2)  B<MAP_SHARED>), then B<mremap>()  will "
"create a new mapping of the same pages.  I<new_size> will be the size of the "
"new mapping and the location of the new mapping may be specified with "
"I<new_address>; see the description of B<MREMAP_FIXED> below.  If a new "
"mapping is requested via this method, then the B<MREMAP_MAYMOVE> flag must "
"also be specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:78
msgid ""
"The I<flags> bit-mask argument may be 0, or include the following flags:"
msgstr "I<flags> ビットマスク引数は 0 または以下のフラグを含む:"

#. type: TP
#: build/C/man2/mremap.2:78
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr "B<MREMAP_MAYMOVE>"

#. type: Plain text
#: build/C/man2/mremap.2:90
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if "
"necessary.  If the mapping is relocated, then absolute pointers into the old "
"mapping location become invalid (offsets relative to the starting address of "
"the mapping should be employed)."
msgstr ""
"デフォルトでは、現在の位置にマッピングを拡張するための 十分な空きがなければ "
"B<mremap>()  は失敗する。 このフラグが指定されると、カーネルは必要があれば"
"マッピングを 新しい仮想アドレスに再配置することができる マッピングが再配置さ"
"れると、古いマッピング位置への絶対ポインターは 無効になる (マッピングの開始ア"
"ドレスからの相対オフセットは有効のままである)。"

#. type: TP
#: build/C/man2/mremap.2:90
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr "B<MREMAP_FIXED> (Linux 2.3.31 以降)"

#. type: Plain text
#: build/C/man2/mremap.2:107
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, I<void"
"\\ *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped."
msgstr "このフラグは B<mmap>(2)  の B<MAP_FIXED> フラグと似たような目的で用いられる。 このフラグが指定されると、 B<mremap>()  は 5 番目の引き数 I<void\\ *new_address> を受け取り、この引数はマッピングが移動されるべきアドレスを指定する。 このアドレスはページ境界に合っていなければならない。 I<new_address> と I<new_size> で指定されるアドレス範囲に過去のマッピングがあった場合、 そのマッピングはアンマップされる (unmapped)。"

#. type: Plain text
#: build/C/man2/mremap.2:113
msgid ""
"If B<MREMAP_FIXED> is specified, then B<MREMAP_MAYMOVE> must also be "
"specified."
msgstr " B<MREMAP_FIXED> を指定した場合は、 B<MREMAP_MAYMOVE> も指定しなければならない。"

#. type: TP
#: build/C/man2/mremap.2:113
#, no-wrap
msgid "B<MREMAP_DONTUNMAP> (since Linux 5.7)"
msgstr "B<MREMAP_DONTUNMAP> (Linux 5.7 以降)"

#.  commit e346b3813067d4b17383f975f197a9aa28a3b077
#. type: Plain text
#: build/C/man2/mremap.2:120
msgid ""
"This flag, which must be used in conjunction with B<MREMAP_MAYMOVE>, remaps "
"a mapping to a new address but does not unmap the mapping at I<old_address>."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:130
msgid ""
"The B<MREMAP_DONTUNMAP> flag can be used only with private anonymous "
"mappings (see the description of B<MAP_PRIVATE> and B<MAP_ANONYMOUS> in "
"B<mmap>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:143
msgid ""
"After completion, any access to the range specified by I<old_address> and "
"I<old_size> will result in a page fault.  The page fault will be handled by "
"a B<userfaultfd>(2)  handler if the address is in a range previously "
"registered with B<userfaultfd>(2).  Otherwise, the kernel allocates a zero-"
"filled page to handle the fault."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:150
msgid ""
"The B<MREMAP_DONTUNMAP> flag may be used to atomically move a mapping while "
"leaving the source mapped.  See NOTES for some possible applications of "
"B<MREMAP_DONTUNMAP>."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:160
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory "
"locked by the process may change."
msgstr ""
"I<old_address> と I<old_size> で指定されるメモリーセグメントが (B<mlock>(2)  "
"や同様のもので) ロックされている場合、セグメントのサイズが変わったり 再配置さ"
"れたりした時にロックも維持される。 その結果、プロセスによってロックされるメモ"
"リーの量は変化する。"

#. type: Plain text
#: build/C/man2/mremap.2:168
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned, "
"and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<mremap>()  は新しい仮想メモリー領域へのポインターを返す。 エ"
"ラーの場合は B<MAP_FAILED> (すなわち I<(void\\ *)\\ -1>) が返され、 I<errno> "
"が適切に設定される。"

#. type: Plain text
#: build/C/man2/mremap.2:175
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not "
"possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""
"呼び出し元がロックされているメモリーセグメントを拡張しようとしたが、 "
"B<RLIMIT_MEMLOCK> リソース制限を越えずにこれを行うことができない。"

#. type: Plain text
#: build/C/man2/mremap.2:184
msgid ""
"Some address in the range I<old_address> to I<old_address>+I<old_size> is an "
"invalid virtual memory address for this process.  You can also get B<EFAULT> "
"even if there exist mappings that cover the whole address space requested, "
"but those mappings are of different types."
msgstr "I<old_address> から I<old_address>+I<old_size> の 範囲のアドレスのどれかがこのプロセスにおいて不正な仮想メモリーアドレスである。 たとえ要求したアドレス空間全体を含むようなマッピングがあったとしても、 それらのマッピングが異なった型ならば B<EFAULT> を受け取るだろう。"

#. type: Plain text
#: build/C/man2/mremap.2:188
msgid "An invalid argument was given.  Possible causes are:"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:192
msgid "I<old_address> was not page aligned;"
msgstr "I<old_address> がページ境界ではない。"

#. type: Plain text
#: build/C/man2/mremap.2:201
msgid ""
"a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> or "
"B<MREMAP_DONTUNMAP> was specified in I<flags>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:204
msgid "I<new_size> was zero;"
msgstr "I<new_size> が 0 であった。"

#. type: Plain text
#: build/C/man2/mremap.2:209
msgid "I<new_size> or I<new_address> was invalid;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:218
msgid ""
"the new address range specified by I<new_address> and I<new_size> overlapped "
"the old address range specified by I<old_address> and I<old_size>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:224
msgid ""
"B<MREMAP_FIXED> or B<MREMAP_DONTUNMAP> was specified without also specifying "
"B<MREMAP_MAYMOVE>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:231
msgid ""
"B<MREMAP_DONTUNMAP> was specified, but one or more pages in the range "
"specified by I<old_address> and I<old_size> were not private anonymous;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:237
msgid ""
"B<MREMAP_DONTUNMAP> was specified and I<old_size> was not equal to "
"I<new_size>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:240
msgid ""
"I<old_size> was zero and I<old_address> does not refer to a shareable "
"mapping (but see BUGS);"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:244
msgid "I<old_size> was zero and the B<MREMAP_MAYMOVE> flag was not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:249
msgid ""
"Not enough memory was available to complete the operation.  Possible causes "
"are:"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:255
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""
"現在の仮想アドレスではメモリー領域が拡張できず、 B<MREMAP_MAYMOVE> フラグが "
"I<flags> に設定されていない。 または十分な (仮想) メモリーが存在しない。"

#. type: Plain text
#: build/C/man2/mremap.2:260
msgid ""
"B<MREMAP_DONTUNMAP> was used causing a new mapping to be created that would "
"exceed the (virtual) memory available.  Or, it would exceed the maximum "
"number of allowed mappings."
msgstr ""

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: build/C/man2/mremap.2:267
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで 使用すべきではな"
"い。"

#. type: Plain text
#: build/C/man2/mremap.2:273
msgid ""
"B<mremap>()  changes the mapping between virtual addresses and memory "
"pages.  This can be used to implement a very efficient B<realloc>(3)."
msgstr "B<mremap>()  は仮想アドレスとメモリーページのマッピングを変更する。これは非常に効率的な B<realloc>(3)  を実装するのに使用されている。"

#. type: Plain text
#: build/C/man2/mremap.2:287
msgid ""
"In Linux, memory is divided into pages.  A process has (one or)  several "
"linear virtual memory segments.  Each virtual memory segment has one or more "
"mappings to real memory pages (in the page table).  Each virtual memory "
"segment has its own protection (access rights), which may cause a "
"segmentation violation (B<SIGSEGV>)  if the memory is accessed incorrectly "
"(e.g., writing to a read-only segment).  Accessing virtual memory outside of "
"the segments will also cause a segmentation violation."
msgstr "Linux ではメモリーはページに分割される。プロセスは (一つまたは)  複数のリニアな仮想メモリーセグメントを持つ。 それぞれの仮想メモリーセグメントは一つ以上の実メモリーページ にマッピングされている (マッピング情報はページテーブルで管理される)。 仮想メモリーセグメントにはセグメント毎の保護 (アクセス権) が設定されており、 メモリーが不正にアクセスされた場合 (例えば読み込み専用のセグメントに 書き込んだ場合)、セグメンテーション侵害 (segmentation violation; B<SIGSEGV>) を引き起こす。また、セグメント外の仮想メモリーにアクセスした場合にも セグメンテーション侵害が発生する。"

#. type: Plain text
#: build/C/man2/mremap.2:298
msgid ""
"If B<mremap>()  is used to move or expand an area locked with B<mlock>(2)  "
"or equivalent, the B<mremap>()  call will make a best effort to populate the "
"new area but will not fail with B<ENOMEM> if the area cannot be populated."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:307
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""
"バージョン 2.4 より前の glibc では、 B<MREMAP_FIXED> の定義は公開されておら"
"ず、 B<mremap>()  のプロトタイプは I<new_address> 引き数を取らなかった。"

#. type: SS
#: build/C/man2/mremap.2:307
#, no-wrap
msgid "MREMAP_DONTUNMAP use cases"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:311
msgid "Possible applications for B<MREMAP_DONTUNMAP> include:"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:320
msgid ""
"Non-cooperative B<userfaultfd>(2): an application can yank out a virtual "
"address range using B<MREMAP_DONTUNMAP> and then employ a B<userfaultfd>(2)  "
"handler to handle the page faults that subsequently occur as other threads "
"in the process touch pages in the yanked range."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:333
msgid ""
"Garbage collection: B<MREMAP_DONTUNMAP> can be used in conjunction with "
"B<userfaultfd>(2)  to implement garbage collection algorithms (e.g., in a "
"Java virtual machine).  Such an implementation can be cheaper (and simpler)  "
"than conventional garbage collection techniques that involve marking pages "
"with protection B<PROT_NONE> in conjunction with the of a B<SIGSEGV> handler "
"to catch accesses to those pages."
msgstr ""

#.  commit dba58d3b8c5045ad89c1c95d33d01451e3964db7
#. type: Plain text
#: build/C/man2/mremap.2:354
msgid ""
"Before Linux 4.14, if I<old_size> was zero and the mapping referred to by "
"I<old_address> was a private mapping (B<mmap>(2) B<MAP_PRIVATE>), "
"B<mremap>()  created a new private mapping unrelated to the original "
"mapping.  This behavior was unintended and probably unexpected in user-space "
"applications (since the intention of B<mremap>()  is to create a new mapping "
"based on the original mapping).  Since Linux 4.14, B<mremap>()  fails with "
"the error B<EINVAL> in this scenario."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:363
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<realloc>(3), B<malloc>(3)"

#. type: Plain text
#: build/C/man2/mremap.2:369
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S.\\& Tanenbaum, "
"I<Inside Linux> by Randolph Bentson, I<The Design of the UNIX Operating "
"System> by Maurice J.\\& Bach)"
msgstr "ページ分割されたメモリーについてもっと詳しく知りたいならば、あなたのお気に入りのオペレーティングシステムの教科書を参照してほしい (例えば、 I<Modern Operating Systems> by Andrew S.\\& Tanenbaum, I<Inside Linux> by Randolf Bentson, I<The Design of the UNIX Operating System> by Maurice J.\\& Bach.)"

#. type: TH
#: build/C/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr "MSYNC"

#. type: Plain text
#: build/C/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr "msync - ファイルをマップしたメモリーと同期させる"

#. type: Plain text
#: build/C/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to the filesystem.  Without use of "
"this call, there is no guarantee that changes are written back before "
"B<munmap>(2)  is called.  To be more precise, the part of the file that "
"corresponds to the memory area starting at I<addr> and having length "
"I<length> is updated."
msgstr ""
"B<msync>()  は B<mmap>(2)  を使ってメモリーにマップされたファイルの、 メモ"
"リー上のコピーになされた変更をファイルシステムに反映させる。 この関数を使用し"
"ないと、 B<munmap>(2)  が呼び出されるまで変更が書き戻される保証はない。 より"
"正確には、ファイルのうち I<addr> から始まり長さ I<length> のメモリー領域に対"
"応する部分が更新される。"

#. type: Plain text
#: build/C/man2/msync.2:59
msgid ""
"The I<flags> argument should specify exactly one of B<MS_ASYNC> and "
"B<MS_SYNC>, and may additionally include the B<MS_INVALIDATE> bit.  These "
"bits have the following meanings:"
msgstr ""

#. type: TP
#: build/C/man2/msync.2:59
#, no-wrap
msgid "B<MS_ASYNC>"
msgstr "B<MS_ASYNC>"

#. type: Plain text
#: build/C/man2/msync.2:62
msgid ""
"Specifies that an update be scheduled, but the call returns immediately."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:62
#, no-wrap
msgid "B<MS_SYNC>"
msgstr "B<MS_SYNC>"

#. type: Plain text
#: build/C/man2/msync.2:65
msgid "Requests an update and waits for it to complete."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:65
#, no-wrap
msgid "B<MS_INVALIDATE>"
msgstr "B<MS_INVALIDATE>"

#.  Since Linux 2.4, this seems to be a no-op (other than the
#.  EBUSY check for VM_LOCKED).
#. type: Plain text
#: build/C/man2/msync.2:71
msgid ""
"Asks to invalidate other mappings of the same file (so that they can be "
"updated with the fresh values just written)."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:76
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、 0 が返る。エラーの場合、 -1 が返り、 I<errno> が適切に設定され"
"る。"

#. type: TP
#: build/C/man2/msync.2:77
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/msync.2:83
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the "
"specified address range."
msgstr ""
"I flags に B<MS_INVALIDATE> が指定されたが、指定されたアドレス範囲にロックが"
"存在する。"

#. type: Plain text
#: build/C/man2/msync.2:96
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""
"I<addr> が PAGESIZE の倍数でない。または、 I<flags> に B<MS_ASYNC>、"
"B<MS_INVALIDATE>、B<MS_SYNC> 以外のビットが設定された。 または、 I<flags> に "
"B<MS_SYNC> と B<MS_ASYNC> の両方が設定された。"

#. type: Plain text
#: build/C/man2/msync.2:99
msgid "The indicated memory (or part of it) was not mapped."
msgstr "指定されたメモリー (またはその一部) がマップされていない。"

#. type: Plain text
#: build/C/man2/msync.2:101 build/C/man3/shm_open.3:265
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/msync.2:108
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of "
"B<ENOMEM>.  In Linux 2.4.19, this was changed to the POSIX value B<ENOMEM>."
msgstr ""
"この関数は Linux 1.3.21 で導入されたが、 B<ENOMEM> ではなく B<EFAULT> が使わ"
"れていた。 これは Linux 2.4.19 で POSIX における値 B<ENOMEM> に変更された。"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/msync.2:123
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<msync>()  が使用可能な POSIX システムでは B<_POSIX_MAPPED_FILES> と "
"B<_POSIX_SYNCHRONIZED_IO> の両方が I<E<lt>unistd.hE<gt>> で 0 より大きい値に"
"定義される。 (B<sysconf>(3)  を参照すること。 )"

#.  commit 204ec841fbea3e5138168edbc3a76d46747cc987
#. type: Plain text
#: build/C/man2/msync.2:150
msgid ""
"According to POSIX, either B<MS_SYNC> or B<MS_ASYNC> must be specified in "
"I<flags>, and indeed failure to include one of these flags will cause "
"B<msync>()  to fail on some systems.  However, Linux permits a call to "
"B<msync>()  that specifies neither of these flags, with semantics that are "
"(currently) equivalent to specifying B<MS_ASYNC>.  (Since Linux 2.6.19, "
"B<MS_ASYNC> is in fact a no-op, since the kernel properly tracks dirty pages "
"and flushes them to storage as necessary.)  Notwithstanding the Linux "
"behavior, portable, future-proof applications should ensure that they "
"specify either B<MS_SYNC> or B<MS_ASYNC> in I<flags>."
msgstr ""
"POSIX では B<MS_SYNC> と B<MS_ASYNC> のいずれかは必ず I<flags> に指定しなけれ"
"ばならないとされており、 実際にこれらのフラグのいずれかを指定しなかった場合 "
"B<msync>() が失敗するシステムもある。 しかし、 Linux ではこれらのフラグのいず"
"れも指定せずに B<msync>() を呼び出すことができ、 その場合の動作は (現在のとこ"
"ろ) B<MS_ASYNC> を指定した場合と等価である。 (Linux 2.6.19 以降では "
"B<MS_ASYNC> は実際には no-op (何もしない命令) である。 これはカーネルが正し"
"く dirty ページを追跡し、必要に応じてストレージにそれらをフラッシュするからで"
"ある。) Linux の動作に関係なく、アプリケーションの移植性を考慮し、将来も確実"
"に動くようにするには、 B<MS_SYNC> か B<MS_ASYNC> のいずれかを必ず I<flags> に"
"指定するようにすべきである。"

#. type: TP
#: build/C/man2/msync.2:152 build/C/man7/shm_overview.7:45
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: TH
#: build/C/man3/mtrace.3:25
#, no-wrap
msgid "MTRACE"
msgstr "MTRACE"

#. type: Plain text
#: build/C/man3/mtrace.3:28
msgid "mtrace, muntrace - malloc tracing"
msgstr "mtrace, muntrace - malloc のトレース"

#. type: Plain text
#: build/C/man3/mtrace.3:30
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr "B<#include E<lt>mcheck.hE<gt>>"

#. type: Plain text
#: build/C/man3/mtrace.3:32
msgid "B<void mtrace(void);>"
msgstr "B<void mtrace(void);>"

#. type: Plain text
#: build/C/man3/mtrace.3:34
msgid "B<void muntrace(void);>"
msgstr "B<void muntrace(void);>"

#. type: Plain text
#: build/C/man3/mtrace.3:46
msgid ""
"The B<mtrace>()  function installs hook functions for the memory-allocation "
"functions (B<malloc>(3), B<realloc>(3)  B<memalign>(3), B<free>(3)).  These "
"hook functions record tracing information about memory allocation and "
"deallocation.  The tracing information can be used to discover memory leaks "
"and attempts to free nonallocated memory in a program."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:57
msgid ""
"The B<muntrace>()  function disables the hook functions installed by "
"B<mtrace>(), so that tracing information is no longer recorded for the "
"memory-allocation functions.  If no hook functions were successfully "
"installed by B<mtrace>(), B<muntrace>()  does nothing."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:65
msgid ""
"When B<mtrace>()  is called, it checks the value of the environment variable "
"B<MALLOC_TRACE>, which should contain the pathname of a file in which the "
"tracing information is to be recorded.  If the pathname is successfully "
"opened, it is truncated to zero length."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:78
msgid ""
"If B<MALLOC_TRACE> is not set, or the pathname it specifies is invalid or "
"not writable, then no hook functions are installed, and B<mtrace>()  has no "
"effect.  In set-user-ID and set-group-ID programs, B<MALLOC_TRACE> is "
"ignored, and B<mtrace>()  has no effect."
msgstr ""

#. type: tbl table
#: build/C/man3/mtrace.3:89
#, no-wrap
msgid ""
"B<mtrace>(),\n"
"B<muntrace>()"
msgstr ""
"B<mtrace>(),\n"
"B<muntrace>()"

#. type: tbl table
#: build/C/man3/mtrace.3:89
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: build/C/man3/mtrace.3:108
msgid ""
"In normal usage, B<mtrace>()  is called once at the start of execution of a "
"program, and B<muntrace>()  is never called."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:118
msgid ""
"The tracing output produced after a call to B<mtrace>()  is textual, but not "
"designed to be human readable.  The GNU C library provides a Perl script, "
"B<mtrace>(1), that interprets the trace log and produces human-readable "
"output.  For best results, the traced program should be compiled with "
"debugging enabled, so that line-number information is recorded in the "
"executable."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:124
msgid ""
"The tracing performed by B<mtrace>()  incurs a performance penalty (if "
"B<MALLOC_TRACE> points to a valid, writable pathname)."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:130
msgid ""
"The line-number information produced by B<mtrace>(1)  is not always precise: "
"the line number references may refer to the previous or following "
"(nonblank)  line of the source code."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:137
msgid ""
"The shell session below demonstrates the use of the B<mtrace>()  function "
"and the B<mtrace>(1)  command in a program that has memory leaks at two "
"different locations.  The demonstration uses the following program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:144
#, no-wrap
msgid ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mtrace.3:149
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mtrace();\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mtrace();\n"

#. type: Plain text
#: build/C/man3/mtrace.3:152
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"
msgstr ""
"    for (int j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"

#. type: Plain text
#: build/C/man3/mtrace.3:156
#, no-wrap
msgid ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mtrace.3:162
msgid ""
"When we run the program as follows, we see that B<mtrace>()  diagnosed "
"memory leaks at two different locations in the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:175
#, no-wrap
msgid ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"
msgstr ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"

#. type: Plain text
#: build/C/man3/mtrace.3:187
msgid ""
"The first two messages about unfreed memory correspond to the two "
"B<malloc>(3)  calls inside the I<for> loop.  The final message corresponds "
"to the call to B<calloc>(3)  (which in turn calls B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:192
msgid "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"
msgstr "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"

#. type: TH
#: build/C/man2/posix_fadvise.2:29
#, no-wrap
msgid "POSIX_FADVISE"
msgstr "POSIX_FADVISE"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:32
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr "posix_fadvise - ファイルデータのアクセスパターンをあらかじめ宣言する"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:35 build/C/man3/posix_fallocate.3:31
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:38
#, no-wrap
msgid "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"
msgstr "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:47
msgid "B<posix_fadvise>():"
msgstr "B<posix_fadvise>():"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:49 build/C/man3/posix_fallocate.3:44
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:57
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""
"プログラムは、将来特定のパターンでファイルデータに アクセスする意思を伝えるた"
"めに B<posix_fadvise>()  を使うことができる。 これにより、カーネルが適切な最"
"適化を実行することが可能になる。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:64
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""
"I<advice> は I<fd> が参照しているファイルの I<offset> から始まる I<len> バ"
"イ\n"
"トの範囲内 (I<len> が 0 の場合はファイルの終りまで) の (必ずしも存在しない)\n"
"領域に適用される。 I<advice> は義務づけではない。 I<advice> は単にアプリ"
"ケー\n"
"ションのために可能性を構成するだけである。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:66
msgid "Permissible values for I<advice> include:"
msgstr "I<advice> に許される値には、以下のものが含まれる:"

#. type: TP
#: build/C/man2/posix_fadvise.2:66
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr "B<POSIX_FADV_NORMAL>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:72
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""
"指定されたデータのアクセスパターンを指示するアドバイスを アプリケーションが何"
"も持っていないことを示す。 オープンされたファイルにアドバイスが指定されない場"
"合、 これがデフォルトで仮定される。"

#. type: TP
#: build/C/man2/posix_fadvise.2:72
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr "B<POSIX_FADV_SEQUENTIAL>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:76
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""
"アプリケーションは指定されたデータがシーケンシャルに (大きなオフセットの前に"
"小さなオフセットのデータを読むように)  アクセスされることを期待する。"

#. type: TP
#: build/C/man2/posix_fadvise.2:76
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr "B<POSIX_FADV_RANDOM>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:79
msgid "The specified data will be accessed in random order."
msgstr "指定されたデータがランダムな順番でアクセスされる。"

#. type: TP
#: build/C/man2/posix_fadvise.2:79
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr "B<POSIX_FADV_NOREUSE>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:82
msgid "The specified data will be accessed only once."
msgstr "指定されたデータは 1 度しかアクセスされない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:86
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""
"2.6.18 より前のカーネルでは、B<POSIX_FADV_NOREUSE> は B<POSIX_FADV_WILLNEED> "
"と同じ意味であった。 これは多分バグであった。 カーネル 2.6.18 以降では、この"
"フラグは何も行わない。"

#. type: TP
#: build/C/man2/posix_fadvise.2:86
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr "B<POSIX_FADV_WILLNEED>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:89
msgid "The specified data will be accessed in the near future."
msgstr "指定されたデータは近い将来アクセスされる。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:96
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""
"B<POSIX_FADV_WILLNEED> は、 ページキャッシュに指定領域のブロックされない読み"
"込みを開始する。 読み込まれるデータの総量は、 仮想メモリーの負荷に依ってカー"
"ネルが減らすかもしれない (数メガバイトであれば通常は全く十分であり、 それより"
"多くてもめったに役に立たない)。"

#. type: TP
#: build/C/man2/posix_fadvise.2:96
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr "B<POSIX_FADV_DONTNEED>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:99
msgid "The specified data will not be accessed in the near future."
msgstr "指定されたデータは近い将来アクセスされない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:107
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""
"B<POSIX_FADV_DONTNEED> は指定された領域に関連付けられた キャッシュページを解"
"放しようとする。 例えば、これは大きなファイルをストリーミングするときに役立"
"つ。 プログラムは、使用済みのキャッシュされたデータを解放するように、 定期的"
"にカーネルに要求するかもしれない。 そうすることにより、さらに有効なキャッシュ"
"されたページが、 代わりに破棄されることはない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:115
msgid ""
"Requests to discard partial pages are ignored.  It is preferable to preserve "
"needed data than discard unneeded data.  If the application requires that "
"data be considered for discarding, then I<offset> and I<len> must be page-"
"aligned."
msgstr ""
"ページの一部分の破棄要求は無視される。 不要なデータを破棄するよりも必要なデー"
"タを保持する方がよい。 アプリケーションがデータを破棄した方がよいと思う場合"
"は、 I<offset> と I<len> がページ境界に合っていなければならない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:127
#, fuzzy
#| msgid ""
#| "Pages that have not yet been written out will be unaffected, so if the "
#| "application wishes to guarantee that pages will be released, it should "
#| "call B<fsync>(2)  or B<fdatasync>(2)  first."
msgid ""
"The implementation I<may> attempt to write back dirty pages in the specified "
"region, but this is not guaranteed.  Any unwritten dirty pages will not be "
"freed.  If the application wishes to ensure that dirty pages will be "
"released, it should call B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""
"まだ書き出されていないページは影響を受けないので、 そのページの解放が保証され"
"ることをアプリケーションが望んでいるなら、 最初に B<fsync>(2)  または "
"B<fdatasync>(2)  を呼ぶべきである。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:130
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr "成功した場合は 0 が返される。 失敗した場合はエラー番号が返される。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:134
msgid "The I<fd> argument was not a valid file descriptor."
msgstr "I<fd> 引き数が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:137
msgid "An invalid value was specified for I<advice>."
msgstr "無効な値が I<advice> に指定された。"

#.  commit 87ba81dba431232548ce29d5d224115d0c2355ac
#. type: Plain text
#: build/C/man2/posix_fadvise.2:147
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (B<ESPIPE> is the "
"error specified by POSIX, but before kernel version 2.6.16, Linux returned "
"B<EINVAL> in this case.)"
msgstr "指定されたファイルディスクリプターがパイプまたは FIFO を参照している (B<ESPIPE> は POSIX で規定されているエラーだが、 バージョン 2.6.16 より前のカーネルでは、 この場合に B<EINVAL> を返していた。)"

#.  of fadvise64_64()
#. type: Plain text
#: build/C/man2/posix_fadvise.2:155
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""
"カーネルによるサポートは Linux 2.5.60 で最初に登場し、\n"
"対応するシステムコールは B<fadvise64>() という名前である。\n"
"ライブラリによるサポートは glibc バージョン 2.2 以降で提供されており、\n"
"ラッパー関数は B<posix_fadvise>() という名前である。"

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: build/C/man2/posix_fadvise.2:162
msgid ""
"Since Linux 3.18, support for the underlying system call is optional, "
"depending on the setting of the B<CONFIG_ADVISE_SYSCALLS> configuration "
"option."
msgstr ""
"Linux 3.18 以降では、対応するシステムコールのサポートは任意となり、利用できる"
"かはカーネルが B<CONFIG_ADVISE_SYSCALLS> オプションを有効にしてコンパイルされ"
"ているかに依存する。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008.  Note that the type of the I<len> argument was "
"changed from I<size_t> to I<off_t> in POSIX.1-2001 TC1."
msgstr "POSIX.1-2001, POSIX.1-2008.  I<len> 引き数の型が POSIX.1-2001 TC1 において I<size_t> から I<off_t> に変更された点に注意すること。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:177
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""
"Linux では、B<POSIX_FADV_NORMAL> はバッキングデバイスの デフォルトサイズに先"
"読み (readahead) ウインドウを設定する。 B<POSIX_FADV_SEQUENTIAL> はこのサイズ"
"を 2 倍し、 B<POSIX_FADV_RANDOM> は先読みを全く無効にする。 これらの変更は"
"ファイル全体に影響し、指定された領域のみに影響するわけではない (しかし同じ"
"ファイルに対する他のオープンファイルハンドルは影響を受けない)。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:182
msgid ""
"The contents of the kernel buffer cache can be cleared via the I</proc/sys/"
"vm/drop_caches> interface described in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:189
msgid ""
"One can obtain a snapshot of which pages of a file are resident in the "
"buffer cache by opening a file, mapping it with B<mmap>(2), and then "
"applying B<mincore>(2)  to the mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:199
msgid ""
"The name of the wrapper function in the C library is B<posix_fadvise>().  "
"The underlying system call is called B<fadvise64>()  (or, on some "
"architectures, B<fadvise64_64>()); the difference between the two is that "
"the former system call assumes that the type of the I<len> argument is "
"I<size_t>, while the latter expects I<loff_t> there."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:216
msgid ""
"Some architectures require 64-bit arguments to be aligned in a suitable pair "
"of registers (see B<syscall>(2)  for further detail).  On such "
"architectures, the call signature of B<posix_fadvise>()  shown in the "
"SYNOPSIS would force a register to be wasted as padding between the I<fd> "
"and I<offset> arguments.  Therefore, these architectures define a version of "
"the system call that orders the arguments suitably, but is otherwise exactly "
"the same as B<posix_fadvise>()."
msgstr ""
"いくつかのアーキテクチャーでは、 64 ビットの引き数は適切なレジスターの組に割"
"り当てる必要がある (B<syscall>(2) 参照)。 このようなアーキテクチャーでは、 "
"「書式」に書かれている  B<posix_fadvise>() の呼び出しシグネチャーで、 引き数 "
"I<fd> と I<offset> の間のパディング (詰めもの) でレジスターが一つ消費されてし"
"まう。 そのため、 これらのアーキテクチャーでは引き数が適切な順序になった別の"
"システムコールが定義されているが、 それ以外は B<posix_fadvise>() と全く同じで"
"ある。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:218
msgid "For example, since Linux 2.6.14, ARM has the following system call:"
msgstr ""
"例えば、 Linux 2.6.14 以降では、 ARM には以下のシステムコールが存在する。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:223
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:231
msgid ""
"These architecture-specific details are generally hidden from applications "
"by the glibc B<posix_fadvise>()  wrapper function, which invokes the "
"appropriate architecture-specific system call."
msgstr ""
"通常、 glibc の B<posix_fadvise>() ラッパー関数により、 これらのアーキテク"
"チャー固有の詳細はアプリケーションには見えない。 glibc のラッパー関数では、適"
"切なアーキテクチャー固有のシステムコールが呼び出される。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:236
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""
"2.6.6 より前のカーネルでは、 I<len> に 0 が指定された場合、 「ファイルの終り"
"までの全てのバイト」という意味ではなく、 文字通り「0 バイト」として解釈されて"
"いた。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:243
msgid ""
"B<fincore>(1), B<mincore>(2), B<readahead>(2), B<sync_file_range>(2), "
"B<posix_fallocate>(3), B<posix_madvise>(3)"
msgstr "B<fincore>(1), B<mincore>(2), B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3), B<posix_madvise>(3)"

#. type: TH
#: build/C/man3/posix_fallocate.3:25
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr "POSIX_FALLOCATE"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:28
msgid "posix_fallocate - allocate file space"
msgstr "posix_fallocate - ファイルのスペースを確保する"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:33
#, no-wrap
msgid "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:42
msgid "B<posix_fallocate>():"
msgstr "B<posix_fallocate>():"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:61
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the file descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr "関数 B<posix_fallocate>()  は、ファイルディスクリプター I<fd> で参照されるファイルに対して、ディスクスペースを確実に確保する。 ディスクスペースは I<offset> から始まる I<len> バイトの範囲のバイトである。 B<posix_fallocate>()  の呼び出しが成功した後、指定された範囲のバイトに対する書き込みは、 ディスクスペースの不足で失敗しないことが保証される。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:66
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""
"ファイルのサイズが I<offset>+I<len> より小さい場合、ファイルはこのサイズにな"
"るように拡大される。 それ以外の場合、ファイルサイズは変わらない。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:72
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""
"B<posix_fallocate>()  は成功した場合、0 を返す。 失敗した場合、エラー番号を返"
"す。 I<errno> が設定されない点に注意すること。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:81
msgid "I<offset+len> exceeds the maximum file size."
msgstr "I<offset+len> が最大ファイルサイズを超えている。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:84
msgid "A signal was caught during execution."
msgstr "実行中にシグナルが捕捉された。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:91
#, fuzzy
#| msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgid ""
"I<offset> was less than 0, or I<len> was less than or equal to 0, or the "
"underlying filesystem does not support the operation."
msgstr "I<offset> が 0 未満だったか、 I<len> が 0 以下だった。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:95
msgid "I<fd> does not refer to a regular file."
msgstr "I<fd> が通常のファイルとして参照されていない。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:107
#, fuzzy
#| msgid ""
#| "The filesystem containing the file referred to by I<fd> does not support "
#| "this operation; or the I<mode> is not supported by the filesystem "
#| "containing the file referred to by I<fd>."
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation.  This error code can be returned by C libraries that don't "
"perform the emulation shown in NOTES, such as musl libc."
msgstr ""
"I<fd> が参照するファイルを含むファイルシステムが 指定された操作を\n"
"サポートしていない。 I<fd> が参照するファイルを含むファイルシステムが\n"
"I<mode> をサポートしていない。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:111
msgid "I<fd> refers to a pipe."
msgstr "I<fd> がパイプを参照している。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:114
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr "B<posix_fallocate>()  は glibc 2.1.94 以降で利用可能である。"

#. type: tbl table
#: build/C/man3/posix_fallocate.3:124
#, no-wrap
msgid "B<posix_fallocate>()"
msgstr "B<posix_fallocate>()"

#. type: tbl table
#: build/C/man3/posix_fallocate.3:124
#, no-wrap
msgid "MT-Safe (but see NOTES)"
msgstr "MT-Safe (ただし「注意」を参照)"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:128 build/C/man3/posix_madvise.3:109
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/posix_fallocate.3:151
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""
"POSIX.1-2008 では、 I<len> が 0 の場合、もしくは I<offset> が 0 未満の場合、 "
"B<EINVAL> エラーを返すものとされている。 POSIX.1-2001 では、 I<len> が 0 未満"
"の場合、もしくは I<offset> が 0 未満の場合、 B<EINVAL> エラーを返すものとされ"
"ている。また、 I<len> が 0 の場合、 B<EINVAL> エラーを返してもよいとされてい"
"る。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:160
msgid ""
"In the glibc implementation, B<posix_fallocate>()  is implemented using the "
"B<fallocate>(2)  system call, which is MT-safe.  If the underlying "
"filesystem does not support B<fallocate>(2), then the operation is emulated "
"with the following caveats:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:162
msgid "The emulation is inefficient."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:165
msgid ""
"There is a race condition where concurrent writes from another thread or "
"process could be overwritten with null bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:169
msgid ""
"There is a race condition where concurrent file size increases by another "
"thread or process could result in a file whose size is smaller than expected."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:178
msgid ""
"If I<fd> has been opened with the B<O_APPEND> or B<O_WRONLY> flags, the "
"function fails with the error B<EBADF>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:188
msgid ""
"In general, the emulation is not MT-safe.  On Linux, applications may use "
"B<fallocate>(2)  if they cannot tolerate the emulation caveats.  In general, "
"this is only recommended if the application plans to terminate the operation "
"if B<EOPNOTSUPP> is returned, otherwise the application itself will need to "
"implement a fallback with all the same problems as the emulation provided by "
"glibc."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:193
msgid "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"

#. type: TH
#: build/C/man3/posix_madvise.3:20
#, no-wrap
msgid "POSIX_MADVISE"
msgstr "POSIX_MADVISE"

#. type: Plain text
#: build/C/man3/posix_madvise.3:23
msgid "posix_madvise - give advice about patterns of memory usage"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:28
#, no-wrap
msgid "B<int posix_madvise(void *>I<addr>B<, size_t >I<len>B<, int >I<advice>B<);>\n"
msgstr "B<int posix_madvise(void *>I<addr>B<, size_t >I<len>B<, int >I<advice>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_madvise.3:36
msgid "B<posix_madvise>():"
msgstr "B<posix_madvise>():"

#. type: Plain text
#: build/C/man3/posix_madvise.3:40
msgid "_POSIX_C_SOURCE E<gt>= 200112L"
msgstr "_POSIX_C_SOURCE E<gt>= 200112L"

#. type: Plain text
#: build/C/man3/posix_madvise.3:55
msgid ""
"The B<posix_madvise>()  function allows an application to advise the system "
"about its expected patterns of usage of memory in the address range starting "
"at I<addr> and continuing for I<len> bytes.  The system is free to use this "
"advice in order to improve the performance of memory accesses (or to ignore "
"the advice altogether), but calling B<posix_madvise>()  shall not affect the "
"semantics of access to memory in the specified range."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:59
msgid "The I<advice> argument is one of the following:"
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:59
#, no-wrap
msgid "B<POSIX_MADV_NORMAL>"
msgstr "B<POSIX_MADV_NORMAL>"

#. type: Plain text
#: build/C/man3/posix_madvise.3:64
msgid ""
"The application has no special advice regarding its memory usage patterns "
"for the specified address range.  This is the default behavior."
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:64
#, no-wrap
msgid "B<POSIX_MADV_SEQUENTIAL>"
msgstr "B<POSIX_MADV_SEQUENTIAL>"

#. type: Plain text
#: build/C/man3/posix_madvise.3:70
#, fuzzy
#| msgid ""
#| "Expect page references in sequential order.  (Hence, pages in the given "
#| "range can be aggressively read ahead, and may be freed soon after they "
#| "are accessed.)"
msgid ""
"The application expects to access the specified address range sequentially, "
"running from lower addresses to higher addresses.  Hence, pages in this "
"region can be aggressively read ahead, and may be freed soon after they are "
"accessed."
msgstr ""
"ページ参照はシーケンシャルな順序で行われそうだ。 (したがって与えた範囲のペー"
"ジは積極的に先読みしておくと良いだろう。 またアクセスが終わったら速やかに解放"
"して良い。)"

#. type: TP
#: build/C/man3/posix_madvise.3:70
#, no-wrap
msgid "B<POSIX_MADV_RANDOM>"
msgstr "B<POSIX_MADV_RANDOM>"

#. type: Plain text
#: build/C/man3/posix_madvise.3:74
#, fuzzy
#| msgid ""
#| "Expect page references in random order.  (Hence, read ahead may be less "
#| "useful than normally.)"
msgid ""
"The application expects to access the specified address range randomly.  "
"Thus, read ahead may be less useful than normally."
msgstr ""
"ページ参照はランダムな順序で行われそうだ。 (したがって、先読みはあまり効果が"
"なさそうだ。)"

#. type: TP
#: build/C/man3/posix_madvise.3:74
#, no-wrap
msgid "B<POSIX_MADV_WILLNEED>"
msgstr "B<POSIX_MADV_WILLNEED>"

#. type: Plain text
#: build/C/man3/posix_madvise.3:79
#, fuzzy
#| msgid ""
#| "The application expects to access the specified data sequentially (with "
#| "lower offsets read before higher ones)."
msgid ""
"The application expects to access the specified address range in the near "
"future.  Thus, read ahead may be beneficial."
msgstr ""
"アプリケーションは指定されたデータがシーケンシャルに (大きなオフセットの前に"
"小さなオフセットのデータを読むように)  アクセスされることを期待する。"

#. type: TP
#: build/C/man3/posix_madvise.3:79
#, no-wrap
msgid "B<POSIX_MADV_DONTNEED>"
msgstr "B<POSIX_MADV_DONTNEED>"

#. type: Plain text
#: build/C/man3/posix_madvise.3:83
#, fuzzy
#| msgid "The specified data will not be accessed in the near future."
msgid ""
"The application expects that it will not access the specified address range "
"in the near future."
msgstr "指定されたデータは近い将来アクセスされない。"

#. type: Plain text
#: build/C/man3/posix_madvise.3:88
#, fuzzy
#| msgid ""
#| "On success B<madvise>()  returns zero.  On error, it returns -1 and "
#| "I<errno> is set appropriately."
msgid ""
"On success, B<posix_madvise>()  returns 0.  On failure, it returns a "
"positive error number."
msgstr ""
"B<madvise>()  は成功すると 0 を返す。 エラーが起こると -1 を返し、 I<errno> "
"を適切な値に設定する。"

#. type: Plain text
#: build/C/man3/posix_madvise.3:95
#, fuzzy
#| msgid ""
#| "I<addr> is not a valid pointer, or not a multiple of the system page size."
msgid ""
"I<addr> is not a multiple of the system page size or I<len> is negative."
msgstr ""
"I<addr> が有効なポインターでないか、 システムのページサイズの倍数でない。"

#. type: Plain text
#: build/C/man3/posix_madvise.3:99
#, fuzzy
#| msgid "I<advice> is not a valid value"
msgid "I<advice> is invalid."
msgstr "I<advice> が有効な値でない。"

#. type: Plain text
#: build/C/man3/posix_madvise.3:103
#, fuzzy
#| msgid ""
#| "Addresses in the specified range are not currently mapped, or are outside "
#| "the address space of the process."
msgid ""
"Addresses in the specified range are partially or completely outside the "
"caller's address space."
msgstr ""
"指定した範囲のアドレスが、現在マップされていない。 あるいはプロセスのアドレス"
"空間の内部にない。"

#. type: Plain text
#: build/C/man3/posix_madvise.3:107
msgid "Support for B<posix_madvise>()  first appeared in glibc version 2.2."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:116
msgid ""
"POSIX.1 permits an implementation to generate an error if I<len> is 0.  On "
"Linux, specifying I<len> as 0 is permitted (as a successful no-op)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:126
msgid ""
"In glibc, this function is implemented using B<madvise>(2).  However, since "
"glibc 2.6, B<POSIX_MADV_DONTNEED> is treated as a no-op, because the "
"corresponding B<madvise>(2)  value, B<MADV_DONTNEED>, has destructive "
"semantics."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:129
msgid "B<madvise>(2), B<posix_fadvise>(2)"
msgstr "B<madvise>(2), B<posix_fadvise>(2)"

#. type: TH
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr "POSIX_MEMALIGN"

#. type: Plain text
#: build/C/man3/posix_memalign.3:32
msgid ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - allocate aligned "
"memory"
msgstr ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - アラインメント\n"
"されたメモリーの割り当てを行う"

#. type: Plain text
#: build/C/man3/posix_memalign.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"
msgstr ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_memalign.3:44
#, no-wrap
msgid ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"
msgstr ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_memalign.3:54
msgid "B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/posix_memalign.3:57
msgid "B<aligned_alloc>(): _ISOC11_SOURCE"
msgstr "B<aligned_alloc>(): _ISOC11_SOURCE"

#. type: Plain text
#: build/C/man3/posix_memalign.3:59
msgid "B<valloc>():"
msgstr "B<valloc>():"

#. type: TP
#: build/C/man3/posix_memalign.3:62
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "glibc 2.12 以降:"

#. type: Plain text
#: build/C/man3/posix_memalign.3:68
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* glibc 2.19 以前: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: TP
#: build/C/man3/posix_memalign.3:70
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "glibc 2.12 より前:"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/posix_memalign.3:74
msgid "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man3/posix_memalign.3:81
msgid ""
"(The (nonstandard) header file I<E<lt>malloc.hE<gt>> also exposes the "
"declaration of B<valloc>(); no feature test macros are required.)"
msgstr ""
"((非標準の) ヘッダーファイル I<E<lt>malloc.hE<gt>> も\n"
"B<valloc>() の宣言も公開する。機能検査マクロは不要である。"

#.  glibc does this:
#. type: Plain text
#: build/C/man3/posix_memalign.3:104
#, fuzzy
#| msgid ""
#| "The function B<posix_memalign>()  allocates I<size> bytes and places the "
#| "address of the allocated memory in I<*memptr>.  The address of the "
#| "allocated memory will be a multiple of I<alignment>, which must be a "
#| "power of two and a multiple of I<sizeof(void\\ *)>.  If I<size> is 0, "
#| "then the value placed in I<*memptr> is either NULL, or a unique pointer "
#| "value that can later be successfully passed to B<free>(3)."
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated "
"memory will be a multiple of I<alignment>, which must be a power of two and "
"a multiple of I<sizeof(void\\ *)>.  This address can later be successfully "
"passed to B<free>(3).  If I<size> is 0, then the value placed in I<*memptr> "
"is either NULL or a unique pointer value."
msgstr ""
"関数 B<posix_memalign>()  は、 I<size> バイトのメモリーを割り当て、割り当てら"
"れたメモリーのアドレスを I<*memptr> に設定する。 割り当てられたメモリーのアド"
"レスは I<alignment> の倍数になっているはずである。 I<alignment> は 2 のべき乗"
"で、かつ I<sizeof(void\\ *)> の倍数でなければならない。 I<size> が 0 の場"
"合、 I<*memptr> には NULL か一意なポインター値が書かれる。 このポインター値"
"は、後で B<free>(3)  に問題なく渡すことができる。"

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: build/C/man3/posix_memalign.3:115
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<alignment>, which must be a power of two."
msgstr ""
"廃止された関数である B<memalign>() は、 I<size> バイトのメモリーを割り当"
"て、\n"
"割り当てられたメモリーへのポインターを返す。 メモリーのアドレスは "
"I<alignment> \n"
"の倍数になっているはずである。 I<alignment> は 2 のべき乗でなければならない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:124
msgid ""
"The function B<aligned_alloc>()  is the same as B<memalign>(), except for "
"the added restriction that I<size> should be a multiple of I<alignment>."
msgstr ""
"関数 B<aligned_alloc>() は B<memalign>() と同じだが、I<size> が "
"I<alignment>\n"
"の倍数でなければならないという追加の制限がある点が異なる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:133
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""
"廃止された関数である B<valloc>()  は I<size> バイトのメモリーを割り当て、割り"
"当てられたメモリーへのポインターを返す。 メモリーのアドレスはページサイズの倍"
"数になっているはずである。 これは I<memalign(sysconf(_SC_PAGESIZE),size)> と"
"等価である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:140
msgid ""
"The obsolete function B<pvalloc>()  is similar to B<valloc>(), but rounds "
"the size of the allocation up to the next multiple of the system page size."
msgstr ""
"廃止された関数 B<pvalloc>() は B<valloc>() と同様だが、\n"
"割り当てられるサイズがシステムのページサイズの倍数に切り上げられる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:142
msgid "For all of these functions, the memory is not zeroed."
msgstr "これらの関数はいずれもメモリーのゼロクリアを行わない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:151
#, fuzzy
#| msgid ""
#| "B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return "
#| "a pointer to the allocated memory, or NULL if the request fails."
msgid ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return a "
"pointer to the allocated memory on success.  On error, NULL is returned, and "
"I<errno> is set to indicate the cause of the error."
msgstr ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), B<pvalloc>() は割り当てられ"
"た\n"
"メモリーへのポインターを返す。 割り当てに失敗した場合は NULL を返す。"

#.  http://austingroupbugs.net/view.php?id=520
#. type: Plain text
#: build/C/man3/posix_memalign.3:165
#, fuzzy
#| msgid ""
#| "B<posix_memalign>()  returns zero on success, or one of the error values "
#| "listed in the next section on failure.  The value of I<errno> is "
#| "indeterminate after a call to B<posix_memalign>()."
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  The value of I<errno> is not set.  "
"On Linux (and other systems), B<posix_memalign>()  does not modify I<memptr> "
"on failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2008 TC2."
msgstr ""
"B<posix_memalign>()  は成功した場合は 0 を返し、 失敗した場合は次のセクション"
"に記載されたエラー値のいずれかを返す。 B<posix_memalign>() の呼び出し後は "
"I<errno> の値は不定である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:172
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void\\ *)>."
msgstr ""
"I<alignment> 引き数が 2 のべき乗でなかったか、 I<sizeof(void\\ *)> の倍数でな"
"かった。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:175
msgid "There was insufficient memory to fulfill the allocation request."
msgstr "割り当て要求を満たすのに十分なメモリーがなかった。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:182
msgid ""
"The functions B<memalign>(), B<valloc>(), and B<pvalloc>()  have been "
"available since at least glibc 2.0."
msgstr "関数 B<memalign>(), B<valloc>(), B<pvalloc>() は少なくとも glibc 2.0 以降で使用可能である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:186
msgid "The function B<aligned_alloc>()  was added to glibc in version 2.16."
msgstr "関数 B<aligned_alloc>() は glibc バージョン 2.16 で追加された。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:190
msgid "The function B<posix_memalign>()  is available since glibc 2.1.91."
msgstr "関数 B<posix_fallocate>() は glibc 2.1.91 以降で利用可能である。"

#. type: tbl table
#: build/C/man3/posix_memalign.3:200
#, no-wrap
msgid "B<aligned_alloc>(),\n"
msgstr "B<aligned_alloc>(),\n"

#. type: tbl table
#: build/C/man3/posix_memalign.3:202
#, no-wrap
msgid "B<memalign>(),\n"
msgstr "B<memalign>(),\n"

#. type: tbl table
#: build/C/man3/posix_memalign.3:204
#, no-wrap
msgid "B<posix_memalign>()"
msgstr "B<posix_memalign>()"

#. type: tbl table
#: build/C/man3/posix_memalign.3:207
#, no-wrap
msgid "B<valloc>(),\n"
msgstr "B<valloc>(),\n"

#. type: tbl table
#: build/C/man3/posix_memalign.3:209
#, no-wrap
msgid "B<pvalloc>()"
msgstr "B<pvalloc>()"

#. type: tbl table
#: build/C/man3/posix_memalign.3:209
#, no-wrap
msgid "MT-Unsafe init"
msgstr "MT-Unsafe init"

#. type: Plain text
#: build/C/man3/posix_memalign.3:219
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in POSIX.1."
msgstr "関数 B<valloc>() は 3.0BSD で登場した。4.3BSD では廃止されたと記載されており、 SUSv2 では過去の名残だと記載されている。 POSIX.1 には存在しない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:223
msgid "The function B<pvalloc>()  is a GNU extension."
msgstr "関数 B<pvalloc>() は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:227
msgid "The function B<memalign>()  appears in SunOS 4.1.3 but not in 4.4BSD."
msgstr "関数 B<memalign>() は SunOS 4.1.3 で登場したが、4.4BSD にはない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:231
msgid ""
"The function B<posix_memalign>()  comes from POSIX.1d and is specified in "
"POSIX.1-2001 and POSIX.1-2008."
msgstr "関数 B<posix_memalign>() は POSIX.1d に由来し、 POSIX.1-2001 と POSIX.1-2008 で規定されている。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:236
msgid "The function B<aligned_alloc>()  is specified in the C11 standard."
msgstr "関数 I<aligned_alloc>() は C11 標準で規定されている。"

#. type: SS
#: build/C/man3/posix_memalign.3:236
#, no-wrap
msgid "Headers"
msgstr "ヘッダー"

#. type: Plain text
#: build/C/man3/posix_memalign.3:240
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in I<E<lt>stdlib."
"hE<gt>>."
msgstr ""
"B<posix_memalign>()  の宣言を I<E<lt>stdlib.hE<gt>> で行うことに関しては、 皆"
"の意見が一致している。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:244
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""
"いくつかのシステムでは、 B<memalign>()  は I<E<lt>malloc.hE<gt>> ではなく "
"I<E<lt>stdlib.hE<gt>> で宣言されている。"

#.  Libc4,5 and
#. type: Plain text
#: build/C/man3/posix_memalign.3:252
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Glibc declares it in I<E<lt>malloc.hE<gt>>, and also in I<E<lt>stdlib."
"hE<gt>> if suitable feature test macros are defined (see above)."
msgstr "SUSv2 によると、 B<valloc>() は I<E<lt>stdlib.hE<gt>> で宣言される。 glibc では I<E<lt>malloc.hE<gt>> で宣言されており、 さらに適切な機能検査マクロが定義された場合には I<E<lt>stdlib.hE<gt>> でも宣言される(上記を参照)。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:261
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the I<pathconf(path,"
"_PC_REC_XFER_ALIGN)> call that tells what alignment is needed.  Now one can "
"use B<posix_memalign>()  to satisfy this requirement."
msgstr ""
"多くのシステムでは、アラインメントに関して制限がある。例えば、 ブロックデバイ"
"スに対するダイレクト I/O に使用するバッファーには アラインメントに関する制限"
"がある。 POSIX では、どんなアラインメントが必要かを知るために "
"I<pathconf(path,_PC_REC_XFER_ALIGN)> コールを規定している。ここで "
"B<posix_memalign>()  を使うと、この必要条件を満たすことができる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:270
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<alignment> argument "
"is correct."
msgstr ""
"B<posix_memalign>() は I<alignment> が上で詳細に述べた必要条件を満たすか\n"
"どうかを確かめる。 B<memalign>() は I<alignment> 引き数が正しいかどうかの\n"
"確認を行わないかもしれない。"

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: build/C/man3/posix_memalign.3:298
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can pass to B<free>(3)  "
"only a pointer obtained from B<malloc>(3), while, for example, "
"B<memalign>()  would call B<malloc>(3)  and then align the obtained value).  "
"The glibc implementation allows memory obtained from any of these functions "
"to be reclaimed with B<free>(3)."
msgstr ""
"POSIX では B<posix_memalign>() によって獲得したメモリーは B<free>(3) を\n"
"使って解放することができる必要がある。 いくつかのシステムでは\n"
"B<memalign>() やB<valloc>() で割り当てられたメモリーを再利用する手段が\n"
"提供されていない(なぜなら B<free>(3) に渡すことができるのは\n"
"B<malloc>(3) から受け取ったポインターだけだが、例えば B<memalign>() は\n"
"B<malloc>(3) を呼び出し、得た値をアラインメントしてしまうからである)。\n"
"glibc の実装では、 ここに述べた関数のいずれで獲得したメモリーも\n"
"B<free>(3) で再利用することができる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:303
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these functions are needed only if you require larger alignment values."
msgstr ""
"glibc の B<malloc>(3) は常に 8 バイトにアラインメントされたメモリーアドレス"
"を\n"
"返すので、ここで述べた関数が必要になるのは 8 バイトよりも大きなアラインメン"
"ト\n"
"が必要な場合だけである。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:308
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr "READAHEAD"

#. type: Plain text
#: build/C/man2/readahead.2:31
msgid "readahead - initiate file readahead into page cache"
msgstr "readahead - 前もってファイルをページキャッシュに読み込む"

#. type: Plain text
#: build/C/man2/readahead.2:37
#, no-wrap
msgid "B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: build/C/man2/readahead.2:44
msgid ""
"B<readahead>()  initiates readahead on a file so that subsequent reads from "
"that file will be satisfied from the cache, and not block on disk I/O "
"(assuming the readahead was initiated early enough and that other activity "
"on the system did not in the meantime flush pages from the cache)."
msgstr ""
"B<readahead>() はファイルの先読みを行い、そのファイルに対する後の読み込みが"
"キャッシュから行われ、ディスク I/O で停止しないようにする (この条件を満たせる"
"のは、先読みは十分早く行われ、システムの他の動作によりその後にキャッシュから"
"ページがフラッシュされない場合である)。"

#. type: Plain text
#: build/C/man2/readahead.2:66
msgid ""
"The I<fd> argument is a file descriptor identifying the file which is to be "
"read.  The I<offset> argument specifies the starting point from which data "
"is to be read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  The file offset of the open file description referred to by "
"the file descriptor I<fd> is left unchanged."
msgstr "I<fd> 引き数は読み込みを行うファイルを識別するファイルディスクリプターである。 I<offset> 引き数はデータの読み込み開始位置を指定し、 I<count> は読み込むデータのバイト数を指定する。 ディスク I/O はページ単位で実行されるので、 実際には I<offset> はページ境界に切り下げられ、読み込みバイト数は I<(offset+count)> より小さくない次のページ境界まで切り上げられる。 B<readahead>()  はファイルの末尾を越えた範囲まで読み出しを行うことはない。ファイルディスクリプター I<fd> で参照されたオープン済のファイル記述のファイルオフセットは 変更されない。"

#. type: Plain text
#: build/C/man2/readahead.2:72
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"B<readahead>()  は成功すると 0 を返す。失敗した場合 -1 を返し、 I<errno> にエ"
"ラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/readahead.2:77
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""
"I<fd> が有効なファイルディスクリプターでない、または 読み込み用にオープンされ"
"ていない。"

#. type: Plain text
#: build/C/man2/readahead.2:83
msgid ""
"I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""
"I<fd> が参照しているファイルが、 B<readahead>()  を行うことができないタイプの"
"ファイルであった。"

#. type: Plain text
#: build/C/man2/readahead.2:88
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""
"B<readahead>()  システムコールは Linux 2.4.13 で登場した。 glibc でのサポート"
"は glibc バージョン 2.3 以降で行われている。"

#. type: Plain text
#: build/C/man2/readahead.2:93
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""
"B<readahead>()  システムコールは Linux 固有であり、移植を考慮したプログラムで"
"は 使用を避けるべきである。"

#. type: Plain text
#: build/C/man2/readahead.2:98
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""
"いくつかの 32 ビットアーキテクチャーでは、このシステムコールの呼び出しシグネ"
"チャーが違っている。 理由は B<syscall>(2) で説明されている。"

#. type: Plain text
#: build/C/man2/readahead.2:107
msgid ""
"B<readahead>()  attempts to schedule the reads in the background and return "
"immediately.  However, it may block while it reads the filesystem metadata "
"needed to locate the requested blocks.  This occurs frequently with ext[234] "
"on large files using indirect blocks instead of extents, giving the "
"appearance that the call blocks until the requested data has been read."
msgstr ""
"B<readahead>() は読み込みをバックグラウンドで行うようにスケジューリングを行"
"い、すぐに返る。 しかしながら、要求されたブロックの位置を知るために必要なファ"
"イルシステムのメタデータを読み込む間は B<readahead>() は停止することがある。 "
"これは ext[234] で大きなファイルをエクステントではなく間接ブロックを使う場合"
"にしばしば発生し、 要求したデータが読み込まれるまで呼び出しが停止しているよう"
"に見える。"

#. type: Plain text
#: build/C/man2/readahead.2:113
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""
"B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"

#. type: TH
#: build/C/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr "REMAP_FILE_PAGES"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr "remap_file_pages - 非線形ファイルマッピングを作成する。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"

#.  commit 33041a0d76d3c3e0aff28ac95a2ffdedf1282dbc
#.  http://lwn.net/Articles/597632/
#.  commit c8d78c1823f46519473949d33f0d1d33fe21ea16
#. type: Plain text
#: build/C/man2/remap_file_pages.2:53
msgid ""
"B<Note>: this system call was marked as deprecated starting with Linux "
"3.16.  In Linux 4.0, the implementation was replaced by a slower in-kernel "
"emulation.  Those few applications that use this system call should consider "
"migrating to alternatives.  This change was made because the kernel code for "
"this system call was complex, and it is believed to be little used or "
"perhaps even completely unused.  While it had some use cases in database "
"applications on 32-bit systems, those use cases don't exist on 64-bit "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:65
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using "
"B<remap_file_pages>()  over using repeated calls to B<mmap>(2)  is that the "
"former approach does not require the kernel to create additional VMA "
"(Virtual Memory Area) data structures."
msgstr ""
"B<remap_file_pages>()  システムコールは非線形なマッピング、 つまりファイルの"
"ページがメモリー上で連続しない順番でマップされる マッピングを作成するために使"
"われる。 B<remap_file_pages>()  を使う方が B<mmap>(2)  を繰り返して使うより優"
"れている点は、 前者の方法ではカーネルが VMA (Virtual Memory Area, 仮想メモ"
"リー領域)  データ構造体を追加で作成する必要がないことである。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:67
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr "非線形マッピングを作成するためには、 以下のようなステップを実行する:"

#. type: IP
#: build/C/man2/remap_file_pages.2:67 build/C/man2/memfd_create.2:261
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/remap_file_pages.2:75
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""
"B<mmap>(2)  を使い、マッピングを作成する (このマッピングは最初は線形であ"
"る)。 このマッピングは B<MAP_SHARED> フラグを指定して作成されなければならな"
"い。"

#. type: IP
#: build/C/man2/remap_file_pages.2:75 build/C/man2/memfd_create.2:267
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/remap_file_pages.2:83
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""
"B<remap_file_pages>()  を 1 回以上呼び出して、 マッピングのページとファイルの"
"ページの対応関係を再構成する。 ファイルの同じページをマッピング領域の複数の場"
"所に マップすることが可能である。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:94
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""
"I<pgoff> と I<size> 引き数は、マッピング内で再配置されるファイルの領域を指定"
"する。 I<pgoff> はファイルオフセットであり、単位はシステムのページサイズであ"
"る。 I<size> は領域の長さであり、単位はバイトである。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:112
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""
"I<addr> 引き数は 2 つの目的で使われる。 第 1 の目的は、この引き数によって再編"
"成したいページの マッピングを識別することである。 よって I<addr> は "
"B<mmap>(2)  の呼び出しで過去にマップされた領域内のアドレスでなければならな"
"い。 第 2 の目的は、 I<pgoff> と I<size> で識別されるファイルページが置かれる"
"予定のアドレスを、 I<addr> によって指定することである。"

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: build/C/man2/remap_file_pages.2:126
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""
"I<addr> と I<size> に指定する値は、システムのページサイズの倍数とすべきであ"
"る。 それ以外の場合、カーネルは「両方」の値を 最も近いページサイズの倍数へ"
"「切り下げる」。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:130
msgid "The I<prot> argument must be specified as 0."
msgstr "I<prot> 引き数は 0 に指定されなければならない。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:138
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""
"I<flags> 引き数は B<mmap>(2)  のものと同じ意味であるが、 B<MAP_NONBLOCK> 以外"
"の全てのフラグは無視される。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:145
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<remap_file_pages>()  は 0 を返す。 エラーの場合、-1 が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:153
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""
"I<addr> が B<MAP_SHARED> フラグを指定して作成された有効なマッピングを参照して"
"いない。"

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: build/C/man2/remap_file_pages.2:162
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr "I<addr>, I<size>, I<prot>, I<pgoff> のいずれかが不正である。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:167
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""
"B<remap_file_pages>()  システムコールは Linux 2.5.46 で登場した。 glibc での"
"サポートは glibc バージョン 2.3.3 で追加された。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:171
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr "B<remap_file_pages>()  システムコールは Linux 固有のものである。"

#.  commit 3ee6dafc677a68e461a7ddafc94a580ebab80735
#. type: Plain text
#: build/C/man2/remap_file_pages.2:184
msgid ""
"Since Linux 2.6.23, B<remap_file_pages>()  creates non-linear mappings only "
"on in-memory filesystems such as B<tmpfs>(5), hugetlbfs or ramfs.  On "
"filesystems with a backing store, B<remap_file_pages>()  is not much more "
"efficient than using B<mmap>(2)  to adjust which parts of the file are "
"mapped to which addresses."
msgstr "Linux 2.6.23 以降、 B<remap_file_pages>() は B<tmpfs>(5), hugetlbfs, ramfs などのインメモリーファイルシステム上にのみ非線形マッピングを作成する。 裏にデータストアを持つファイルシステム上では、 B<remap_file_pages>() は、 ファイルのどの部分がどのアドレスにマッピングされているかの調整が、 B<mmap>(2) を使った場合ほど効率的ではない。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:191
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"

#. type: TH
#: build/C/man3/shm_open.3:25
#, no-wrap
msgid "SHM_OPEN"
msgstr "SHM_OPEN"

#. type: Plain text
#: build/C/man3/shm_open.3:28
msgid ""
"shm_open, shm_unlink - create/open or unlink POSIX shared memory objects"
msgstr ""
"shm_open, shm_unlink - POSIX 共有メモリーオブジェクトの作成/オープン/削除を行"
"う"

#. type: Plain text
#: build/C/man3/shm_open.3:32
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr "B<#include E<lt>sys/stat.hE<gt>> /* mode 定数用 */"

#. type: Plain text
#: build/C/man3/shm_open.3:34
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr "B<#include E<lt>fcntl.hE<gt>> /* O_* 定数の定義用 */"

#. type: Plain text
#: build/C/man3/shm_open.3:36
msgid ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"

#. type: Plain text
#: build/C/man3/shm_open.3:38
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr "B<int shm_unlink(const char *>I<name>B<);>"

#. type: Plain text
#: build/C/man3/shm_open.3:40
msgid "Link with I<-lrt>."
msgstr "I<-lrt> でリンクする。"

#. type: Plain text
#: build/C/man3/shm_open.3:52
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can "
"be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr ""
"B<shm_open>()  は、POSIX 共有メモリーオブジェクトを新規に作成/オープンした"
"り、 すでに存在するオブジェクトをオープンしたりする。 POSIX 共有メモリーオブ"
"ジェクトは、実際には、関係のないプロセスが 共有メモリーの同じ領域を "
"B<mmap>(2)  するために使用することができる手段である。 B<shm_unlink>()  は、"
"逆の操作、つまり以前に B<shm_open>()  で作成されたオブジェクトの削除を行う。"

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: build/C/man3/shm_open.3:73
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name> "
"specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form I</"
"somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr ""
"B<shm_open>()  の動作は B<open>(2)  とよく似ている。 I<name> で作成したりオー"
"プンしたりする共有メモリーオブジェクトを指定する。 移植性を持たせるためには、"
"共有メモリーオブジェクトは I</somename> という形式の名前で識別し、 その名前"
"は、最大で B<NAME_MAX> (すなわち 255) 文字のヌル終端された文字列で、 スラッ"
"シュで始まり、スラッシュ以外の文字が 1 文字以上続く形式 にすべきである。"

#. type: Plain text
#: build/C/man3/shm_open.3:80
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr ""
"I<oflag> はビットマスクで、 B<O_RDONLY> と B<O_RDWR> のいずれか一方と、以下に"
"述べる他のフラグの論理和をとったもの を指定する。"

#. type: TP
#: build/C/man3/shm_open.3:80
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: build/C/man3/shm_open.3:88
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can be B<mmap>(2)ed only for read (B<PROT_READ>)  access."
msgstr ""
"読み出しアクセス用にオブジェクトをオープンする。 このフラグを指定してオープン"
"された共有メモリーオブジェクトは、 読み出し (B<PROT_READ>) アクセスでのみ "
"B<mmap>(2)  することができる。"

#. type: TP
#: build/C/man3/shm_open.3:88
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: build/C/man3/shm_open.3:91
msgid "Open the object for read-write access."
msgstr "読み書きアクセス用にオブジェクトをオープンする。"

#. type: TP
#: build/C/man3/shm_open.3:91
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In truth it is actually the filesystem IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: build/C/man3/shm_open.3:111
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr ""
"存在しない場合、共有メモリーオブジェクトを作成する。 オブジェクトのユーザーと"
"グループの所有権は、 呼び出し元プロセスの対応する実効 ID が使われ、 オブジェ"
"クトの許可ビットは I<mode> の下位 9 ビットに基づいて設定される。ただし、 ファ"
"イルモード作成マスク (B<umask>(2)  参照) に設定されている値は、新規オブジェク"
"トに関してはクリアされる。 I<mode> を定義するために使用できるマクロ定数(群)"
"は B<open>(2)  に記載されている (これらの定数のシンボル定義は I<E<lt>sys/"
"stat.hE<gt>> のインクルードにより得られる)。"

#. type: Plain text
#: build/C/man3/shm_open.3:117
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr ""
"新規に作成された共有メモリーオブジェクトは長さ 0 で初期化される。 オブジェク"
"トの大きさは B<ftruncate>(2)  を使って設定できる。 共有メモリーオブジェクトと"
"して新規に確保されたバイトは自動的に 0 に初期化される。"

#. type: TP
#: build/C/man3/shm_open.3:117
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: build/C/man3/shm_open.3:126
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the "
"object, and its creation if it does not exist, are performed atomically."
msgstr ""
"B<O_CREAT> が一緒に指定されており、 I<name> で指定された共有メモリーオブジェ"
"クトが既に存在した場合、 エラーを返す。 オブジェクトの存在確認と、存在しな"
"かった場合のオブジェクト作成は、 必ず一連の操作として実行される (performed "
"atomically)。"

#. type: TP
#: build/C/man3/shm_open.3:126
#, no-wrap
msgid "B<O_TRUNC>"
msgstr "B<O_TRUNC>"

#. type: Plain text
#: build/C/man3/shm_open.3:129
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr ""
"共有メモリーオブジェクトがすでに存在した場合、 そのオブジェクトを 0 バイトに"
"切り詰める。"

#. type: Plain text
#: build/C/man3/shm_open.3:132
msgid ""
"Definitions of these flag values can be obtained by including I<E<lt>fcntl."
"hE<gt>>."
msgstr ""
"これらのフラグ値の定義は I<E<lt>fcntl.hE<gt>> のインクルードにより得られる。"

#. type: Plain text
#: build/C/man3/shm_open.3:143
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr ""
"成功して完了した場合、 B<shm_open>()  は共有メモリーオブジェクトを参照する新"
"しいファイルディスクリプターを返す。 このファイルディスクリプターは、そのプロ"
"セス内で過去にオープンされていない ファイルディスクリプターの中で最も小さな数"
"になることが保証される。 B<FD_CLOEXEC> フラグ (B<fcntl>(2)  を参照) が、この"
"ファイルディスクリプターに設定される。"

#. type: Plain text
#: build/C/man3/shm_open.3:152
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)  "
"(for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr ""
"通常、これらのファイルディスクリプターは、この後続けて実行される "
"B<ftruncate>(2)  (新規に作成されたオブジェクトの場合のみ) と B<mmap>(2)  の呼"
"び出しに使用される。 B<mmap>(2)  を呼び出した後は、ファイルディスクリプターを"
"クローズしてもよく、 クローズしてもメモリーマッピングに影響を与えることはな"
"い。"

#. type: Plain text
#: build/C/man3/shm_open.3:170
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a "
"shared memory object name, and, once all processes have unmapped the object, "
"de-allocates and destroys the contents of the associated memory region.  "
"After a successful B<shm_unlink>(), attempts to B<shm_open>()  an object "
"with the same I<name> fail (unless B<O_CREAT> was specified, in which case a "
"new, distinct object is created)."
msgstr ""
"B<shm_unlink>()  の動作は B<unlink>(2)  とよく似ている: 共有メモリーオブジェ"
"クト名を削除し、すべてのプロセスが処理対象の オブジェクトをアンマップした時点"
"でオブジェクトの割り当てを解除し、 対応するメモリー領域の内容を破棄する。 "
"B<shm_unlink>()  が成功した後で、同じ I<name> を持つオブジェクトに対して "
"B<shm_open>()  を行うと、 (B<O_CREAT> が指定されていない場合) 失敗する。 "
"(B<O_CREAT> が指定されている場合、新しく別のオブジェクトが作成される)。"

#. type: Plain text
#: build/C/man3/shm_open.3:179
msgid ""
"On success, B<shm_open>()  returns a file descriptor (a nonnegative "
"integer).  On failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns "
"0 on success, or -1 on error."
msgstr "成功した場合、 B<shm_open>()  はファイルディスクリプター (非負の整数) を返す。 失敗した場合、 B<shm_open>()  は -1 を返す。 B<shm_unlink>()  は、成功した場合 0 を、エラーが起こった場合 -1 を返す。"

#. type: Plain text
#: build/C/man3/shm_open.3:186
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr ""
"失敗した場合、エラーの原因を示すため I<errno> が設定される。 I<errno> に設定"
"される値は以下の通りである:"

#. type: Plain text
#: build/C/man3/shm_open.3:191
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr "共有メモリーオブジェクトを B<shm_unlink>()  する権限がなかった。"

#. type: Plain text
#: build/C/man3/shm_open.3:201
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or "
"B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr ""
"指定された I<mode> で I<name> を B<shm_open>()  する権限がなかった。もしく"
"は、 B<O_TRUNC> が指定されたが、呼び出し元にはそのオブジェクトに対する書き込"
"み権限が なかった。"

#. type: Plain text
#: build/C/man3/shm_open.3:212
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr ""
"B<O_CREAT> と B<O_EXCL> の両方が B<shm_open>()  に指定されたが、 I<name> で指"
"定された共有メモリーオブジェクトが既に存在した。"

#. type: Plain text
#: build/C/man3/shm_open.3:219
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr "B<shm_open>()  に与えられた I<name> 引き数が不正であった。"

#. type: TP
#: build/C/man3/shm_open.3:219 build/C/man2/memfd_create.2:190
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man3/shm_open.3:222 build/C/man2/memfd_create.2:193
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "オープンされているファイルディスクリプター数のプロセス単位の上限に達した。"

#. type: TP
#: build/C/man3/shm_open.3:222
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/shm_open.3:228
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr "I<name> の長さが B<PATH_MAX> を越えている。"

#. type: TP
#: build/C/man3/shm_open.3:231 build/C/man3/shm_open.3:240
#: build/C/man2/shmget.2:257
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/shm_open.3:240
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr ""
"存在していない I<name> のオブジェクトを B<shm_open>()  しようとしたが、 "
"B<O_CREAT> が指定されていなかった。"

#. type: Plain text
#: build/C/man3/shm_open.3:247
msgid ""
"An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr "存在しない I<name> のオブジェクトを B<shm_unlink>()  しようとした。"

#. type: Plain text
#: build/C/man3/shm_open.3:249
msgid "These functions are provided in glibc 2.2 and later."
msgstr "これらの関数は glibc 2.2 以降で提供されている。"

#. type: tbl table
#: build/C/man3/shm_open.3:260
#, no-wrap
msgid ""
"B<shm_open>(),\n"
"B<shm_unlink>()"
msgstr ""
"B<shm_open>(),\n"
"B<shm_unlink>()"

#. type: tbl table
#: build/C/man3/shm_open.3:260
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: build/C/man3/shm_open.3:273
#, fuzzy
#| msgid ""
#| "POSIX.1-2001 says that the group ownership of a newly created shared "
#| "memory object is set to either the calling process's effective group ID "
#| "or \"a system default group ID\"."
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\".  POSIX.1-2008 says that the group ownership may "
"be set to either the calling process's effective group ID or, if the object "
"is visible in the filesystem, the group ID of the parent directory."
msgstr ""
"POSIX.1-2001 には、新規に作成される共有メモリーオブジェクトのグループ所有権"
"は、 呼び出し元プロセスの実効グループ ID か 「システムのデフォルトのグループ "
"ID」 のどちらかに設定される、と書かれている。"

#. type: Plain text
#: build/C/man3/shm_open.3:281
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr ""
"POSIX は B<O_RDONLY> と B<O_TRUNC> が一緒に指定された場合の動作を未定義にして"
"いる。Linux では、 既存の共有メモリーオブジェクトに対する切り詰め (truncate) "
"は成功する。 しかし、他の UNIX システムでも同じであるとは限らない。"

#. type: Plain text
#: build/C/man3/shm_open.3:287
msgid ""
"The POSIX shared memory object implementation on Linux makes use of a "
"dedicated B<tmpfs>(5)  filesystem that is normally mounted under I</dev/shm>."
msgstr "Linux における POSIX 共有メモリーオブジェクトの実装は専用の B<tmpfs>(5) ファイルシステムを使用する。そのファイルシステムは通常 I</dev/shm> にマウントされる。"

#. type: Plain text
#: build/C/man3/shm_open.3:295
msgid ""
"The programs below employ POSIX shared memory and POSIX unnamed semaphores "
"to exchange a piece of data.  The \"bounce\" program (which must be run "
"first) raises the case of a string that is placed into the shared memory by "
"the \"send\" program.  Once the data has been modified, the \"send\" program "
"then prints the contents of the modified shared memory.  An example "
"execution of the two programs is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:302
#, no-wrap
msgid ""
"$ B<./pshm_ucase_bounce /myshm &>\n"
"[1] 270171\n"
"$ B<./pshm_ucase_send /myshm hello>\n"
"HELLO\n"
msgstr ""
"$ B<./pshm_ucase_bounce /myshm &>\n"
"[1] 270171\n"
"$ B<./pshm_ucase_send /myshm hello>\n"
"HELLO\n"

#. type: Plain text
#: build/C/man3/shm_open.3:307
msgid "Further detail about these programs is provided below."
msgstr ""

#. type: SS
#: build/C/man3/shm_open.3:307
#, no-wrap
msgid "Program source: pshm_ucase.h"
msgstr "プログラムのソース: pshm_ucase.h"

#. type: Plain text
#: build/C/man3/shm_open.3:311
msgid ""
"The following header file is included by both programs below.  Its primary "
"purpose is to define a structure that will be imposed on the memory object "
"that is shared between the two programs."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:321
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/shm_open.3:326
#, no-wrap
msgid "#define BUF_SIZE 1024   /* Maximum size for exchanged string */\n"
msgstr "#define BUF_SIZE 1024   /* Maximum size for exchanged string */\n"

#. type: Plain text
#: build/C/man3/shm_open.3:329
#, no-wrap
msgid ""
"/* Define a structure that will be imposed on the shared\n"
"   memory object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:336
#, no-wrap
msgid ""
"struct shmbuf {\n"
"    sem_t  sem1;            /* POSIX unnamed semaphore */\n"
"    sem_t  sem2;            /* POSIX unnamed semaphore */\n"
"    size_t cnt;             /* Number of bytes used in \\(aqbuf\\(aq */\n"
"    char   buf[BUF_SIZE];   /* Data being transferred */\n"
"};\n"
msgstr ""

#. type: SS
#: build/C/man3/shm_open.3:339
#, no-wrap
msgid "Program source: pshm_ucase_bounce.c"
msgstr "プログラムのソース: pshm_ucase_bounce.c"

#. type: Plain text
#: build/C/man3/shm_open.3:347
msgid ""
"The \"bounce\" program creates a new shared memory object with the name "
"given in its command-line argument and sizes the object to match the size of "
"the I<shmbuf> structure defined in the header file.  It then maps the object "
"into the process's address space, and initializes two POSIX semaphores "
"inside the object to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:352
msgid ""
"After the \"send\" program has posted the first of the semaphores, the "
"\"bounce\" program upper cases the data that has been placed in the memory "
"by the \"send\" program and then posts the second semaphore to tell the "
"\"send\" program that it may now access the shared memory."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:356
#, no-wrap
msgid "/* pshm_ucase_bounce.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:361
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>ctype.hE<gt>\n"
"#include \"pshm_ucase.h\"\n"
msgstr ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>ctype.hE<gt>\n"
"#include \"pshm_ucase.h\"\n"

#. type: Plain text
#: build/C/man3/shm_open.3:369
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s /shm-path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s /shm-path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/shm_open.3:371
#, no-wrap
msgid "    char *shmpath = argv[1];\n"
msgstr "    char *shmpath = argv[1];\n"

#. type: Plain text
#: build/C/man3/shm_open.3:374
#, no-wrap
msgid ""
"    /* Create shared memory object and set its size to the size\n"
"       of our structure */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:379
#, no-wrap
msgid ""
"    int fd = shm_open(shmpath, O_CREAT | O_EXCL | O_RDWR,\n"
"                      S_IRUSR | S_IWUSR);\n"
"    if (fd == -1)\n"
"        errExit(\"shm_open\");\n"
msgstr ""
"    int fd = shm_open(shmpath, O_CREAT | O_EXCL | O_RDWR,\n"
"                      S_IRUSR | S_IWUSR);\n"
"    if (fd == -1)\n"
"        errExit(\"shm_open\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:382
#, no-wrap
msgid ""
"    if (ftruncate(fd, sizeof(struct shmbuf)) == -1)\n"
"        errExit(\"ftruncate\");\n"
msgstr ""
"    if (ftruncate(fd, sizeof(struct shmbuf)) == -1)\n"
"        errExit(\"ftruncate\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:384
#, no-wrap
msgid "    /* Map the object into the caller\\(aqs address space */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:390 build/C/man3/shm_open.3:479
#, no-wrap
msgid ""
"    struct shmbuf *shmp = mmap(NULL, sizeof(*shmp),\n"
"                               PROT_READ | PROT_WRITE,\n"
"                               MAP_SHARED, fd, 0);\n"
"    if (shmp == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""
"    struct shmbuf *shmp = mmap(NULL, sizeof(*shmp),\n"
"                               PROT_READ | PROT_WRITE,\n"
"                               MAP_SHARED, fd, 0);\n"
"    if (shmp == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:392
#, no-wrap
msgid "    /* Initialize semaphores as process-shared, with value 0 */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:397
#, no-wrap
msgid ""
"    if (sem_init(&shmp-E<gt>sem1, 1, 0) == -1)\n"
"        errExit(\"sem_init-sem1\");\n"
"    if (sem_init(&shmp-E<gt>sem2, 1, 0) == -1)\n"
"        errExit(\"sem_init-sem2\");\n"
msgstr ""
"    if (sem_init(&shmp-E<gt>sem1, 1, 0) == -1)\n"
"        errExit(\"sem_init-sem1\");\n"
"    if (sem_init(&shmp-E<gt>sem2, 1, 0) == -1)\n"
"        errExit(\"sem_init-sem2\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:400
#, no-wrap
msgid ""
"    /* Wait for \\(aqsem1\\(aq to be posted by peer before touching\n"
"       shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:403
#, no-wrap
msgid ""
"    if (sem_wait(&shmp-E<gt>sem1) == -1)\n"
"        errExit(\"sem_wait\");\n"
msgstr ""
"    if (sem_wait(&shmp-E<gt>sem1) == -1)\n"
"        errExit(\"sem_wait\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:405
#, no-wrap
msgid "    /* Convert data in shared memory into upper case */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:408
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> shmp-E<gt>cnt; j++)\n"
"        shmp-E<gt>buf[j] = toupper((unsigned char) shmp-E<gt>buf[j]);\n"
msgstr ""
"    for (int j = 0; j E<lt> shmp-E<gt>cnt; j++)\n"
"        shmp-E<gt>buf[j] = toupper((unsigned char) shmp-E<gt>buf[j]);\n"

#. type: Plain text
#: build/C/man3/shm_open.3:411
#, no-wrap
msgid ""
"    /* Post \\(aqsem2\\(aq to tell the to tell peer that it can now\n"
"       access the modified data in shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:414
#, no-wrap
msgid ""
"    if (sem_post(&shmp-E<gt>sem2) == -1)\n"
"        errExit(\"sem_post\");\n"
msgstr ""
"    if (sem_post(&shmp-E<gt>sem2) == -1)\n"
"        errExit(\"sem_post\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:418
#, no-wrap
msgid ""
"    /* Unlink the shared memory object. Even if the peer process\n"
"       is still using the object, this is okay. The object will\n"
"       be removed only after all open references are closed. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:420
#, no-wrap
msgid "    shm_unlink(shmpath);\n"
msgstr "    shm_unlink(shmpath);\n"

#. type: SS
#: build/C/man3/shm_open.3:426
#, no-wrap
msgid "Program source: pshm_ucase_send.c"
msgstr "プログラムのソース: pshm_ucase_send.c"

#. type: Plain text
#: build/C/man3/shm_open.3:430
msgid ""
"The \"send\" program takes two command-line arguments: the pathname of a "
"shared memory object previously created by the \"bounce\" program and a "
"string that is to be copied into that object."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:440
msgid ""
"The program opens the shared memory object and maps the object into its "
"address space.  It then copies the data specified in its second argument "
"into the shared memory, and posts the first semaphore, which tells the "
"\"bounce\" program that it can now access that data.  After the \"bounce\" "
"program posts the second semaphore, the \"send\" program prints the contents "
"of the shared memory on standard output."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:444
#, no-wrap
msgid "/* pshm_ucase_send.c\n"
msgstr "/* pshm_ucase_send.c\n"

#. type: Plain text
#: build/C/man3/shm_open.3:449
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>string.hE<gt>\n"
"#include \"pshm_ucase.h\"\n"
msgstr ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>string.hE<gt>\n"
"#include \"pshm_ucase.h\"\n"

#. type: Plain text
#: build/C/man3/shm_open.3:457
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s /shm-path string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s /shm-path string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/shm_open.3:461
#, no-wrap
msgid ""
"    char *shmpath = argv[1];\n"
"    char *string = argv[2];\n"
"    size_t len = strlen(string);\n"
msgstr ""
"    char *shmpath = argv[1];\n"
"    char *string = argv[2];\n"
"    size_t len = strlen(string);\n"

#. type: Plain text
#: build/C/man3/shm_open.3:466
#, no-wrap
msgid ""
"    if (len E<gt> BUF_SIZE) {\n"
"        fprintf(stderr, \"String is too long\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (len E<gt> BUF_SIZE) {\n"
"        fprintf(stderr, \"String is too long\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/shm_open.3:469
#, no-wrap
msgid ""
"    /* Open the existing shared memory object and map it\n"
"       into the caller\\(aqs address space */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:473
#, no-wrap
msgid ""
"    int fd = shm_open(shmpath, O_RDWR, 0);\n"
"    if (fd == -1)\n"
"        errExit(\"shm_open\");\n"
msgstr ""
"    int fd = shm_open(shmpath, O_RDWR, 0);\n"
"    if (fd == -1)\n"
"        errExit(\"shm_open\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:481
#, no-wrap
msgid "    /* Copy data into the shared memory object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:484
#, no-wrap
msgid ""
"    shmp-E<gt>cnt = len;\n"
"    memcpy(&shmp-E<gt>buf, string, len);\n"
msgstr ""
"    shmp-E<gt>cnt = len;\n"
"    memcpy(&shmp-E<gt>buf, string, len);\n"

#. type: Plain text
#: build/C/man3/shm_open.3:486
#, no-wrap
msgid "    /* Tell peer that it can now access shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:489
#, no-wrap
msgid ""
"    if (sem_post(&shmp-E<gt>sem1) == -1)\n"
"        errExit(\"sem_post\");\n"
msgstr ""
"    if (sem_post(&shmp-E<gt>sem1) == -1)\n"
"        errExit(\"sem_post\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:492
#, no-wrap
msgid ""
"    /* Wait until peer says that it has finished accessing\n"
"       the shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:495
#, no-wrap
msgid ""
"    if (sem_wait(&shmp-E<gt>sem2) == -1)\n"
"        errExit(\"sem_wait\");\n"
msgstr ""
"    if (sem_wait(&shmp-E<gt>sem2) == -1)\n"
"        errExit(\"sem_wait\");\n"

#. type: Plain text
#: build/C/man3/shm_open.3:497
#, no-wrap
msgid "    /* Write modified data in shared memory to standard output */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:500
#, no-wrap
msgid ""
"    write(STDOUT_FILENO, &shmp-E<gt>buf, len);\n"
"    write(STDOUT_FILENO, \"\\en\", 1);\n"
msgstr ""
"    write(STDOUT_FILENO, &shmp-E<gt>buf, len);\n"
"    write(STDOUT_FILENO, \"\\en\", 1);\n"

#. type: Plain text
#: build/C/man3/shm_open.3:517
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<memfd_create>(2), B<mmap>(2), B<open>(2), B<umask>(2), "
"B<shm_overview>(7)"
msgstr ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<memfd_create>(2), B<mmap>(2), B<open>(2), B<umask>(2), "
"B<shm_overview>(7)"

#. type: TH
#: build/C/man7/shm_overview.7:26
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr "SHM_OVERVIEW"

#. type: Plain text
#: build/C/man7/shm_overview.7:29
msgid "shm_overview - overview of POSIX shared memory"
msgstr "shm_overview - POSIX 共有メモリーの概要"

#. type: Plain text
#: build/C/man7/shm_overview.7:32
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""
"POSIX 共有メモリー API を使用すると、メモリーのある領域を共有して、 プロセス"
"間で情報をやり取りすることができる。"

#. type: Plain text
#: build/C/man7/shm_overview.7:34
msgid "The interfaces employed in the API are:"
msgstr "この API では以下のインターフェースが採用されている。"

#. type: TP
#: build/C/man7/shm_overview.7:34
#, no-wrap
msgid "B<shm_open>(3)"
msgstr "B<shm_open>(3)"

#. type: Plain text
#: build/C/man7/shm_overview.7:41
msgid ""
"Create and open a new object, or open an existing object.  This is analogous "
"to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""
"新しいオブジェクトを生成しオープンする、もしくは 既存のオブジェクトをオープン"
"する。これは B<open>(2)  と同じである。下記にある他のインターフェースで使用す"
"る ファイルディスクリプターを返す。"

#. type: TP
#: build/C/man7/shm_overview.7:41
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr "B<ftruncate>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:45
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr "共有メモリーオブジェクトの大きさを設定する。"

#. type: Plain text
#: build/C/man7/shm_overview.7:49
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""
"呼び出したプロセスの仮想アドレス空間に共有メモリーオブジェクトを マップする。"

#. type: TP
#: build/C/man7/shm_overview.7:49
#, no-wrap
msgid "B<munmap>(2)"
msgstr "B<munmap>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:53
msgid ""
"Unmap the shared memory object from the virtual address space of the calling "
"process."
msgstr ""
"呼び出したプロセスの仮想アドレス空間から 共有メモリーオブジェクトをアンマップ"
"する。"

#. type: TP
#: build/C/man7/shm_overview.7:53
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr "B<shm_unlink>(3)"

#. type: Plain text
#: build/C/man7/shm_overview.7:56
msgid "Remove a shared memory object name."
msgstr "共有メモリーオブジェクト名を削除する。"

#. type: TP
#: build/C/man7/shm_overview.7:56
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:61
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""
"B<shm_open>(3)  で割り当てられたファイルディスクリプターが不要になった際に、 "
"そのファイルディスクリプターをクローズする。"

#. type: TP
#: build/C/man7/shm_overview.7:61
#, no-wrap
msgid "B<fstat>(2)"
msgstr "B<fstat>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:75
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""
"その共有メモリーオブジェクトについての情報が入った I<stat> 構造体を取得す"
"る。 このシステムコールが返す情報には、オブジェクトのサイズ (I<st_size>)、 許"
"可属性 (I<st_mode>)、 所有者 (I<st_uid>)、 グループ (I<st_gid>)  がある。"

#. type: TP
#: build/C/man7/shm_overview.7:75
#, no-wrap
msgid "B<fchown>(2)"
msgstr "B<fchown>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:78
msgid "To change the ownership of a shared memory object."
msgstr "共有メモリーオブジェクトの所有権を変更する。"

#. type: TP
#: build/C/man7/shm_overview.7:78
#, no-wrap
msgid "B<fchmod>(2)"
msgstr "B<fchmod>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:81
msgid "To change the permissions of a shared memory object."
msgstr "共有メモリーオブジェクトの許可属性を変更する。"

#. type: SS
#: build/C/man7/shm_overview.7:81
#, no-wrap
msgid "Versions"
msgstr "Versions"

#. type: Plain text
#: build/C/man7/shm_overview.7:83
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr "POSIX 共有メモリーは Linux 2.4 と glibc 2.2 以降でサポートされている。"

#. type: SS
#: build/C/man7/shm_overview.7:83
#, no-wrap
msgid "Persistence"
msgstr "持続性"

#. type: Plain text
#: build/C/man7/shm_overview.7:88
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""
"POSIX 共有メモリーオブジェクトはカーネル内で保持される。 共有メモリーオブジェ"
"クトは、システムがシャットダウンされるか、 全てのプロセスがそのオブジェクトを"
"アンマップし、 B<shm_unlink>(3)  で削除されるまで、存在し続ける。"

#. type: SS
#: build/C/man7/shm_overview.7:88
#, no-wrap
msgid "Linking"
msgstr "リンク"

#. type: Plain text
#: build/C/man7/shm_overview.7:93
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""
"POSIX 共有メモリー API を使用したプログラムは I<cc -lrt> でコンパイルし、リア"
"ルタイムライブラリ I<librt> とリンクしなければならない。"

#. type: SS
#: build/C/man7/shm_overview.7:93
#, no-wrap
msgid "Accessing shared memory objects via the filesystem"
msgstr "ファイルシステム経由での共有メモリーオブジェクトへのアクセス"

#. type: Plain text
#: build/C/man7/shm_overview.7:100
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>(5))  virtual "
"filesystem, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual filesystem."
msgstr "Linux では、共有メモリーオブジェクトは通常 I</dev/shm> 以下にマウントされる仮想ファイルシステム (B<tmpfs>(5))  内に作成される。 カーネル 2.6.19 以降の Linux では、 仮想ファイルシステム内のオブジェクトの許可属性の制御に、 アクセス制御リスト (ACL; access control lists) を使うことができる。"

#. type: Plain text
#: build/C/man7/shm_overview.7:103
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""
"通常は、共有メモリーオブジェクトにアクセスするプロセスは、 POSIX セマフォなど"
"を使ってプロセス間で同期をとらなければならない。"

#. type: Plain text
#: build/C/man7/shm_overview.7:111
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""
"System V 共有メモリー (B<shmget>(2), B<shmop>(2)  など) は古い共有メモリー "
"API である。 POSIX 共有メモリーは、より簡単で、うまく設計されたインターフェー"
"スを提供している。 一方で、POSIX 共有メモリーは System V 共有メモリーと比べる"
"と 利用できるシステムが少ない (特に、古いシステムでは少ない)。"

#. type: Plain text
#: build/C/man7/shm_overview.7:124
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"

#. type: TH
#: build/C/man2/shmctl.2:46
#, no-wrap
msgid "SHMCTL"
msgstr "SHMCTL"

#. type: Plain text
#: build/C/man2/shmctl.2:49
msgid "shmctl - System V shared memory control"
msgstr "shmctl - System V 共有メモリー (shared memory) を制御する"

#. type: Plain text
#: build/C/man2/shmctl.2:52 build/C/man2/shmget.2:44
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr "B<#include E<lt>sys/ipc.hE<gt>>"

#. type: Plain text
#: build/C/man2/shmctl.2:54 build/C/man2/shmget.2:46
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr "B<#include E<lt>sys/shm.hE<gt>>"

#. type: Plain text
#: build/C/man2/shmctl.2:56
msgid ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/shmctl.2:63
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the System"
"\\ V shared memory segment whose identifier is given in I<shmid>."
msgstr ""
"B<shmctl>()  は、識別子が I<shmid> の System\\ V 共有メモリーセグメントに対し"
"て I<cmd> で指示した制御命令を実行する。"

#. type: Plain text
#: build/C/man2/shmctl.2:68
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""
"I<buf> 引き数は、 I<shmid_ds> 構造体へのポインターである。 この構造体は "
"I<E<lt>sys/shm.hE<gt>> で以下のように定義されている"

#. type: Plain text
#: build/C/man2/shmctl.2:83
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Creation time/time of last\n"
"                                    modification via shmctl() */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* 所有権と許可 */\n"
"    size_t          shm_segsz;   /* セグメントのサイズ (バイト) */\n"
"    time_t          shm_atime;   /* 最後の付加 (attach) の時刻 */\n"
"    time_t          shm_dtime;   /* 最後の分離 (detach) の時刻 */\n"
"    time_t          shm_ctime;   /* 作成時刻 / shmctl() による\n"
"                                    最後の変更時刻 */\n"
"    pid_t           shm_cpid;    /* 作成者 (creator) の PID */\n"
"    pid_t           shm_lpid;    /* 最後の shmat(2)/shmdt(2) の PID */\n"
"    shmatt_t        shm_nattch;  /* 現在付加されている数 */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmctl.2:89
msgid "The fields of the I<shmid_ds> structure are as follows:"
msgstr "I<shmid_ds> 構造体のフィールドは以下の通りである。"

#. type: TP
#: build/C/man2/shmctl.2:89
#, no-wrap
msgid "I<shm_perm>"
msgstr "I<shm_perm>"

#. type: Plain text
#: build/C/man2/shmctl.2:95
msgid ""
"This is an I<ipc_perm> structure (see below) that specifies the access "
"permissions on the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:95
#, no-wrap
msgid "I<shm_segsz>"
msgstr "I<shm_segsz>"

#. type: Plain text
#: build/C/man2/shmctl.2:98
msgid "Size in bytes of the shared memory segment."
msgstr "共有メモリーセグメントのサイズ (バイト単位)。"

#. type: TP
#: build/C/man2/shmctl.2:98
#, no-wrap
msgid "I<shm_atime>"
msgstr "I<shm_atime>"

#. type: Plain text
#: build/C/man2/shmctl.2:103
msgid "Time of the last B<shmat>(2)  system call that attached this segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:103
#, no-wrap
msgid "I<shm_dtime>"
msgstr "I<shm_dtime>"

#. type: Plain text
#: build/C/man2/shmctl.2:108
msgid "Time of the last B<shmdt>(2)  system call that detached tgis segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:108
#, no-wrap
msgid "I<shm_ctime>"
msgstr "I<shm_ctime>"

#. type: Plain text
#: build/C/man2/shmctl.2:114
msgid ""
"Time of creation of segment or time of the last B<shmctl>()  B<IPC_SET> "
"operation."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:114
#, no-wrap
msgid "I<shm_cpid>"
msgstr "I<shm_cpid>"

#. type: Plain text
#: build/C/man2/shmctl.2:117
msgid "ID of the process that created the shared memory segment."
msgstr "その共有メモリーセグメントを作成したプロセスの ID。"

#. type: TP
#: build/C/man2/shmctl.2:117
#, no-wrap
msgid "I<shm_lpid>"
msgstr "I<shm_lpid>"

#. type: Plain text
#: build/C/man2/shmctl.2:124
msgid ""
"ID of the last process that executed a B<shmat>(2)  or B<shmdt>(2)  system "
"call on this segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:124
#, no-wrap
msgid "I<shm_nattch>"
msgstr "I<shm_nattch>"

#. type: Plain text
#: build/C/man2/shmctl.2:127
msgid "Number of processes that have this segment attached."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:133
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""
"I<ipc_perm> 構造体は以下のように定義されている (強調されたフィールドは "
"B<IPC_SET> を使って設定可能である):"

#. type: Plain text
#: build/C/man2/shmctl.2:146
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key;    /* shmget(2) に与えられるキー */\n"
"    uid_t          B<uid>;      /* 所有者の実効 UID */\n"
"    gid_t          B<gid>;      /* 所有者の実効 GID */\n"
"    uid_t          cuid;     /* 作成者の実効 UID */\n"
"    gid_t          cgid;     /* 作成者の実効 GID */\n"
"    unsigned short B<mode>;     /* B<許可> + SHM_DEST と\n"
"                                SHM_LOCKED フラグ */\n"
"    unsigned short __seq;    /* シーケンス番号 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmctl.2:155
msgid ""
"The least significant 9 bits of the I<mode> field of the I<ipc_perm> "
"structure define the access permissions for the shared memory segment.  The "
"permission bits are as follows:"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:157
#, no-wrap
msgid "0400"
msgstr "0400"

#. type: tbl table
#: build/C/man2/shmctl.2:157
#, no-wrap
msgid "Read by user"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:158
#, no-wrap
msgid "0200"
msgstr "0200"

#. type: tbl table
#: build/C/man2/shmctl.2:158
#, no-wrap
msgid "Write by user"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:159
#, no-wrap
msgid "0040"
msgstr "0040"

#. type: tbl table
#: build/C/man2/shmctl.2:159
#, no-wrap
msgid "Read by group"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:160
#, no-wrap
msgid "0020"
msgstr "0020"

#. type: tbl table
#: build/C/man2/shmctl.2:160
#, no-wrap
msgid "Write by group"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:161
#, no-wrap
msgid "0004"
msgstr "0004"

#. type: tbl table
#: build/C/man2/shmctl.2:161
#, no-wrap
msgid "Read by others"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:162
#, no-wrap
msgid "0002"
msgstr "0002"

#. type: tbl table
#: build/C/man2/shmctl.2:162
#, no-wrap
msgid "Write by others"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:172
msgid ""
"Bits 0100, 0010, and 0001 (the execute bits) are unused by the system.  (It "
"is not necessary to have execute permission on a segment in order to perform "
"a B<shmat>(2)  call with the B<SHM_EXEC> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:176
msgid "Valid values for I<cmd> are:"
msgstr "I<cmd> として有効な値は以下の通り:"

#. type: TP
#: build/C/man2/shmctl.2:176
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: build/C/man2/shmctl.2:185
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""
"I<shmid> に関連づけられたカーネルデータ構造体の情報を I<buf> で指された "
"I<shmid_ds> 構造体にコピーする。 呼び出し元は共有メモリーセグメントに対する "
"読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/shmctl.2:185
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: build/C/man2/shmctl.2:195
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:199
msgid ""
"The following fields are updated: I<shm_perm.uid>, I<shm_perm.gid>, and (the "
"least significant 9 bits of) I<shm_perm.mode>."
msgstr "以下のフィールドが更新される: I<shm_perm.uid>, I<shm_perm.gid> および I<shm_perm.mode> (の下位 9 ビット)。"

#. type: Plain text
#: build/C/man2/shmctl.2:205
msgid ""
"The effective UID of the calling process must match the owner (I<shm_perm."
"uid>)  or creator (I<shm_perm.cuid>)  of the shared memory segment, or the "
"caller must be privileged."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:205
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: build/C/man2/shmctl.2:218
msgid ""
"Mark the segment to be destroyed.  The segment will actually be destroyed "
"only after the last process detaches it (i.e., when the I<shm_nattch> member "
"of the associated structure I<shmid_ds> is zero).  The caller must be the "
"owner or creator of the segment, or be privileged.  The I<buf> argument is "
"ignored."
msgstr ""
"セグメントに破棄済みのマークを付ける。 セグメントは、実際には最後プロセスがセ"
"グメントを分離した (関連する I<shmid_ds> 構造体の I<shm_nattch> メンバーが 0 "
"になった) 後でのみ破棄される。 呼び出し元はそのセグメントの所有者か作成者であ"
"るか、特権を持たなければならない。 I<buf> 引き数は無視される。"

#. type: Plain text
#: build/C/man2/shmctl.2:226
msgid ""
"If a segment has been marked for destruction, then the (nonstandard)  "
"B<SHM_DEST> flag of the I<shm_perm.mode> field in the associated data "
"structure retrieved by B<IPC_STAT> will be set."
msgstr ""
"セグメントに破棄のマークが付けられると、 関連するデータ構造体において "
"I<shm_perm.mode> フィールドの (標準ではない)  B<SHM_DEST> フラグが設定され"
"る。 このデータ構造体は B<IPC_STAT> で取得される。"

#. type: Plain text
#: build/C/man2/shmctl.2:229
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""
"呼び出し元は最終的にはセグメントを忘れずに破棄I<しなければならない>。 そうで"
"なれば、フォールト (fault) されたページは メモリーかスワップ (swap) に残り続"
"ける。"

#. type: Plain text
#: build/C/man2/shmctl.2:234
msgid ""
"See also the description of I</proc/sys/kernel/shm_rmid_forced> in "
"B<proc>(5)."
msgstr "B<proc>(5) の I</proc/sys/kernel/shm_rmid_forced> の説明も参照のこと。"

#. type: TP
#: build/C/man2/shmctl.2:234
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:247
msgid ""
"Return information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"システム全体での共有メモリーの制限とパラメーターに関する情報を、 I<buf> が指"
"す構造体に入れて返す。 この構造体は I<shminfo> 型である (そのためキャストが必"
"要である)。 I<shminfo> は B<_GNU_SOURCE> 機能検査マクロが定義された場合に "
"I<E<lt>sys/shm.hE<gt>> で以下のように定義される:"

#. type: Plain text
#: build/C/man2/shmctl.2:261
#, no-wrap
msgid ""
"struct shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""
"struct  shminfo {\n"
"    unsigned long shmmax; /* 最大セグメントサイズ */\n"
"    unsigned long shmmin; /* 最小セグメントサイズ。\n"
"                             常に 1 */\n"
"    unsigned long shmmni; /* 最大セグメント数 */\n"
"    unsigned long shmseg; /* プロセスが付加できる\n"
"                             セグメントの最大数。\n"
"                             カーネル内では未使用 */\n"
"    unsigned long shmall; /* 共有メモリーの最大ページ数。\n"
"                             システム全体での値 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmctl.2:274
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""
"設定 I<shmmni>, I<shmmax>, I<shmall> は I</proc> にある同じ名前のファイル経由"
"で変更可能である。 詳しくは B<proc>(5)  を参照。"

#. type: TP
#: build/C/man2/shmctl.2:274
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr "B<SHM_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:285
msgid ""
"Return a I<shm_info> structure whose fields contain information about system "
"resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"共有メモリーが消費しているシステム資源に関する情報を 格納した I<shm_info> 構"
"造体を返す。 この構造体は、 B<_GNU_SOURCE> 機能検査マクロが定義された場合に "
"I<E<lt>sys/shm.hE<gt>> で以下のように定義される:"

#. type: Plain text
#: build/C/man2/shmctl.2:302
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""
"struct shm_info {\n"
"    int           used_ids; /* 現在存在するセグメント数 */\n"
"    unsigned long shm_tot;  /* 共有メモリーのページ総数 */\n"
"    unsigned long shm_rss;  /* メモリー上にある (スワップされて\n"
"                               いない) 共有メモリーページ数 */\n"
"    unsigned long shm_swp;  /* スワップされている共有メモリー\n"
"                               ページ数 */\n"
"    unsigned long swap_attempts;\n"
"                            /* Linux 2.4 以降では未使用 */\n"
"    unsigned long swap_successes;\n"
"                            /* Linux 2.4 以降では未使用 */\n"
"};\n"

#. type: TP
#: build/C/man2/shmctl.2:304
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr "B<SHM_STAT> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:315
msgid ""
"Return a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""
"B<IPC_STAT> と同じく I<shmid_ds> 構造体を返す。 但し、 I<shmid> 引き数は、セ"
"グメント識別子ではなく、システム上の全ての共有メモリー セグメントに関する情報"
"を管理するカーネルの内部配列へのインデックス である。"

#. type: TP
#: build/C/man2/shmctl.2:315
#, no-wrap
msgid "B<SHM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr "B<SHM_STAT_ANY> (Linux-specific, Linux 4.17 以降)"

#. type: Plain text
#: build/C/man2/shmctl.2:328
msgid ""
"Return a I<shmid_ds> structure as for B<SHM_STAT>.  However, I<shm_perm."
"mode> is not checked for read access for I<shmid>, meaning that any user can "
"employ this operation (just as any user may read I</proc/sysvipc/shm> to "
"obtain the same information)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:331
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""
"呼び出し元は、I<cmd> に以下の値を指定することで、共有メモリーセグメントが ス"
"ワップされることを防止したり、許可したりできる:"

#. type: TP
#: build/C/man2/shmctl.2:331
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr "B<SHM_LOCK> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:343
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""
"共有メモリーセグメントをスワップすることを防止する。 ロックが有効になった後、"
"呼び出し元は、 存在することが要求された全てのページをフォールトさせなければな"
"らない。 セグメントがロックされると、 関連するデータ構造体において "
"I<shm_perm.mode> フィールドの (標準的ではない)  B<SHM_LOCKED> フラグが設定さ"
"れる。 このデータ構造体は B<IPC_STAT> で取得される。"

#. type: TP
#: build/C/man2/shmctl.2:343
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr "B<SHM_UNLOCK> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:346
msgid "Unlock the segment, allowing it to be swapped out."
msgstr "セグメントのロックを解除し、スワップアウトすることを可能にする。"

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: build/C/man2/shmctl.2:364
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""
"2.6.10 より前のカーネルでは、特権プロセスだけが B<SHM_LOCK> と B<SHM_UNLOCK> "
"を利用することができた。 2.6.10 以降のカーネルでは、非特権プロセスであっても"
"次の条件を満たせば これらの操作を利用することができる。その条件とは、プロセス"
"の実効 UID がそのセグメントの所有者もしくは作成者の UID と一致し、 "
"(B<SHM_LOCK> の場合には) ロックするメモリーの合計が B<RLIMIT_MEMLOCK> リソー"
"ス上限 (B<setrlimit>(2)  参照) の範囲内に入っていることである。"

#. type: Plain text
#: build/C/man2/shmctl.2:384
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> or B<SHM_STAT_ANY> operations to obtain information "
"about all shared memory segments on the system.)  A successful B<SHM_STAT> "
"operation returns the identifier of the shared memory segment whose index "
"was given in I<shmid>.  Other operations return 0 on success."
msgstr "B<IPC_INFO> と B<SHM_INFO> 操作は、成功すると、全ての共有メモリーセグメントに関する情報を 管理しているカーネルの内部配列の使用中エントリーのインデックスの うち最大値を返す (この情報は、システムの全ての共有メモリーセグメントに関する情報を 取得するために、操作 B<SHM_STAT> か B<SHM_STAT_ANY> を繰り返し実行する際に使用できる)。 B<SHM_STAT> 操作は、成功すると、 I<shmid> で指定されたインデックスを持つ共有メモリーセグメントの識別子を返す。 他の操作は、成功の場合 0 を返す。"

#. type: Plain text
#: build/C/man2/shmctl.2:388
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/shmctl.2:397
#, fuzzy
#| msgid ""
#| "B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not "
#| "allow read access for I<shmid>, and the calling process does not have the "
#| "B<CAP_IPC_OWNER> capability."
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability in the user namespace that governs its IPC "
"namespace."
msgstr ""
"B<IPC_STAT> または B<SHM_STAT> が要求され、 I<shm_perm.mode> が I<shmid> への"
"読み込みアクセスを許しておらず、 かつ呼び出したプロセスが B<CAP_IPC_OWNER> "
"ケーパビリティ (capability) を持っていない。"

#. type: Plain text
#: build/C/man2/shmctl.2:408
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""
"I<cmd> 引き数に B<IPC_SET> か B<IPC_STAT> が指定されたが I<buf> で指されてい"
"るアドレスにアクセスできない。"

#. type: TP
#: build/C/man2/shmctl.2:408 build/C/man2/shmop.2:193
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: build/C/man2/shmctl.2:411 build/C/man2/shmop.2:196
msgid "I<shmid> points to a removed identifier."
msgstr "I<shmid> が削除 (remove) された識別子 (identifier) を指している。"

#. type: Plain text
#: build/C/man2/shmctl.2:422
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> or B<SHM_STAT_ANY> operation, the index value specified in "
"I<shmid> referred to an array slot that is currently unused."
msgstr "I<shmid> が有効な識別子でないか、 I<cmd> が有効なコマンドでない。 もしくは、操作 B<SHM_STAT> か B<SHM_STAT_ANY> の場合に、 I<shmid> で指定されたインデックス値が現在未使用の配列のスロットを参照していた。"

#. type: Plain text
#: build/C/man2/shmctl.2:433
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the to-"
"be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""
"(2.6.9 以降のカーネルにおいて)  B<SHM_LOCK> が指定され、 ロックされる予定のセ"
"グメントのサイズ (ロックされる共有メモリーセグメントの合計バイト数) が、 呼び"
"出したプロセスの実ユーザー ID についての制限を超えた。 この制限は "
"B<RLIMIT_MEMLOCK> ソフト資源制限で定義される (B<setrlimit>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/shmctl.2:438
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""
"B<IPC_STAT> が試みられ、GID や UID の値が I<buf> で指示される構造体に格納する"
"には大き過ぎる。"

#. type: Plain text
#: build/C/man2/shmctl.2:450
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""
"B<IPC_SET> か B<IPC_RMID> が試みられ、 呼び出したプロセスの実効ユーザー ID が"
"作成者 (I<shm_perm.cuid>)  でも所有者 (I<shm_perm.uid>)  でもなく、プロセスが"
"特権を持たない (Linux では B<CAP_SYS_ADMIN> ケーパビリティを持たない)。"

#. type: Plain text
#: build/C/man2/shmctl.2:462
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""
"または (2.6.9 より前のカーネルで)  B<SHM_LOCK> または B<SHM_UNLOCK> が指定さ"
"れているが、プロセスが特権を持たない (Linux では B<CAP_IPC_LOCK> ケーパビリ"
"ティを持たない)。 (Linux 2.6.9 以降では、 B<RLIMIT_MEMLOCK> が 0 で呼び出し元"
"が特権を持たない場合にも、このエラーが起こる。)"

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/shmctl.2:480 build/C/man2/shmget.2:301
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""
"Linux や POSIX の全てのバージョンでは、 I<E<lt>sys/types.hE<gt>> と "
"I<E<lt>sys/ipc.hE<gt>> のインクルードは必要ない。しかしながら、いくつかの古い"
"実装ではこれらのヘッダーファイルのインクルードが必要であり、 SVID でもこれら"
"のインクルードをするように記載されている。このような古いシステムへの移植性を"
"意図したアプリケーションではこれらのファイルをインクルードする必要があるかも"
"しれない。"

#. type: Plain text
#: build/C/man2/shmctl.2:492
msgid ""
"The B<IPC_INFO>, B<SHM_STAT>, and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future, these may modified or moved to a I</proc> filesystem interface."
msgstr ""
"B<IPC_INFO>, B<SHM_STAT>, B<SHM_INFO> 操作は、 B<ipcs>(1)  プログラムで割り当"
"て済の資源に関する情報を提供するために 使用されている。将来、これらの操作は変"
"更されたり、 I</proc> ファイルシステムのインターフェースに移動されるかもしれ"
"ない。"

#. type: Plain text
#: build/C/man2/shmctl.2:500
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""
"Linux では、 I<shmctl(IPC_RMID)> を使ってすでに削除マークがつけられている共有"
"メモリーセグメントを あるプロセスが付加 (attach)  (B<shmat>(2))  することを許"
"可している。 この機能は他の UNIX の実装では利用できない。 移植性を考慮したア"
"プリケーションではこれに依存しないようにすべきである。"

#. type: Plain text
#: build/C/man2/shmctl.2:513
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"I<構造体 shmid_ds> 内の多くのフィールドは、 Linux 2.2 では I<short> 型だった"
"が、Linux 2.4 では I<long> 型になった。 この利点を生かすには、glibc-2.1.91 以"
"降の環境下で 再コンパイルすれば十分である。 カーネルは新しい形式の呼び出しと"
"古い形式の呼び出しを I<cmd> 内の B<IPC_64> フラグで区別する。"

#. type: Plain text
#: build/C/man2/shmctl.2:520
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<sysvipc>(7)"
msgstr "B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr "SHMGET"

#. type: Plain text
#: build/C/man2/shmget.2:41
msgid "shmget - allocates a System V shared memory segment"
msgstr "shmget - System V 共有メモリーセグメントを割り当てる"

#. type: Plain text
#: build/C/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"

#. type: Plain text
#: build/C/man2/shmget.2:62
#, fuzzy
#| msgid ""
#| "B<shmget>()  returns the identifier of the System\\ V shared memory "
#| "segment associated with the value of the argument I<key>.  A new shared "
#| "memory segment, with size equal to the value of I<size> rounded up to a "
#| "multiple of B<PAGE_SIZE>, is created if I<key> has the value "
#| "B<IPC_PRIVATE> or I<key> isn't B<IPC_PRIVATE>, no shared memory segment "
#| "corresponding to I<key> exists, and B<IPC_CREAT> is specified in "
#| "I<shmflg>."
msgid ""
"B<shmget>()  returns the identifier of the System\\ V shared memory segment "
"associated with the value of the argument I<key>.  It may be used either to "
"obtain the identifier of a previously created shared memory segment (when "
"I<shmflg> is zero and I<key> does not have the value B<IPC_PRIVATE>), or to "
"create a new set."
msgstr ""
"B<shmget>()  は I<key> 引き数に対応する System\\ V 共有メモリーセグメントの識"
"別子を返す。 I<key> の値が B<IPC_PRIVATE> の場合、もしくは I<key> に対応する"
"共有メモリーセグメントが存在せず、 I<shmflg> に B<IPC_CREAT> が指定されていた"
"場合、 新しい共有メモリーセグメントを作成する。 作成される共有メモリーセグメ"
"ントは、 I<size> 引き数の値を B<PAGE_SIZE> の倍数へと切り上げた (round up) 大"
"きさとなる。"

#. type: Plain text
#: build/C/man2/shmget.2:81
msgid ""
"A new shared memory segment, with size equal to the value of I<size> rounded "
"up to a multiple of B<PAGE_SIZE>, is created if I<key> has the value "
"B<IPC_PRIVATE> or I<key> isn't B<IPC_PRIVATE>, no shared memory segment "
"corresponding to I<key> exists, and B<IPC_CREAT> is specified in I<shmflg>."
msgstr "I<key> の値が B<IPC_PRIVATE> の場合、もしくは I<key> に対応する共有メモリーセグメントが存在せず、 I<shmflg> に B<IPC_CREAT> が指定されていた場合、 新しい共有メモリーセグメントを作成する。 作成される共有メモリーセグメントは、 I<size> 引き数の値を B<PAGE_SIZE> の倍数へと切り上げた (round up) 大きさとなる。"

#. type: Plain text
#: build/C/man2/shmget.2:100
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""
"I<shmflg> に B<IPC_CREAT> と B<IPC_EXCL> の両方が指定された場合、 I<key> に対"
"応する共有メモリーセグメントが既に存在すると、 B<shmget>()  は失敗し、 "
"I<errno> に B<EEXIST> が設定される (これは B<open>(2)  に B<O_CREAT | "
"O_EXCL> を指定した場合の動作と同じである)。"

#. type: Plain text
#: build/C/man2/shmget.2:104
msgid "The value I<shmflg> is composed of:"
msgstr "I<shmflg> は以下の内容から構成される:"

#. type: TP
#: build/C/man2/shmget.2:104
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr "B<IPC_CREAT>"

#. type: Plain text
#: build/C/man2/shmget.2:111
msgid ""
"Create a new segment.  If this flag is not used, then B<shmget>()  will find "
"the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""
"新しいセグメントを作成する。このフラグが指定されなかった場合、 B<shmget>()  "
"は I<key> に対応するセグメントを探し、 ユーザーがそのセグメントにアクセスする"
"許可があるかどうかをチェックする。"

#. type: TP
#: build/C/man2/shmget.2:111
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr "B<IPC_EXCL>"

#. type: Plain text
#: build/C/man2/shmget.2:117
msgid ""
"This flag is used with B<IPC_CREAT> to ensure that this call creates the "
"segment.  If the segment already exists, the call fails."
msgstr ""
"このフラグは B<IPC_CREAT> とともに使用し、 この呼び出しで確実にセグメントが作"
"成されるようにする。 セグメントが既に存在した場合には、 呼び出しは失敗する。"

#. type: TP
#: build/C/man2/shmget.2:117
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr "B<SHM_HUGETLB> (Linux 2.6 以降)"

#. type: Plain text
#: build/C/man2/shmget.2:123
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information."
msgstr "\"ヒュージページ (huge page)\" を使うセグメントを割り当てる。詳細な情報は、Linux カーネルソースのファイル I<Documentation/admin-guide/vm/hugetlbpage.rst> を参照。"

#. type: TP
#: build/C/man2/shmget.2:123
#, no-wrap
msgid "B<SHM_HUGE_2MB>, B<SHM_HUGE_1GB> (since Linux 3.8)"
msgstr "B<SHM_HUGE_2MB>, B<SHM_HUGE_1GB> (Linux 3.8 以降)"

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: build/C/man2/shmget.2:130
msgid ""
"Used in conjunction with B<SHM_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:135
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<SHM_HUGE_SHIFT>.  Thus, the above two constants are defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:140
#, no-wrap
msgid ""
"#define SHM_HUGE_2MB    (21 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
"#define SHM_HUGE_1GB    (30 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:146
msgid ""
"For some additional details, see the discussion of the similarly named "
"constants in B<mmap>(2)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:146
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr "B<SHM_NORESERVE> (Linux 2.6.15 以降)"

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: build/C/man2/shmget.2:165
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5)."
msgstr ""
"このフラグは、 B<mmap>(2)  の B<MAP_NORESERVE> フラグと同じ役割を果たす。 こ"
"のセグメントに対するスワップ空間の予約を行わない。 スワップ空間を予約した場合"
"は、そのセグメントの変更が必ず成功することが 保証される。スワップ空間の予約を"
"行わなかった場合は、物理メモリーに空きが ないと書き込み時に B<SIGSEGV> を受け"
"取る可能性がある。 B<proc>(5)  にある I</proc/sys/vm/overcommit_memory> ファ"
"イルに関する議論も参照のこと。"

#. type: Plain text
#: build/C/man2/shmget.2:175
msgid ""
"In addition to the above flags, the least significant 9 bits of I<shmflg> "
"specify the permissions granted to the owner, group, and others.  These bits "
"have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2).  Presently, execute permissions are not used by the system."
msgstr ""
"上記のフラグに加えて、 I<shmflg> の下位 9 ビットは、所有者、グループ、その他"
"への許可を指定する。 これらのビットは B<open>(2)  の I<mode> 引き数と同じ形式"
"で同じ意味を持つ。 今のところ、システムは実行 (execute) 許可を参照しない。"

#. type: Plain text
#: build/C/man2/shmget.2:183
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr ""
"共有メモリーセグメントが新たに作成される際、 共有メモリーセグメントの内容は "
"0 で初期化され、 関連情報を保持するデータ構造体 I<shmid_ds> は以下のように初"
"期化される。"

#. type: IP
#: build/C/man2/shmget.2:183 build/C/man2/shmget.2:188
#: build/C/man2/shmget.2:193 build/C/man2/shmget.2:198
#: build/C/man2/shmget.2:202 build/C/man2/shmget.2:209 build/C/man2/shmop.2:61
#: build/C/man2/shmop.2:67 build/C/man2/shmop.2:79 build/C/man2/shmop.2:129
#: build/C/man2/shmop.2:132 build/C/man2/shmop.2:135 build/C/man2/shmop.2:156
#: build/C/man2/shmop.2:159 build/C/man2/shmop.2:162
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man2/shmget.2:188
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"I<shm_perm.cuid> と I<shm_perm.uid> に呼び出し元プロセスの実効 (effective) "
"ユーザーID を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:193
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"I<shm_perm.cgid> と I<shm_perm.gid> に呼び出し元プロセスの実効グループID を設"
"定する。"

#. type: Plain text
#: build/C/man2/shmget.2:198
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""
"I<shm_perm.mode> の下位 9 ビットに I<shmflg> の下位 9 ビットを設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:202
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr "I<shm_segsz> に I<size> の値を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:209
msgid ""
"I<shm_lpid>, I<shm_nattch>, I<shm_atime>, and I<shm_dtime> are set to 0."
msgstr ""
"I<shm_lpid>, I<shm_nattch>, I<shm_atime>, I<shm_dtime> に 0 を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:212
msgid "I<shm_ctime> is set to the current time."
msgstr "I<shm_ctime> に現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:215
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""
"共有メモリーセグメントが既に存在する場合、アクセス許可の検査と、 破壊 "
"(destruction) マークがつけられていないかのチェックが行われる。"

#. type: Plain text
#: build/C/man2/shmget.2:220
msgid ""
"On success, a valid shared memory identifier is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the error."
msgstr ""
"成功の場合、有効な共有メモリーセグメントの識別子が返される。 エラーの場合、 "
"-1 が返り、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/shmget.2:224
msgid "On failure, I<errno> is set to one of the following:"
msgstr "失敗した場合は I<errno> が以下のどれかに設定される:"

#. type: Plain text
#: build/C/man2/shmget.2:230
#, fuzzy
#| msgid ""
#| "The user does not have permission to access the shared memory segment, "
#| "and does not have the B<CAP_IPC_OWNER> capability."
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""
"ユーザーはその共有メモリーセグメントへのアクセス許可を持たず、 "
"B<CAP_IPC_OWNER> ケーパビリティも持っていない。"

#. type: Plain text
#: build/C/man2/shmget.2:239
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<shmflg>, but a shared "
"memory segment already exists for I<key>."
msgstr ""
"B<IPC_CREAT> と B<IPC_EXCL> が I<shmflg> に指定されたが、 I<key> に対応する共"
"有メモリーセグメントはすでに存在する。"

#. type: Plain text
#: build/C/man2/shmget.2:247
msgid ""
"A new segment was to be created and I<size> is less than B<SHMMIN> or "
"greater than B<SHMMAX>."
msgstr ""
"新しいセグメントを作成しようとしたが、 I<size> が B<SHMMIN> より小さいか "
"B<SHMMAX> よりも大きかった。"

#. type: Plain text
#: build/C/man2/shmget.2:253
msgid ""
"A segment for the given I<key> exists, but I<size> is greater than the size "
"of that segment."
msgstr ""
"指定された I<key> に対応するセグメントが既に存在するが、 I<size> がそのセグメ"
"ントのサイズよりも大きかった。"

#. type: Plain text
#: build/C/man2/shmget.2:262
msgid ""
"No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr ""
"指定された I<key> に対応するセグメントが存在せず、 B<IPC_CREAT> も指定されて"
"いなかった。"

#. type: Plain text
#: build/C/man2/shmget.2:265
msgid "No memory could be allocated for segment overhead."
msgstr "セグメントの管理情報 (overhead) に割り当てるメモリーがなかった。"

#. type: Plain text
#: build/C/man2/shmget.2:273
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the system-"
"wide limit on shared memory (B<SHMALL>)."
msgstr ""
"システム全体の共有メモリーセグメント数の制限 (B<SHMMNI>)  に達した、または要"
"求された I<size> のセグメントの割り当てが システム全体の共有メモリーサイズの"
"制限 (B<SHMALL>)  を超過した。"

#. type: Plain text
#: build/C/man2/shmget.2:280
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""
"B<SHM_HUGETLB> フラグが指定されたが、呼び出し元には権限がなかった "
"(B<CAP_IPC_LOCK> ケーパビリティを持っていなかった)。"

#. type: Plain text
#: build/C/man2/shmget.2:288
msgid "B<SHM_HUGETLB> and B<SHM_NORESERVE> are Linux extensions."
msgstr "B<SHM_HUGETLB> と B<SHM_NORESERVE> は Linux での拡張である。"

#. type: Plain text
#: build/C/man2/shmget.2:312
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment."
msgstr ""
"B<IPC_PRIVATE> はフラグではなく I<key_t> 型である。 この特別な値が I<key> に"
"使用された場合は、 B<shmget>()  は I<shmflg> の下位 9 ビットを除いた全てを無"
"視し、 新しい共有メモリーセグメントを作成する。"

#. type: SS
#: build/C/man2/shmget.2:312
#, no-wrap
msgid "Shared memory limits"
msgstr "共有メモリーの上限"

#. type: Plain text
#: build/C/man2/shmget.2:316
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr ""
"B<shmget>()  コールに影響する共有メモリーセグメント資源の制限は以下の通りであ"
"る:"

#. type: TP
#: build/C/man2/shmget.2:316
#, no-wrap
msgid "B<SHMALL>"
msgstr "B<SHMALL>"

#. type: Plain text
#: build/C/man2/shmget.2:320
msgid ""
"System-wide limit on the total amount of shared memory, measured in units of "
"the system page size."
msgstr ""
"共有メモリーの全使用量のシステム全体での上限値。 システムページサイズが単位で"
"ある。"

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: build/C/man2/shmget.2:326
msgid ""
"On Linux, this limit can be read and modified via I</proc/sys/kernel/"
"shmall>.  Since Linux 3.16, the default value for this limit is:"
msgstr ""
"Linux では、この上限値は I</proc/sys/kernel/shmall> 経由で参照したり、変更し"
"たりできる。 Linux 3.16 以降では、 この上限値のデフォルト値は以下のとおりであ"
"る。"

#. type: Plain text
#: build/C/man2/shmget.2:328 build/C/man2/shmget.2:363
#, no-wrap
msgid "    ULONG_MAX - 2^24\n"
msgstr "    ULONG_MAX - 2^24\n"

#. type: Plain text
#: build/C/man2/shmget.2:339
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  This value, rather "
"than B<ULONG_MAX>, was chosen as the default to prevent some cases where "
"historical applications simply raised the existing limit without first "
"checking its current value.  Such applications would cause the value to "
"overflow if the limit was set at B<ULONG_MAX>."
msgstr ""
"この値は割り当てに関する上限としては適用されない (なお、この値は 32 ビットシ"
"ステムにも 64 ビットシステムにも適したものになっている)。 B<ULONG_MAX> ではな"
"く、この値が選ばれたのは、 古いアプリケーションが最初に現在の値を確認せずに既"
"存の上限をそのまま増やしてしまっても問題が起こらないようなデフォルト値を選ん"
"だからである。 このようなアプリケーションでは、 上限を B<ULONG_MAX> に設定す"
"ると値がオーバーフローしてしまうことになる。"

#. type: Plain text
#: build/C/man2/shmget.2:342
msgid "From Linux 2.4 up to Linux 3.15, the default value for this limit was:"
msgstr "Linux 2.4 から Linux 3.15 では、この上限のデフォルト値は以下であった。"

#. type: Plain text
#: build/C/man2/shmget.2:344
#, no-wrap
msgid "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"
msgstr "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"

#. type: Plain text
#: build/C/man2/shmget.2:352
msgid ""
"If B<SHMMAX> and B<SHMMNI> were not modified, then multiplying the result of "
"this formula by the page size (to get a value in bytes) yielded a value of "
"8\\ GB as the limit on the total memory used by all shared memory segments."
msgstr "B<SHMMAX> と B<SHMMNI> が変更されないとすると、 この式の結果に (バイト単位の値を得るために) ページサイズを掛け算すると、 全ての共有メモリーセグメントで使用される全メモリーの上限として、 8\\ GB という値が得られる。"

#. type: TP
#: build/C/man2/shmget.2:352
#, no-wrap
msgid "B<SHMMAX>"
msgstr "B<SHMMAX>"

#. type: Plain text
#: build/C/man2/shmget.2:355
msgid "Maximum size in bytes for a shared memory segment."
msgstr "1 つの共有メモリーセグメントの最大サイズ (バイト数)。"

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: build/C/man2/shmget.2:361
msgid ""
"On Linux, this limit can be read and modified via I</proc/sys/kernel/"
"shmmax>.  Since Linux 3.16, the default value for this limit is:"
msgstr ""
"Linux では、この上限値は I</proc/sys/kernel/shmmax> 経由で参照したり、変更し"
"たりできる。 Linux 3.16 以降では、 この上限値のデフォルト値は以下のとおりであ"
"る。"

#. type: Plain text
#: build/C/man2/shmget.2:372
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  See the description of "
"B<SHMALL> for a discussion of why this default value (rather than "
"B<ULONG_MAX>)  is used."
msgstr ""
"この値は割り当てに関する上限としては適用されない (なお、この値は 32 ビットシ"
"ステムにも 64 ビットシステムにも適したものになっている)。 (B<ULONG_MAX> では"
"なく) このデフォルト値が使われている理由については B<SHMALL> の説明を参照。"

#. type: Plain text
#: build/C/man2/shmget.2:375
msgid ""
"From Linux 2.2 up to Linux 3.15, the default value of this limit was "
"0x2000000 (32\\ MB)."
msgstr "Linux 2.2 から Linux 3.15 までは、この上限値のデフォルト値は 0x2000000 (32\\ MB) であった。"

#. type: Plain text
#: build/C/man2/shmget.2:381
msgid ""
"Because it is not possible to map just part of a shared memory segment, the "
"amount of virtual memory places another limit on the maximum size of a "
"usable segment: for example, on i386 the largest segments that can be mapped "
"have a size of around 2.8\\ GB, and on x86-64 the limit is around 127 TB."
msgstr "共有メモリーセグメントの一部分だけをマッピングすることはできないので、 使用可能なセグメントの最大サイズには仮想メモリーの総量という別の上限が適用される。 例えば、i386 ではマッピング可能な最大セグメントの大きさはおおよそ 2.8\\ GB で、 x86-64 では上限はおおよそ 127TB である。"

#. type: TP
#: build/C/man2/shmget.2:381
#, no-wrap
msgid "B<SHMMIN>"
msgstr "B<SHMMIN>"

#. type: Plain text
#: build/C/man2/shmget.2:387
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""
"共有メモリーセグメントのバイト単位の大きさの下限: 実装依存 (現在は 1 バイトだ"
"が、実質的な最小サイズは B<PAGE_SIZE> である)。"

#. type: TP
#: build/C/man2/shmget.2:387
#, no-wrap
msgid "B<SHMMNI>"
msgstr "B<SHMMNI>"

#. type: Plain text
#: build/C/man2/shmget.2:392
msgid ""
"System-wide limit on the number of shared memory segments.  In Linux 2.2, "
"the default value for this limit was 128; since Linux 2.4, the default value "
"is 4096."
msgstr ""
"システム全体の共有メモリーセグメント数の上限値。 この上限値のデフォルトは、 "
"Linux 2.2 以降では 128、 Linux 2.4 以降で 4096 である。"

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: build/C/man2/shmget.2:398
msgid ""
"On Linux, this limit can be read and modified via I</proc/sys/kernel/shmmni>."
msgstr ""
"Linux では、この上限値は I</proc/sys/kernel/shmmni> 経由で参照したり、変更し"
"たりできる。"

#. type: Plain text
#: build/C/man2/shmget.2:402
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""
"プロセス当りの共有メモリーセグメントの個数の最大値 (B<SHMSEG>)  に関する実装"
"上の制限はない。"

#. type: Plain text
#: build/C/man2/shmget.2:408
msgid ""
"Until version 2.3.30, Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""
"バージョン 2.3.30 までは、Linux は 削除が予定されている共有メモリーセグメント"
"に対して B<shmget>()  が行われると B<EIDRM> を返していた。"

#. type: Plain text
#: build/C/man2/shmget.2:414
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""
"B<IPC_PRIVATE> という名前を選んだのはおそらく失敗であろう。 B<IPC_NEW> の方が"
"より明確にその機能を表しているだろう。"

#. type: Plain text
#: build/C/man2/shmget.2:417
msgid "See B<shmop>(2)."
msgstr "B<shmop>(2) を参照。"

#. type: Plain text
#: build/C/man2/shmget.2:426
msgid ""
"B<memfd_create>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), "
"B<capabilities>(7), B<shm_overview>(7), B<sysvipc>(7)"
msgstr "B<memfd_create>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), B<shm_overview>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/shmop.2:40
#, no-wrap
msgid "SHMOP"
msgstr "SHMOP"

#. type: Plain text
#: build/C/man2/shmop.2:43
msgid "shmat, shmdt - System V shared memory operations"
msgstr "shmat, shmdt - System V 共有メモリー (shared memory) の操作"

#. type: Plain text
#: build/C/man2/shmop.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/shmop.2:49
#, no-wrap
msgid "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"
msgstr "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"

#. type: Plain text
#: build/C/man2/shmop.2:51
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr "B<int shmdt(const void *>I<shmaddr>B<);>\n"

#. type: SS
#: build/C/man2/shmop.2:53
#, no-wrap
msgid "shmat()"
msgstr "shmat()"

#. type: Plain text
#: build/C/man2/shmop.2:61
msgid ""
"B<shmat>()  attaches the System\\ V shared memory segment identified by "
"I<shmid> to the address space of the calling process.  The attaching address "
"is specified by I<shmaddr> with one of the following criteria:"
msgstr ""
"B<shmat>()  は I<shmid> で指定された System\\ V 共有メモリーセグメント "
"(shared memory segment) を コールしたプロセスのアドレス空間に付加 (attach) す"
"る。 付加するアドレスは I<shmaddr> に以下のどれかの形式で指定する:"

#. type: Plain text
#: build/C/man2/shmop.2:67
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) page-aligned "
"address to attach the segment."
msgstr "I<shmaddr> が NULL ならば、システムはセグメントを付加するための 適切な (使用されていない) ページ境界のアドレスを選択する。"

#. type: Plain text
#: build/C/man2/shmop.2:79
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>."
msgstr ""
"I<shmaddr> が NULL でなく B<SHM_RND> が I<shmflg> に指定されている場合は、 "
"I<shmaddr> を B<SHMLBA> の倍数へと切り捨てた (rounding down) のと等しいアドレ"
"スへ付加する。"

#. type: Plain text
#: build/C/man2/shmop.2:83
msgid ""
"Otherwise, I<shmaddr> must be a page-aligned address at which the attach "
"occurs."
msgstr ""
"その他の場合は I<shmaddr> は付加を行なうアドレスで、ページ境界を指している必"
"要がある。"

#. type: Plain text
#: build/C/man2/shmop.2:89
msgid ""
"In addition to B<SHM_RND>, the following flags may be specified in the "
"I<shmflg> bit-mask argument:"
msgstr ""
"B<SHM_RND> に加えて、以下のフラグを I<shmflg> ビットマスク引き数に指定でき"
"る。"

#. type: TP
#: build/C/man2/shmop.2:89
#, no-wrap
msgid "B<SHM_EXEC> (Linux-specific; since Linux 2.6.9)"
msgstr "B<SHM_EXEC> (Linux 固有; Linux 2.6.9 以降)"

#. type: Plain text
#: build/C/man2/shmop.2:93
msgid ""
"Allow the contents of the segment to be executed.  The caller must have "
"execute permission on the segment."
msgstr ""
"セグメントの内容を実行できる。 呼び出し元はセグメントに対する実行許可を持って"
"いなければならない。"

#. type: TP
#: build/C/man2/shmop.2:93
#, no-wrap
msgid "B<SHM_RDONLY>"
msgstr "B<SHM_RDONLY>"

#. type: Plain text
#: build/C/man2/shmop.2:101
msgid ""
"Attach the segment for read-only access.  The process must have read "
"permission for the segment.  If this flag is not specified, the segment is "
"attached for read and write access, and the process must have read and write "
"permission for the segment.  There is no notion of a write-only shared "
"memory segment."
msgstr ""
"セグメントを読み込み専用に付加する。 プロセスはそのセグメントへの読み込み許可"
"を持っていなければならない。 このフラグが指定されなかった場合、そのセグメント"
"は読み込みと書き込みアクセスのために付加され、 プロセスはそのセグメントに読み"
"込みと書き込みの許可を持っていなければならない。 書き込み専用の共有メモリーセ"
"グメントという概念は存在しない。"

#. type: TP
#: build/C/man2/shmop.2:101
#, no-wrap
msgid "B<SHM_REMAP> (Linux-specific)"
msgstr "B<SHM_REMAP> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmop.2:114
msgid ""
"This flag specifies that the mapping of the segment should replace any "
"existing mapping in the range starting at I<shmaddr> and continuing for the "
"size of the segment.  (Normally, an B<EINVAL> error would result if a "
"mapping already exists in this address range.)  In this case, I<shmaddr> "
"must not be NULL."
msgstr ""
"このフラグは、 セグメントのマッピングを既存のマッピングに置き換えることを指示"
"する。 マッピングの範囲は、 I<shmaddr> から始まりセグメントのサイズ分だけあ"
"る (通常 B<EINVAL> エラーは、このアドレス範囲にマッピングが既に存在するために"
"起る)。 このフラグを指定する場合は、 I<shmaddr> が NULL であってはならない。"

#. type: Plain text
#: build/C/man2/shmop.2:121
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""
"呼び出したプロセスの B<brk>(2)  の値は付加によって変化しない。 そのセグメント"
"はプロセスが終了 (exit) したら自動的に分離 (detach) される。 同じセグメントを"
"プロセスのアドレス空間に、読み込み専用および読み書き両用 として付加でき、また"
"複数回付加することもできる。"

#. type: Plain text
#: build/C/man2/shmop.2:129
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""
"成功した B<shmat>()  コールは共有メモリーセグメントに関連する I<shmid_ds> 構"
"造体 (B<shmctl>(2)  を参照) のメンバーを以下のように更新する:"

#. type: Plain text
#: build/C/man2/shmop.2:132
msgid "I<shm_atime> is set to the current time."
msgstr "I<shm_atime> には現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/shmop.2:135 build/C/man2/shmop.2:162
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr "I<shm_lpid> には呼び出したプロセスのプロセス ID が設定される。"

#. type: Plain text
#: build/C/man2/shmop.2:139
msgid "I<shm_nattch> is incremented by one."
msgstr "I<shm_nattch> を 1 増加させる。"

#. type: SS
#: build/C/man2/shmop.2:139
#, no-wrap
msgid "shmdt()"
msgstr "shmdt()"

#. type: Plain text
#: build/C/man2/shmop.2:150
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""
"B<shmdt>()  は呼び出したプロセスのアドレス空間から I<shmaddr> で指定されたア"
"ドレスに配置された共有メモリーセグメントを分離 (detach) する。 分離する共有メ"
"モリーセグメントは、現在 I<shmaddr> に付加されているものでなければならない。 "
"I<shmaddr> は、それを付加した時に B<shmat>()  が返した値に等しくなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/shmop.2:156
msgid ""
"On a successful B<shmdt>()  call, the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""
"成功した B<shmdt>()  コールはその共有メモリーセグメントに関連する "
"I<shmid_ds> 構造体のメンバーを以下のように更新する:"

#. type: Plain text
#: build/C/man2/shmop.2:159
msgid "I<shm_dtime> is set to the current time."
msgstr "I<shm_dtime> には現在の時刻が設定される。"

#. type: Plain text
#: build/C/man2/shmop.2:167
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""
"I<shm_nattch> を 1 減少させる。 もし 0 になり、削除マークがあった場合は その"
"セグメントは削除される。"

#. type: Plain text
#: build/C/man2/shmop.2:175
msgid ""
"On success, B<shmat>()  returns the address of the attached shared memory "
"segment; on error, I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""
"B<shmat>()  は、成功した場合、 付加された共有メモリーセグメントのアドレスを返"
"す。 エラーの場合、 I<(void\\ *)\\ -1> を返し、 I<errno> にエラーの原因を示す"
"値を設定する。"

#. type: Plain text
#: build/C/man2/shmop.2:181
msgid ""
"On success, B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""
"B<shmdt>()  は、成功すると 0 を返す。 エラーの場合、-1 を返し、 I<errno> にエ"
"ラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/shmop.2:187
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""
"B<shmat>()  が失敗した場合、 I<errno> に以下の値のどれかを設定して返す:"

#. type: Plain text
#: build/C/man2/shmop.2:193
#, fuzzy
#| msgid ""
#| "The calling process does not have the required permissions for the "
#| "requested attach type, and does not have the B<CAP_IPC_OWNER> capability."
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability in the user "
"namespace that governs its IPC namespace."
msgstr ""
"呼び出したプロセスに要求された種類の付加に必要な許可がなく、 "
"B<CAP_IPC_OWNER> ケーパビリティ (capability) がない。"

#. type: Plain text
#: build/C/man2/shmop.2:210
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""
"I<shmid> の値が不正である。 I<shmaddr> の値が境界違反 (unaligned) (つまり、"
"ページ境界に合っておらず、 B<SHM_RND> が指定されていない) または が不正であ"
"る。 I<shmaddr> へのセグメントの付加に失敗した。 または B<SHM_REMAP> が指定さ"
"れているが、 I<shmaddr> が NULL であった。"

#. type: Plain text
#: build/C/man2/shmop.2:213
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr ""
"ディスクリプター (descriptor) やページテーブルのためのメモリーを 割り当てるこ"
"とができない。"

#. type: Plain text
#: build/C/man2/shmop.2:219
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr "B<shmdt>()  が失敗した場合、 B<EINVAL> は以下のようにセットされる:"

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: build/C/man2/shmop.2:227
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""
"I<shmaddr> に付加された共有メモリーセグメントが存在しない。 もしくは、 "
"I<shmaddr> がページ境界に合っていない。"

#. type: Plain text
#: build/C/man2/shmop.2:242
msgid ""
"In SVID 3 (or perhaps earlier), the type of the I<shmaddr> argument was "
"changed from I<char\\ *> into I<const void\\ *>, and the returned type of "
"B<shmat>()  from I<char\\ *> into I<void\\ *>."
msgstr ""
"SVID 3 で (たぶんそれより前だと思うが)  I<shmaddr> 引き数の型は I<char\\ *> "
"から I<const void\\ *> に、I<shmat>() の返り値の型は I<char\\ *> から I<void"
"\\ *> に変更された。"

#. type: Plain text
#: build/C/man2/shmop.2:246
msgid ""
"After a B<fork>(2), the child inherits the attached shared memory segments."
msgstr ""
"B<fork>(2)  した後、子プロセスは付加された共有メモリーセグメントを継承する。"

#. type: Plain text
#: build/C/man2/shmop.2:250
msgid ""
"After an B<execve>(2), all attached shared memory segments are detached from "
"the process."
msgstr ""
"B<exec>(2)  した後、全ての付加された共有メモリーセグメントはプロセスから分離"
"される。"

#. type: Plain text
#: build/C/man2/shmop.2:254
msgid ""
"Upon B<_exit>(2), all attached shared memory segments are detached from the "
"process."
msgstr ""
"B<exit>(2)  において、全ての付加された共有メモリーセグメントはプロセスから分"
"離される。"

#. type: Plain text
#: build/C/man2/shmop.2:266
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""
"共有メモリーセグメントを付加する場合の移植性の高い方法としては、 I<shmaddr> "
"を NULL にして B<shmat>()  を使用するのがよい。 このような方法で付加される共"
"有メモリーセグメントは、 プロセスが異なれば別のアドレスに付加される、という点"
"に注意すること。 よって共有メモリー内で管理されるポインターは、 絶対アドレス"
"ではなく、 (一般的にはセグメントの開始アドレスからの)  相対アドレスで作成する"
"べきである。"

#. type: Plain text
#: build/C/man2/shmop.2:271
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1 does not specify this "
"behavior and many other implementations do not support it."
msgstr "Linux では共有メモリーセグメントに既に削除マークが付けられていても、 その共有メモリーセグメントを付加することができる。 しかし POSIX.1 ではこのような動作を指定しておらず、 他の多くの実装もこれをサポートしていない。"

#. type: Plain text
#: build/C/man2/shmop.2:274
msgid "The following system parameter affects B<shmat>():"
msgstr "以下のシステムパラメーターは、 B<shmat>()  に影響する:"

#. type: TP
#: build/C/man2/shmop.2:274
#, no-wrap
msgid "B<SHMLBA>"
msgstr "B<SHMLBA>"

#. type: Plain text
#: build/C/man2/shmop.2:289
msgid ""
"Segment low boundary address multiple.  When explicitly specifying an attach "
"address in a call to B<shmat>(), the caller should ensure that the address "
"is a multiple of this value.  This is necessary on some architectures, in "
"order either to ensure good CPU cache performance or to ensure that "
"different attaches of the same segment have consistent views within the CPU "
"cache.  B<SHMLBA> is normally some multiple of the system page size.  (On "
"many Linux architectures, B<SHMLBA> is the same as the system page size.)"
msgstr "セグメントの下限アドレス倍数 (Segment low boundary address multiple)。 B<shmat>() の呼び出しにおいて付加するアドレスを明示的に指定する際、 呼び出し元は指定するアドレスがこの値の倍数になるように保証しなければならない。 これはいくつかのアーキテクチャーでは必要なことで、 CPU キャッシュの性能を保証するためであったり、 同じセグメントの別の付与を CPU キャッシュ内部で一貫して扱えるようにするためだったりする。 B<SHMLBA> は通常はシステムページサイズの倍数である (Linux の多くのアーキテクチャーでは B<SHMLBA> はシステムページサイズと同じである)。"

#. type: Plain text
#: build/C/man2/shmop.2:293
msgid ""
"The implementation places no intrinsic per-process limit on the number of "
"shared memory segments (B<SHMSEG>)."
msgstr ""
"現在の実装では、プロセスごとの 共有メモリーセグメントの最大数 (B<SHMSEG>)  に"
"関する実装依存の制限はない。"

#. type: Plain text
#: build/C/man2/shmop.2:297
msgid ""
"The two programs shown below exchange a string using a shared memory "
"segment.  Further details about the programs are given below.  First, we "
"show a shell session demonstrating their use."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:302
msgid ""
"In one terminal window, we run the \"reader\" program, which creates a "
"System V shared memory segment and a System V semaphore set.  The program "
"prints out the IDs of the created objects, and then waits for the semaphore "
"to change value."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:307
#, no-wrap
msgid ""
"$ B<./svshm_string_read>\n"
"shmid = 1114194; semid = 15\n"
msgstr ""
"$ B<./svshm_string_read>\n"
"shmid = 1114194; semid = 15\n"

#. type: Plain text
#: build/C/man2/shmop.2:316
msgid ""
"In another terminal window, we run the \"writer\" program.  The \"writer\" "
"program takes three command-line arguments: the IDs of the shared memory "
"segment and semaphore set created by the \"reader\", and a string.  It "
"attaches the existing shared memory segment, copies the string to the shared "
"memory, and modifies the semaphore value."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:320
#, no-wrap
msgid "$ B<./svshm_string_write 1114194 15 \\(aqHello, world\\(aq>\n"
msgstr "$ B<./svshm_string_write 1114194 15 \\(aqHello, world\\(aq>\n"

#. type: Plain text
#: build/C/man2/shmop.2:327
msgid ""
"Returning to the terminal where the \"reader\" is running, we see that the "
"program has ceased waiting on the semaphore and has printed the string that "
"was copied into the shared memory segment by the writer:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:331
#, no-wrap
msgid "Hello, world\n"
msgstr "Hello, world\n"

#. type: SS
#: build/C/man2/shmop.2:334
#, no-wrap
msgid "Program source: svshm_string.h"
msgstr "プログラムのソース: svshm_string.h"

#. type: Plain text
#: build/C/man2/shmop.2:336
msgid ""
"The following header file is included by the \"reader\" and \"writer\" "
"programs."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:346
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/shm.hE<gt>\n"
"#include E<lt>sys/sem.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/shm.hE<gt>\n"
"#include E<lt>sys/sem.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/shmop.2:358
#, no-wrap
msgid ""
"union semun {                   /* Used in calls to semctl() */\n"
"    int                 val;\n"
"    struct semid_ds *   buf;\n"
"    unsigned short *    array;\n"
"#if defined(__linux__)\n"
"    struct seminfo *    __buf;\n"
"#endif\n"
"};\n"
msgstr ""
"union semun {                   /* Used in calls to semctl() */\n"
"    int                 val;\n"
"    struct semid_ds *   buf;\n"
"    unsigned short *    array;\n"
"#if defined(__linux__)\n"
"    struct seminfo *    __buf;\n"
"#endif\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmop.2:360
#, no-wrap
msgid "#define MEM_SIZE 4096\n"
msgstr "#define MEM_SIZE 4096\n"

#. type: SS
#: build/C/man2/shmop.2:363
#, no-wrap
msgid "Program source: svshm_string_read.c"
msgstr "プログラムのソース: svshm_string_read.c"

#. type: Plain text
#: build/C/man2/shmop.2:371
msgid ""
"The \"reader\" program creates a shared memory segment and a semaphore set "
"containing one semaphore.  It then attaches the shared memory object into "
"its address space and initializes the semaphore value to 1.  Finally, the "
"program waits for the semaphore value to become 0, and afterwards prints the "
"string that has been copied into the shared memory segment by the \"writer\"."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:375
#, no-wrap
msgid "/* svshm_string_read.c\n"
msgstr "/* svshm_string_read.c\n"

#. type: Plain text
#: build/C/man2/shmop.2:379 build/C/man2/shmop.2:453
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include \"svshm_string.h\"\n"
msgstr ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include \"svshm_string.h\"\n"

#. type: Plain text
#: build/C/man2/shmop.2:387
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, shmid;\n"
"    union semun arg, dummy;\n"
"    struct sembuf sop;\n"
"    char *addr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, shmid;\n"
"    union semun arg, dummy;\n"
"    struct sembuf sop;\n"
"    char *addr;\n"

#. type: Plain text
#: build/C/man2/shmop.2:390
#, no-wrap
msgid ""
"    /* Create shared memory and semaphore set containing one\n"
"       semaphore */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:394
#, no-wrap
msgid ""
"    shmid = shmget(IPC_PRIVATE, MEM_SIZE, IPC_CREAT | 0600);\n"
"    if (shmid == -1)\n"
"        errExit(\"shmget\");\n"
msgstr ""
"    shmid = shmget(IPC_PRIVATE, MEM_SIZE, IPC_CREAT | 0600);\n"
"    if (shmid == -1)\n"
"        errExit(\"shmget\");\n"

#. type: Plain text
#: build/C/man2/shmop.2:398
#, no-wrap
msgid ""
"    semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0600);\n"
"    if (shmid == -1)\n"
"        errExit(\"shmget\");\n"
msgstr ""
"    semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0600);\n"
"    if (shmid == -1)\n"
"        errExit(\"shmget\");\n"

#. type: Plain text
#: build/C/man2/shmop.2:400
#, no-wrap
msgid "    /* Attach shared memory into our address space */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:404
#, no-wrap
msgid ""
"    addr = shmat(shmid, NULL, SHM_RDONLY);\n"
"    if (addr == (void *) -1)\n"
"        errExit(\"shmat\");\n"
msgstr ""
"    addr = shmat(shmid, NULL, SHM_RDONLY);\n"
"    if (addr == (void *) -1)\n"
"        errExit(\"shmat\");\n"

#. type: Plain text
#: build/C/man2/shmop.2:406
#, no-wrap
msgid "    /* Initialize semaphore 0 in set with value 1 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:410
#, no-wrap
msgid ""
"    arg.val = 1;\n"
"    if (semctl(semid, 0, SETVAL, arg) == -1)\n"
"        errExit(\"semctl\");\n"
msgstr ""
"    arg.val = 1;\n"
"    if (semctl(semid, 0, SETVAL, arg) == -1)\n"
"        errExit(\"semctl\");\n"

#. type: Plain text
#: build/C/man2/shmop.2:412
#, no-wrap
msgid "    printf(\"shmid = %d; semid = %d\\en\", shmid, semid);\n"
msgstr "    printf(\"shmid = %d; semid = %d\\en\", shmid, semid);\n"

#. type: Plain text
#: build/C/man2/shmop.2:414
#, no-wrap
msgid "    /* Wait for semaphore value to become 0 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:418
#, no-wrap
msgid ""
"    sop.sem_num = 0;\n"
"    sop.sem_op = 0;\n"
"    sop.sem_flg = 0;\n"
msgstr ""
"    sop.sem_num = 0;\n"
"    sop.sem_op = 0;\n"
"    sop.sem_flg = 0;\n"

#. type: Plain text
#: build/C/man2/shmop.2:421 build/C/man2/shmop.2:495
#, no-wrap
msgid ""
"    if (semop(semid, &sop, 1) == -1)\n"
"        errExit(\"semop\");\n"
msgstr ""
"    if (semop(semid, &sop, 1) == -1)\n"
"        errExit(\"semop\");\n"

#. type: Plain text
#: build/C/man2/shmop.2:423
#, no-wrap
msgid "    /* Print the string from shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:425
#, no-wrap
msgid "    printf(\"%s\\en\", addr);\n"
msgstr "    printf(\"%s\\en\", addr);\n"

#. type: Plain text
#: build/C/man2/shmop.2:427
#, no-wrap
msgid "    /* Remove shared memory and semaphore set */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:432
#, no-wrap
msgid ""
"    if (shmctl(shmid, IPC_RMID, NULL) == -1)\n"
"        errExit(\"shmctl\");\n"
"    if (semctl(semid, 0, IPC_RMID, dummy) == -1)\n"
"        errExit(\"semctl\");\n"
msgstr ""
"    if (shmctl(shmid, IPC_RMID, NULL) == -1)\n"
"        errExit(\"shmctl\");\n"
"    if (semctl(semid, 0, IPC_RMID, dummy) == -1)\n"
"        errExit(\"semctl\");\n"

#. type: SS
#: build/C/man2/shmop.2:438
#, no-wrap
msgid "Program source: svshm_string_write.c"
msgstr "プログラムのソース: svshm_string_write.c"

#. type: Plain text
#: build/C/man2/shmop.2:445
msgid ""
"The writer program takes three command-line arguments: the IDs of the shared "
"memory segment and semaphore set that have already been created by the "
"\"reader\", and a string.  It attaches the shared memory segment into its "
"address space, and then decrements the semaphore value to 0 in order to "
"inform the \"reader\" that it can now examine the contents of the shared "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:449
#, no-wrap
msgid "/* svshm_string_write.c\n"
msgstr "/* svshm_string_write.c\n"

#. type: Plain text
#: build/C/man2/shmop.2:461
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, shmid;\n"
"    struct sembuf sop;\n"
"    char *addr;\n"
"    size_t len;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, shmid;\n"
"    struct sembuf sop;\n"
"    char *addr;\n"
"    size_t len;\n"

#. type: Plain text
#: build/C/man2/shmop.2:466
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s shmid semid string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s shmid semid string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/shmop.2:472
#, no-wrap
msgid ""
"    len = strlen(argv[3]) + 1;  /* +1 to include trailing \\(aq\\e0\\(aq */\n"
"    if (len E<gt> MEM_SIZE) {\n"
"        fprintf(stderr, \"String is too big!\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    len = strlen(argv[3]) + 1;  /* +1 to include trailing \\(aq\\e0\\(aq */\n"
"    if (len E<gt> MEM_SIZE) {\n"
"        fprintf(stderr, \"String is too big!\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/shmop.2:474
#, no-wrap
msgid "    /* Get object IDs from command-line */\n"
msgstr "    /* Get object IDs from command-line */\n"

#. type: Plain text
#: build/C/man2/shmop.2:477
#, no-wrap
msgid ""
"    shmid = atoi(argv[1]);\n"
"    semid = atoi(argv[2]);\n"
msgstr ""
"    shmid = atoi(argv[1]);\n"
"    semid = atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man2/shmop.2:480
#, no-wrap
msgid ""
"    /* Attach shared memory into our address space and copy string\n"
"       (including trailing null byte) into memory. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:484
#, no-wrap
msgid ""
"    addr = shmat(shmid, NULL, 0);\n"
"    if (addr == (void *) -1)\n"
"        errExit(\"shmat\");\n"
msgstr ""
"    addr = shmat(shmid, NULL, 0);\n"
"    if (addr == (void *) -1)\n"
"        errExit(\"shmat\");\n"

#. type: Plain text
#: build/C/man2/shmop.2:486
#, no-wrap
msgid "    memcpy(addr, argv[3], len);\n"
msgstr "    memcpy(addr, argv[3], len);\n"

#. type: Plain text
#: build/C/man2/shmop.2:488
#, no-wrap
msgid "    /* Decrement semaphore to 0 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:492
#, no-wrap
msgid ""
"    sop.sem_num = 0;\n"
"    sop.sem_op = -1;\n"
"    sop.sem_flg = 0;\n"
msgstr ""
"    sop.sem_num = 0;\n"
"    sop.sem_op = -1;\n"
"    sop.sem_flg = 0;\n"

#. type: Plain text
#: build/C/man2/shmop.2:508
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<sysvipc>(7)"
msgstr "B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), B<shm_overview>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr "SUBPAGE_PROT"

#. type: Plain text
#: build/C/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<int subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""
"B<int subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"

#. type: Plain text
#: build/C/man2/subpage_prot.2:41 build/C/man2/membarrier.2:38
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4\\ kB subpages on systems "
"configured with a page size of 64\\ kB."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4\\ kB subpage; thus each 32-bit word specifies the "
"protections of 16 4\\ kB subpages inside a 64\\ kB page (so, the number of "
"32-bit words pointed to by I<map> should equate to the number of 64-kB pages "
"specified by I<len>).  Each 2-bit field in the protection map is either 0 to "
"allow any access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr "メモリー不足である。"

#. type: Plain text
#: build/C/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:101 build/C/man2/membarrier.2:328
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""

#. type: SS
#: build/C/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr ""

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4 kB hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: build/C/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the memory-"
"management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is "
"slow.)  The idea is that the emulator supplies an array of protection masks "
"to apply to a specified range of virtual addresses.  These masks are applied "
"at the level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:131
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr "B<mprotect>(2), B<syscall>(2)"

#. type: Plain text
#: build/C/man2/subpage_prot.2:134
msgid ""
"I<Documentation/admin-guide/mm/hugetlbpage.rst> in the Linux kernel source "
"tree"
msgstr "Linux カーネルソースの I<Documentation/admin-guide/vm/hugetlbpage.rst>"

#. type: TH
#: build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr "SYNC_FILE_RANGE"

#. type: Plain text
#: build/C/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr "sync_file_range - ファイルセグメントをディスクと同期する"

#. type: Plain text
#: build/C/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""
"B<sync_file_range>()  を使うと、ファイルディスクリプター I<fd> で参照される"
"オープンされたファイルのディスクとの同期に関して、 きめ細かな制御が可能とな"
"る。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""
"I<offset> は、同期を行うファイルの領域の開始バイトである。 I<nbytes> には同期"
"を行う領域の長さをバイト単位で指定する。 I<nbytes> が 0 の場合は、 I<offset> "
"からファイル末尾までの全バイトを同期する。 同期はシステムのページサイズの単位"
"で行われる。 I<offset> はページ境界にあわせて切り下げられ、 I<(offset"
"+nbytes-1)> はページ境界にあわせて切り上げられる。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr "ビットマスク引き数 I<flags> には以下の値を指定することができる:"

#. type: TP
#: build/C/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""
"何らかの書き込みを行う前に、指定された領域のページで 書き出しを行うようにデバ"
"イスドライバにすでに要求が発行されている ページの書き出しが全て完了するのを待"
"つ。"

#. type: TP
#: build/C/man2/sync_file_range.2:70 build/C/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr "B<SYNC_FILE_RANGE_WRITE>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""
"指定された領域のページで、書き出し要求が発行されていない 全ての dirty (キャッ"
"シュだけが変更されている) ページの 書き出しを開始する。 リクエストキューの大"
"きさより多く書き込もうとした場合には、 この処理は停止 (block) する可能性があ"
"る点に注意すること。"

#. type: TP
#: build/C/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:80
msgid ""
"Wait upon write-out of all pages in the range after performing any write."
msgstr ""
"何らかの書き込み後に、指定された領域の全てのページの 書き出しが行われるのを待"
"つ。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr "I<flags> に 0 を指定した場合、何もしないことを表す。"

#. type: SS
#: build/C/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr "警告"

#. type: Plain text
#: build/C/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On filesystems using copy-on-write semantics (e.g., "
"I<btrfs>)  an overwrite of existing allocated blocks is impossible.  When "
"writing into preallocated space, many filesystems also require calls into "
"the block allocator, which this system call does not sync out to disk.  This "
"system call does not flush disk write caches and thus does not provide any "
"data integrity on systems with volatile disk write caches."
msgstr ""
"このシステムコールは非常に危険であり、 移植性が必要なプログラムで使用すべきで"
"はない。 これらの操作ではどれもファイルのメタデータの書き出しを行わない。 し"
"たがって、アプリケーションにより作成済みのディスクブロックの 上書きの実行が確"
"実に行われない限り、クラッシュの後でもデータが 利用できる保証はない。 書き込"
"みが上書きだけであるかを知るためのユーザーインターフェースは存在しない。 "
"(I<btrfs> などの) copy-on-write 動作を使ったファイルシステムでは、 既存の割り"
"当て済みのブロックに対する上書き自体ができない。 前もって割り当てられた領域に"
"書き込みを行う場合、 多くのファイルシステムでは block allocator への書き込み"
"も必要となるが、 このシステムコールは block allocator のディスクへの同期を行"
"わない。 このシステムコールはディスク書き込みキャッシュのフラッシュを 行わな"
"いので、揮発性のディスク書き込みキャッシュを使ったシステムでは このシステム"
"コールではデータの一貫性を確保できないことになる。"

#. type: SS
#: build/C/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr "詳細"

#. type: Plain text
#: build/C/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> と B<SYNC_FILE_RANGE_WAIT_AFTER> は I/O エラー"
"や B<ENOSPC> 状態を検出し、呼び出し元にこれらの情報を返す。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr "I<flags> の役に立つビットの組み合わせを以下に示す:"

#. type: TP
#: build/C/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""
"指定された範囲内のページで、 B<sync_file_range>()  が呼び出された際に dirty "
"であった全てのページが、 確実に書き出し対象となるようにする。 これは、start-"
"write-for-data-integrity 操作 (データ完全性確保のための書き込み開始の操作) で"
"ある。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""
"指定された範囲内のページで、現在書き出し中でない全ての dirty ページの 書き出"
"しを開始する。これは非同期のディスクへのフラッシュ (flush-to-disk)  操作であ"
"る。データ完全性確保が必要な操作としては適切ではない。"

#. type: TP
#: build/C/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"

#. type: Plain text
#: build/C/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""
"指定された範囲内の全てのページの書き出しの完了を待つ。 このフラグは、前に行わ"
"れた操作 B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE> の後に使用で"
"き、この操作の完了を待ち、結果を取得することができる。"

#. type: TP
#: build/C/man2/sync_file_range.2:134
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""
"これは write-for-data-integrity 操作 (データ完全性確保のための書き込み) であ"
"り、指定された範囲内の、 B<sync_file_range>()  が呼ばれた時点で dirty な全て"
"のページが ディスクに格納されることが保証される。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功の場合、 B<sync_file_range>()  は 0 を返す。失敗の場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:160
msgid ""
"I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""
"I<flags> に不正なビットが指定されている。または I<offset> か I<nbytes> が不正"
"である。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:163
msgid "I/O error."
msgstr "I/O エラー。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr "ディスク領域不足である。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:174
msgid ""
"I<fd> refers to something other than a regular file, a block device, or a "
"directory."
msgstr "I<fd> が、通常のファイル、ブロックデバイス、ディレクトリ以外のものを指している。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:177
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr "B<sync_file_range>()  はカーネル 2.6.17 で Linux に登場した。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:180
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""
"このシステムコールは Linux 独自であり、 移植性が必要なプログラムでは使用を避"
"けるべきである。"

#. type: SS
#: build/C/man2/sync_file_range.2:181
#, no-wrap
msgid "sync_file_range2()"
msgstr "sync_file_range2()"

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: build/C/man2/sync_file_range.2:198
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  shown in the SYNOPSIS would force a register to be "
"wasted as padding between the I<fd> and I<offset> arguments.  (See "
"B<syscall>(2)  for details.)  Therefore, these architectures define a "
"different system call that orders the arguments suitably:"
msgstr ""
"いくつかのアーキテクチャー (例えば、 PowerPC や ARM) では、 64 ビットの引き数"
"は適切なレジスターの組に割り当てる必要がある。 このようなアーキテクチャーで"
"は、 「書式」に書かれている B<sync_file_range>() の呼び出しシグネチャーで、 "
"引き数 I<fd> と I<offset> の間のパディング (詰めもの) でレジスターが一つ消費"
"されてしまう (詳細は B<syscall>(2) 参照)。 そのため、 これらのアーキテク"
"チャーでは引き数が適切な順序になった別のシステムコールが定義されている。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:203
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"

#. type: Plain text
#: build/C/man2/sync_file_range.2:208
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""
"上記の点以外は、このシステムコールの動作は B<sync_file_range>() と\n"
"全く同じである。このシステムコールに対するライブラリによるサポートは\n"
"glibc では提供されていない。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:219
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""
"このバージョンのシステムコールは、Linux 2.6.20 で ARM アーキテクチャーで\n"
"初めて登場し、 B<arm_sync_file_range>() という名前であった。\n"
"Linux 2.6.22 で、同様のシステムコールが PowerPC 用に追加された際に、\n"
"システムコールの名前が変更された。\n"
"glibc によるサポートが提供されているアーキテクチャーでは、\n"
"glibc のラッパー関数は B<sync_file_range>() という名前で\n"
"B<sync_file_range2>() を適切に使用するようになっている。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:224
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"

#. type: TH
#: build/C/man2/memfd_create.2:21
#, no-wrap
msgid "MEMFD_CREATE"
msgstr "MEMFD_CREATE"

#. type: Plain text
#: build/C/man2/memfd_create.2:24
msgid "memfd_create - create an anonymous file"
msgstr "memfd_create - 無名ファイル (anonymous file) を作成する"

#. type: Plain text
#: build/C/man2/memfd_create.2:30
#, no-wrap
msgid "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"

#.  David Herrmann:
#.      memfd uses VM_NORESERVE so each page is accounted on first access.
#.      This means, the overcommit-limits (see __vm_enough_memory()) and the
#.      memory-cgroup limits (mem_cgroup_try_charge()) are applied. Note that
#.      those are accounted on "current" and "current->mm", that is, the
#.      process doing the first page access.
#. type: Plain text
#: build/C/man2/memfd_create.2:54
msgid ""
"B<memfd_create>()  creates an anonymous file and returns a file descriptor "
"that refers to it.  The file behaves like a regular file, and so can be "
"modified, truncated, memory-mapped, and so on.  However, unlike a regular "
"file, it lives in RAM and has a volatile backing storage.  Once all "
"references to the file are dropped, it is automatically released.  Anonymous "
"memory is used for all backing pages of the file.  Therefore, files created "
"by B<memfd_create>()  have the same semantics as other anonymous memory "
"allocations such as those allocated using B<mmap>(2)  with the "
"B<MAP_ANONYMOUS> flag."
msgstr "B<memfd_create>() は、 無名ファイル (anonymous file) を作成し、 そのファイルを参照するファイルディスクリプターを返す。 このファイルは通常のファイルと同様に振る舞い、 変更、切り詰め (truncate)、 メモリーマップなどを行うことができる。 しかし、 通常のファイルとは違い、 このファイルは RAM 上に置かれ、 格納されるストレージは揮発性である。 このファイルへの参照がすべてなくなると、 ファイルは自動的に解放される。 このファイルが置かれるページには無名メモリー (anonymous memory) が使用される。 したがって、 B<memfd_create>() で作成されたファイルは、 他の無名メモリーの割り当て (B<MAP_ANONYMOUS> フラグ付きの B<mmap>(2) を使って割り当てられた無名メモリーなど) と同じ動作をする。"

#. type: Plain text
#: build/C/man2/memfd_create.2:61
msgid ""
"The initial size of the file is set to 0.  Following the call, the file size "
"should be set using B<ftruncate>(2).  (Alternatively, the file may be "
"populated by calls to B<write>(2)  or similar.)"
msgstr ""
"ファイルの初期サイズは 0 に設定される。 呼び出しの後に、 B<ftruncate>(2) を"
"使ってファイルサイズを設定すべきである (代わりに、 B<write>(2) や同様の関数を"
"呼び出してファイルにデータを書き込むこともできる)。"

#. type: Plain text
#: build/C/man2/memfd_create.2:72
msgid ""
"The name supplied in I<name> is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory I</proc/self/"
"fd/>.  The displayed name is always prefixed with I<memfd:> and serves only "
"for debugging purposes.  Names do not affect the behavior of the file "
"descriptor, and as such multiple files can have the same name without any "
"side effects."
msgstr ""
"I<name> に指定された名前はファイル名として使用され、 ディレクトリ I</proc/"
"self/fd/> で対応するシンボリックリンクのリンク先として表示される。 表示される"
"名前の前には常に I<memfd:> が付き、 この名前はデバッグ用途としてのみ機能す"
"る。 名前はファイルディスクリプターの動作には影響せず、 複数のファイルが同じ"
"名前を持っても副作用はない。"

#. type: Plain text
#: build/C/man2/memfd_create.2:77
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<memfd_create>():"
msgstr ""
"以下の値をビット論理和で I<flags> に指定して、 B<memfd_create>() の動作を変更"
"できる。"

#. type: TP
#: build/C/man2/memfd_create.2:77
#, no-wrap
msgid "B<MFD_CLOEXEC>"
msgstr "B<MFD_CLOEXEC>"

#. type: Plain text
#: build/C/man2/memfd_create.2:87
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプターに close-on-exec (B<FD_CLOEXEC>) フラグをセット"
"する。 これが有用な理由については B<open>(2) の B<O_CLOEXEC> フラグの説明を参"
"照のこと。"

#. type: TP
#: build/C/man2/memfd_create.2:87
#, no-wrap
msgid "B<MFD_ALLOW_SEALING>"
msgstr "B<MFD_ALLOW_SEALING>"

#.  FIXME Why is the MFD_ALLOW_SEALING behavior not simply the default?
#.  Is it worth adding some text explaining this?
#. type: Plain text
#: build/C/man2/memfd_create.2:103
msgid ""
"Allow sealing operations on this file.  See the discussion of the "
"B<F_ADD_SEALS> and B<F_GET_SEALS> operations in B<fcntl>(2), and also NOTES, "
"below.  The initial set of seals is empty.  If this flag is not set, the "
"initial set of seals will be B<F_SEAL_SEAL>, meaning that no other seals can "
"be set on the file."
msgstr ""
"このファイルに対して sealing 操作を許可する。 B<fcntl>(2) の B<F_ADD_SEALS> "
"と B<F_GET_SEALS> 操作の議論を参照。 下記の「注意」も参照。 初期の seal 集合"
"は空となる。 このフラグを指定しなかった場合、 初期の seal 集合は "
"B<F_SEAL_SEAL> となり、 これはこのファイルには他の seal をセットできないこと"
"ということである。"

#. type: TP
#: build/C/man2/memfd_create.2:103
#, no-wrap
msgid "B<MFD_HUGETLB> (since Linux 4.14)"
msgstr "B<MFD_HUGETLB> (Linux 4.14 以降)"

#.  commit 749df87bd7bee5a79cef073f5d032ddb2b211de8
#.  commit 47b9012ecdc747f6936395265e677d41e11a31ff
#. type: Plain text
#: build/C/man2/memfd_create.2:119
msgid ""
"The anonymous file will be created in the hugetlbfs filesystem using huge "
"pages.  See the Linux kernel source file I<Documentation/admin-guide/mm/"
"hugetlbpage.rst> for more information about hugetlbfs.  Specifying both "
"B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> in I<flags> is supported since Linux "
"4.16."
msgstr ""

#. type: TP
#: build/C/man2/memfd_create.2:119
#, no-wrap
msgid "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"
msgstr "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"

#. type: Plain text
#: build/C/man2/memfd_create.2:128
msgid ""
"Used in conjunction with B<MFD_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB, 1\\ GB, ...)  on systems that support multiple "
"hugetlb page sizes.  Definitions for known huge page sizes are included in "
"the header file I<E<lt>linux/memfd.hE<gt>.>"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:132
msgid ""
"For details on encoding huge page sizes not included in the header file, see "
"the discussion of the similarly named constants in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:136
msgid "Unused bits in I<flags> must be 0."
msgstr "I<flags> の未使用のビットは 0 でなければならない。"

#. type: Plain text
#: build/C/man2/memfd_create.2:145
msgid ""
"As its return value, B<memfd_create>()  returns a new file descriptor that "
"can be used to refer to the file.  This file descriptor is opened for both "
"reading and writing (B<O_RDWR>)  and B<O_LARGEFILE> is set for the file "
"descriptor."
msgstr ""
"返り値として B<memfd_create>() は、 作成したファイルを参照するのに使用できる"
"新しいファイルディスクリプターを返す。 このファイルディスクリプターは読み書き"
"両用 (B<O_RDWR>) でオープンされ、 B<O_LARGEFILE> がこのファイルディスクリプ"
"ターにセットされる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:158
msgid ""
"With respect to B<fork>(2)  and B<execve>(2), the usual semantics apply for "
"the file descriptor created by B<memfd_create>().  A copy of the file "
"descriptor is inherited by the child produced by B<fork>(2)  and refers to "
"the same file.  The file descriptor is preserved across B<execve>(2), unless "
"the close-on-exec flag has been set."
msgstr ""
"B<fork>(2) と B<execve>(2) に関しては、 B<memfd_create>() で作成したファイル"
"ディスクリプターについても通常の動作が適用される。 ファイルディスクリプターの"
"コピーは B<fork>(2) で生成される子プロセスに継承され、 同じファイルを参照す"
"る。 close-on-exec フラグがセットされていない限り、 B<execve>(2) の前後でファ"
"イルディスクリプターは保持される。"

#. type: Plain text
#: build/C/man2/memfd_create.2:165
msgid ""
"On success, B<memfd_create>()  returns a new file descriptor.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""
"成功の場合、 B<memfd_create>() は新しいファイルディスクリプターを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/memfd_create.2:171
msgid "The address in I<name> points to invalid memory."
msgstr "I<name> のアドレスが無効なメモリーを指している。"

#. type: Plain text
#: build/C/man2/memfd_create.2:175
msgid "I<flags> included unknown bits."
msgstr ""

#.  NAME_MAX - strlen("memfd:")
#. type: Plain text
#: build/C/man2/memfd_create.2:182
msgid ""
"I<name> was too long.  (The limit is 249 bytes, excluding the terminating "
"null byte.)"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:190
msgid ""
"Both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:199
msgid "There was insufficient memory to create a new anonymous file."
msgstr "新しい無名ファイルを作成するのに十分なメモリーがなかった。"

#. type: Plain text
#: build/C/man2/memfd_create.2:204
msgid ""
"The B<memfd_create>()  system call first appeared in Linux 3.17; glibc "
"support was added in version 2.27."
msgstr "B<memfd_create>() システムコールは Linux 3.17 で登場した。 glibc でのサポートは glibc バージョン 2.27 で追加された。"

#. type: Plain text
#: build/C/man2/memfd_create.2:208
msgid "The B<memfd_create>()  system call is Linux-specific."
msgstr "B<memfd_create>()  システムコールは Linux 固有である。"

#.  See also http://lwn.net/Articles/593918/
#.  and http://lwn.net/Articles/594919/ and http://lwn.net/Articles/591108/
#. type: Plain text
#: build/C/man2/memfd_create.2:221
msgid ""
"The B<memfd_create>()  system call provides a simple alternative to manually "
"mounting a B<tmpfs>(5)  filesystem and creating and opening a file in that "
"filesystem.  The primary purpose of B<memfd_create>()  is to create files "
"and associated file descriptors that are used with the file-sealing APIs "
"provided by B<fcntl>(2)."
msgstr "B<memfd_create>() システムコールは、 手動で B<tmpfs>(5) ファイルシステムをマウントして、 そのファイルシステムにファイルをオープンするという操作の、 簡単な代替手段を提供している。 B<memfd_create>() の主な目的は、 B<fcntl>(2) が提供する file-sealing API で使用できる、 ファイルとそれに関連付けられるファイルディスクリプターを作成することである。"

#. type: Plain text
#: build/C/man2/memfd_create.2:235
msgid ""
"The B<memfd_create>()  system call also has uses without file sealing (which "
"is why file-sealing is disabled, unless explicitly requested with the "
"B<MFD_ALLOW_SEALING> flag).  In particular, it can be used as an alternative "
"to creating files in I<tmp> or as an alternative to using the B<open>(2)  "
"B<O_TMPFILE> in cases where there is no intention to actually link the "
"resulting file into the filesystem."
msgstr ""
"B<memfd_create>() システムコールは、 file sealing なしでも用途がある (これが"
"明示的に B<MFD_ALLOW_SEALING> フラグが要求されない限り、 file-sealing が無効"
"になる理由である)。 特に、 ファイルシステムに実際にファイルを残す意図がない場"
"合、 I<tmp> にファイルを作成したり B<open>(2) B<O_TMPFILE> を使ったりする際の"
"代替手段として使用できる。"

#. type: SS
#: build/C/man2/memfd_create.2:235
#, no-wrap
msgid "File sealing"
msgstr "file sealing"

#. type: Plain text
#: build/C/man2/memfd_create.2:253
msgid ""
"In the absence of file sealing, processes that communicate via shared memory "
"must either trust each other, or take measures to deal with the possibility "
"that an untrusted peer may manipulate the shared memory region in "
"problematic ways.  For example, an untrusted peer might modify the contents "
"of the shared memory at any time, or shrink the shared memory region.  The "
"former possibility leaves the local process vulnerable to time-of-check-to-"
"time-of-use race conditions (typically dealt with by copying data from the "
"shared memory region before checking and using it).  The latter possibility "
"leaves the local process vulnerable to B<SIGBUS> signals when an attempt is "
"made to access a now-nonexistent location in the shared memory region.  "
"(Dealing with this possibility necessitates the use of a handler for the "
"B<SIGBUS> signal.)"
msgstr ""
"file sealing がない場合、 共有メモリー経由で通信するプロセスは、 互いに信頼す"
"るか、 信頼していない相手が共有メモリー領域を問題がある方法で操作する可能性に"
"対処するための対策を講じなければならない。\n"
"例えば、 信頼していない相手は、 いつでも共有メモリーの内容を変更したり、 共有"
"メモリー領域を縮小したりする可能性がある。 前者の場合は、 ローカルプロセスで"
"は、 データの確認時点と使用時点の競合条件の問題が起こり得る (通常はこの問題へ"
"の対処は共有メモリー領域からデータをこぴーしてからデータを確認、使用すること"
"である)。 後者の場合は、 ローカルプロセスでは、 共有メモリー領域の存在しなく"
"なった場所にアクセスしようとした際にシグナル B<SIGBUS> が発生する可能性があ"
"る (この可能性に対処するにはシグナル B<SIGBUS> に対してハンドラーを使用する必"
"要がある)。"

#. type: Plain text
#: build/C/man2/memfd_create.2:259
msgid ""
"Dealing with untrusted peers imposes extra complexity on code that employs "
"shared memory.  Memory sealing enables that extra complexity to be "
"eliminated, by allowing a process to operate secure in the knowledge that "
"its peer can't modify the shared memory in an undesired fashion."
msgstr ""
"信頼していない相手への対処により、 共有メモリーを利用するコードに余計な複雑性"
"が増すことになる。 メモリー sealing により余計な複雑性をなくすことができる。 "
"相手が望まない方法で共有メモリーを変更できないことを知っていることで、 プロセ"
"スは安全に動作できるようになる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:261
msgid "An example of the usage of the sealing mechanism is as follows:"
msgstr "sealing 機構の使い方の例は以下のとおりである。"

#. type: Plain text
#: build/C/man2/memfd_create.2:267
msgid ""
"The first process creates a B<tmpfs>(5)  file using B<memfd_create>().  The "
"call yields a file descriptor used in subsequent steps."
msgstr "最初のプロセスは B<memfd_create>() を使って B<tmpfs>(5) ファイルを作成する。 B<memfd_create>() はこれ以降のステップで使用するファイルディスクリプターを返す。"

#. type: Plain text
#: build/C/man2/memfd_create.2:274
msgid ""
"The first process sizes the file created in the previous step using "
"B<ftruncate>(2), maps it using B<mmap>(2), and populates the shared memory "
"with the desired data."
msgstr ""
"最初のプロセスは B<ftruncate>(2) を使って直前のステップで作成したファイルのサ"
"イズを変更し、 B<mmap>(2) を使ってそのファイルをマッピングし、 共有メモリーに"
"所望のデータを配置する。"

#. type: IP
#: build/C/man2/memfd_create.2:274
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man2/memfd_create.2:293
#, fuzzy
#| msgid ""
#| "The first process uses the B<fcntl>(2)  B<F_ADD_SEALS> operation to place "
#| "one or more seals on the file, in order to restrict further modifications "
#| "on the file.  (If placing the seal B<F_SEAL_WRITE>, then it will be "
#| "necessary to first unmap the shared writable mapping created in the "
#| "previous step.)"
msgid ""
"The first process uses the B<fcntl>(2)  B<F_ADD_SEALS> operation to place "
"one or more seals on the file, in order to restrict further modifications on "
"the file.  (If placing the seal B<F_SEAL_WRITE>, then it will be necessary "
"to first unmap the shared writable mapping created in the previous step.  "
"Otherwise, behavior similar to B<F_SEAL_WRITE> can be achieved by using "
"B<F_SEAL_FUTURE_WRITE>, which will prevent future writes via B<mmap>(2)  and "
"B<write>(2)  from succeeding while keeping existing shared writable "
"mappings)."
msgstr ""
"最初のプロセスは、 このファイルに対する今後の変更を制限するために、 "
"B<fcntl>(2) の B<F_ADD_SEALS> 操作を使って、 そのファイルに seal をいくつか設"
"定する。 (seal B<F_SEAL_WRITE> を設定する場合、 直前のステップで作成した書き"
"込み可能な共有マッピングをまずアンマップする必要が出てくる。)"

#. type: IP
#: build/C/man2/memfd_create.2:293
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man2/memfd_create.2:298
msgid ""
"A second process obtains a file descriptor for the B<tmpfs>(5)  file and "
"maps it.  Among the possible ways in which this could happen are the "
"following:"
msgstr "二つ目のプロセスは B<tmpfs>(5) ファイルのファイルディスクリプターを入手し、 そのファイルをマップする。 以下に示す方法を使用することができる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:309
msgid ""
"The process that called B<memfd_create>()  could transfer the resulting file "
"descriptor to the second process via a UNIX domain socket (see B<unix>(7)  "
"and B<cmsg>(3)).  The second process then maps the file using B<mmap>(2)."
msgstr ""
"B<memfd_create>() を呼び出したプロセスは、 得られたファイルディスクリプターを"
"二つ目のプロセスに UNIX ドメインソケット経由で渡すことができる (B<unix>(7) "
"と B<cmsg>(3) を参照)。 それから、二つ目のプロセスは B<mmap>(2) を使ってファ"
"イルをマップする。"

#. type: Plain text
#: build/C/man2/memfd_create.2:317
msgid ""
"The second process is created via B<fork>(2)  and thus automatically "
"inherits the file descriptor and mapping.  (Note that in this case and the "
"next, there is a natural trust relationship between the two processes, since "
"they are running under the same user ID.  Therefore, file sealing would not "
"normally be necessary.)"
msgstr ""
"二つ目のプロセスを B<fork>(2) を使って作成する。 そうすると、 自動的にファイ"
"ルディスクリプターとマッピングが継承される。 (この方法と次の方法では、 二つの"
"プロセス間で自然な信頼関係が存在することになる。 なぜなら、 二つのプロセスは"
"同じユーザー ID。 の元で実行されているからである。 したがって、 file sealing "
"は通常は不要であろう。)"

#. type: Plain text
#: build/C/man2/memfd_create.2:331
msgid ""
"The second process opens the file I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>>, "
"where I<E<lt>pidE<gt>> is the PID of the first process (the one that called "
"B<memfd_create>()), and I<E<lt>fdE<gt>> is the number of the file descriptor "
"returned by the call to B<memfd_create>()  in that process.  The second "
"process then maps the file using B<mmap>(2)."
msgstr "二つ目のプロセスは I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>> をオープンする。 I<E<lt>pidE<gt>> は最初のプロセス (B<memfd_create>() を呼び出したプロセス) の PID で、 I<E<lt>fdE<gt>> は最初のプロセスでの B<memfd_create>() の呼び出しで返されたファイルディスクリプター番号である。 それからこのファイルを B<mmap>(2) を使ってマッピングする。"

#. type: IP
#: build/C/man2/memfd_create.2:332
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man2/memfd_create.2:344
msgid ""
"The second process uses the B<fcntl>(2)  B<F_GET_SEALS> operation to "
"retrieve the bit mask of seals that has been applied to the file.  This bit "
"mask can be inspected in order to determine what kinds of restrictions have "
"been placed on file modifications.  If desired, the second process can apply "
"further seals to impose additional restrictions (so long as the "
"B<F_SEAL_SEAL> seal has not yet been applied)."
msgstr ""
"二つ目のプロセスは B<fcntl>(2) の B<F_GET_SEALS> 操作を使って、 そのファイル"
"に適用されている seal のビットマスクを取得する。 このビットマスクを調べて、 "
"ファイルの変更に関してどのような制限が適用されているかを知ることができる。 "
"(B<F_SEAL_SEAL> seal がそれまでに適用されていない限りは) 必要であれば、 二つ"
"目のプロセスはさらに seal を設定して追加の制限をかけることができる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:348
msgid ""
"Below are shown two example programs that demonstrate the use of "
"B<memfd_create>()  and the file sealing API."
msgstr ""
"以下では B<memfd_create>() と file sealing API の使用例を示すサンプルプログラ"
"ムを 2 つとりあげる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:363
msgid ""
"The first program, I<t_memfd_create.c>, creates a B<tmpfs>(5)  file using "
"B<memfd_create>(), sets a size for the file, maps it into memory, and "
"optionally places some seals on the file.  The program accepts up to three "
"command-line arguments, of which the first two are required.  The first "
"argument is the name to associate with the file, the second argument is the "
"size to be set for the file, and the optional third argument is a string of "
"characters that specify seals to be set on file."
msgstr "最初のプログラム I<t_memfd_create.c> は、 B<memfd_create>() を使って B<tmpfs>(5) ファイルを作成し、 そのファイルのサイズを設定し、 メモリーにマッピングし、 要求された場合にはそのファイルに seal を設定する。 このプログラムは最大で 3 つのコマンドライン引き数を取り、 最初の 2 つは必須である。 最初の引き数はファイルに関連付けられる名前で、 2 番目の引き数はファイルに設定されるサイズである。 省略可能な 3 番目の引き数は、 このファイルに設定する seal を指定する文字列である。"

#. type: Plain text
#: build/C/man2/memfd_create.2:369
msgid ""
"The second program, I<t_get_seals.c>, can be used to open an existing file "
"that was created via B<memfd_create>()  and inspect the set of seals that "
"have been applied to that file."
msgstr ""
"2 つめのプログラム I<t_get_seals.c> を使うと、 B<memfd_create>() を使って作成"
"された既存のファイルをオープンし、 そのファイルに適用されている seal の集合を"
"調査できる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:374
msgid ""
"The following shell session demonstrates the use of these programs.  First "
"we create a B<tmpfs>(5)  file and set some seals on it:"
msgstr "以下のシェルのセッションはこれらのプログラムの使用例を示したものである。 まず B<tmpfs>(5) ファイルを作成し、そのファイルに seal をいくつか設定している。"

#. type: Plain text
#: build/C/man2/memfd_create.2:380
#, no-wrap
msgid ""
"$ B<./t_memfd_create my_memfd_file 4096 sw &>\n"
"[1] 11775\n"
"PID: 11775; fd: 3; /proc/11775/fd/3\n"
msgstr ""
"$ B<./t_memfd_create my_memfd_file 4096 sw &>\n"
"[1] 11775\n"
"PID: 11775; fd: 3; /proc/11775/fd/3\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:398
msgid ""
"At this point, the I<t_memfd_create> program continues to run in the "
"background.  From another program, we can obtain a file descriptor for the "
"file created by B<memfd_create>()  by opening the I</proc/[pid]/fd> file "
"that corresponds to the file descriptor opened by B<memfd_create>().  Using "
"that pathname, we inspect the content of the I</proc/[pid]/fd> symbolic "
"link, and use our I<t_get_seals> program to view the seals that have been "
"placed on the file:"
msgstr "この時点では、 I<t_memfd_create> プログラムはバックグラウンドで動作し続ける。 もう一つのプログラムから、 B<memfd_create>() がオープンしたファイルディスクリプターに対応する I</proc/[pid]/fd> ファイルをオープンすることで、 B<memfd_create>() で作成されたファイルのファイルディスクリプターを取得できる。そのパス名を使って、 I</proc/[pid]/fd> シンボリックリンクの内容を調査し、 I<t_get_seals> プログラムを使ってそのファイルに設定されている seal を見ることができる。"

#. type: Plain text
#: build/C/man2/memfd_create.2:405
#, no-wrap
msgid ""
"$ B<readlink /proc/11775/fd/3>\n"
"/memfd:my_memfd_file (deleted)\n"
"$ B<./t_get_seals /proc/11775/fd/3>\n"
"Existing seals: WRITE SHRINK\n"
msgstr ""
"$ B<readlink /proc/11775/fd/3>\n"
"/memfd:my_memfd_file (deleted)\n"
"$ B<./t_get_seals /proc/11775/fd/3>\n"
"Existing seals: WRITE SHRINK\n"

#. type: SS
#: build/C/man2/memfd_create.2:407
#, no-wrap
msgid "Program source: t_memfd_create.c"
msgstr "プログラムのソース: t_memfd_create.c"

#. type: Plain text
#: build/C/man2/memfd_create.2:418
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:430
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
"    char *addr;\n"
"    char *name, *seals_arg;\n"
"    ssize_t len;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
"    char *addr;\n"
"    char *name, *seals_arg;\n"
"    ssize_t len;\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:442
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s name size [seals]\\en\", argv[0]);\n"
"        fprintf(stderr, \"\\et\\(aqseals\\(aq can contain any of the \"\n"
"                \"following characters:\\en\");\n"
"        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n"
"        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n"
"        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etW - F_SEAL_FUTURE_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s name size [seals]\\en\", argv[0]);\n"
"        fprintf(stderr, \"\\et\\(aqseals\\(aq can contain any of the \"\n"
"                \"following characters:\\en\");\n"
"        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n"
"        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n"
"        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etW - F_SEAL_FUTURE_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:446
#, no-wrap
msgid ""
"    name = argv[1];\n"
"    len = atoi(argv[2]);\n"
"    seals_arg = argv[3];\n"
msgstr ""
"    name = argv[1];\n"
"    len = atoi(argv[2]);\n"
"    seals_arg = argv[3];\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:449
#, no-wrap
msgid ""
"    /* Create an anonymous file in tmpfs; allow seals to be\n"
"       placed on the file */\n"
msgstr ""
"    /* Create an anonymous file in tmpfs; allow seals to be\n"
"       placed on the file */\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:453
#, no-wrap
msgid ""
"    fd = memfd_create(name, MFD_ALLOW_SEALING);\n"
"    if (fd == -1)\n"
"        errExit(\"memfd_create\");\n"
msgstr ""
"    fd = memfd_create(name, MFD_ALLOW_SEALING);\n"
"    if (fd == -1)\n"
"        errExit(\"memfd_create\");\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:455
#, no-wrap
msgid "    /* Size the file as specified on the command line */\n"
msgstr "    /* Size the file as specified on the command line */\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:458
#, no-wrap
msgid ""
"    if (ftruncate(fd, len) == -1)\n"
"        errExit(\"truncate\");\n"
msgstr ""
"    if (ftruncate(fd, len) == -1)\n"
"        errExit(\"truncate\");\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:461
#, no-wrap
msgid ""
"    printf(\"PID: %jd; fd: %d; /proc/%jd/fd/%d\\en\",\n"
"            (intmax_t) getpid(), fd, (intmax_t) getpid(), fd);\n"
msgstr ""
"    printf(\"PID: %jd; fd: %d; /proc/%jd/fd/%d\\en\",\n"
"            (intmax_t) getpid(), fd, (intmax_t) getpid(), fd);\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:464
#, no-wrap
msgid ""
"    /* Code to map the file and populate the mapping with data\n"
"       omitted */\n"
msgstr ""
"    /* Code to map the file and populate the mapping with data\n"
"       omitted */\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:467
#, no-wrap
msgid ""
"    /* If a \\(aqseals\\(aq command-line argument was supplied, set some\n"
"       seals on the file */\n"
msgstr ""
"    /* If a \\(aqseals\\(aq command-line argument was supplied, set some\n"
"       seals on the file */\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:470
#, no-wrap
msgid ""
"    if (seals_arg != NULL) {\n"
"        seals = 0;\n"
msgstr ""
"    if (seals_arg != NULL) {\n"
"        seals = 0;\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:481
#, no-wrap
msgid ""
"        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n"
"            seals |= F_SEAL_GROW;\n"
"        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n"
"            seals |= F_SEAL_SHRINK;\n"
"        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n"
"            seals |= F_SEAL_WRITE;\n"
"        if (strchr(seals_arg, \\(aqW\\(aq) != NULL)\n"
"            seals |= F_SEAL_FUTURE_WRITE;\n"
"        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n"
"            seals |= F_SEAL_SEAL;\n"
msgstr ""
"        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n"
"            seals |= F_SEAL_GROW;\n"
"        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n"
"            seals |= F_SEAL_SHRINK;\n"
"        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n"
"            seals |= F_SEAL_WRITE;\n"
"        if (strchr(seals_arg, \\(aqW\\(aq) != NULL)\n"
"            seals |= F_SEAL_FUTURE_WRITE;\n"
"        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n"
"            seals |= F_SEAL_SEAL;\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:485
#, no-wrap
msgid ""
"        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n"
"            errExit(\"fcntl\");\n"
"    }\n"
msgstr ""
"        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n"
"            errExit(\"fcntl\");\n"
"    }\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:488
#, no-wrap
msgid ""
"    /* Keep running, so that the file created by memfd_create()\n"
"       continues to exist */\n"
msgstr ""
"    /* Keep running, so that the file created by memfd_create()\n"
"       continues to exist */\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:490
#, no-wrap
msgid "    pause();\n"
msgstr "    pause();\n"

#. type: SS
#: build/C/man2/memfd_create.2:494
#, no-wrap
msgid "Program source: t_get_seals.c"
msgstr "プログラムのソース: t_get_seals.c"

#. type: Plain text
#: build/C/man2/memfd_create.2:504
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:513
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:518
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:522
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDWR);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDWR);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:526
#, no-wrap
msgid ""
"    seals = fcntl(fd, F_GET_SEALS);\n"
"    if (seals == -1)\n"
"        errExit(\"fcntl\");\n"
msgstr ""
"    seals = fcntl(fd, F_GET_SEALS);\n"
"    if (seals == -1)\n"
"        errExit(\"fcntl\");\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:539
#, no-wrap
msgid ""
"    printf(\"Existing seals:\");\n"
"    if (seals & F_SEAL_SEAL)\n"
"        printf(\" SEAL\");\n"
"    if (seals & F_SEAL_GROW)\n"
"        printf(\" GROW\");\n"
"    if (seals & F_SEAL_WRITE)\n"
"        printf(\" WRITE\");\n"
"    if (seals & F_SEAL_FUTURE_WRITE)\n"
"        printf(\" FUTURE_WRITE\");\n"
"    if (seals & F_SEAL_SHRINK)\n"
"        printf(\" SHRINK\");\n"
"    printf(\"\\en\");\n"
msgstr ""
"    printf(\"Existing seals:\");\n"
"    if (seals & F_SEAL_SEAL)\n"
"        printf(\" SEAL\");\n"
"    if (seals & F_SEAL_GROW)\n"
"        printf(\" GROW\");\n"
"    if (seals & F_SEAL_WRITE)\n"
"        printf(\" WRITE\");\n"
"    if (seals & F_SEAL_FUTURE_WRITE)\n"
"        printf(\" FUTURE_WRITE\");\n"
"    if (seals & F_SEAL_SHRINK)\n"
"        printf(\" SHRINK\");\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:542
#, no-wrap
msgid ""
"    /* Code to map the file and access the contents of the\n"
"       resulting mapping omitted */\n"
msgstr ""
"    /* Code to map the file and access the contents of the\n"
"       resulting mapping omitted */\n"

#. type: Plain text
#: build/C/man2/memfd_create.2:552
msgid "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"
msgstr "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"

#. type: TH
#: build/C/man2/s390_pci_mmio_write.2:25
#, no-wrap
msgid "S390_PCI_MMIO_WRITE"
msgstr "S390_PCI_MMIO_WRITE"

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:29
msgid ""
"s390_pci_mmio_write, s390_pci_mmio_read - transfer data to/from PCI MMIO "
"memory page"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:32
#, no-wrap
msgid "B<#include E<lt>asm/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>asm/unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:37
#, no-wrap
msgid ""
"B<int s390_pci_mmio_write(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
"B<int s390_pci_mmio_read(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<int s390_pci_mmio_write(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
"B<int s390_pci_mmio_read(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:56
msgid ""
"The B<s390_pci_mmio_write>()  system call writes I<length> bytes of data "
"from the user-space buffer I<user_buffer> to the PCI MMIO memory location "
"specified by I<mmio_addr>.  The B<s390_pci_mmio_read>()  system call reads "
"I<length> bytes of data from the PCI MMIO memory location specified by "
"I<mmio_addr> to the user-space buffer I<user_buffer>."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:67
msgid ""
"These system calls must be used instead of the simple assignment or data-"
"transfer operations that are used to access the PCI MMIO memory areas mapped "
"to user space on the Linux System z platform.  The address specified by "
"I<mmio_addr> must belong to a PCI MMIO memory page mapping in the caller's "
"address space, and the data being written or read must not cross a page "
"boundary.  The I<length> value cannot be greater than the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:76
msgid ""
"On success, B<s390_pci_mmio_write>()  and B<s390_pci_mmio_read>()  return "
"0.  On error, -1 is returned and I<errno> is set to one of the error codes "
"listed below."
msgstr ""
"成功すると、 B<s390_pci_mmio_write>() と B<s390_pci_mmio_read>() は 0 を返"
"す。 エラーの場合、-1 を返し、 I<errno> に以下のリストにあるエラーコードのい"
"ずれかを設定する。"

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:82
msgid "The address in I<mmio_addr> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:86
msgid ""
"I<user_buffer> does not point to a valid location in the caller's address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:91
msgid "Invalid I<length> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:94
msgid "PCI support is not enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:97
msgid "Insufficient memory."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:99
msgid "These system calls are available since Linux 3.19."
msgstr "これらのシステムコールは Linux 3.19 以降で使用可能である。"

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:102
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The required PCI support is available beginning with System z EC12."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:106
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to "
"call it."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:108
msgid "B<syscall>(2)"
msgstr "B<syscall>(2)"

#. type: TH
#: build/C/man2/membarrier.2:25
#, no-wrap
msgid "MEMBARRIER"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:28
msgid "membarrier - issue memory barriers on a set of threads"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:32
#, no-wrap
msgid "B<#include E<lt>linux/membarrier.hE<gt>>\n"
msgstr "B<#include E<lt>linux/membarrier.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/membarrier.2:34
#, no-wrap
msgid "B<int membarrier(int >I<cmd>B<, unsigned int >I<flags>B<, int >I<cpu_id>B<);>\n"
msgstr "B<int membarrier(int >I<cmd>B<, unsigned int >I<flags>B<, int >I<cpu_id>B<);>\n"

#. type: Plain text
#: build/C/man2/membarrier.2:48
msgid ""
"The B<membarrier>()  system call helps reducing the overhead of the memory "
"barrier instructions required to order memory accesses on multi-core "
"systems.  However, this system call is heavier than a memory barrier, so "
"using it effectively is I<not> as simple as replacing memory barriers with "
"this system call, but requires understanding of the details below."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:53
msgid ""
"Use of memory barriers needs to be done taking into account that a memory "
"barrier always needs to be either matched with its memory barrier "
"counterparts, or that the architecture's memory model doesn't require the "
"matching barriers."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:62
msgid ""
"There are cases where one side of the matching barriers (which we will refer "
"to as \"fast side\") is executed much more often than the other (which we "
"will refer to as \"slow side\").  This is a prime target for the use of "
"B<membarrier>().  The key idea is to replace, for these matching barriers, "
"the fast-side memory barriers by simple compiler barriers, for example:"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:66
#, no-wrap
msgid "asm volatile (\"\" : : : \"memory\")\n"
msgstr "asm volatile (\"\" : : : \"memory\")\n"

#. type: Plain text
#: build/C/man2/membarrier.2:71
msgid "and replace the slow-side memory barriers by calls to B<membarrier>()."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:77
msgid ""
"This will add overhead to the slow side, and remove overhead from the fast "
"side, thus resulting in an overall performance increase as long as the slow "
"side is infrequent enough that the overhead of the B<membarrier>()  calls "
"does not outweigh the performance gain on the fast side."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:81
msgid "The I<cmd> argument is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:81
#, no-wrap
msgid "B<MEMBARRIER_CMD_QUERY> (since Linux 4.3)"
msgstr "B<MEMBARRIER_CMD_QUERY> (Linux 4.3 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:92
msgid ""
"Query the set of supported commands.  The return value of the call is a bit "
"mask of supported commands.  B<MEMBARRIER_CMD_QUERY>, which has the value 0, "
"is not itself included in this bit mask.  This command is always supported "
"(on kernels where B<membarrier>()  is provided)."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:92
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_GLOBAL> (Linux 4.16 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:100
msgid ""
"Ensure that all threads from all processes on the system pass through a "
"state where all memory accesses to user-space addresses match program order "
"between entry to and return from the B<membarrier>()  system call.  All "
"threads on the system are targeted by this command."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:100
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (Linux 4.16 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:105
msgid ""
"Execute a memory barrier on all running threads of all processes that "
"previously registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:113
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all running threads have passed through a state where all memory accesses to "
"user-space addresses match program order between entry to and return from "
"the system call (non-running threads are de facto in such a state).  This "
"guarantee is provided only for the threads of processes that previously "
"registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:119
msgid ""
"Given that registration is about the intent to receive the barriers, it is "
"valid to invoke B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> from a process that has "
"not employed B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:122 build/C/man2/membarrier.2:142
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones; they "
"never block, but have the downside of causing extra overhead."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:122
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (Linux 4.16 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:127
msgid ""
"Register the process's intent to receive B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> "
"memory barriers."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:127
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (Linux 4.14 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:131
msgid ""
"Execute a memory barrier on each running thread belonging to the same "
"process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:139
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all its running thread siblings have passed through a state where all memory "
"accesses to user-space addresses match program order between entry to and "
"return from the system call (non-running threads are de facto in such a "
"state).  This guarantee is provided only for threads in the same process as "
"the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:145
msgid ""
"A process must register its intent to use the private expedited command "
"prior to using it."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:145
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (Linux 4.14 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:149
msgid ""
"Register the process's intent to use B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:149
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (Linux 4.16 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:157
msgid ""
"In addition to providing the memory ordering guarantees described in "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, upon return from system call the "
"calling thread has a guarantee that all its running thread siblings have "
"executed a core serializing instruction.  This guarantee is provided only "
"for threads in the same process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:160
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones, they "
"never block, but have the downside of causing extra overhead."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:163
msgid ""
"A process must register its intent to use the private expedited sync core "
"command prior to using it."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:163
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (Linux 4.16 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:167
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:167
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ> (since Linux 5.10)"
msgstr "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ> (Linux 5.10 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:181
msgid ""
"Ensure the caller thread, upon return from system call, that all its running "
"thread siblings have any currently running rseq critical sections restarted "
"if I<flags> parameter is 0; if I<flags> parameter is "
"B<MEMBARRIER_CMD_FLAG_CPU>, then this operation is performed only on CPU "
"indicated by I<cpu_id>.  This guarantee is provided only for threads in the "
"same process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:183
msgid "RSEQ membarrier is only available in the \"private expedited\" form."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:186
msgid ""
"A process must register its intent to use the private expedited rseq command "
"prior to using it."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:186
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ> (since Linux 5.10)"
msgstr "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ> (Linux 5.10 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:190
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ>."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:190
#, no-wrap
msgid "B<MEMBARRIER_CMD_SHARED> (since Linux 4.3)"
msgstr "B<MEMBARRIER_CMD_SHARED> (Linux 4.3 以降)"

#. type: Plain text
#: build/C/man2/membarrier.2:195
msgid ""
"This is an alias for B<MEMBARRIER_CMD_GLOBAL> that exists for header "
"backward compatibility."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:204
msgid ""
"The I<flags> argument must be specified as 0 unless the command is "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ>, in which case I<flags> can be "
"either 0 or B<MEMBARRIER_CMD_FLAG_CPU>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:213
msgid ""
"The I<cpu_id> argument is ignored unless I<flags> is "
"B<MEMBARRIER_CMD_FLAG_CPU>, in which case it must specify the CPU targeted "
"by this membarrier command."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:217
msgid ""
"All memory accesses performed in program order from each targeted thread are "
"guaranteed to be ordered with respect to B<membarrier>()."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:231
msgid ""
"If we use the semantic I<barrier()> to represent a compiler barrier forcing "
"memory accesses to be performed in program order across the barrier, and "
"I<smp_mb()> to represent explicit memory barriers forcing full memory "
"ordering across the barrier, we have the following ordering table for each "
"pairing of I<barrier()>, B<membarrier>(), and I<smp_mb()>.  The pair "
"ordering is detailed as (O: ordered, X: not ordered):"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:236
#, no-wrap
msgid ""
"                       barrier()  smp_mb()  membarrier()\n"
"       barrier()          X          X          O\n"
"       smp_mb()           X          O          O\n"
"       membarrier()       O          O          O\n"
msgstr ""
"                       barrier()  smp_mb()  membarrier()\n"
"       barrier()          X          X          O\n"
"       smp_mb()           X          O          O\n"
"       membarrier()       O          O          O\n"

#. type: Plain text
#: build/C/man2/membarrier.2:253
msgid ""
"On success, the B<MEMBARRIER_CMD_QUERY> operation returns a bit mask of "
"supported commands, and the B<MEMBARRIER_CMD_GLOBAL>, "
"B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>, and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> operations return "
"zero.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:263
msgid ""
"For a given command, with I<flags> set to 0, this system call is guaranteed "
"to always return the same value until reboot.  Further calls with the same "
"arguments will lead to the same result.  Therefore, with I<flags> set to 0, "
"error handling is required only for the first call to B<membarrier>()."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:278
msgid ""
"I<cmd> is invalid, or I<flags> is nonzero, or the B<MEMBARRIER_CMD_GLOBAL> "
"command is disabled because the I<nohz_full> CPU parameter has been set, or "
"the B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> commands are not "
"implemented by the architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:283
msgid "The B<membarrier>()  system call is not implemented by this kernel."
msgstr "システムコール B<membarrier>() はこのカーネルでサポートされていない。"

#. type: Plain text
#: build/C/man2/membarrier.2:287
msgid ""
"The current process was not registered prior to using private expedited "
"commands."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:291
msgid "The B<membarrier>()  system call was added in Linux 4.3."
msgstr "B<membarrier>() システムコールは Linux 4.3 で追加された。"

#. type: Plain text
#: build/C/man2/membarrier.2:295
msgid "Before Linux 5.10, the prototype for B<membarrier>()  was:"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:299
#, no-wrap
msgid "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>\n"
msgstr "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>\n"

#.  .SH SEE ALSO
#.  FIXME See if the following syscalls make it into Linux 4.15 or later
#.  .BR cpu_opv (2),
#.  .BR rseq (2)
#. type: Plain text
#: build/C/man2/membarrier.2:308
msgid "B<membarrier>()  is Linux-specific."
msgstr "B<membarrier>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/membarrier.2:317
msgid ""
"A memory barrier instruction is part of the instruction set of architectures "
"with weakly ordered memory models.  It orders memory accesses prior to the "
"barrier and after the barrier with respect to matching barriers on other "
"cores.  For instance, a load fence can order loads prior to and following "
"that fence with respect to stores ordered by store fences."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:320
msgid ""
"Program order is the order in which instructions are ordered in the program "
"assembly code."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:325
msgid ""
"Examples where B<membarrier>()  can be useful include implementations of "
"Read-Copy-Update libraries and garbage collectors."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:333
msgid ""
"Assuming a multithreaded application where \"fast_path()\" is executed very "
"frequently, and where \"slow_path()\" is executed infrequently, the "
"following code (x86) can be transformed using B<membarrier>():"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:337
#, no-wrap
msgid "#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man2/membarrier.2:339 build/C/man2/membarrier.2:397
#, no-wrap
msgid "static volatile int a, b;\n"
msgstr "static volatile int a, b;\n"

#. type: Plain text
#: build/C/man2/membarrier.2:347
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"

#. type: Plain text
#: build/C/man2/membarrier.2:355
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_a = a;\n"
"}\n"
msgstr ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_a = a;\n"
"}\n"

#. type: Plain text
#: build/C/man2/membarrier.2:360 build/C/man2/membarrier.2:446
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int read_a, read_b;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int read_a, read_b;\n"

#. type: Plain text
#: build/C/man2/membarrier.2:366 build/C/man2/membarrier.2:455
#, no-wrap
msgid ""
"    /*\n"
"     * Real applications would call fast_path() and slow_path()\n"
"     * from different threads. Call those from main() to keep\n"
"     * this example short.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:369 build/C/man2/membarrier.2:458
#, no-wrap
msgid ""
"    slow_path(&read_a);\n"
"    fast_path(&read_b);\n"
msgstr ""
"    slow_path(&read_a);\n"
"    fast_path(&read_b);\n"

#. type: Plain text
#: build/C/man2/membarrier.2:374 build/C/man2/membarrier.2:463
#, no-wrap
msgid ""
"    /*\n"
"     * read_b == 0 implies read_a == 1 and\n"
"     * read_a == 0 implies read_b == 1.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:377 build/C/man2/membarrier.2:466
#, no-wrap
msgid ""
"    if (read_b == 0 && read_a == 0)\n"
"        abort();\n"
msgstr ""
"    if (read_b == 0 && read_a == 0)\n"
"        abort();\n"

#. type: Plain text
#: build/C/man2/membarrier.2:386
msgid "The code above transformed to use B<membarrier>()  becomes:"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:395
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/membarrier.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/membarrier.hE<gt>\n"

#. type: Plain text
#: build/C/man2/membarrier.2:403
#, no-wrap
msgid ""
"static int\n"
"membarrier(int cmd, unsigned int flags, int cpu_id)\n"
"{\n"
"    return syscall(__NR_membarrier, cmd, flags, cpu_id);\n"
"}\n"
msgstr ""
"static int\n"
"membarrier(int cmd, unsigned int flags, int cpu_id)\n"
"{\n"
"    return syscall(__NR_membarrier, cmd, flags, cpu_id);\n"
"}\n"

#. type: Plain text
#: build/C/man2/membarrier.2:408
#, no-wrap
msgid ""
"static int\n"
"init_membarrier(void)\n"
"{\n"
"    int ret;\n"
msgstr ""
"static int\n"
"init_membarrier(void)\n"
"{\n"
"    int ret;\n"

#. type: Plain text
#: build/C/man2/membarrier.2:410
#, no-wrap
msgid "    /* Check that membarrier() is supported. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:416
#, no-wrap
msgid ""
"    ret = membarrier(MEMBARRIER_CMD_QUERY, 0, 0);\n"
"    if (ret E<lt> 0) {\n"
"        perror(\"membarrier\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    ret = membarrier(MEMBARRIER_CMD_QUERY, 0, 0);\n"
"    if (ret E<lt> 0) {\n"
"        perror(\"membarrier\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/membarrier.2:422
#, no-wrap
msgid ""
"    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n"
"        fprintf(stderr,\n"
"            \"membarrier does not support MEMBARRIER_CMD_GLOBAL\\en\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n"
"        fprintf(stderr,\n"
"            \"membarrier does not support MEMBARRIER_CMD_GLOBAL\\en\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/membarrier.2:425
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man2/membarrier.2:433
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"

#. type: Plain text
#: build/C/man2/membarrier.2:441
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    membarrier(MEMBARRIER_CMD_GLOBAL, 0, 0);\n"
"    *read_a = a;\n"
"}\n"
msgstr ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    membarrier(MEMBARRIER_CMD_GLOBAL, 0, 0);\n"
"    *read_a = a;\n"
"}\n"

#. type: Plain text
#: build/C/man2/membarrier.2:449
#, no-wrap
msgid ""
"    if (init_membarrier())\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    if (init_membarrier())\n"
"        exit(EXIT_FAILURE);\n"

#. type: TH
#: build/C/man2/pkey_alloc.2:25
#, no-wrap
msgid "PKEY_ALLOC"
msgstr "PKEY_ALLOC"

#. type: Plain text
#: build/C/man2/pkey_alloc.2:28
msgid "pkey_alloc, pkey_free - allocate or free a protection key"
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:35
#, no-wrap
msgid ""
"B<int pkey_alloc(unsigned int >I<flags>B<, unsigned int >I<access_rights>B<);>\n"
"B<int pkey_free(int >I<pkey>B<);>\n"
msgstr ""
"B<int pkey_alloc(unsigned int >I<flags>B<, unsigned int >I<access_rights>B<);>\n"
"B<int pkey_free(int >I<pkey>B<);>\n"

#. type: Plain text
#: build/C/man2/pkey_alloc.2:40
msgid ""
"B<pkey_alloc>()  allocates a protection key (pkey) and allows it to be "
"passed to B<pkey_mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:45
msgid ""
"The B<pkey_alloc>()  I<flags> is reserved for future use and currently must "
"always be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:50
msgid ""
"The B<pkey_alloc>()  I<access_rights> argument may contain zero or more "
"disable operations:"
msgstr ""

#. type: TP
#: build/C/man2/pkey_alloc.2:50
#, no-wrap
msgid "B<PKEY_DISABLE_ACCESS>"
msgstr "B<PKEY_DISABLE_ACCESS>"

#. type: Plain text
#: build/C/man2/pkey_alloc.2:53
msgid ""
"Disable all data access to memory covered by the returned protection key."
msgstr ""

#. type: TP
#: build/C/man2/pkey_alloc.2:53
#, no-wrap
msgid "B<PKEY_DISABLE_WRITE>"
msgstr "B<PKEY_DISABLE_WRITE>"

#. type: Plain text
#: build/C/man2/pkey_alloc.2:56
msgid "Disable write access to memory covered by the returned protection key."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:62
msgid ""
"B<pkey_free>()  frees a protection key and makes it available for later "
"allocations.  After a protection key has been freed, it may no longer be "
"used in any protection-key-related operations."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:70
msgid ""
"An application should not call B<pkey_free>()  on any protection key which "
"has been assigned to an address range by B<pkey_mprotect>(2)  and which is "
"still in use.  The behavior in this case is undefined and may result in an "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:80
msgid ""
"On success, B<pkey_alloc>()  returns a positive protection key value.  On "
"success, B<pkey_free>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:88
msgid "I<pkey>, I<flags>, or I<access_rights> is invalid."
msgstr "I<pkey>, I<flags>, I<access_rights> のいずれかが無効である。"

#. type: Plain text
#: build/C/man2/pkey_alloc.2:97
msgid ""
"(B<pkey_alloc>())  All protection keys available for the current process "
"have been allocated.  The number of keys available is architecture-specific "
"and implementation-specific and may be reduced by kernel-internal use of "
"certain keys.  There are currently 15 keys available to user programs on x86."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:103
msgid ""
"This error will also be returned if the processor or operating system does "
"not support protection keys.  Applications should always be prepared to "
"handle this error, since factors outside of the application's control can "
"reduce the number of available pkeys."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:109
msgid ""
"B<pkey_alloc>()  and B<pkey_free>()  were added to Linux in kernel 4.9; "
"library support was added in glibc 2.27."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:115
msgid ""
"The B<pkey_alloc>()  and B<pkey_free>()  system calls are Linux-specific."
msgstr "システムコール B<pkey_alloc>() と B<pkey_free>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/pkey_alloc.2:123
msgid ""
"B<pkey_alloc>()  is always safe to call regardless of whether or not the "
"operating system supports protection keys.  It can be used in lieu of any "
"other mechanism for detecting pkey support and will simply fail with the "
"error B<ENOSPC> if the operating system has no pkey support."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:134
msgid ""
"The kernel guarantees that the contents of the hardware rights register "
"(PKRU) will be preserved only for allocated protection keys.  Any time a key "
"is unallocated (either before the first call returning that key from "
"B<pkey_alloc>()  or after it is freed via B<pkey_free>()), the kernel may "
"make arbitrary changes to the parts of the rights register affecting access "
"to that key."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:137
msgid "See B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:140
msgid "B<pkey_mprotect>(2), B<pkeys>(7)"
msgstr "B<pkey_mprotect>(2), B<pkeys>(7)"

#. type: TH
#: build/C/man7/pkeys.7:25
#, no-wrap
msgid "PKEYS"
msgstr "PKEYS"

#. type: Plain text
#: build/C/man7/pkeys.7:28
msgid "pkeys - overview of Memory Protection Keys"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:37
msgid ""
"Memory Protection Keys (pkeys) are an extension to existing page-based "
"memory permissions.  Normal page permissions using page tables require "
"expensive system calls and TLB invalidations when changing permissions.  "
"Memory Protection Keys provide a mechanism for changing protections without "
"requiring modification of the page tables on every permission change."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:43
msgid ""
"To use pkeys, software must first \"tag\" a page in the page tables with a "
"pkey.  After this tag is in place, an application only has to change the "
"contents of a register in order to remove write access, or all access to a "
"tagged page."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:54
msgid ""
"Protection keys work in conjunction with the existing B<PROT_READ>/ "
"B<PROT_WRITE>/ B<PROT_EXEC> permissions passed to system calls such as "
"B<mprotect>(2)  and B<mmap>(2), but always act to further restrict these "
"traditional permission mechanisms."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:62
msgid ""
"If a process performs an access that violates pkey restrictions, it receives "
"a B<SIGSEGV> signal.  See B<sigaction>(2)  for details of the information "
"available with that signal."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:72
msgid ""
"To use the pkeys feature, the processor must support it, and the kernel must "
"contain support for the feature on a given processor.  As of early 2016 only "
"future Intel x86 processors are supported, and this hardware supports 16 "
"protection keys in each process.  However, pkey 0 is used as the default "
"key, so a maximum of 15 are available for actual application use.  The "
"default key is assigned to any memory region for which a pkey has not been "
"explicitly assigned via B<pkey_mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:80
msgid ""
"Protection keys have the potential to add a layer of security and "
"reliability to applications.  But they have not been primarily designed as a "
"security feature.  For instance, WRPKRU is a completely unprivileged "
"instruction, so pkeys are useless in any case that an attacker controls the "
"PKRU register or can execute arbitrary instructions."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:99
msgid ""
"Applications should be very careful to ensure that they do not \"leak\" "
"protection keys.  For instance, before calling B<pkey_free>(2), the "
"application should be sure that no memory has that pkey assigned.  If the "
"application left the freed pkey assigned, a future user of that pkey might "
"inadvertently change the permissions of an unrelated data structure, which "
"could impact security or stability.  The kernel currently allows in-use "
"pkeys to have B<pkey_free>(2)  called on them because it would have "
"processor or memory performance implications to perform the additional "
"checks needed to disallow it.  Implementation of the necessary checks is "
"left up to applications.  Applications may implement these checks by "
"searching the I</proc/[pid]/smaps> file for memory regions with the pkey "
"assigned.  Further details can be found in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:113
msgid ""
"Any application wanting to use protection keys needs to be able to function "
"without them.  They might be unavailable because the hardware that the "
"application runs on does not support them, the kernel code does not contain "
"support, the kernel support has been disabled, or because the keys have all "
"been allocated, perhaps by a library the application is using.  It is "
"recommended that applications wanting to use protection keys should simply "
"call B<pkey_alloc>(2)  and test whether the call succeeds, instead of "
"attempting to detect support for the feature in any other way."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:126
msgid ""
"Although unnecessary, hardware support for protection keys may be enumerated "
"with the I<cpuid> instruction.  Details of how to do this can be found in "
"the Intel Software Developers Manual.  The kernel performs this enumeration "
"and exposes the information in I</proc/cpuinfo> under the \"flags\" field.  "
"The string \"pku\" in this field indicates hardware support for protection "
"keys and the string \"ospke\" indicates that the kernel contains and has "
"enabled protection keys support."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:139
msgid ""
"Applications using threads and protection keys should be especially "
"careful.  Threads inherit the protection key rights of the parent at the "
"time of the B<clone>(2), system call.  Applications should either ensure "
"that their own permissions are appropriate for child threads at the time "
"when B<clone>(2)  is called, or ensure that each child thread can perform "
"its own initialization of protection key rights."
msgstr ""

#. type: SS
#: build/C/man7/pkeys.7:139
#, no-wrap
msgid "Signal Handler Behavior"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:148
msgid ""
"Each time a signal handler is invoked (including nested signals), the thread "
"is temporarily given a new, default set of protection key rights that "
"override the rights from the interrupted context.  This means that "
"applications must re-establish their desired protection key rights upon "
"entering a signal handler if the desired rights differ from the defaults.  "
"The rights of any interrupted context are restored when the signal handler "
"returns."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:154
msgid ""
"This signal behavior is unusual and is due to the fact that the x86 PKRU "
"register (which stores protection key access rights) is managed with the "
"same hardware mechanism (XSAVE) that manages floating-point registers.  The "
"signal behavior is the same as that of floating-point registers."
msgstr ""

#. type: SS
#: build/C/man7/pkeys.7:154
#, no-wrap
msgid "Protection Keys system calls"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:160
msgid ""
"The Linux kernel implements the following pkey-related system calls: "
"B<pkey_mprotect>(2), B<pkey_alloc>(2), and B<pkey_free>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:165
msgid ""
"The Linux pkey system calls are available only if the kernel was configured "
"and built with the B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:174
msgid ""
"The program below allocates a page of memory with read and write "
"permissions.  It then writes some data to the memory and successfully reads "
"it back.  After that, it attempts to allocate a protection key and disallows "
"access to the page by using the WRPKRU instruction.  It then tries to access "
"the page, which we now expect to cause a fatal signal to the application."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:181
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"buffer contains: 73\n"
"about to read buffer again...\n"
"Segmentation fault (core dumped)\n"
msgstr ""
"$B< ./a.out>\n"
"buffer contains: 73\n"
"about to read buffer again...\n"
"Segmentation fault (core dumped)\n"

#. type: Plain text
#: build/C/man7/pkeys.7:191
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"

#. type: Plain text
#: build/C/man7/pkeys.7:198
#, no-wrap
msgid ""
"static inline void\n"
"wrpkru(unsigned int pkru)\n"
"{\n"
"    unsigned int eax = pkru;\n"
"    unsigned int ecx = 0;\n"
"    unsigned int edx = 0;\n"
msgstr ""
"static inline void\n"
"wrpkru(unsigned int pkru)\n"
"{\n"
"    unsigned int eax = pkru;\n"
"    unsigned int ecx = 0;\n"
"    unsigned int edx = 0;\n"

#. type: Plain text
#: build/C/man7/pkeys.7:202
#, no-wrap
msgid ""
"    asm volatile(\".byte 0x0f,0x01,0xef\\en\\et\"\n"
"                 : : \"a\" (eax), \"c\" (ecx), \"d\" (edx));\n"
"}\n"
msgstr ""
"    asm volatile(\".byte 0x0f,0x01,0xef\\en\\et\"\n"
"                 : : \"a\" (eax), \"c\" (ecx), \"d\" (edx));\n"
"}\n"

#. type: Plain text
#: build/C/man7/pkeys.7:209
#, no-wrap
msgid ""
"int\n"
"pkey_set(int pkey, unsigned long rights, unsigned long flags)\n"
"{\n"
"    unsigned int pkru = (rights E<lt>E<lt> (2 * pkey));\n"
"    return wrpkru(pkru);\n"
"}\n"
msgstr ""
"int\n"
"pkey_set(int pkey, unsigned long rights, unsigned long flags)\n"
"{\n"
"    unsigned int pkru = (rights E<lt>E<lt> (2 * pkey));\n"
"    return wrpkru(pkru);\n"
"}\n"

#. type: Plain text
#: build/C/man7/pkeys.7:216
#, no-wrap
msgid ""
"int\n"
"pkey_mprotect(void *ptr, size_t size, unsigned long orig_prot,\n"
"              unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_mprotect, ptr, size, orig_prot, pkey);\n"
"}\n"
msgstr ""
"int\n"
"pkey_mprotect(void *ptr, size_t size, unsigned long orig_prot,\n"
"              unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_mprotect, ptr, size, orig_prot, pkey);\n"
"}\n"

#. type: Plain text
#: build/C/man7/pkeys.7:222
#, no-wrap
msgid ""
"int\n"
"pkey_alloc(void)\n"
"{\n"
"    return syscall(SYS_pkey_alloc, 0, 0);\n"
"}\n"
msgstr ""
"int\n"
"pkey_alloc(void)\n"
"{\n"
"    return syscall(SYS_pkey_alloc, 0, 0);\n"
"}\n"

#. type: Plain text
#: build/C/man7/pkeys.7:228
#, no-wrap
msgid ""
"int\n"
"pkey_free(unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_free, pkey);\n"
"}\n"
msgstr ""
"int\n"
"pkey_free(unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_free, pkey);\n"
"}\n"

#. type: Plain text
#: build/C/man7/pkeys.7:231
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                           } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                           } while (0)\n"

#. type: Plain text
#: build/C/man7/pkeys.7:238
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int status;\n"
"    int pkey;\n"
"    int *buffer;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int status;\n"
"    int pkey;\n"
"    int *buffer;\n"

#. type: Plain text
#: build/C/man7/pkeys.7:246
#, no-wrap
msgid ""
"    /*\n"
"     *Allocate one page of memory\n"
"     */\n"
"    buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n"
"                  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n"
"    if (buffer == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""
"    /*\n"
"     *Allocate one page of memory\n"
"     */\n"
"    buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n"
"                  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n"
"    if (buffer == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"

#. type: Plain text
#: build/C/man7/pkeys.7:252
#, no-wrap
msgid ""
"    /*\n"
"     * Put some random data into the page (still OK to touch)\n"
"     */\n"
"    *buffer = __LINE__;\n"
"    printf(\"buffer contains: %d\\en\", *buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:259
#, no-wrap
msgid ""
"    /*\n"
"     * Allocate a protection key:\n"
"     */\n"
"    pkey = pkey_alloc();\n"
"    if (pkey == -1)\n"
"        errExit(\"pkey_alloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:267
#, no-wrap
msgid ""
"    /*\n"
"     * Disable access to any memory with \"pkey\" set,\n"
"     * even though there is none right now\n"
"     */\n"
"    status = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0);\n"
"    if (status)\n"
"        errExit(\"pkey_set\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:277
#, no-wrap
msgid ""
"    /*\n"
"     * Set the protection key on \"buffer\".\n"
"     * Note that it is still read/write as far as mprotect() is\n"
"     * concerned and the previous pkey_set() overrides it.\n"
"     */\n"
"    status = pkey_mprotect(buffer, getpagesize(),\n"
"                           PROT_READ | PROT_WRITE, pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_mprotect\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:279
#, no-wrap
msgid "    printf(\"about to read buffer again...\\en\");\n"
msgstr "    printf(\"about to read buffer again...\\en\");\n"

#. type: Plain text
#: build/C/man7/pkeys.7:284
#, no-wrap
msgid ""
"    /*\n"
"     * This will crash, because we have disallowed access\n"
"     */\n"
"    printf(\"buffer contains: %d\\en\", *buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:288
#, no-wrap
msgid ""
"    status = pkey_free(pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_free\");\n"
msgstr ""
"    status = pkey_free(pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_free\");\n"

#. type: Plain text
#: build/C/man7/pkeys.7:297
msgid "B<pkey_alloc>(2), B<pkey_free>(2), B<pkey_mprotect>(2), B<sigaction>(2)"
msgstr "B<pkey_alloc>(2), B<pkey_free>(2), B<pkey_mprotect>(2), B<sigaction>(2)"

#~ msgid ""
#~ "This Linux-specific system call is available only on MIPS-based systems.  "
#~ "It should not be used in programs intended to be portable."
#~ msgstr ""
#~ "この Linux 特有のシステムコールは MIPS ベースのシステムでのみ有効である。 "
#~ "移植を意図したプログラムで使用すべきではない。"

#~ msgid ""
#~ "Do not expect access in the near future.  (For the time being, the "
#~ "application is finished with the given range, so the kernel can free "
#~ "resources associated with it.)  Subsequent accesses of pages in this "
#~ "range will succeed, but will result either in reloading of the memory "
#~ "contents from the underlying mapped file (see B<mmap>(2))  or zero-fill-"
#~ "on-demand pages for mappings without an underlying file."
#~ msgstr ""
#~ "しばらくアクセスはなさそうだ。 (現時点でアプリケーションは与えた範囲の処理"
#~ "を終えている。 したがってカーネルはこれに関連するリソースを解放して良"
#~ "い。)  これ以降この範囲のページへのアクセスがあると、 成功はするが、メモ"
#~ "リーの内容をマップ元のファイルからロードし直すことになる (B<mmap>(2)  を見"
#~ "よ) か、 または元ファイルがないマップページでは アクセスがあったときに 0 "
#~ "埋めが行われることになる。"

#~ msgid ""
#~ "Free up a given range of pages and its associated backing store.  "
#~ "Currently, only shmfs/tmpfs supports this; other filesystems return with "
#~ "the error B<ENOSYS>."
#~ msgstr ""
#~ "指定された範囲のページと関連するバッキングストアを解放する。 現在のとこ"
#~ "ろ、 shmfs/tmpfs だけがこれに対応している。 他のファイルシステムでは "
#~ "B<ENOSYS> が返される。"

#~ msgid "This error can occur for the following reasons:"
#~ msgstr "このエラーは以下の理由で発生する。"

#~ msgid "The value I<len> is negative."
#~ msgstr "I<len> が負の値である。"

#~ msgid ""
#~ "The application is attempting to release locked or shared pages (with "
#~ "B<MADV_DONTNEED>)."
#~ msgstr ""
#~ "アプリケーションがロックされたページや共有ページを (B<MADV_DONTNEED> で) "
#~ "解放\n"
#~ "しようとしている。"

#~ msgid ""
#~ "The current Linux implementation (2.4.0) views this system call more as a "
#~ "command than as advice and hence may return an error when it cannot do "
#~ "what it usually would do in response to this advice.  (See the ERRORS "
#~ "description above.)  This is nonstandard behavior."
#~ msgstr ""
#~ "現在の Linux の実装 (2.4.0) では、 このシステムコールをアドバイスというよ"
#~ "りは命令と見ている。 したがってこのアドバイスに対して通常行われる動作が不"
#~ "可能な場合は、 エラーを返すことがある (上記の エラー の記述を参照)。 この"
#~ "振舞いは標準とは異なる。"

#~ msgid ""
#~ "This function cannot release free memory located at places other than the "
#~ "top of the heap."
#~ msgstr ""
#~ "この関数は、 ヒープの一番上以外の場所にある未使用メモリーを解放することは"
#~ "できない。"

#~ msgid "This function releases only memory in the main arena."
#~ msgstr "この関数はメイン領域のメモリーだけを解放する。"

#~ msgid "AVAILABILITY"
#~ msgstr "可用性"

#~ msgid "Both of these flags are described in POSIX.1-2001."
#~ msgstr "上記の二つのフラグは POSIX.1-2001 で規定されている。"

#~ msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
#~ msgstr "B<MAP_ANONYMOUS> の同義語。非推奨。"

#~ msgid ""
#~ "Used for stacks.  Indicates to the kernel virtual memory system that the "
#~ "mapping should extend downward in memory."
#~ msgstr ""
#~ "スタック用に使用される。マッピングをメモリー内で逆向きに行うことを カーネ"
#~ "ル仮想メモリーシステムに指示する。 (訳注：マッピングは通常はメモリーアドレ"
#~ "スが増加する向きに行うが、 このオプションを指定すると逆向きにマッピングを"
#~ "行う)"

#~ msgid ""
#~ "Lock the pages of the mapped region into memory in the manner of "
#~ "B<mlock>(2).  This flag is ignored in older kernels."
#~ msgstr ""
#~ "マップされた領域のページを B<mlock>(2)  の方法でメモリー内にロックする。 "
#~ "それ以前のカーネルでは、このフラグは無視される。"

#~ msgid ""
#~ "Allocate the mapping at an address suitable for a process or thread "
#~ "stack.  This flag is currently a no-op, but is used in the glibc "
#~ "threading implementation so that if some architectures require special "
#~ "treatment for stack allocations, support can later be transparently "
#~ "implemented for glibc."
#~ msgstr ""
#~ "プロセスやスレッドのスタックに適したアドレスにマッピングを割り当てる。 現"
#~ "在のところ、このフラグは何もしないが、 glibc のスレッド実装では使用されて"
#~ "いる。 これは、いくつかのアーキテクチャーではスタックの割り当てに関して特"
#~ "別な扱い が必要な場合に、glibc にそのサポートを後で透過的に実装できるよう"
#~ "にする ためである。"

#~ msgid ""
#~ "Some systems document the additional flags B<MAP_AUTOGROW>, "
#~ "B<MAP_AUTORESRV>, B<MAP_COPY>, and B<MAP_LOCAL>."
#~ msgstr ""
#~ "いくつかのシステムでは、上記以外にフラグとして B<MAP_AUTOGROW>, "
#~ "B<MAP_AUTORESRV>, B<MAP_COPY>, B<MAP_LOCAL> が規定されている。"

#~ msgid ""
#~ "On success, B<mmap>()  returns a pointer to the mapped area.  On error, "
#~ "the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and "
#~ "I<errno> is set appropriately.  On success, B<munmap>()  returns 0, on "
#~ "failure -1, and I<errno> is set (probably to B<EINVAL>)."
#~ msgstr ""
#~ "B<mmap>()  は成功するとマップされた領域へのポインターを返す。 失敗すると"
#~ "値 B<MAP_FAILED> (つまり I<(void\\ *)\\ -1>)  を返し、 I<errno> がエラーの"
#~ "内容にしたがってセットされる。 B<munmap>()  は成功すると 0 を返す。失敗す"
#~ "ると -1 を返し、 I<errno> がセットされる (多くの場合 B<EINVAL> になるだろ"
#~ "う)。"

#~ msgid "The system limit on the total number of open files has been reached."
#~ msgstr "システム全体でオープンされているファイルの総数が上限に達した。"

#~ msgid ""
#~ "No memory is available, or the process's maximum number of mappings would "
#~ "have been exceeded."
#~ msgstr ""
#~ "メモリーに空きがない、または処理中のプロセスのマッピング数が最大数を超過し"
#~ "た。"

#~ msgid ""
#~ "Attempted access to a portion of the buffer that does not correspond to "
#~ "the file (for example, beyond the end of the file, including the case "
#~ "where another process has truncated the file)."
#~ msgstr ""
#~ "バッファーのうち、ファイルに関連づけられていない部分 (例えばファイル末尾を"
#~ "越えた部分など。これには 他のプロセスがファイルを切り詰めた場合なども含ま"
#~ "れる)  にアクセスしようとした。"

#~ msgid ""
#~ "An invalid argument was given.  Possible causes are: I<old_address> was "
#~ "not page aligned; a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> "
#~ "was specified in I<flags>; I<new_size> was zero; I<new_size> or "
#~ "I<new_address> was invalid; or the new address range specified by "
#~ "I<new_address> and I<new_size> overlapped the old address range specified "
#~ "by I<old_address> and I<old_size>; or B<MREMAP_FIXED> was specified "
#~ "without also specifying B<MREMAP_MAYMOVE>."
#~ msgstr ""
#~ "不正な引き数が与えられた。 可能性のある原因は以下の通りである: たいていは "
#~ "I<old_address> がページ境界に 合ってない; I<flags> に B<MREMAP_MAYMOVE> ま"
#~ "たは B<MREMAP_FIXED> 以外の値が指定されている; I<new_size> がゼロ; "
#~ "I<new_size> または I<new_address> の値が不正; I<new_address> と "
#~ "I<new_size> で指定される新しいアドレス範囲が I<old_address> と "
#~ "I<old_size> で指定される古いアドレス範囲と重なっている; B<MREMAP_FIXED> が"
#~ "指定されているが B<MREMAP_MAYMOVE> が指定されていない。"

#~ msgid ""
#~ "The I<flags> argument may have the bits B<MS_ASYNC>, B<MS_SYNC>, and "
#~ "B<MS_INVALIDATE> set, but not both B<MS_ASYNC> and B<MS_SYNC>.  "
#~ "B<MS_ASYNC> specifies that an update be scheduled, but the call returns "
#~ "immediately.  B<MS_SYNC> asks for an update and waits for it to "
#~ "complete.  B<MS_INVALIDATE> asks to invalidate other mappings of the same "
#~ "file (so that they can be updated with the fresh values just written)."
#~ msgstr ""
#~ "I<flags> 引数にはビット B<MS_ASYNC>, B<MS_SYNC>, B<MS_INVALIDATE> を設定す"
#~ "ることができるが、 B<MS_ASYNC> と B<MS_SYNC> を同時に指定することはできな"
#~ "い。 B<MS_ASYNC> は更新を予定に組み込むことを表し、呼び出しは直ちに返る。 "
#~ "B<MS_SYNC> は更新を要求し、更新が完了するまで待つ。 B<MS_INVALIDATE> は"
#~ "(たった今書き込んだ新しい値でマッピングを更新することができるように)  同じ"
#~ "ファイルに対する他のマッピングを無効にすることを要求する。"

#~ msgid ""
#~ "In the glibc implementation, B<posix_fallocate>()  is implemented using "
#~ "B<fallocate>(2)."
#~ msgstr ""
#~ "glibc の実装では、 B<posix_fallocate>() は B<fallocate>() を使って実装され"
#~ "ている。"

#~ msgid ""
#~ "B<Note>: this system call is (since Linux 3.16) deprecated and will "
#~ "eventually be replaced by a slower in-kernel emulation.  Those few "
#~ "applications that use this system call should consider migrating to "
#~ "alternatives."
#~ msgstr ""
#~ "B<注意>: このシステムコールは (Linux 3.16 以降で) 非推奨となっており、 や"
#~ "がてより低速なカーネル内でのエミュレーションに置き換えられる予定である。 "
#~ "このシステムコールを使用しているアプリケーションは少ないが、こうしたアプリ"
#~ "ケーションは代替手段への移行を検討すべきである。"

#~ msgid "The process already has the maximum number of files open."
#~ msgstr "プロセスがオープン可能なファイル数の上限にすでに達していた。"

#~ msgid ""
#~ "The limit on the total number of files open on the system has been "
#~ "reached."
#~ msgstr "ファイルシステムでオープンできるファイル数の上限に達した。"

#~ msgid ""
#~ "Write the values of some members of the I<shmid_ds> structure pointed to "
#~ "by I<buf> to the kernel data structure associated with this shared memory "
#~ "segment, updating also its I<shm_ctime> member.  The following fields can "
#~ "be changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant "
#~ "9 bits of) I<shm_perm.mode>.  The effective UID of the calling process "
#~ "must match the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of "
#~ "the shared memory segment, or the caller must be privileged."
#~ msgstr ""
#~ "I<buf> によって指される I<shmid_ds> 構造体のいくつかのメンバーの値を、 こ"
#~ "の共有メモリーセグメントに関連づけられたカーネルデータ構造体に書き込み、 "
#~ "I<shm_ctime> メンバーも更新する。 以下のフィールドは変更できる。 "
#~ "I<shm_perm.uid>, I<shm_perm.gid>, I<shm_perm.mode> (の最下位 9 ビット)。 "
#~ "呼び出したプロセスの実効 UID が所有者 (I<shm_perm.uid>)  または作成者 "
#~ "(I<shm_perm.cuid>)  と一致するか、呼び出し元が特権を持たなければならない。"

#~ msgid ""
#~ "An unsupported value was specified in one of the arguments: I<flags> "
#~ "included unknown bits, or I<name> was too long."
#~ msgstr ""
#~ "サポートされていない値がいずれかの引き数で指定された。 I<flags> に未知の"
#~ "ビットが含まれていたか、 I<name> が長過ぎた。"

#~ msgid ""
#~ "The B<memfd_create>()  system call first appeared in Linux 3.17.  Support "
#~ "in the GNU C library is pending."
#~ msgstr ""
#~ "B<memfd_create>() システムコールは Linux 3.17 で初めて登場した。 GNU C ラ"
#~ "イブラリでのサポートは検討中である。"

#~ msgid "System-wide limit on the number of pages of shared memory."
#~ msgstr "共有メモリーのページ数のシステム全体での上限値。"

#~ msgid ""
#~ "Segment low boundary address multiple.  Must be page aligned.  For the "
#~ "current implementation, the B<SHMLBA> value is B<PAGE_SIZE>."
#~ msgstr ""
#~ "セグメントの境界アドレスの最小倍数。ページ境界に合ってなければならない。 "
#~ "現在の実装では B<SHMLBA> の値は B<PAGE_SIZE> である。"

#~ msgid "B<IPC_CREAT | IPC_EXCL> was specified and the segment exists."
#~ msgstr ""
#~ "B<IPC_CREAT | IPC_EXCL> が指定されていたが、そのセグメントが既に存在する。"

#~ msgid ""
#~ "Assuming a 4kB page size, this formula yields (since Linux 2.4) the value "
#~ "2^20 (2,097,152)."
#~ msgstr ""
#~ "4kB ページサイズと仮定すると、 (Linux 2.4 以降では) この式の結果は 2^20 "
#~ "(2,097,152) になる。"

#~ msgid ""
#~ "Maximum size in bytes for a shared memory segment: policy dependent (on "
#~ "Linux, this limit can be read and modified via I</proc/sys/kernel/"
#~ "shmmax>)."
#~ msgstr ""
#~ "共有メモリーセグメントのバイト単位の大きさの上限: 方針依存 (Linux では、こ"
#~ "の上限値は I</proc/sys/kernel/shmmax> 経由で参照したり、変更したりでき"
#~ "る)。"

#~ msgid ""
#~ "System wide maximum number of shared memory segments: implementation "
#~ "dependent (currently 4096, was 128 before Linux 2.3.99; on Linux, this "
#~ "limit can be read and modified via I</proc/sys/kernel/shmmni>)."
#~ msgstr ""
#~ "システム全体の共有メモリーの数の上限: 実装依存 (現在は 4096。Linux 2.3.99 "
#~ "より前では 128。 Linux では、この上限値は I</proc/sys/kernel/shmmni> 経由"
#~ "で参照したり、変更したりできる)。"

#~ msgid ""
#~ "A valid segment identifier, I<shmid>, is returned on success, -1 on error."
#~ msgstr ""
#~ "成功した場合、有効なセグメント識別子 I<shmid> が返される。エラーの場合、 "
#~ "-1 が返される。"

#~ msgid ""
#~ "The ARM architecture needs 64-bit arguments to be aligned in a suitable "
#~ "pair of registers.  On this architecture, the call signature of "
#~ "B<posix_fadvise>()  is flawed, since it forces a register to be wasted as "
#~ "padding between the I<fd> and I<len> arguments.  Therefore, since Linux "
#~ "2.6.14, ARM defines a different system call that orders the arguments "
#~ "suitably:"
#~ msgstr ""
#~ "ARM アーキテクチャーでは、64 ビットの引き数は適切なレジスターの組に割り当"
#~ "て\n"
#~ "る必要がある。このアーキテクチャーでは、B<posix_fadvise>() の呼び出し方"
#~ "に\n"
#~ "は欠陥があり、それはこのシステムコールでは引き数 I<fd> と I<len> の間の\n"
#~ "パディング (詰めもの) でレジスターが一つ消費されてしまうというものであ"
#~ "る。\n"
#~ "そのため、Linux 2.6.14 以降では、ARM では引き数が適切な順序になった別の\n"
#~ "システムコールが定義されている。"

#~ msgid ""
#~ "The behavior of this system call is otherwise exactly the same as "
#~ "B<posix_fadvise>().  No library support is provided for this system call "
#~ "in glibc."
#~ msgstr ""
#~ "上記の点以外は、このシステムコールの動作は B<posix_fadvise>() と全く\n"
#~ "同じである。このシステムコールに対するライブラリによるサポートは glibc\n"
#~ "では提供されていない。"

#~ msgid ""
#~ "The I<mode> is not supported by the file system containing the file "
#~ "referred to by I<fd>."
#~ msgstr ""
#~ "I<fd> が参照するファイルを含むファイルシステムが I<mode> をサポートしてい"
#~ "ない。"

#~ msgid ""
#~ "The function B<mtrace>()  installs handlers for B<malloc>(3), "
#~ "B<realloc>(3)  and B<free>(3).  The function B<muntrace>()  disables "
#~ "these handlers."
#~ msgstr ""
#~ "関数 B<mtrace>()  は、 B<malloc>(3), B<realloc>(3), B<free>(3)  のハンド"
#~ "ラーを組み込む。 関数 B<muntrace>()  はこれらのハンドラーを解除する。"

#~ msgid ""
#~ "The environment variable B<MALLOC_TRACE> defines a file where "
#~ "B<mtrace>()  writes its output.  This file must be writable to the user "
#~ "or B<mtrace>()  will do nothing.  If the file is not empty it will be "
#~ "truncated."
#~ msgstr ""
#~ "環境変数 B<MALLOC_TRACE> は B<mtrace>()  が出力を書き出すファイルを指定す"
#~ "る。 ユーザーが書き込み権限を持つファイルを指定しなければならない。 書き込"
#~ "み権限がない場合、 B<mtrace>()  は何もしない。 ファイルが空でない場合、"
#~ "ファイルの元の内容を上書きする。"

#~ msgid ""
#~ "The output of B<mtrace>()  will be ASCII but not in a friendly format.  "
#~ "So glibc comes with a perl-script called mtrace to make sense of it."
#~ msgstr ""
#~ "B<mtrace>()  の出力は ASCII 形式だが、人が読みやすいフォーマットではな"
#~ "い。 そこで、glibc には mtrace 出力を分かりやすい形式に変換する perl スク"
#~ "リプトが付属している。"

#~ msgid ""
#~ "This flag allocates and initializes to zero the disk space within the "
#~ "range specified by I<offset> and I<len>.  After a successful call, "
#~ "subsequent writes into this range are guaranteed not to fail because of "
#~ "lack of disk space.  Preallocating zeroed blocks beyond the end of the "
#~ "file is useful for optimizing append workloads.  Preallocating blocks "
#~ "does not change the file size (as reported by B<stat>(2))  even if it is "
#~ "less than I<offset>+I<len>."
#~ msgstr ""
#~ "このフラグは、 I<offset> と I<len> で指定された領域のディスク空間を割り当"
#~ "て、その空間を 0 で初期化する。 呼び出しが成功すると、それに続いてこの領域"
#~ "への書き込みが行われるが、 ディスク空間の不足による書き込み失敗が発生しな"
#~ "いことが保証される。 ファイル末尾より後ろの領域について 0 で埋めたブロック"
#~ "を前もって 割り当てておくことは、追記 (append) の作業負荷を最適化するのに "
#~ "有用である。 ファイルサイズが I<offset>+I<len> よりも小さい場合であって"
#~ "も、ブロックの前もっての割り当てにより (B<stat>(2)  が返す) ファイルサイズ"
#~ "は変更されることはない。"
