# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-05-21 16:14+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/getcontext.3:25
#, no-wrap
msgid "GETCONTEXT"
msgstr "GETCONTEXT"

#. type: TH
#: build/C/man3/getcontext.3:25 build/C/man3/makecontext.3:28
#: build/C/man3/pthread_tryjoin_np.3:26 build/C/man7/pthreads.7:25
#: build/C/man7/attributes.7:24
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: TH
#: build/C/man3/getcontext.3:25 build/C/man3/pthread_attr_init.3:26
#: build/C/man3/pthread_attr_setaffinity_np.3:26
#: build/C/man3/pthread_attr_setdetachstate.3:26
#: build/C/man3/pthread_attr_setguardsize.3:26
#: build/C/man3/pthread_attr_setinheritsched.3:26
#: build/C/man3/pthread_attr_setschedparam.3:26
#: build/C/man3/pthread_attr_setschedpolicy.3:26
#: build/C/man3/pthread_attr_setscope.3:26
#: build/C/man3/pthread_attr_setstack.3:26
#: build/C/man3/pthread_attr_setstackaddr.3:26
#: build/C/man3/pthread_attr_setstacksize.3:26 build/C/man3/pthread_cancel.3:26
#: build/C/man3/pthread_cleanup_push.3:26
#: build/C/man3/pthread_cleanup_push_defer_np.3:26
#: build/C/man3/pthread_create.3:26 build/C/man3/pthread_detach.3:26
#: build/C/man3/pthread_equal.3:26 build/C/man3/pthread_exit.3:26
#: build/C/man3/pthread_getattr_np.3:26 build/C/man3/pthread_getcpuclockid.3:26
#: build/C/man3/pthread_join.3:26 build/C/man3/pthread_kill.3:26
#: build/C/man3/pthread_kill_other_threads_np.3:26
#: build/C/man3/pthread_self.3:26 build/C/man3/pthread_setaffinity_np.3:26
#: build/C/man3/pthread_setcancelstate.3:26
#: build/C/man3/pthread_setconcurrency.3:25
#: build/C/man3/pthread_setname_np.3:26 build/C/man3/pthread_setschedparam.3:26
#: build/C/man3/pthread_setschedprio.3:26 build/C/man3/pthread_sigmask.3:26
#: build/C/man3/pthread_sigqueue.3:25 build/C/man3/pthread_testcancel.3:26
#: build/C/man3/pthread_tryjoin_np.3:26 build/C/man3/pthread_yield.3:25
#: build/C/man3/pthread_atfork.3:25
#: build/C/man3/pthread_attr_setsigmask_np.3:26
#: build/C/man3/pthread_getattr_default_np.3:25
#: build/C/man3/pthread_mutex_consistent.3:26
#: build/C/man3/pthread_mutexattr_getpshared.3:25
#: build/C/man3/pthread_mutexattr_init.3:25
#: build/C/man3/pthread_mutexattr_setrobust.3:26
#: build/C/man3/pthread_spin_init.3:25 build/C/man3/pthread_spin_lock.3:25
#: build/C/man7/pthreads.7:25 build/C/man7/attributes.7:24
#: build/C/man7/nptl.7:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/getcontext.3:25 build/C/man3/makecontext.3:28
#: build/C/man3/pthread_attr_init.3:26
#: build/C/man3/pthread_attr_setaffinity_np.3:26
#: build/C/man3/pthread_attr_setdetachstate.3:26
#: build/C/man3/pthread_attr_setguardsize.3:26
#: build/C/man3/pthread_attr_setinheritsched.3:26
#: build/C/man3/pthread_attr_setschedparam.3:26
#: build/C/man3/pthread_attr_setschedpolicy.3:26
#: build/C/man3/pthread_attr_setscope.3:26
#: build/C/man3/pthread_attr_setstack.3:26
#: build/C/man3/pthread_attr_setstackaddr.3:26
#: build/C/man3/pthread_attr_setstacksize.3:26 build/C/man3/pthread_cancel.3:26
#: build/C/man3/pthread_cleanup_push.3:26
#: build/C/man3/pthread_cleanup_push_defer_np.3:26
#: build/C/man3/pthread_create.3:26 build/C/man3/pthread_detach.3:26
#: build/C/man3/pthread_equal.3:26 build/C/man3/pthread_exit.3:26
#: build/C/man3/pthread_getattr_np.3:26 build/C/man3/pthread_getcpuclockid.3:26
#: build/C/man3/pthread_join.3:26 build/C/man3/pthread_kill.3:26
#: build/C/man3/pthread_kill_other_threads_np.3:26
#: build/C/man3/pthread_rwlockattr_setkind_np.3:25
#: build/C/man3/pthread_self.3:26 build/C/man3/pthread_setaffinity_np.3:26
#: build/C/man3/pthread_setcancelstate.3:26
#: build/C/man3/pthread_setconcurrency.3:25
#: build/C/man3/pthread_setname_np.3:26 build/C/man3/pthread_setschedparam.3:26
#: build/C/man3/pthread_setschedprio.3:26 build/C/man3/pthread_sigmask.3:26
#: build/C/man3/pthread_sigqueue.3:25 build/C/man3/pthread_testcancel.3:26
#: build/C/man3/pthread_tryjoin_np.3:26 build/C/man3/pthread_yield.3:25
#: build/C/man3/pthread_atfork.3:25
#: build/C/man3/pthread_attr_setsigmask_np.3:26
#: build/C/man3/pthread_getattr_default_np.3:25
#: build/C/man3/pthread_mutex_consistent.3:26
#: build/C/man3/pthread_mutexattr_getpshared.3:25
#: build/C/man3/pthread_mutexattr_init.3:25
#: build/C/man3/pthread_mutexattr_setrobust.3:26
#: build/C/man3/pthread_spin_init.3:25 build/C/man3/pthread_spin_lock.3:25
#: build/C/man7/pthreads.7:25 build/C/man7/attributes.7:24
#: build/C/man7/nptl.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/getcontext.3:26 build/C/man3/makecontext.3:29
#: build/C/man3/pthread_attr_init.3:27
#: build/C/man3/pthread_attr_setaffinity_np.3:27
#: build/C/man3/pthread_attr_setdetachstate.3:27
#: build/C/man3/pthread_attr_setguardsize.3:27
#: build/C/man3/pthread_attr_setinheritsched.3:27
#: build/C/man3/pthread_attr_setschedparam.3:27
#: build/C/man3/pthread_attr_setschedpolicy.3:27
#: build/C/man3/pthread_attr_setscope.3:27
#: build/C/man3/pthread_attr_setstack.3:27
#: build/C/man3/pthread_attr_setstackaddr.3:27
#: build/C/man3/pthread_attr_setstacksize.3:27 build/C/man3/pthread_cancel.3:27
#: build/C/man3/pthread_cleanup_push.3:27
#: build/C/man3/pthread_cleanup_push_defer_np.3:27
#: build/C/man3/pthread_create.3:27 build/C/man3/pthread_detach.3:27
#: build/C/man3/pthread_equal.3:27 build/C/man3/pthread_exit.3:27
#: build/C/man3/pthread_getattr_np.3:27 build/C/man3/pthread_getcpuclockid.3:27
#: build/C/man3/pthread_join.3:27 build/C/man3/pthread_kill.3:27
#: build/C/man3/pthread_kill_other_threads_np.3:27
#: build/C/man3/pthread_rwlockattr_setkind_np.3:26
#: build/C/man3/pthread_self.3:27 build/C/man3/pthread_setaffinity_np.3:27
#: build/C/man3/pthread_setcancelstate.3:27
#: build/C/man3/pthread_setconcurrency.3:26
#: build/C/man3/pthread_setname_np.3:27 build/C/man3/pthread_setschedparam.3:27
#: build/C/man3/pthread_setschedprio.3:27 build/C/man3/pthread_sigmask.3:27
#: build/C/man3/pthread_sigqueue.3:26 build/C/man3/pthread_testcancel.3:27
#: build/C/man3/pthread_tryjoin_np.3:27 build/C/man3/pthread_yield.3:26
#: build/C/man3/pthread_atfork.3:26
#: build/C/man3/pthread_attr_setsigmask_np.3:27
#: build/C/man3/pthread_getattr_default_np.3:26
#: build/C/man3/pthread_mutex_consistent.3:27
#: build/C/man3/pthread_mutexattr_getpshared.3:26
#: build/C/man3/pthread_mutexattr_init.3:26
#: build/C/man3/pthread_mutexattr_setrobust.3:27
#: build/C/man3/pthread_spin_init.3:26 build/C/man3/pthread_spin_lock.3:26
#: build/C/man7/pthreads.7:26 build/C/man7/attributes.7:25
#: build/C/man7/nptl.7:27
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/getcontext.3:28
msgid "getcontext, setcontext - get or set the user context"
msgstr "getcontext, setcontext - ユーザーコンテキストを取得/設定する"

#. type: SH
#: build/C/man3/getcontext.3:28 build/C/man3/makecontext.3:31
#: build/C/man3/pthread_attr_init.3:30
#: build/C/man3/pthread_attr_setaffinity_np.3:30
#: build/C/man3/pthread_attr_setdetachstate.3:30
#: build/C/man3/pthread_attr_setguardsize.3:30
#: build/C/man3/pthread_attr_setinheritsched.3:30
#: build/C/man3/pthread_attr_setschedparam.3:30
#: build/C/man3/pthread_attr_setschedpolicy.3:30
#: build/C/man3/pthread_attr_setscope.3:30
#: build/C/man3/pthread_attr_setstack.3:30
#: build/C/man3/pthread_attr_setstackaddr.3:30
#: build/C/man3/pthread_attr_setstacksize.3:30 build/C/man3/pthread_cancel.3:29
#: build/C/man3/pthread_cleanup_push.3:30
#: build/C/man3/pthread_cleanup_push_defer_np.3:30
#: build/C/man3/pthread_create.3:29 build/C/man3/pthread_detach.3:29
#: build/C/man3/pthread_equal.3:29 build/C/man3/pthread_exit.3:29
#: build/C/man3/pthread_getattr_np.3:29 build/C/man3/pthread_getcpuclockid.3:29
#: build/C/man3/pthread_join.3:29 build/C/man3/pthread_kill.3:29
#: build/C/man3/pthread_kill_other_threads_np.3:29
#: build/C/man3/pthread_rwlockattr_setkind_np.3:29
#: build/C/man3/pthread_self.3:29 build/C/man3/pthread_setaffinity_np.3:30
#: build/C/man3/pthread_setcancelstate.3:30
#: build/C/man3/pthread_setconcurrency.3:29
#: build/C/man3/pthread_setname_np.3:29 build/C/man3/pthread_setschedparam.3:30
#: build/C/man3/pthread_setschedprio.3:29 build/C/man3/pthread_sigmask.3:29
#: build/C/man3/pthread_sigqueue.3:28 build/C/man3/pthread_testcancel.3:29
#: build/C/man3/pthread_tryjoin_np.3:30 build/C/man3/pthread_yield.3:28
#: build/C/man3/pthread_atfork.3:28
#: build/C/man3/pthread_attr_setsigmask_np.3:30
#: build/C/man3/pthread_getattr_default_np.3:29
#: build/C/man3/pthread_mutex_consistent.3:29
#: build/C/man3/pthread_mutexattr_getpshared.3:29
#: build/C/man3/pthread_mutexattr_init.3:29
#: build/C/man3/pthread_mutexattr_setrobust.3:30
#: build/C/man3/pthread_spin_init.3:28 build/C/man3/pthread_spin_lock.3:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/getcontext.3:30 build/C/man3/makecontext.3:33
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr "B<#include E<lt>ucontext.hE<gt>>"

#. type: Plain text
#: build/C/man3/getcontext.3:32
msgid "B<int getcontext(ucontext_t *>I<ucp>B<);>"
msgstr "B<int getcontext(ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: build/C/man3/getcontext.3:34
msgid "B<int setcontext(const ucontext_t *>I<ucp>B<);>"
msgstr "B<int setcontext(const ucontext_t *>I<ucp>B<);>"

#. type: SH
#: build/C/man3/getcontext.3:34 build/C/man3/makecontext.3:38
#: build/C/man3/pthread_attr_init.3:39
#: build/C/man3/pthread_attr_setaffinity_np.3:42
#: build/C/man3/pthread_attr_setdetachstate.3:41
#: build/C/man3/pthread_attr_setguardsize.3:41
#: build/C/man3/pthread_attr_setinheritsched.3:41
#: build/C/man3/pthread_attr_setschedparam.3:41
#: build/C/man3/pthread_attr_setschedpolicy.3:41
#: build/C/man3/pthread_attr_setscope.3:41
#: build/C/man3/pthread_attr_setstack.3:54
#: build/C/man3/pthread_attr_setstackaddr.3:41
#: build/C/man3/pthread_attr_setstacksize.3:41 build/C/man3/pthread_cancel.3:37
#: build/C/man3/pthread_cleanup_push.3:40
#: build/C/man3/pthread_cleanup_push_defer_np.3:53
#: build/C/man3/pthread_create.3:38 build/C/man3/pthread_detach.3:37
#: build/C/man3/pthread_equal.3:37 build/C/man3/pthread_exit.3:37
#: build/C/man3/pthread_getattr_np.3:38 build/C/man3/pthread_getcpuclockid.3:38
#: build/C/man3/pthread_join.3:37 build/C/man3/pthread_kill.3:49
#: build/C/man3/pthread_kill_other_threads_np.3:35
#: build/C/man3/pthread_rwlockattr_setkind_np.3:54
#: build/C/man3/pthread_self.3:37 build/C/man3/pthread_setaffinity_np.3:42
#: build/C/man3/pthread_setcancelstate.3:39
#: build/C/man3/pthread_setconcurrency.3:38
#: build/C/man3/pthread_setname_np.3:39 build/C/man3/pthread_setschedparam.3:41
#: build/C/man3/pthread_setschedprio.3:37 build/C/man3/pthread_sigmask.3:50
#: build/C/man3/pthread_sigqueue.3:46 build/C/man3/pthread_testcancel.3:37
#: build/C/man3/pthread_tryjoin_np.3:42 build/C/man3/pthread_yield.3:37
#: build/C/man3/pthread_atfork.3:37
#: build/C/man3/pthread_attr_setsigmask_np.3:42
#: build/C/man3/pthread_getattr_default_np.3:39
#: build/C/man3/pthread_mutex_consistent.3:50
#: build/C/man3/pthread_mutexattr_getpshared.3:40
#: build/C/man3/pthread_mutexattr_init.3:38
#: build/C/man3/pthread_mutexattr_setrobust.3:57
#: build/C/man3/pthread_spin_init.3:51 build/C/man3/pthread_spin_lock.3:53
#: build/C/man7/pthreads.7:28 build/C/man7/attributes.7:27
#: build/C/man7/nptl.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/getcontext.3:49
msgid ""
"In a System V-like environment, one has the two types I<mcontext_t> and "
"I<ucontext_t> defined in I<E<lt>ucontext.hE<gt>> and the four functions "
"B<getcontext>(), B<setcontext>(), B<makecontext>(3), and B<swapcontext>(3)  "
"that allow user-level context switching between multiple threads of control "
"within a process."
msgstr ""
"System V 的な環境では、 I<mcontext_t> および I<ucontext_t> という 2 つの型"
"と、 B<getcontext>(), B<setcontext>(), B<makecontext>(3), B<swapcontext>(3)  "
"という 4 つの関数が I<E<lt>ucontext.hE<gt>> で定義されており、あるプロセス内"
"部で制御下にある複数のスレッド間で、 ユーザーレベルのコンテキスト切替えができ"
"るようになっている。"

#. type: Plain text
#: build/C/man3/getcontext.3:57
msgid ""
"The I<mcontext_t> type is machine-dependent and opaque.  The I<ucontext_t> "
"type is a structure that has at least the following fields:"
msgstr ""
"I<mcontext_t> 型はマシン依存で、外部からは隠蔽されている。 I<ucontext_t> 型は"
"構造体で、少なくとも以下の 4 つのフィールドを持つ。"

#. type: Plain text
#: build/C/man3/getcontext.3:67
#, no-wrap
msgid ""
"typedef struct ucontext_t {\n"
"    struct ucontext_t *uc_link;\n"
"    sigset_t          uc_sigmask;\n"
"    stack_t           uc_stack;\n"
"    mcontext_t        uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"
msgstr ""
"typedef struct ucontext_t {\n"
"    struct ucontext_t *uc_link;\n"
"    sigset_t          uc_sigmask;\n"
"    stack_t           uc_stack;\n"
"    mcontext_t        uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"

#. type: Plain text
#: build/C/man3/getcontext.3:94
msgid ""
"with I<sigset_t> and I<stack_t> defined in I<E<lt>signal.hE<gt>>.  Here "
"I<uc_link> points to the context that will be resumed when the current "
"context terminates (in case the current context was created using "
"B<makecontext>(3)), I<uc_sigmask> is the set of signals blocked in this "
"context (see B<sigprocmask>(2)), I<uc_stack> is the stack used by this "
"context (see B<sigaltstack>(2)), and I<uc_mcontext> is the machine-specific "
"representation of the saved context, that includes the calling thread's "
"machine registers."
msgstr ""
"I<sigset_t> と I<stack_t> は I<E<lt>signal.hE<gt>> で定義されている。 ここで "
"I<uc_link> は、 現在のコンテキストが終了したとき、 続いて切り替わるコンテキス"
"トへのポインターである (現在のコンテキストが B<makecontext>(3)  で生成された"
"ものの場合)。 I<uc_sigmask> はこのコンテキストでブロックされている シグナル群"
"である (B<sigprocmask>(2)  を見よ)。 I<uc_stack> はこのコンテキストが用いてい"
"るスタックである (B<signalstack>(2)  を見よ)。 I<uc_mcontext> は保存されてい"
"るコンテキストの マシン特有の表現形式であり、 ここには呼び出したスレッドのマ"
"シンレジスターが格納される。"

#. type: Plain text
#: build/C/man3/getcontext.3:101
msgid ""
"The function B<getcontext>()  initializes the structure pointed to by I<ucp> "
"to the currently active context."
msgstr ""
"B<getcontext>()  関数は、 ポインター I<ucp> が指す構造体を、 現在アクティブな"
"コンテキストに初期化する。"

#. type: Plain text
#: build/C/man3/getcontext.3:117
#, fuzzy
#| msgid ""
#| "The function B<setcontext>()  restores the user context pointed at by "
#| "I<ucp>.  A successful call does not return.  The context should have been "
#| "obtained by a call of B<getcontext>(), or B<makecontext>(3), or passed as "
#| "third argument to a signal handler."
msgid ""
"The function B<setcontext>()  restores the user context pointed to by "
"I<ucp>.  A successful call does not return.  The context should have been "
"obtained by a call of B<getcontext>(), or B<makecontext>(3), or received as "
"the third argument to a signal handler (see the discussion of the "
"B<SA_SIGINFO> flag in B<sigaction>(2))."
msgstr ""
"B<setcontext>()  関数は、ポインター I<ucp> が指すユーザーコンテキストをリスト"
"アする。 呼び出しに成功すると返らない。 このコンテキストは、以前に "
"B<getcontext>()  または B<makecontext>(3)  で得られたものか、 あるいはシグナ"
"ルの第三引数として与えられたものになる。"

#. type: Plain text
#: build/C/man3/getcontext.3:121
msgid ""
"If the context was obtained by a call of B<getcontext>(), program execution "
"continues as if this call just returned."
msgstr ""
"コンテキストが B<getcontext>()  の呼び出しによって得られていたものの場合は、 "
"プログラムはこの呼び出しから返った直後からのように実行を継続する。"

#. type: Plain text
#: build/C/man3/getcontext.3:138
msgid ""
"If the context was obtained by a call of B<makecontext>(3), program "
"execution continues by a call to the function I<func> specified as the "
"second argument of that call to B<makecontext>(3).  When the function "
"I<func> returns, we continue with the I<uc_link> member of the structure "
"I<ucp> specified as the first argument of that call to B<makecontext>(3).  "
"When this member is NULL, the thread exits."
msgstr ""
"コンテキストが B<makecontext>(3)  の呼び出しによって得られていたものの場合"
"は、 プログラムの実行はその B<makecontext>(3)  呼び出しの第二引数で指定された"
"関数 I<func> を呼び出すかたちで継続する。 I<func> から返ると、 "
"B<makecontext>(3)  呼び出しの第一引数で指定されていた I<ucp> 構造体の "
"I<uc_link> メンバで継続する。 このメンバが NULL だった場合は、そのスレッドは"
"終了する。"

#. type: Plain text
#: build/C/man3/getcontext.3:145
msgid ""
"If the context was obtained by a call to a signal handler, then old standard "
"text says that \"program execution continues with the program instruction "
"following the instruction interrupted by the signal\".  However, this "
"sentence was removed in SUSv2, and the present verdict is \"the result is "
"unspecified\"."
msgstr ""
"コンテキストがシグナルハンドラーの呼び出しによって得られていたものの場合は、 "
"古い標準によれば 「プログラムの実行はシグナルによって割り込まれた命令の次の命"
"令から継続される」。 しかしこの文は SUSv2 で削除されたので、 現在の判断は「結"
"果は定義されていない」である。"

#. type: SH
#: build/C/man3/getcontext.3:145 build/C/man3/makecontext.3:85
#: build/C/man3/pthread_attr_init.3:68
#: build/C/man3/pthread_attr_setaffinity_np.3:76
#: build/C/man3/pthread_attr_setdetachstate.3:77
#: build/C/man3/pthread_attr_setguardsize.3:90
#: build/C/man3/pthread_attr_setinheritsched.3:93
#: build/C/man3/pthread_attr_setschedparam.3:85
#: build/C/man3/pthread_attr_setschedpolicy.3:83
#: build/C/man3/pthread_attr_setscope.3:103
#: build/C/man3/pthread_attr_setstack.3:85
#: build/C/man3/pthread_attr_setstackaddr.3:74
#: build/C/man3/pthread_attr_setstacksize.3:61
#: build/C/man3/pthread_cancel.3:112 build/C/man3/pthread_cleanup_push.3:121
#: build/C/man3/pthread_create.3:115 build/C/man3/pthread_detach.3:49
#: build/C/man3/pthread_equal.3:41 build/C/man3/pthread_exit.3:71
#: build/C/man3/pthread_getattr_np.3:73 build/C/man3/pthread_getcpuclockid.3:49
#: build/C/man3/pthread_join.3:70 build/C/man3/pthread_kill.3:63
#: build/C/man3/pthread_rwlockattr_setkind_np.3:121
#: build/C/man3/pthread_self.3:46 build/C/man3/pthread_setaffinity_np.3:77
#: build/C/man3/pthread_setcancelstate.3:97
#: build/C/man3/pthread_setconcurrency.3:56
#: build/C/man3/pthread_setname_np.3:72
#: build/C/man3/pthread_setschedparam.3:104
#: build/C/man3/pthread_setschedprio.3:53 build/C/man3/pthread_sigmask.3:61
#: build/C/man3/pthread_sigqueue.3:66 build/C/man3/pthread_testcancel.3:50
#: build/C/man3/pthread_tryjoin_np.3:88 build/C/man3/pthread_yield.3:44
#: build/C/man3/pthread_atfork.3:67
#: build/C/man3/pthread_attr_setsigmask_np.3:67
#: build/C/man3/pthread_mutex_consistent.3:59
#: build/C/man3/pthread_mutexattr_getpshared.3:76
#: build/C/man3/pthread_mutexattr_init.3:56
#: build/C/man3/pthread_mutexattr_setrobust.3:129
#: build/C/man3/pthread_spin_init.3:111 build/C/man3/pthread_spin_lock.3:91
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/getcontext.3:154
msgid ""
"When successful, B<getcontext>()  returns 0 and B<setcontext>()  does not "
"return.  On error, both return -1 and set I<errno> appropriately."
msgstr ""
"成功すると、 B<getcontext>()  は 0 を返し、 B<setcontext>()  は返らない。 失"
"敗すると、両者とも -1 を返し、I<errno> をエラーに応じて設定する。"

#. type: SH
#: build/C/man3/getcontext.3:154 build/C/man3/makecontext.3:97
#: build/C/man3/pthread_attr_init.3:71
#: build/C/man3/pthread_attr_setaffinity_np.3:79
#: build/C/man3/pthread_attr_setdetachstate.3:80
#: build/C/man3/pthread_attr_setguardsize.3:93
#: build/C/man3/pthread_attr_setinheritsched.3:96
#: build/C/man3/pthread_attr_setschedparam.3:88
#: build/C/man3/pthread_attr_setschedpolicy.3:86
#: build/C/man3/pthread_attr_setscope.3:106
#: build/C/man3/pthread_attr_setstack.3:88
#: build/C/man3/pthread_attr_setstackaddr.3:77
#: build/C/man3/pthread_attr_setstacksize.3:64
#: build/C/man3/pthread_cancel.3:117 build/C/man3/pthread_cleanup_push.3:123
#: build/C/man3/pthread_create.3:122 build/C/man3/pthread_detach.3:54
#: build/C/man3/pthread_equal.3:45 build/C/man3/pthread_exit.3:73
#: build/C/man3/pthread_getattr_np.3:76 build/C/man3/pthread_getcpuclockid.3:52
#: build/C/man3/pthread_join.3:75 build/C/man3/pthread_kill.3:68
#: build/C/man3/pthread_rwlockattr_setkind_np.3:129
#: build/C/man3/pthread_self.3:48 build/C/man3/pthread_setaffinity_np.3:80
#: build/C/man3/pthread_setcancelstate.3:100
#: build/C/man3/pthread_setconcurrency.3:68
#: build/C/man3/pthread_setname_np.3:75
#: build/C/man3/pthread_setschedparam.3:112
#: build/C/man3/pthread_setschedprio.3:61 build/C/man3/pthread_sigmask.3:66
#: build/C/man3/pthread_sigqueue.3:71 build/C/man3/pthread_testcancel.3:54
#: build/C/man3/pthread_tryjoin_np.3:92 build/C/man3/pthread_yield.3:49
#: build/C/man3/pthread_atfork.3:82
#: build/C/man3/pthread_attr_setsigmask_np.3:84
#: build/C/man3/pthread_getattr_default_np.3:66
#: build/C/man3/pthread_mutex_consistent.3:65
#: build/C/man3/pthread_mutexattr_getpshared.3:79
#: build/C/man3/pthread_mutexattr_setrobust.3:136
#: build/C/man3/pthread_spin_init.3:117 build/C/man3/pthread_spin_lock.3:94
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/getcontext.3:156
msgid "None defined."
msgstr "定義されていない。"

#. type: TH
#: build/C/man3/getcontext.3:156 build/C/man3/makecontext.3:106
#: build/C/man3/pthread_attr_init.3:79
#: build/C/man3/pthread_attr_setaffinity_np.3:108
#: build/C/man3/pthread_attr_setdetachstate.3:87
#: build/C/man3/pthread_attr_setguardsize.3:106
#: build/C/man3/pthread_attr_setinheritsched.3:110
#: build/C/man3/pthread_attr_setschedparam.3:107
#: build/C/man3/pthread_attr_setschedpolicy.3:100
#: build/C/man3/pthread_attr_setscope.3:119
#: build/C/man3/pthread_attr_setstack.3:112
#: build/C/man3/pthread_attr_setstackaddr.3:83
#: build/C/man3/pthread_attr_setstacksize.3:83
#: build/C/man3/pthread_cancel.3:125 build/C/man3/pthread_cleanup_push.3:127
#: build/C/man3/pthread_create.3:153 build/C/man3/pthread_detach.3:64
#: build/C/man3/pthread_equal.3:47 build/C/man3/pthread_exit.3:75
#: build/C/man3/pthread_getattr_np.3:98 build/C/man3/pthread_getcpuclockid.3:68
#: build/C/man3/pthread_join.3:98 build/C/man3/pthread_kill.3:72
#: build/C/man3/pthread_kill_other_threads_np.3:47
#: build/C/man3/pthread_self.3:50 build/C/man3/pthread_setaffinity_np.3:117
#: build/C/man3/pthread_setcancelstate.3:118
#: build/C/man3/pthread_setconcurrency.3:83
#: build/C/man3/pthread_setname_np.3:102
#: build/C/man3/pthread_setschedparam.3:141
#: build/C/man3/pthread_setschedprio.3:83 build/C/man3/pthread_sigmask.3:69
#: build/C/man3/pthread_sigqueue.3:94 build/C/man3/pthread_testcancel.3:58
#: build/C/man3/pthread_tryjoin_np.3:123 build/C/man3/pthread_yield.3:53
#: build/C/man3/pthread_attr_setsigmask_np.3:91
#: build/C/man3/pthread_getattr_default_np.3:81 build/C/man7/attributes.7:24
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/getcontext.3:159 build/C/man3/makecontext.3:109
#: build/C/man3/pthread_attr_init.3:82
#: build/C/man3/pthread_attr_setaffinity_np.3:111
#: build/C/man3/pthread_attr_setdetachstate.3:90
#: build/C/man3/pthread_attr_setguardsize.3:109
#: build/C/man3/pthread_attr_setinheritsched.3:113
#: build/C/man3/pthread_attr_setschedparam.3:110
#: build/C/man3/pthread_attr_setschedpolicy.3:103
#: build/C/man3/pthread_attr_setscope.3:122
#: build/C/man3/pthread_attr_setstack.3:115
#: build/C/man3/pthread_attr_setstackaddr.3:86
#: build/C/man3/pthread_attr_setstacksize.3:86
#: build/C/man3/pthread_cancel.3:128 build/C/man3/pthread_cleanup_push.3:130
#: build/C/man3/pthread_create.3:156 build/C/man3/pthread_detach.3:67
#: build/C/man3/pthread_equal.3:50 build/C/man3/pthread_exit.3:78
#: build/C/man3/pthread_getattr_np.3:101
#: build/C/man3/pthread_getcpuclockid.3:71 build/C/man3/pthread_join.3:101
#: build/C/man3/pthread_kill.3:75
#: build/C/man3/pthread_kill_other_threads_np.3:50
#: build/C/man3/pthread_self.3:53 build/C/man3/pthread_setaffinity_np.3:120
#: build/C/man3/pthread_setcancelstate.3:121
#: build/C/man3/pthread_setconcurrency.3:86
#: build/C/man3/pthread_setname_np.3:105
#: build/C/man3/pthread_setschedparam.3:144
#: build/C/man3/pthread_setschedprio.3:86 build/C/man3/pthread_sigmask.3:72
#: build/C/man3/pthread_sigqueue.3:97 build/C/man3/pthread_testcancel.3:61
#: build/C/man3/pthread_tryjoin_np.3:126 build/C/man3/pthread_yield.3:56
#: build/C/man3/pthread_attr_setsigmask_np.3:94
#: build/C/man3/pthread_getattr_default_np.3:84
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/getcontext.3:163 build/C/man3/makecontext.3:113
#: build/C/man3/pthread_attr_init.3:87
#: build/C/man3/pthread_attr_setaffinity_np.3:115
#: build/C/man3/pthread_attr_setdetachstate.3:94
#: build/C/man3/pthread_attr_setguardsize.3:113
#: build/C/man3/pthread_attr_setinheritsched.3:117
#: build/C/man3/pthread_attr_setschedparam.3:114
#: build/C/man3/pthread_attr_setschedpolicy.3:107
#: build/C/man3/pthread_attr_setscope.3:126
#: build/C/man3/pthread_attr_setstack.3:119
#: build/C/man3/pthread_attr_setstackaddr.3:90
#: build/C/man3/pthread_attr_setstacksize.3:90
#: build/C/man3/pthread_cancel.3:132 build/C/man3/pthread_cleanup_push.3:134
#: build/C/man3/pthread_create.3:160 build/C/man3/pthread_detach.3:71
#: build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:82
#: build/C/man3/pthread_getattr_np.3:106
#: build/C/man3/pthread_getcpuclockid.3:75 build/C/man3/pthread_join.3:105
#: build/C/man3/pthread_kill.3:79
#: build/C/man3/pthread_kill_other_threads_np.3:54
#: build/C/man3/pthread_self.3:57 build/C/man3/pthread_setaffinity_np.3:124
#: build/C/man3/pthread_setcancelstate.3:126
#: build/C/man3/pthread_setconcurrency.3:90
#: build/C/man3/pthread_setname_np.3:109
#: build/C/man3/pthread_setschedparam.3:148
#: build/C/man3/pthread_setschedprio.3:90 build/C/man3/pthread_sigmask.3:76
#: build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:65
#: build/C/man3/pthread_tryjoin_np.3:131 build/C/man3/pthread_yield.3:60
#: build/C/man3/pthread_attr_setsigmask_np.3:98
#: build/C/man3/pthread_getattr_default_np.3:89
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/getcontext.3:163 build/C/man3/makecontext.3:113
#: build/C/man3/pthread_attr_init.3:87
#: build/C/man3/pthread_attr_setaffinity_np.3:115
#: build/C/man3/pthread_attr_setdetachstate.3:94
#: build/C/man3/pthread_attr_setguardsize.3:113
#: build/C/man3/pthread_attr_setinheritsched.3:117
#: build/C/man3/pthread_attr_setschedparam.3:114
#: build/C/man3/pthread_attr_setschedpolicy.3:107
#: build/C/man3/pthread_attr_setscope.3:126
#: build/C/man3/pthread_attr_setstack.3:119
#: build/C/man3/pthread_attr_setstackaddr.3:90
#: build/C/man3/pthread_attr_setstacksize.3:90
#: build/C/man3/pthread_cancel.3:132 build/C/man3/pthread_cleanup_push.3:134
#: build/C/man3/pthread_create.3:160 build/C/man3/pthread_detach.3:71
#: build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:82
#: build/C/man3/pthread_getattr_np.3:106
#: build/C/man3/pthread_getcpuclockid.3:75 build/C/man3/pthread_join.3:105
#: build/C/man3/pthread_kill.3:79
#: build/C/man3/pthread_kill_other_threads_np.3:54
#: build/C/man3/pthread_self.3:57 build/C/man3/pthread_setaffinity_np.3:124
#: build/C/man3/pthread_setcancelstate.3:126
#: build/C/man3/pthread_setconcurrency.3:90
#: build/C/man3/pthread_setname_np.3:109
#: build/C/man3/pthread_setschedparam.3:148
#: build/C/man3/pthread_setschedprio.3:90 build/C/man3/pthread_sigmask.3:76
#: build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:65
#: build/C/man3/pthread_tryjoin_np.3:131 build/C/man3/pthread_yield.3:60
#: build/C/man3/pthread_attr_setsigmask_np.3:98
#: build/C/man3/pthread_getattr_default_np.3:89
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/getcontext.3:163 build/C/man3/makecontext.3:113
#: build/C/man3/pthread_attr_init.3:87
#: build/C/man3/pthread_attr_setaffinity_np.3:115
#: build/C/man3/pthread_attr_setdetachstate.3:94
#: build/C/man3/pthread_attr_setguardsize.3:113
#: build/C/man3/pthread_attr_setinheritsched.3:117
#: build/C/man3/pthread_attr_setschedparam.3:114
#: build/C/man3/pthread_attr_setschedpolicy.3:107
#: build/C/man3/pthread_attr_setscope.3:126
#: build/C/man3/pthread_attr_setstack.3:119
#: build/C/man3/pthread_attr_setstackaddr.3:90
#: build/C/man3/pthread_attr_setstacksize.3:90
#: build/C/man3/pthread_cancel.3:132 build/C/man3/pthread_cleanup_push.3:134
#: build/C/man3/pthread_create.3:160 build/C/man3/pthread_detach.3:71
#: build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:82
#: build/C/man3/pthread_getattr_np.3:106
#: build/C/man3/pthread_getcpuclockid.3:75 build/C/man3/pthread_join.3:105
#: build/C/man3/pthread_kill.3:79
#: build/C/man3/pthread_kill_other_threads_np.3:54
#: build/C/man3/pthread_self.3:57 build/C/man3/pthread_setaffinity_np.3:124
#: build/C/man3/pthread_setcancelstate.3:126
#: build/C/man3/pthread_setconcurrency.3:90
#: build/C/man3/pthread_setname_np.3:109
#: build/C/man3/pthread_setschedparam.3:148
#: build/C/man3/pthread_setschedprio.3:90 build/C/man3/pthread_sigmask.3:76
#: build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:65
#: build/C/man3/pthread_tryjoin_np.3:131 build/C/man3/pthread_yield.3:60
#: build/C/man3/pthread_attr_setsigmask_np.3:98
#: build/C/man3/pthread_getattr_default_np.3:89
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/getcontext.3:167
#, no-wrap
msgid ""
"B<getcontext>(),\n"
"B<setcontext>()"
msgstr ""
"B<getcontext>(),\n"
"B<setcontext>()"

#. type: tbl table
#: build/C/man3/getcontext.3:167 build/C/man3/makecontext.3:116
#: build/C/man3/makecontext.3:119 build/C/man3/pthread_attr_init.3:91
#: build/C/man3/pthread_attr_setaffinity_np.3:119
#: build/C/man3/pthread_attr_setdetachstate.3:98
#: build/C/man3/pthread_attr_setguardsize.3:117
#: build/C/man3/pthread_attr_setinheritsched.3:121
#: build/C/man3/pthread_attr_setschedparam.3:118
#: build/C/man3/pthread_attr_setschedpolicy.3:111
#: build/C/man3/pthread_attr_setscope.3:130
#: build/C/man3/pthread_attr_setstack.3:123
#: build/C/man3/pthread_attr_setstackaddr.3:94
#: build/C/man3/pthread_attr_setstacksize.3:94
#: build/C/man3/pthread_cancel.3:135 build/C/man3/pthread_cleanup_push.3:138
#: build/C/man3/pthread_create.3:163 build/C/man3/pthread_detach.3:74
#: build/C/man3/pthread_equal.3:57 build/C/man3/pthread_exit.3:85
#: build/C/man3/pthread_getattr_np.3:109
#: build/C/man3/pthread_getcpuclockid.3:78 build/C/man3/pthread_join.3:108
#: build/C/man3/pthread_kill.3:82
#: build/C/man3/pthread_kill_other_threads_np.3:57
#: build/C/man3/pthread_self.3:60 build/C/man3/pthread_setaffinity_np.3:128
#: build/C/man3/pthread_setcancelstate.3:130
#: build/C/man3/pthread_setconcurrency.3:94
#: build/C/man3/pthread_setname_np.3:113
#: build/C/man3/pthread_setschedparam.3:152
#: build/C/man3/pthread_setschedprio.3:93 build/C/man3/pthread_sigmask.3:79
#: build/C/man3/pthread_sigqueue.3:104 build/C/man3/pthread_testcancel.3:68
#: build/C/man3/pthread_tryjoin_np.3:135 build/C/man3/pthread_yield.3:63
#: build/C/man3/pthread_attr_setsigmask_np.3:102
#: build/C/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/getcontext.3:167 build/C/man3/makecontext.3:116
#, no-wrap
msgid "MT-Safe race:ucp"
msgstr "MT-Safe race:ucp"

#. type: SH
#: build/C/man3/getcontext.3:169 build/C/man3/makecontext.3:121
#: build/C/man3/pthread_attr_init.3:94
#: build/C/man3/pthread_attr_setaffinity_np.3:122
#: build/C/man3/pthread_attr_setdetachstate.3:100
#: build/C/man3/pthread_attr_setguardsize.3:119
#: build/C/man3/pthread_attr_setinheritsched.3:123
#: build/C/man3/pthread_attr_setschedparam.3:120
#: build/C/man3/pthread_attr_setschedpolicy.3:113
#: build/C/man3/pthread_attr_setscope.3:132
#: build/C/man3/pthread_attr_setstack.3:125
#: build/C/man3/pthread_attr_setstackaddr.3:96
#: build/C/man3/pthread_attr_setstacksize.3:96
#: build/C/man3/pthread_cancel.3:138 build/C/man3/pthread_cleanup_push.3:141
#: build/C/man3/pthread_cleanup_push_defer_np.3:114
#: build/C/man3/pthread_create.3:166 build/C/man3/pthread_detach.3:77
#: build/C/man3/pthread_equal.3:59 build/C/man3/pthread_exit.3:87
#: build/C/man3/pthread_getattr_np.3:112
#: build/C/man3/pthread_getcpuclockid.3:80 build/C/man3/pthread_join.3:111
#: build/C/man3/pthread_kill.3:84
#: build/C/man3/pthread_kill_other_threads_np.3:59
#: build/C/man3/pthread_rwlockattr_setkind_np.3:140
#: build/C/man3/pthread_self.3:62 build/C/man3/pthread_setaffinity_np.3:130
#: build/C/man3/pthread_setcancelstate.3:142
#: build/C/man3/pthread_setconcurrency.3:96
#: build/C/man3/pthread_setname_np.3:116
#: build/C/man3/pthread_setschedparam.3:154
#: build/C/man3/pthread_setschedprio.3:95 build/C/man3/pthread_sigmask.3:81
#: build/C/man3/pthread_sigqueue.3:106 build/C/man3/pthread_testcancel.3:70
#: build/C/man3/pthread_tryjoin_np.3:138 build/C/man3/pthread_yield.3:65
#: build/C/man3/pthread_atfork.3:86
#: build/C/man3/pthread_attr_setsigmask_np.3:105
#: build/C/man3/pthread_getattr_default_np.3:96
#: build/C/man3/pthread_mutex_consistent.3:72
#: build/C/man3/pthread_mutexattr_getpshared.3:92
#: build/C/man3/pthread_mutexattr_init.3:59
#: build/C/man3/pthread_mutexattr_setrobust.3:150
#: build/C/man3/pthread_spin_init.3:130 build/C/man3/pthread_spin_lock.3:109
#: build/C/man7/nptl.7:114
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/getcontext.3:175
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<getcontext>(), citing portability issues, and recommending that "
"applications be rewritten to use POSIX threads instead."
msgstr ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 では、移植性の問題から B<getcontext>()  の"
"仕様が削除された。 代わりに、アプリケーションを POSIX スレッドを使って書き直"
"すことが 推奨されている。"

#. type: SH
#: build/C/man3/getcontext.3:175 build/C/man3/makecontext.3:129
#: build/C/man3/pthread_attr_init.3:96
#: build/C/man3/pthread_attr_setaffinity_np.3:125
#: build/C/man3/pthread_attr_setdetachstate.3:102
#: build/C/man3/pthread_attr_setguardsize.3:121
#: build/C/man3/pthread_attr_setschedparam.3:122
#: build/C/man3/pthread_attr_setscope.3:134
#: build/C/man3/pthread_attr_setstack.3:127
#: build/C/man3/pthread_attr_setstackaddr.3:99
#: build/C/man3/pthread_attr_setstacksize.3:98
#: build/C/man3/pthread_cancel.3:140 build/C/man3/pthread_cleanup_push.3:143
#: build/C/man3/pthread_create.3:168 build/C/man3/pthread_detach.3:79
#: build/C/man3/pthread_equal.3:61 build/C/man3/pthread_exit.3:89
#: build/C/man3/pthread_getcpuclockid.3:82 build/C/man3/pthread_join.3:113
#: build/C/man3/pthread_kill.3:86
#: build/C/man3/pthread_kill_other_threads_np.3:62
#: build/C/man3/pthread_self.3:64 build/C/man3/pthread_setaffinity_np.3:133
#: build/C/man3/pthread_setcancelstate.3:144
#: build/C/man3/pthread_setconcurrency.3:98
#: build/C/man3/pthread_setname_np.3:119
#: build/C/man3/pthread_setschedparam.3:156
#: build/C/man3/pthread_setschedprio.3:97 build/C/man3/pthread_sigmask.3:83
#: build/C/man3/pthread_sigqueue.3:108 build/C/man3/pthread_yield.3:71
#: build/C/man3/pthread_atfork.3:88
#: build/C/man3/pthread_attr_setsigmask_np.3:108
#: build/C/man3/pthread_mutex_consistent.3:74
#: build/C/man3/pthread_mutexattr_init.3:61
#: build/C/man3/pthread_mutexattr_setrobust.3:152
#: build/C/man3/pthread_spin_init.3:135 build/C/man3/pthread_spin_lock.3:111
#: build/C/man7/nptl.7:117
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/getcontext.3:192
msgid ""
"The earliest incarnation of this mechanism was the B<setjmp>(3)/"
"B<longjmp>(3)  mechanism.  Since that does not define the handling of the "
"signal context, the next stage was the B<sigsetjmp>(3)/B<siglongjmp>(3)  "
"pair.  The present mechanism gives much more control.  On the other hand, "
"there is no easy way to detect whether a return from B<getcontext>()  is "
"from the first call, or via a B<setcontext>()  call.  The user has to invent "
"their own bookkeeping device, and a register variable won't do since "
"registers are restored."
msgstr ""
"このメカニズムの最古の実装は、 B<setjmp>(3)/B<longjmp>(3)  機構であった。 こ"
"れらにはシグナルコンテキストの取り扱いが定義されていなかったので、 次の段階で"
"は B<sigsetjmp>(3)/B<siglongjmp>(3)  のペアが現われた。 現在の機構ではずっと"
"細かな制御ができる。 一方 B<getcontext>()  から返ったとき、 これが最初の呼び"
"出しであったか、 それとも B<setcontext>()  呼び出しからのものであるかを 区別"
"する容易な方法がなくなってしまった。 ユーザーは「しおり」機構を自分で作らなけ"
"ればならない。 レジスター変数は (レジスターはリストアされてしまうので) これを"
"やってくれない。"

#. type: Plain text
#: build/C/man3/getcontext.3:203
msgid ""
"When a signal occurs, the current user context is saved and a new context is "
"created by the kernel for the signal handler.  Do not leave the handler "
"using B<longjmp>(3): it is undefined what would happen with contexts.  Use "
"B<siglongjmp>(3)  or B<setcontext>()  instead."
msgstr ""
"シグナルが発生すると、 現在のユーザーコンテキストは保存され、 シグナルハンド"
"ラー用のコンテキストがカーネルによって生成される。 今後はハンドラーに "
"B<longjmp>(3)  を使わせないこと: この関数のコンテキスト下での動作は定義されて"
"いない。 代わりに B<siglongjmp>(3)  か B<setcontext>()  を使うこと。"

#. type: SH
#: build/C/man3/getcontext.3:203 build/C/man3/makecontext.3:235
#: build/C/man3/pthread_attr_init.3:312
#: build/C/man3/pthread_attr_setaffinity_np.3:132
#: build/C/man3/pthread_attr_setdetachstate.3:124
#: build/C/man3/pthread_attr_setguardsize.3:171
#: build/C/man3/pthread_attr_setinheritsched.3:144
#: build/C/man3/pthread_attr_setschedparam.3:129
#: build/C/man3/pthread_attr_setschedpolicy.3:118
#: build/C/man3/pthread_attr_setscope.3:145
#: build/C/man3/pthread_attr_setstack.3:168
#: build/C/man3/pthread_attr_setstackaddr.3:123
#: build/C/man3/pthread_attr_setstacksize.3:124
#: build/C/man3/pthread_cancel.3:239 build/C/man3/pthread_cleanup_push.3:329
#: build/C/man3/pthread_cleanup_push_defer_np.3:117
#: build/C/man3/pthread_create.3:405 build/C/man3/pthread_detach.3:110
#: build/C/man3/pthread_equal.3:68 build/C/man3/pthread_exit.3:117
#: build/C/man3/pthread_getattr_np.3:359
#: build/C/man3/pthread_getcpuclockid.3:186 build/C/man3/pthread_join.3:143
#: build/C/man3/pthread_kill.3:116
#: build/C/man3/pthread_kill_other_threads_np.3:78
#: build/C/man3/pthread_rwlockattr_setkind_np.3:143
#: build/C/man3/pthread_self.3:88 build/C/man3/pthread_setaffinity_np.3:215
#: build/C/man3/pthread_setcancelstate.3:208
#: build/C/man3/pthread_setconcurrency.3:113
#: build/C/man3/pthread_setname_np.3:214
#: build/C/man3/pthread_setschedparam.3:446
#: build/C/man3/pthread_setschedprio.3:103 build/C/man3/pthread_sigmask.3:167
#: build/C/man3/pthread_sigqueue.3:118 build/C/man3/pthread_testcancel.3:75
#: build/C/man3/pthread_tryjoin_np.3:175 build/C/man3/pthread_yield.3:85
#: build/C/man3/pthread_atfork.3:122
#: build/C/man3/pthread_attr_setsigmask_np.3:142
#: build/C/man3/pthread_getattr_default_np.3:196
#: build/C/man3/pthread_mutex_consistent.3:99
#: build/C/man3/pthread_mutexattr_getpshared.3:94
#: build/C/man3/pthread_mutexattr_init.3:64
#: build/C/man3/pthread_mutexattr_setrobust.3:276
#: build/C/man3/pthread_spin_init.3:162 build/C/man3/pthread_spin_lock.3:117
#: build/C/man7/pthreads.7:916 build/C/man7/attributes.7:882
#: build/C/man7/nptl.7:128
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/getcontext.3:211
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), B<makecontext>(3), B<sigsetjmp>(3), B<signal>(7)"

#. type: SH
#: build/C/man3/getcontext.3:211 build/C/man3/makecontext.3:241
#: build/C/man3/pthread_attr_init.3:330
#: build/C/man3/pthread_attr_setaffinity_np.3:138
#: build/C/man3/pthread_attr_setdetachstate.3:130
#: build/C/man3/pthread_attr_setguardsize.3:179
#: build/C/man3/pthread_attr_setinheritsched.3:156
#: build/C/man3/pthread_attr_setschedparam.3:141
#: build/C/man3/pthread_attr_setschedpolicy.3:129
#: build/C/man3/pthread_attr_setscope.3:155
#: build/C/man3/pthread_attr_setstack.3:180
#: build/C/man3/pthread_attr_setstackaddr.3:129
#: build/C/man3/pthread_attr_setstacksize.3:131
#: build/C/man3/pthread_cancel.3:251 build/C/man3/pthread_cleanup_push.3:335
#: build/C/man3/pthread_cleanup_push_defer_np.3:123
#: build/C/man3/pthread_create.3:419 build/C/man3/pthread_detach.3:117
#: build/C/man3/pthread_equal.3:72 build/C/man3/pthread_exit.3:121
#: build/C/man3/pthread_getattr_np.3:375
#: build/C/man3/pthread_getcpuclockid.3:194 build/C/man3/pthread_join.3:150
#: build/C/man3/pthread_kill.3:125
#: build/C/man3/pthread_kill_other_threads_np.3:84
#: build/C/man3/pthread_rwlockattr_setkind_np.3:145
#: build/C/man3/pthread_self.3:92 build/C/man3/pthread_setaffinity_np.3:224
#: build/C/man3/pthread_setcancelstate.3:213
#: build/C/man3/pthread_setconcurrency.3:116
#: build/C/man3/pthread_setname_np.3:220
#: build/C/man3/pthread_setschedparam.3:460
#: build/C/man3/pthread_setschedprio.3:117 build/C/man3/pthread_sigmask.3:177
#: build/C/man3/pthread_sigqueue.3:126 build/C/man3/pthread_testcancel.3:80
#: build/C/man3/pthread_tryjoin_np.3:180 build/C/man3/pthread_yield.3:90
#: build/C/man3/pthread_atfork.3:126
#: build/C/man3/pthread_attr_setsigmask_np.3:148
#: build/C/man3/pthread_getattr_default_np.3:212
#: build/C/man3/pthread_mutex_consistent.3:107
#: build/C/man3/pthread_mutexattr_getpshared.3:99
#: build/C/man3/pthread_mutexattr_init.3:71
#: build/C/man3/pthread_mutexattr_setrobust.3:285
#: build/C/man3/pthread_spin_init.3:170 build/C/man3/pthread_spin_lock.3:124
#: build/C/man7/pthreads.7:958 build/C/man7/attributes.7:885
#: build/C/man7/nptl.7:133
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/getcontext.3:219 build/C/man3/makecontext.3:249
#: build/C/man3/pthread_attr_init.3:338
#: build/C/man3/pthread_attr_setaffinity_np.3:146
#: build/C/man3/pthread_attr_setdetachstate.3:138
#: build/C/man3/pthread_attr_setguardsize.3:187
#: build/C/man3/pthread_attr_setinheritsched.3:164
#: build/C/man3/pthread_attr_setschedparam.3:149
#: build/C/man3/pthread_attr_setschedpolicy.3:137
#: build/C/man3/pthread_attr_setscope.3:163
#: build/C/man3/pthread_attr_setstack.3:188
#: build/C/man3/pthread_attr_setstackaddr.3:137
#: build/C/man3/pthread_attr_setstacksize.3:139
#: build/C/man3/pthread_cancel.3:259 build/C/man3/pthread_cleanup_push.3:343
#: build/C/man3/pthread_cleanup_push_defer_np.3:131
#: build/C/man3/pthread_create.3:427 build/C/man3/pthread_detach.3:125
#: build/C/man3/pthread_equal.3:80 build/C/man3/pthread_exit.3:129
#: build/C/man3/pthread_getattr_np.3:383
#: build/C/man3/pthread_getcpuclockid.3:202 build/C/man3/pthread_join.3:158
#: build/C/man3/pthread_kill.3:133
#: build/C/man3/pthread_kill_other_threads_np.3:92
#: build/C/man3/pthread_rwlockattr_setkind_np.3:153
#: build/C/man3/pthread_self.3:100 build/C/man3/pthread_setaffinity_np.3:232
#: build/C/man3/pthread_setcancelstate.3:221
#: build/C/man3/pthread_setconcurrency.3:124
#: build/C/man3/pthread_setname_np.3:228
#: build/C/man3/pthread_setschedparam.3:468
#: build/C/man3/pthread_setschedprio.3:125 build/C/man3/pthread_sigmask.3:185
#: build/C/man3/pthread_sigqueue.3:134 build/C/man3/pthread_testcancel.3:88
#: build/C/man3/pthread_tryjoin_np.3:188 build/C/man3/pthread_yield.3:98
#: build/C/man3/pthread_atfork.3:134
#: build/C/man3/pthread_attr_setsigmask_np.3:156
#: build/C/man3/pthread_getattr_default_np.3:220
#: build/C/man3/pthread_mutex_consistent.3:115
#: build/C/man3/pthread_mutexattr_getpshared.3:107
#: build/C/man3/pthread_mutexattr_init.3:79
#: build/C/man3/pthread_mutexattr_setrobust.3:293
#: build/C/man3/pthread_spin_init.3:178 build/C/man3/pthread_spin_lock.3:132
#: build/C/man7/pthreads.7:966 build/C/man7/attributes.7:893
#: build/C/man7/nptl.7:141
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/makecontext.3:28
#, no-wrap
msgid "MAKECONTEXT"
msgstr "MAKECONTEXT"

#. type: TH
#: build/C/man3/makecontext.3:28
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/makecontext.3:31
msgid "makecontext, swapcontext - manipulate user context"
msgstr "makecontext, swapcontext - ユーザーコンテキストを操作する"

#. type: Plain text
#: build/C/man3/makecontext.3:36
msgid ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"
msgstr ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"

#. type: Plain text
#: build/C/man3/makecontext.3:38
msgid ""
"B<int swapcontext(ucontext_t *>I<oucp>B<, const ucontext_t *>I<ucp>B<);>"
msgstr ""
"B<int swapcontext(ucontext_t *>I<oucp>B<, const ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: build/C/man3/makecontext.3:53
#, fuzzy
#| msgid ""
#| "In a System V-like environment, one has the type I<ucontext_t> defined in "
#| "I<E<lt>ucontext.hE<gt>> and the four functions B<getcontext>(3), "
#| "B<setcontext>(3), B<makecontext>()  and B<swapcontext>()  that allow user-"
#| "level context switching between multiple threads of control within a "
#| "process."
msgid ""
"In a System V-like environment, one has the type I<ucontext_t> (defined in "
"I<E<lt>ucontext.hE<gt>> and described in B<getcontext>(3))  and the four "
"functions B<getcontext>(3), B<setcontext>(3), B<makecontext>(), and "
"B<swapcontext>()  that allow user-level context switching between multiple "
"threads of control within a process."
msgstr ""
"System V 的な環境では、 B<mcontext_t> および B<ucontext_t> という 2 つの型"
"と、 B<getcontext>(3), B<setcontext>(3), B<makecontext>(), B<swapcontext>()  "
"という 4 つの関数が I<E<lt>ucontext.hE<gt>> で定義されており、あるプロセス内"
"部で制御下にある複数のスレッド間で、 ユーザーレベルのコンテキスト切替えができ"
"るようになっている。"

#. type: Plain text
#: build/C/man3/makecontext.3:65
msgid ""
"The B<makecontext>()  function modifies the context pointed to by I<ucp> "
"(which was obtained from a call to B<getcontext>(3)).  Before invoking "
"B<makecontext>(), the caller must allocate a new stack for this context and "
"assign its address to I<ucp-E<gt>uc_stack>, and define a successor context "
"and assign its address to I<ucp-E<gt>uc_link>."
msgstr ""
"B<makecontext>()  関数は、ポインター I<ucp> が指すコンテキストを変更する "
"(I<ucp> は以前の B<getcontext>(3)  呼び出しで得られたものである)。 "
"B<makecontext>()  を起動する前には、呼び出し者は、このコンテキスト用に 新しい"
"スタックを確保し、そのアドレスを I<ucp-E<gt>uc_stack> に代入し、 さらに後継の"
"コンテキストを定義し、そのアドレスを I<ucp-E<gt>uc_link> に 代入しなければな"
"らない。"

#. type: Plain text
#: build/C/man3/makecontext.3:79
msgid ""
"When this context is later activated (using B<setcontext>(3)  or "
"B<swapcontext>())  the function I<func> is called, and passed the series of "
"integer (I<int>)  arguments that follow I<argc>; the caller must specify the "
"number of these arguments in I<argc>.  When this function returns, the "
"successor context is activated.  If the successor context pointer is NULL, "
"the thread exits."
msgstr ""
"このコンテキストが将来 (B<setcontext>(3)  または B<swapcontext>()  によっ"
"て)  有効にされると、関数 I<func> が呼ばれ、 引き数として I<argc> 以降の整数 "
"(I<int>)  引き数の列が渡される。 呼び出し者は I<argc> にこれらの引き数の個数"
"を指定しなければならない。 この関数が戻ると、後継のコンテキストが有効にな"
"る。 後継コンテキストのポインターが NULL の場合、そのスレッドが終了する。"

#. type: Plain text
#: build/C/man3/makecontext.3:85
msgid ""
"The B<swapcontext>()  function saves the current context in the structure "
"pointed to by I<oucp>, and then activates the context pointed to by I<ucp>."
msgstr ""
"B<swapcontext>()  関数は現在のコンテキストを ポインター I<oucp> が指す構造体"
"に保存し、 ポインター I<ucp> が指すコンテキストを有効にする。"

#. type: Plain text
#: build/C/man3/makecontext.3:97
msgid ""
"When successful, B<swapcontext>()  does not return.  (But we may return "
"later, in case I<oucp> is activated, in which case it looks like "
"B<swapcontext>()  returns 0.)  On error, B<swapcontext>()  returns -1 and "
"sets I<errno> appropriately."
msgstr ""
"成功すると、 B<swapcontext>()  は返らない (しかし後に I<oucp> が有効になった"
"場合には返ることがある。 このときには B<swapcontext>()  は 0 を返すように見え"
"る。)  失敗すると、 B<swapcontext>()  は -1 を返し、 I<errno> をエラーに応じ"
"て設定する。"

#. type: TP
#: build/C/man3/makecontext.3:98 build/C/man3/pthread_attr_setaffinity_np.3:102
#: build/C/man3/pthread_getattr_np.3:77 build/C/man3/pthread_atfork.3:83
#: build/C/man3/pthread_attr_setsigmask_np.3:85
#: build/C/man3/pthread_getattr_default_np.3:74
#: build/C/man3/pthread_spin_init.3:125
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/makecontext.3:101
msgid "Insufficient stack space left."
msgstr "スタックに割り当てる空間が残っていない。"

#. type: SH
#: build/C/man3/makecontext.3:101
#: build/C/man3/pthread_attr_setaffinity_np.3:106
#: build/C/man3/pthread_attr_setguardsize.3:104
#: build/C/man3/pthread_attr_setstack.3:110
#: build/C/man3/pthread_attr_setstackaddr.3:81
#: build/C/man3/pthread_attr_setstacksize.3:81
#: build/C/man3/pthread_getattr_np.3:96 build/C/man3/pthread_getcpuclockid.3:66
#: build/C/man3/pthread_rwlockattr_setkind_np.3:134
#: build/C/man3/pthread_setaffinity_np.3:115
#: build/C/man3/pthread_setconcurrency.3:81
#: build/C/man3/pthread_setname_np.3:100 build/C/man3/pthread_setschedprio.3:81
#: build/C/man3/pthread_sigqueue.3:90 build/C/man3/pthread_tryjoin_np.3:121
#: build/C/man3/pthread_attr_setsigmask_np.3:89
#: build/C/man3/pthread_getattr_default_np.3:79
#: build/C/man3/pthread_mutex_consistent.3:69
#: build/C/man3/pthread_mutexattr_setrobust.3:145
#: build/C/man3/pthread_spin_init.3:128 build/C/man3/pthread_spin_lock.3:107
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/makecontext.3:106
msgid ""
"B<makecontext>()  and B<swapcontext>()  are provided in glibc since version "
"2.1."
msgstr ""
"B<makecontext>()  と B<swapcontext>()  は、バージョン 2.1 以降の glibc で提供"
"されている。"

#. type: tbl table
#: build/C/man3/makecontext.3:116
#, no-wrap
msgid "B<makecontext>()"
msgstr "B<makecontext>()"

#. type: tbl table
#: build/C/man3/makecontext.3:119
#, no-wrap
msgid "B<swapcontext>()"
msgstr "B<swapcontext>()"

#. type: tbl table
#: build/C/man3/makecontext.3:119
#, no-wrap
msgid "MT-Safe race:oucp race:ucp"
msgstr "MT-Safe race:oucp race:ucp"

#. type: Plain text
#: build/C/man3/makecontext.3:129
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specifications of "
"B<makecontext>()  and B<swapcontext>(), citing portability issues, and "
"recommending that applications be rewritten to use POSIX threads instead."
msgstr ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 では、移植性の問題から B<makecontext>()  "
"と B<swapcontext>()  の仕様が削除されている。 代わりに、アプリケーションを "
"POSIX スレッドを使って書き直すことが 推奨されている。"

#. type: Plain text
#: build/C/man3/makecontext.3:137
msgid ""
"The interpretation of I<ucp-E<gt>uc_stack> is just as in B<sigaltstack>(2), "
"namely, this struct contains the start and length of a memory area to be "
"used as the stack, regardless of the direction of growth of the stack.  "
"Thus, it is not necessary for the user program to worry about this direction."
msgstr ""
"I<ucp-E<gt>uc_stack> の解釈は B<sigaltstack>(2)  の場合と同じである。 すなわ"
"ちこの構造体には、 スタックとして用いられるメモリー領域の開始アドレスと長さが"
"含まれ、 これはスタックが伸びる方向がどちらであるかには関係しない。 したがっ"
"て、ユーザープログラムはこの件については心配しなくてよい。"

#. type: Plain text
#: build/C/man3/makecontext.3:153
msgid ""
"On architectures where I<int> and pointer types are the same size (e.g., "
"x86-32, where both types are 32 bits), you may be able to get away with "
"passing pointers as arguments to B<makecontext>()  following I<argc>.  "
"However, doing this is not guaranteed to be portable, is undefined according "
"to the standards, and won't work on architectures where pointers are larger "
"than I<int>s.  Nevertheless, starting with version 2.8, glibc makes some "
"changes to B<makecontext>(), to permit this on some 64-bit architectures (e."
"g., x86-64)."
msgstr ""
"I<int> とポインター型が同じ大きさであるアーキテクチャーでは (x86-32 はその例"
"であり、両方の型とも 32 ビットである)、 B<makecontext>()  の I<argc> 以降の引"
"き数としてポインターを渡してもうまく動くかもしれない。 しかしながら、このよう"
"にすると、移植性は保証されず、 標準に従えば動作は未定義であり、ポインターが "
"I<int> よりも大きいアーキテクチャーでは正しく動作しないことだろう。 それにも"
"関わらず、バージョン 2.8 以降の glibc では、 B<makecontext>()  に変更が行わ"
"れ、(x86-64 などの) いくつかの 64 ビットアーキテクチャーで 引き数としてポイン"
"ターを渡すことができるようになっている。"

#. type: SH
#: build/C/man3/makecontext.3:153 build/C/man3/pthread_attr_init.3:102
#: build/C/man3/pthread_attr_setdetachstate.3:121
#: build/C/man3/pthread_attr_setguardsize.3:168
#: build/C/man3/pthread_attr_setinheritsched.3:141
#: build/C/man3/pthread_attr_setschedparam.3:126
#: build/C/man3/pthread_attr_setschedpolicy.3:115
#: build/C/man3/pthread_attr_setstack.3:165
#: build/C/man3/pthread_attr_setstacksize.3:121
#: build/C/man3/pthread_cancel.3:148 build/C/man3/pthread_cleanup_push.3:169
#: build/C/man3/pthread_create.3:239 build/C/man3/pthread_detach.3:106
#: build/C/man3/pthread_getattr_np.3:115
#: build/C/man3/pthread_getcpuclockid.3:93 build/C/man3/pthread_join.3:140
#: build/C/man3/pthread_setaffinity_np.3:163
#: build/C/man3/pthread_setcancelstate.3:205
#: build/C/man3/pthread_setname_np.3:129
#: build/C/man3/pthread_setschedparam.3:162 build/C/man3/pthread_sigmask.3:93
#: build/C/man3/pthread_testcancel.3:72 build/C/man3/pthread_tryjoin_np.3:141
#: build/C/man3/pthread_getattr_default_np.3:99
#: build/C/man3/pthread_mutex_consistent.3:96
#: build/C/man3/pthread_mutexattr_setrobust.3:188
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/makecontext.3:160
msgid ""
"The example program below demonstrates the use of B<getcontext>(3), "
"B<makecontext>(), and B<swapcontext>().  Running the program produces the "
"following output:"
msgstr ""
"以下のサンプルプログラムは、 B<getcontext>(3), B<makecontext>(), "
"B<swapcontext>()  の使用方法の例を示すものである。 このプログラムを実行する"
"と、以下のような出力が得られる:"

#. type: Plain text
#: build/C/man3/makecontext.3:172
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"
msgstr ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"

#. type: SS
#: build/C/man3/makecontext.3:174 build/C/man3/pthread_attr_init.3:163
#: build/C/man3/pthread_cancel.3:164 build/C/man3/pthread_cleanup_push.3:245
#: build/C/man3/pthread_create.3:278 build/C/man3/pthread_getattr_np.3:193
#: build/C/man3/pthread_getcpuclockid.3:111
#: build/C/man3/pthread_setname_np.3:154
#: build/C/man3/pthread_setschedparam.3:237 build/C/man3/pthread_sigmask.3:111
#: build/C/man3/pthread_getattr_default_np.3:117
#: build/C/man3/pthread_mutexattr_setrobust.3:211
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/makecontext.3:180
#, no-wrap
msgid ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/makecontext.3:182
#, no-wrap
msgid "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"
msgstr "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"

#. type: Plain text
#: build/C/man3/makecontext.3:185
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/makecontext.3:195
#, no-wrap
msgid ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"
msgstr ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/makecontext.3:205
#, no-wrap
msgid ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"
msgstr ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/makecontext.3:211
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"

#. type: Plain text
#: build/C/man3/makecontext.3:218
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"
msgstr ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"

#. type: Plain text
#: build/C/man3/makecontext.3:226
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"
msgstr ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"

#. type: Plain text
#: build/C/man3/makecontext.3:230
#, no-wrap
msgid ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
msgstr ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"

#. type: Plain text
#: build/C/man3/makecontext.3:234
#, no-wrap
msgid ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/makecontext.3:241
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<getcontext>(3), "
"B<sigsetjmp>(3)"
msgstr ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<getcontext>(3), "
"B<sigsetjmp>(3)"

#. type: TH
#: build/C/man3/pthread_attr_init.3:26
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr "PTHREAD_ATTR_INIT"

#. type: TH
#: build/C/man3/pthread_attr_init.3:26 build/C/man3/pthread_create.3:26
#: build/C/man3/pthread_getattr_np.3:26 build/C/man3/pthread_getcpuclockid.3:26
#: build/C/man3/pthread_setaffinity_np.3:26
#: build/C/man3/pthread_setname_np.3:26 build/C/man3/pthread_sigmask.3:26
#: build/C/man3/pthread_attr_setsigmask_np.3:26
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:30
msgid ""
"pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
"attributes object"
msgstr ""
"pthread_attr_init, pthread_attr_destroy - \n"
"スレッド属性オブジェクトの初期化と破棄を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:33
#: build/C/man3/pthread_attr_setdetachstate.3:33
#: build/C/man3/pthread_attr_setguardsize.3:33
#: build/C/man3/pthread_attr_setinheritsched.3:33
#: build/C/man3/pthread_attr_setschedparam.3:33
#: build/C/man3/pthread_attr_setschedpolicy.3:33
#: build/C/man3/pthread_attr_setscope.3:33
#: build/C/man3/pthread_attr_setstack.3:33
#: build/C/man3/pthread_attr_setstackaddr.3:33
#: build/C/man3/pthread_attr_setstacksize.3:33 build/C/man3/pthread_cancel.3:32
#: build/C/man3/pthread_cleanup_push.3:33
#: build/C/man3/pthread_cleanup_push_defer_np.3:33
#: build/C/man3/pthread_create.3:32 build/C/man3/pthread_detach.3:32
#: build/C/man3/pthread_equal.3:32 build/C/man3/pthread_exit.3:32
#: build/C/man3/pthread_join.3:32
#: build/C/man3/pthread_kill_other_threads_np.3:32
#: build/C/man3/pthread_rwlockattr_setkind_np.3:32
#: build/C/man3/pthread_self.3:32 build/C/man3/pthread_setcancelstate.3:33
#: build/C/man3/pthread_setconcurrency.3:32
#: build/C/man3/pthread_setschedparam.3:33
#: build/C/man3/pthread_setschedprio.3:32 build/C/man3/pthread_testcancel.3:32
#: build/C/man3/pthread_atfork.3:31 build/C/man3/pthread_mutex_consistent.3:32
#: build/C/man3/pthread_mutexattr_getpshared.3:32
#: build/C/man3/pthread_mutexattr_init.3:32
#: build/C/man3/pthread_mutexattr_setrobust.3:33
#: build/C/man3/pthread_spin_init.3:31 build/C/man3/pthread_spin_lock.3:32
#, no-wrap
msgid "B<#include E<lt>pthread.hE<gt>>\n"
msgstr "B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:38
#: build/C/man3/pthread_attr_setaffinity_np.3:41
#: build/C/man3/pthread_attr_setdetachstate.3:40
#: build/C/man3/pthread_attr_setguardsize.3:40
#: build/C/man3/pthread_attr_setinheritsched.3:40
#: build/C/man3/pthread_attr_setschedparam.3:40
#: build/C/man3/pthread_attr_setschedpolicy.3:40
#: build/C/man3/pthread_attr_setscope.3:40
#: build/C/man3/pthread_attr_setstack.3:40
#: build/C/man3/pthread_attr_setstackaddr.3:40
#: build/C/man3/pthread_attr_setstacksize.3:40 build/C/man3/pthread_cancel.3:36
#: build/C/man3/pthread_cleanup_push.3:39 build/C/man3/pthread_equal.3:36
#: build/C/man3/pthread_exit.3:36 build/C/man3/pthread_getattr_np.3:37
#: build/C/man3/pthread_getcpuclockid.3:37
#: build/C/man3/pthread_rwlockattr_setkind_np.3:39
#: build/C/man3/pthread_self.3:36 build/C/man3/pthread_setaffinity_np.3:41
#: build/C/man3/pthread_setcancelstate.3:38
#: build/C/man3/pthread_setconcurrency.3:37
#: build/C/man3/pthread_setschedparam.3:40
#: build/C/man3/pthread_setschedprio.3:36 build/C/man3/pthread_testcancel.3:36
#: build/C/man3/pthread_attr_setsigmask_np.3:41
#: build/C/man3/pthread_getattr_default_np.3:38
#, no-wrap
msgid "Compile and link with I<-pthread>.\n"
msgstr "I<-pthread> でコンパイルしてリンクする。\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:50
msgid ""
"The B<pthread_attr_init>()  function initializes the thread attributes "
"object pointed to by I<attr> with default attribute values.  After this "
"call, individual attributes of the object can be set using various related "
"functions (listed under SEE ALSO), and then the object can be used in one or "
"more B<pthread_create>(3)  calls that create threads."
msgstr ""
"B<pthread_attr_init>() 関数は I<attr> が指すスレッド属性オブジェクト\n"
"(thread attributes object) をデフォルトの属性値で初期化する。\n"
"この呼び出しの後、オブジェクトの各属性は (関連項目に載っている) 種々の\n"
"関数を使って設定することができ、このオブジェクトはスレッドの作成を行う\n"
"B<pthread_create>(3) の呼び出しにおいて使用することができる (一つの\n"
"オブジェクトを複数の B<pthread_create>(3) に渡してもよい)。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:55
msgid ""
"Calling B<pthread_attr_init>()  on a thread attributes object that has "
"already been initialized results in undefined behavior."
msgstr ""
"すでに初期化されているスレッド属性オブジェクトに対して\n"
"B<pthread_attr_init>() を呼び出した場合、\n"
"どのような動作になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:62
msgid ""
"When a thread attributes object is no longer required, it should be "
"destroyed using the B<pthread_attr_destroy>()  function.  Destroying a "
"thread attributes object has no effect on threads that were created using "
"that object."
msgstr ""
"スレッド属性オブジェクトがもはや必要なくなった際には、\n"
"そのオブジェクトは B<pthread_attr_destroy>() 関数を使って破棄すべきである。\n"
"スレッド属性オブジェクトを破棄しても、\n"
"そのオブジェクトを使って作成されたスレッドには影響はない。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:68
msgid ""
"Once a thread attributes object has been destroyed, it can be reinitialized "
"using B<pthread_attr_init>().  Any other use of a destroyed thread "
"attributes object has undefined results."
msgstr ""
"いったん破棄したスレッド属性オブジェクトは、\n"
"B<pthread_attr_init>() を使って再初期化することができる。\n"
"破棄したスレッド属性オブジェクトをこれ以外の用途で\n"
"使った場合の結果は不定である。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:71
#: build/C/man3/pthread_attr_setaffinity_np.3:79
#: build/C/man3/pthread_attr_setdetachstate.3:80
#: build/C/man3/pthread_attr_setguardsize.3:93
#: build/C/man3/pthread_attr_setinheritsched.3:96
#: build/C/man3/pthread_attr_setschedparam.3:88
#: build/C/man3/pthread_attr_setschedpolicy.3:86
#: build/C/man3/pthread_attr_setscope.3:106
#: build/C/man3/pthread_attr_setstack.3:88
#: build/C/man3/pthread_attr_setstackaddr.3:77
#: build/C/man3/pthread_attr_setstacksize.3:64
#: build/C/man3/pthread_setaffinity_np.3:80
#: build/C/man3/pthread_setcancelstate.3:100
#: build/C/man3/pthread_setname_np.3:75
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:79
msgid ""
"POSIX.1 documents an B<ENOMEM> error for B<pthread_attr_init>(); on Linux "
"these functions always succeed (but portable and future-proof applications "
"should nevertheless handle a possible error return)."
msgstr "POSIX.1 では B<pthread_attr_init>() にはエラー B<ENOMEM> が記載されている。 Linux では、これらの関数は常に成功する (ただし、移植性や将来も動作することを保証したいアプリケーションでは正のエラーの返り値を処理するようにすべきである)。"

#. type: tbl table
#: build/C/man3/pthread_attr_init.3:91
#, no-wrap
msgid ""
"B<pthread_attr_init>(),\n"
"B<pthread_attr_destroy>()"
msgstr ""
"B<pthread_attr_init>(),\n"
"B<pthread_attr_destroy>()"

#. type: tbl table
#: build/C/man3/pthread_attr_init.3:91
#: build/C/man3/pthread_attr_setaffinity_np.3:119
#: build/C/man3/pthread_attr_setdetachstate.3:98
#: build/C/man3/pthread_attr_setguardsize.3:117
#: build/C/man3/pthread_attr_setinheritsched.3:121
#: build/C/man3/pthread_attr_setschedparam.3:118
#: build/C/man3/pthread_attr_setschedpolicy.3:111
#: build/C/man3/pthread_attr_setscope.3:130
#: build/C/man3/pthread_attr_setstack.3:123
#: build/C/man3/pthread_attr_setstackaddr.3:94
#: build/C/man3/pthread_attr_setstacksize.3:94
#: build/C/man3/pthread_cancel.3:135 build/C/man3/pthread_cleanup_push.3:138
#: build/C/man3/pthread_create.3:163 build/C/man3/pthread_detach.3:74
#: build/C/man3/pthread_equal.3:57 build/C/man3/pthread_exit.3:85
#: build/C/man3/pthread_getattr_np.3:109
#: build/C/man3/pthread_getcpuclockid.3:78 build/C/man3/pthread_join.3:108
#: build/C/man3/pthread_kill.3:82
#: build/C/man3/pthread_kill_other_threads_np.3:57
#: build/C/man3/pthread_self.3:60 build/C/man3/pthread_setaffinity_np.3:128
#: build/C/man3/pthread_setcancelstate.3:132
#: build/C/man3/pthread_setconcurrency.3:94
#: build/C/man3/pthread_setname_np.3:113
#: build/C/man3/pthread_setschedparam.3:152
#: build/C/man3/pthread_setschedprio.3:93 build/C/man3/pthread_sigmask.3:79
#: build/C/man3/pthread_sigqueue.3:104 build/C/man3/pthread_testcancel.3:68
#: build/C/man3/pthread_tryjoin_np.3:135 build/C/man3/pthread_yield.3:63
#: build/C/man3/pthread_attr_setsigmask_np.3:102
#: build/C/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:96
#: build/C/man3/pthread_attr_setdetachstate.3:102
#: build/C/man3/pthread_attr_setguardsize.3:121
#: build/C/man3/pthread_attr_setinheritsched.3:125
#: build/C/man3/pthread_attr_setschedparam.3:122
#: build/C/man3/pthread_attr_setschedpolicy.3:115
#: build/C/man3/pthread_attr_setscope.3:134
#: build/C/man3/pthread_attr_setstack.3:127
#: build/C/man3/pthread_attr_setstacksize.3:98
#: build/C/man3/pthread_cancel.3:140 build/C/man3/pthread_cleanup_push.3:143
#: build/C/man3/pthread_create.3:168 build/C/man3/pthread_detach.3:79
#: build/C/man3/pthread_equal.3:61 build/C/man3/pthread_exit.3:89
#: build/C/man3/pthread_getcpuclockid.3:82 build/C/man3/pthread_join.3:113
#: build/C/man3/pthread_kill.3:86 build/C/man3/pthread_self.3:64
#: build/C/man3/pthread_setcancelstate.3:144
#: build/C/man3/pthread_setconcurrency.3:98
#: build/C/man3/pthread_setschedparam.3:156
#: build/C/man3/pthread_setschedprio.3:97 build/C/man3/pthread_sigmask.3:83
#: build/C/man3/pthread_testcancel.3:72 build/C/man3/pthread_atfork.3:88
#: build/C/man3/pthread_mutexattr_getpshared.3:94
#: build/C/man3/pthread_mutexattr_init.3:61
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:102
msgid ""
"The I<pthread_attr_t> type should be treated as opaque: any access to the "
"object other than via pthreads functions is nonportable and produces "
"undefined results."
msgstr ""
"I<pthread_attr_t> 型の内部構造は意識すべきではない。\n"
"pthreads 関数経由以外でのオブジェクトへのアクセスは移植性がなく、\n"
"どのような結果が得られるかも分からない。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:111
msgid ""
"The program below optionally makes use of B<pthread_attr_init>()  and "
"various related functions to initialize a thread attributes object that is "
"used to create a single thread.  Once created, the thread uses the "
"B<pthread_getattr_np>(3)  function (a nonstandard GNU extension) to retrieve "
"the thread's attributes, and then displays those attributes."
msgstr ""
"下記のプログラムは、B<pthread_attr_init>() と種々の関連関数を使って、\n"
"スレッド属性オブジェクトの初期化を行い、\n"
"そのオブジェクトを使ってスレッドを一つ作成する。\n"
"作成されたスレッドは、作成後に B<pthread_getattr_np>(3) 関数 \n"
"(非標準の GNU 拡張) を使ってスレッドの属性を取得し、\n"
"取得した属性を表示する。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:120
msgid ""
"If the program is run with no command-line argument, then it passes NULL as "
"the I<attr> argument of B<pthread_create>(3), so that the thread is created "
"with default attributes.  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""
"コマンドライン引き数なしでプログラムを実行した場合、\n"
"B<pthread_create>(3) の I<attr> 引き数には NULL が渡される。\n"
"この場合、スレッドはデフォルトの属性で作成される。\n"
"このプログラムを NPTL スレッド実装が使われている Linux/x86-32 で\n"
"動作させると、以下のような出力が得られる。"

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: build/C/man3/pthread_attr_init.3:136
#, no-wrap
msgid ""
"$B< ulimit -s>       # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"
msgstr ""
"$B< ulimit -s>       # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:146
msgid ""
"When we supply a stack size as a command-line argument, the program "
"initializes a thread attributes object, sets various attributes in that "
"object, and passes a pointer to the object in the call to "
"B<pthread_create>(3).  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""
"コマンドライン引き数でスタックサイズが与えられた場合、\n"
"このプログラムは、スレッド属性オブジェクトを初期化し、\n"
"そのオブジェクトの各種属性を設定し、\n"
"B<pthread_create>(3) の呼び出しでこのオブジェクトへのポインターを渡す。\n"
"このプログラムを NPTL スレッド実装が使われている Linux/x86-32 で\n"
"動作させると、以下のような出力が得られる。"

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: build/C/man3/pthread_attr_init.3:161
#, no-wrap
msgid ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"
msgstr ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:172 build/C/man3/pthread_getattr_np.3:202
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:175 build/C/man3/pthread_cancel.3:175
#: build/C/man3/pthread_cleanup_push.3:257 build/C/man3/pthread_create.3:291
#: build/C/man3/pthread_getattr_np.3:205
#: build/C/man3/pthread_getcpuclockid.3:130
#: build/C/man3/pthread_setaffinity_np.3:181
#: build/C/man3/pthread_setschedparam.3:250 build/C/man3/pthread_sigmask.3:125
#: build/C/man3/pthread_mutexattr_setrobust.3:221
#, no-wrap
msgid ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:183
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"
msgstr ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:191
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:199
#, no-wrap
msgid ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:207
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:216
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:221
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"
msgstr ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:226
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, v);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, v);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:233
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = %#zx bytes\\en\", prefix, v);\n"
"}\n"
msgstr ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = %#zx bytes\\en\", prefix, v);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:239
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:243
#, no-wrap
msgid ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"
msgstr ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:247
#, no-wrap
msgid ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:250
#, no-wrap
msgid ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"
msgstr ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:253 build/C/man3/pthread_getattr_np.3:254
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:261
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:263
#: build/C/man3/pthread_setschedparam.3:368
#, no-wrap
msgid "    attrp = NULL;\n"
msgstr "    attrp = NULL;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:267
#, no-wrap
msgid ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"
msgstr ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:271
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        size_t stack_size;\n"
"        void *sp;\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        size_t stack_size;\n"
"        void *sp;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:273
#, no-wrap
msgid "        attrp = &attr;\n"
msgstr "        attrp = &attr;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:277
#, no-wrap
msgid ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:281
#, no-wrap
msgid ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"
msgstr ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:285
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
msgstr ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:287
#, no-wrap
msgid "        stack_size = strtoul(argv[1], NULL, 0);\n"
msgstr "        stack_size = strtoul(argv[1], NULL, 0);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:291
#, no-wrap
msgid ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"
msgstr ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:293
#, no-wrap
msgid "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"
msgstr "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:298
#, no-wrap
msgid ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:302 build/C/man3/pthread_getattr_np.3:349
#, no-wrap
msgid ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:308 build/C/man3/pthread_getattr_np.3:355
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:311 build/C/man3/pthread_getattr_np.3:358
#, no-wrap
msgid ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"
msgstr ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:330
msgid ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setsigmask_np>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), "
"B<pthread_getattr_np>(3), B<pthread_setattr_default_np>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), B<pthread_attr_setsigmask_np>(3), B<pthread_attr_setstack>(3), B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthread_getattr_np>(3), B<pthread_setattr_default_np>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETAFFINITY_NP"
msgstr "PTHREAD_ATTR_SETAFFINITY_NP"

#. type: TH
#: build/C/man3/pthread_attr_setaffinity_np.3:26
#: build/C/man3/pthread_attr_setscope.3:26
#: build/C/man3/pthread_attr_setstackaddr.3:26
#: build/C/man3/pthread_cleanup_push_defer_np.3:26
#: build/C/man3/pthread_exit.3:26 build/C/man3/pthread_kill.3:26
#: build/C/man3/pthread_kill_other_threads_np.3:26
#: build/C/man3/pthread_self.3:26 build/C/man3/pthread_setconcurrency.3:25
#: build/C/man3/pthread_sigqueue.3:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:30
msgid ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU "
"affinity attribute in thread attributes object"
msgstr ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - \n"
"スレッド属性オブジェクトの CPU affinity 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:34
#: build/C/man3/pthread_getattr_np.3:33
#: build/C/man3/pthread_setaffinity_np.3:34
#: build/C/man3/pthread_tryjoin_np.3:34 build/C/man3/pthread_yield.3:32
#: build/C/man3/pthread_attr_setsigmask_np.3:34
#: build/C/man3/pthread_getattr_default_np.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:54
msgid ""
"The B<pthread_attr_setaffinity_np>()  function sets the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<cpuset>.  This attribute determines the CPU affinity "
"mask of a thread created using the thread attributes object I<attr>."
msgstr ""
"B<pthread_attr_setaffinity_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの CPU affinity マスク属性を\n"
"I<cpuset> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されたスレッドの CPU affinity マスクが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:63
msgid ""
"The B<pthread_attr_getaffinity_np>()  function returns the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<cpuset>."
msgstr ""
"B<pthread_attr_getaffinity_np>() 関数は、 I<attr> が参照する\n"
"スレッド属性オブジェクトの CPU affinity マスク属性を\n"
"I<cpuset> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:70
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>."
msgstr ""
"I<cpusetsize> 引き数は I<cpuset> が指すバッファーの (バイト単位の)\n"
"大きさである。通常は、この引き数には I<sizeof(cpu_set_t)> を\n"
"指定することだろう。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:76
#: build/C/man3/pthread_setaffinity_np.3:67
msgid ""
"For more details on CPU affinity masks, see B<sched_setaffinity>(2).  For a "
"description of a set of macros that can be used to manipulate and inspect "
"CPU sets, see B<CPU_SET>(3)."
msgstr ""
"CPU affinity マスクの詳細については、 \n"
"B<sched_setaffinity>(2) を参照してほしい。\n"
"CPU 集合の操作や取得を行う際に利用できるマクロ群の説明は \n"
"B<CPU_SET>(3) を参照してほしい。"

#. type: TP
#: build/C/man3/pthread_attr_setaffinity_np.3:80
#: build/C/man3/pthread_attr_setaffinity_np.3:92
#: build/C/man3/pthread_attr_setdetachstate.3:83
#: build/C/man3/pthread_attr_setinheritsched.3:99
#: build/C/man3/pthread_attr_setschedparam.3:91
#: build/C/man3/pthread_attr_setschedpolicy.3:89
#: build/C/man3/pthread_attr_setscope.3:109
#: build/C/man3/pthread_attr_setstack.3:91
#: build/C/man3/pthread_attr_setstacksize.3:67
#: build/C/man3/pthread_create.3:144 build/C/man3/pthread_detach.3:55
#: build/C/man3/pthread_join.3:85 build/C/man3/pthread_join.3:89
#: build/C/man3/pthread_kill.3:69
#: build/C/man3/pthread_rwlockattr_setkind_np.3:130
#: build/C/man3/pthread_setaffinity_np.3:84
#: build/C/man3/pthread_setaffinity_np.3:93
#: build/C/man3/pthread_setaffinity_np.3:105
#: build/C/man3/pthread_setcancelstate.3:104
#: build/C/man3/pthread_setcancelstate.3:112
#: build/C/man3/pthread_setconcurrency.3:71
#: build/C/man3/pthread_setschedparam.3:122
#: build/C/man3/pthread_setschedprio.3:62 build/C/man3/pthread_sigqueue.3:78
#: build/C/man3/pthread_tryjoin_np.3:109
#: build/C/man3/pthread_getattr_default_np.3:67
#: build/C/man3/pthread_mutex_consistent.3:66
#: build/C/man3/pthread_mutexattr_getpshared.3:82
#: build/C/man3/pthread_mutexattr_setrobust.3:137
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:92
msgid ""
"(B<pthread_attr_setaffinity_np>())  I<cpuset> specified a CPU that was "
"outside the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""
"(B<pthread_attr_setaffinity_np>())\n"
"I<cpuset> がカーネルがサポートする CPU 集合にない CPU を指定していた。\n"
"(CPU 集合を表現するのに使われるカーネルのデータ型がサポートする集合の範囲"
"は、\n"
"カーネルの設定オプション B<CONFIG_NR_CPUS> により定義される)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:102
msgid ""
"(B<pthread_attr_getaffinity_np>())  A CPU in the affinity mask of the thread "
"attributes object referred to by I<attr> lies outside the range specified by "
"I<cpusetsize> (i.e., I<cpuset>/I<cpusetsize> is too small)."
msgstr ""
"(B<pthread_attr_getaffinity_np>())\n"
"I<attr> が参照するスレッド属性オブジェクトの affinity マスク内の CPU が、\n"
"I<cpusetsize> により指定された範囲の中になかった\n"
"(すなわち、I<cpuset>/I<cpusetsize> が小さすぎる)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:106
msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgstr ""
"(B<pthread_attr_setaffinity_np>()) メモリーを割り当てることができなかった。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:108
#: build/C/man3/pthread_setaffinity_np.3:117
msgid "These functions are provided by glibc since version 2.3.4."
msgstr "これらの関数は glibc バージョン 2.3.4 以降で提供されている。"

#. type: tbl table
#: build/C/man3/pthread_attr_setaffinity_np.3:119
#, no-wrap
msgid ""
"B<pthread_attr_setaffinity_np>(),\n"
"B<pthread_attr_getaffinity_np>()"
msgstr ""
"B<pthread_attr_setaffinity_np>(),\n"
"B<pthread_attr_getaffinity_np>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:125
#: build/C/man3/pthread_cleanup_push_defer_np.3:117
#: build/C/man3/pthread_setaffinity_np.3:133
#: build/C/man3/pthread_setname_np.3:119 build/C/man3/pthread_tryjoin_np.3:141
#: build/C/man3/pthread_attr_setsigmask_np.3:108
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in the names."
msgstr ""
"これらの関数は非標準の GNU による拡張である。\n"
"そのため、名前に \"_np\" (nonportable; 移植性がない) という接尾辞が\n"
"付いている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:132
#: build/C/man3/pthread_setaffinity_np.3:159
msgid ""
"In glibc 2.3.3 only, versions of these functions were provided that did not "
"have a I<cpusetsize> argument.  Instead the CPU set size given to the "
"underlying system calls was always I<sizeof(cpu_set_t)>."
msgstr ""
"(このバージョンだけであるが) glibc 2.3.3 では、\n"
"これらの関数は I<cpusetsize> 引き数を持っていなかった。\n"
"内部で呼ばれるシステムコールに渡される CPU セットの大きさは\n"
"常に I<sizeof(cpu_set_t)> であった。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:138
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setdetachstate.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETDETACHSTATE"
msgstr "PTHREAD_ATTR_SETDETACHSTATE"

#. type: TH
#: build/C/man3/pthread_attr_setdetachstate.3:26
#: build/C/man3/pthread_attr_setguardsize.3:26
#: build/C/man3/pthread_attr_setinheritsched.3:26
#: build/C/man3/pthread_attr_setschedparam.3:26
#: build/C/man3/pthread_attr_setschedpolicy.3:26
#: build/C/man3/pthread_attr_setstack.3:26
#: build/C/man3/pthread_attr_setstacksize.3:26 build/C/man3/pthread_cancel.3:26
#: build/C/man3/pthread_cleanup_push.3:26 build/C/man3/pthread_detach.3:26
#: build/C/man3/pthread_join.3:26 build/C/man3/pthread_setcancelstate.3:26
#: build/C/man3/pthread_setschedparam.3:26 build/C/man3/pthread_testcancel.3:26
#: build/C/man3/pthread_getattr_default_np.3:25
#: build/C/man3/pthread_mutex_consistent.3:26
#: build/C/man3/pthread_mutexattr_setrobust.3:26
#: build/C/man3/pthread_spin_init.3:25
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:30
msgid ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach "
"state attribute in thread attributes object"
msgstr ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - \n"
"スレッド属性オブジェクトの detach state 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                int *>I<detachstate>B<);>\n"
msgstr ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                int *>I<detachstate>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:53
msgid ""
"The B<pthread_attr_setdetachstate>()  function sets the detach state "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<detachstate>.  The detach state attribute determines "
"whether a thread created using the thread attributes object I<attr> will be "
"created in a joinable or a detached state."
msgstr ""
"B<pthread_attr_setdetachstate>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの detach state 属性を\n"
"I<detachstate> で指定された値に設定する。\n"
"detach state 属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが、 join 可能な状態で作成されるか、\n"
"detached (切り離された) 状態で作成されるかが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:56
msgid "The following values may be specified in I<detachstate>:"
msgstr "I<detachstate> には以下の値を指定できる。"

#. type: TP
#: build/C/man3/pthread_attr_setdetachstate.3:56
#, no-wrap
msgid "B<PTHREAD_CREATE_DETACHED>"
msgstr "B<PTHREAD_CREATE_DETACHED>"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:61
msgid ""
"Threads that are created using I<attr> will be created in a detached state."
msgstr "I<attr> を使って作成されるスレッドは detached 状態で作成される。"

#. type: TP
#: build/C/man3/pthread_attr_setdetachstate.3:61
#, no-wrap
msgid "B<PTHREAD_CREATE_JOINABLE>"
msgstr "B<PTHREAD_CREATE_JOINABLE>"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:66
msgid ""
"Threads that are created using I<attr> will be created in a joinable state."
msgstr "I<attr> を使って作成されるスレッドは join 可能な状態で作成される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:70
msgid ""
"The default setting of the detach state attribute in a newly initialized "
"thread attributes object is B<PTHREAD_CREATE_JOINABLE>."
msgstr ""
"新規に初期化されたスレッド属性オブジェクトの detach state 属性の\n"
"デフォルト設定は B<PTHREAD_CREATE_JOINABLE> である。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:77
msgid ""
"The B<pthread_attr_getdetachstate>()  returns the detach state attribute of "
"the thread attributes object I<attr> in the buffer pointed to by "
"I<detachstate>."
msgstr ""
"B<pthread_attr_getdetachstate>() は、\n"
"スレッド属性オブジェクト I<attr> の detach state 属性を\n"
"I<detachstate> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:83
msgid "B<pthread_attr_setdetachstate>()  can fail with the following error:"
msgstr "B<pthread_attr_setdetachstate>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:87
msgid "An invalid value was specified in I<detachstate>."
msgstr "無効な値が I<detachstate> で指定された。"

#. type: tbl table
#: build/C/man3/pthread_attr_setdetachstate.3:98
#, no-wrap
msgid ""
"B<pthread_attr_setdetachstate>(),\n"
"B<pthread_attr_getdetachstate>()"
msgstr ""
"B<pthread_attr_setdetachstate>(),\n"
"B<pthread_attr_getdetachstate>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:106
msgid ""
"See B<pthread_create>(3)  for more details on detached and joinable threads."
msgstr ""
"detached 状態のスレッド、join 可能状態のスレッドの詳細については、\n"
"B<pthread_create>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:114
msgid ""
"A thread that is created in a joinable state should eventually either be "
"joined using B<pthread_join>(3)  or detached using B<pthread_detach>(3); see "
"B<pthread_create>(3)."
msgstr ""
"join 可能状態で作成されたスレッドは、最終的に\n"
"B<pthread_join>(3) を使って join するか、\n"
"B<pthread_detach>(3) を使って切り離すか、\n"
"のどちらかを行うべきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:121
msgid ""
"It is an error to specify the thread ID of a thread that was created in a "
"detached state in a later call to B<pthread_detach>(3)  or "
"B<pthread_join>(3)."
msgstr ""
"detached 状態で作成されたスレッドのスレッド ID を指定して、\n"
"B<pthread_detach>(3) や B<pthread_join>(3) を後から呼び出すのは\n"
"エラーである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:124
#: build/C/man3/pthread_attr_setstack.3:168
msgid "See B<pthread_attr_init>(3)."
msgstr "B<pthread_attr_init>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:130
msgid ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setguardsize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETGUARDSIZE"
msgstr "PTHREAD_ATTR_SETGUARDSIZE"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:30
msgid ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - \n"
"スレッド属性オブジェクトの guard size 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              size_t *>I<guardsize>B<);>\n"
msgstr ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              size_t *>I<guardsize>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:49
msgid ""
"The B<pthread_attr_setguardsize>()  function sets the guard size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<guardsize>."
msgstr ""
"B<pthread_attr_setguardsize>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの guard size 属性を\n"
"I<guardsize> で指定された値に設定する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:59
msgid ""
"If I<guardsize> is greater than 0, then for each new thread created using "
"I<attr> the system allocates an additional region of at least I<guardsize> "
"bytes at the end of the thread's stack to act as the guard area for the "
"stack (but see BUGS)."
msgstr ""
"I<guardsize> が 0 より大きい場合、\n"
"I<attr> を使って新しく作成された各スレッドに対して、\n"
"システムはスレッドのスタックの末尾に少なくとも I<guardsize> バイトの\n"
"追加領域を割り当てる。この追加領域はスタックに対するガード領域として\n"
"機能する (ただし「バグ」の節も参照)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:65
msgid ""
"If I<guardsize> is 0, then new threads created with I<attr> will not have a "
"guard area."
msgstr ""
"I<guardsize> が 0 の場合、\n"
"I<attr> を使って新しく作成されたスレッドはガード領域を持たない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:67
msgid "The default guard size is the same as the system page size."
msgstr "デフォルトの guard size はシステムのページサイズと同じである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:82
msgid ""
"If the stack address attribute has been set in I<attr> (using "
"B<pthread_attr_setstack>(3)  or B<pthread_attr_setstackaddr>(3)), meaning "
"that the caller is allocating the thread's stack, then the guard size "
"attribute is ignored (i.e., no guard area is created by the system): it is "
"the application's responsibility to handle stack overflow (perhaps by using "
"B<mprotect>(2)  to manually define a guard area at the end of the stack that "
"it has allocated)."
msgstr ""
"(B<pthread_attr_setstack>(3) や B<pthread_attr_setstackaddr>(3)を使って)\n"
"I<attr> でスタックアドレス属性が設定されている場合には、呼び出し側がそ\n"
"のスレッドのスタックを割り当てていることを意味するので、guard size 属性\n"
"は無視される (すなわち、システムによるガード領域の作成は行われない)。\n"
"この場合、スタックオーバーフローが起こらないように対処するのはアプリ\n"
"ケーション側の責任となる (おそらく B<mprotect>(2) を使って、割り当て\n"
"られたスタックの最後に手動でガード領域を定義することになるだろう)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:90
msgid ""
"The B<pthread_attr_getguardsize>()  function returns the guard size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<guardsize>."
msgstr ""
"B<pthread_attr_getguardsize>() は、\n"
"スレッド属性オブジェクト I<attr> の guard size 属性を\n"
"I<guardsize> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:104
msgid ""
"POSIX.1 documents an B<EINVAL> error if I<attr> or I<guardsize> is invalid.  "
"On Linux these functions always succeed (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""
"POSIX.1 では、エラー B<EINVAL> が\n"
" I<attr> か I<guardsize> が無効な場合に対して規定されている。\n"
"Linux では、これらの関数は常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:106
#: build/C/man3/pthread_attr_setstackaddr.3:83
#: build/C/man3/pthread_attr_setstacksize.3:83
msgid "These functions are provided by glibc since version 2.1."
msgstr "これらの関数は glibc バージョン 2.1 以降で提供されている。"

#. type: tbl table
#: build/C/man3/pthread_attr_setguardsize.3:117
#, no-wrap
msgid ""
"B<pthread_attr_setguardsize>(),\n"
"B<pthread_attr_getguardsize>()"
msgstr ""
"B<pthread_attr_setguardsize>(),\n"
"B<pthread_attr_getguardsize>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:135
msgid ""
"A guard area consists of virtual memory pages that are protected to prevent "
"read and write access.  If a thread overflows its stack into the guard area, "
"then, on most hard architectures, it receives a B<SIGSEGV> signal, thus "
"notifying it of the overflow.  Guard areas start on page boundaries, and the "
"guard size is internally rounded up to the system page size when creating a "
"thread.  (Nevertheless, B<pthread_attr_getguardsize>()  returns the guard "
"size that was set by B<pthread_attr_setguardsize>().)"
msgstr ""
"ガード領域は、読み出し/書き込みアクセスが行われないように保護がかけ\n"
"られた仮想メモリーページで構成で構成される。スレッドがスタックをガード\n"
"領域までオーバーフローさせた場合、ほとんどのハードウェアアーキテクチャー\n"
"では、スレッドに B<SIGSEGV> シグナルが送られ、オーバーフローが発生した\n"
"ことが通知される。ガード領域はページ境界から開始され、ガード領域の\n"
"大きさはスレッド作成時に内部的にシステムのページサイズに切り上げられる\n"
"(その場合も B<pthread_attr_getguardsize>() では\n"
"B<pthread_attr_setguardsize>() で設定された guard size が返される)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:139
msgid ""
"Setting a guard size of 0 may be useful to save memory in an application "
"that creates many threads and knows that stack overflow can never occur."
msgstr ""
"多くのスレッドを作成するアプリケーションで、かつ、スタックオーバーフロー\n"
"が決して発生しないことが分かっている場合には、guard size を 0 に設定\n"
"することで、メモリーを節約できることもある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:143
msgid ""
"Choosing a guard size larger than the default size may be necessary for "
"detecting stack overflows if a thread allocates large data structures on the "
"stack."
msgstr ""
"スレッドがスタックに大きなデータ構造を割り当てる場合には、\n"
"スタックオーバーフローを検出するためには、デフォルトサイズよりも\n"
"大きな guard size を選ぶ必要があるかもしれない。"

#. type: SH
#: build/C/man3/pthread_attr_setguardsize.3:143
#: build/C/man3/pthread_attr_setinheritsched.3:125
#: build/C/man3/pthread_attr_setstacksize.3:109
#: build/C/man3/pthread_create.3:233 build/C/man3/pthread_exit.3:105
#: build/C/man3/pthread_tryjoin_np.3:163
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:154
msgid ""
"As at glibc 2.8, the NPTL threading implementation includes the guard area "
"within the stack size allocation, rather than allocating extra space at the "
"end of the stack, as POSIX.1 requires.  (This can result in an B<EINVAL> "
"error from B<pthread_create>(3)  if the guard size value is too large, "
"leaving no space for the actual stack.)"
msgstr ""
"glibc 2.8 の時点では、 NPTL スレッド実装ではガード領域はスタックサイズ\n"
"で割り当てられる領域の中に含まれている。一方、POSIX.1 では、スタックの\n"
"末尾に追加の領域を割り当てることが求められている。\n"
"(このため、ガード領域が大きすぎて、\n"
"実際のスタック用の場所がなくなってしまう場合、\n"
"B<pthread_create>(3) で B<EINVAL> エラーが発生することになる。)"

#.  glibc includes the guardsize within the allocated stack size,
#.  which looks pretty clearly to be in violation of POSIX.
#.  Filed bug, 22 Oct 2008:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6973
#.  Older reports:
#.  https//bugzilla.redhat.com/show_bug.cgi?id=435337
#.  Reportedly, LinuxThreads did the right thing, allocating
#.  extra space at the end of the stack:
#.  http://sourceware.org/ml/libc-alpha/2008-05/msg00086.html
#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:168
msgid ""
"The obsolete LinuxThreads implementation did the right thing, allocating "
"extra space at the end of the stack for the guard area."
msgstr ""
"廃止予定の LinuxThreads 実装では、\n"
"POSIX.1 で求められている通りの動作で、\n"
"ガード領域がスタックの末尾に追加の領域が割り当てられる。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:171
msgid "See B<pthread_getattr_np>(3)."
msgstr "B<pthread_getattr_np>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:179
msgid ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setinheritsched.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETINHERITSCHED"
msgstr "PTHREAD_ATTR_SETINHERITSCHED"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:30
msgid ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get inherit-"
"scheduler attribute in thread attributes object"
msgstr ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - スレッド属性オブ"
"ジェクトの inherit-scheduler 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"
msgstr ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:55
msgid ""
"The B<pthread_attr_setinheritsched>()  function sets the inherit-scheduler "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<inheritsched>.  The inherit-scheduler attribute "
"determines whether a thread created using the thread attributes object "
"I<attr> will inherit its scheduling attributes from the calling thread or "
"whether it will take them from I<attr>."
msgstr ""
"B<pthread_attr_setinheritsched>() 関数は、 I<attr> が参照するスレッド属性オブ"
"ジェクトの inherit-scheduler 属性を I<inheritsched> で指定された値に設定す"
"る。 inherit-scheduler 属性により、スレッド属性オブジェクト I<attr> を使って"
"作成されるスレッドが、呼び出したスレッドのスケジューリング属性を継承するか、 "
"I<attr> からスケジューリング属性を取得するかが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:64
msgid ""
"The following scheduling attributes are affected by the inherit-scheduler "
"attribute: scheduling policy (B<pthread_attr_setschedpolicy>(3)), scheduling "
"priority (B<pthread_attr_setschedparam>(3)), and contention scope "
"(B<pthread_attr_setscope>(3))."
msgstr ""
"次に挙げるスケジューリング属性は inherit-scheduler 属性の影響を受ける: スケ"
"ジューリングポリシー (B<pthread_attr_setschedpolicy>(3))、 スケジューリング優"
"先度 (B<pthread_attr_setschedparam>(3))、 contention scope "
"(B<pthread_attr_setscope>(3))。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:67
msgid "The following values may be specified in I<inheritsched>:"
msgstr "以下の値を I<inheritsched> に指定できる。"

#. type: TP
#: build/C/man3/pthread_attr_setinheritsched.3:67
#, no-wrap
msgid "B<PTHREAD_INHERIT_SCHED>"
msgstr "B<PTHREAD_INHERIT_SCHED>"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:75
msgid ""
"Threads that are created using I<attr> inherit scheduling attributes from "
"the creating thread; the scheduling attributes in I<attr> are ignored."
msgstr ""
"I<attr> を使って作成されたスレッドは、\n"
"スレッドを作成するスレッドからスケジューリング属性を継承する。\n"
"I<attr> 内のスケジューリング属性は無視される。"

#. type: TP
#: build/C/man3/pthread_attr_setinheritsched.3:75
#, no-wrap
msgid "B<PTHREAD_EXPLICIT_SCHED>"
msgstr "B<PTHREAD_EXPLICIT_SCHED>"

#.  FIXME Document the defaults for scheduler settings
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:82
msgid ""
"Threads that are created using I<attr> take their scheduling attributes from "
"the values specified by the attributes object."
msgstr ""
"I<attr> を使って作成されたスレッドは、スレッド属性オブジェクトで\n"
"指定された値からスケジューリング属性を取得する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:86
msgid ""
"The default setting of the inherit-scheduler attribute in a newly "
"initialized thread attributes object is B<PTHREAD_INHERIT_SCHED>."
msgstr ""
"新たに初期化されたスレッド属性オブジェクトの inherit-scheduler 属性のデフォル"
"ト設定は B<PTHREAD_INHERIT_SCHED> である。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:93
msgid ""
"The B<pthread_attr_getinheritsched>()  returns the inherit-scheduler "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<inheritsched>."
msgstr ""
"B<pthread_attr_getinheritsched>() は、 スレッド属性オブジェクト I<attr> の "
"inherit-scheduler 属性を I<inheritsched> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:99
msgid "B<pthread_attr_setinheritsched>()  can fail with the following error:"
msgstr "B<pthread_attr_setinheritsched>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:103
msgid "Invalid value in I<inheritsched>."
msgstr "I<inheritsched> に無効な値が指定された。"

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:110
msgid ""
"POSIX.1 also documents an optional B<ENOTSUP> error (\"attempt was made to "
"set the attribute to an unsupported value\") for "
"B<pthread_attr_setinheritsched>()."
msgstr ""
"POSIX.1 では、 B<pthread_attr_setinheritsched>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値を属性に設定しようとした\")\n"
"も追加で規定されている。"

#. type: tbl table
#: build/C/man3/pthread_attr_setinheritsched.3:121
#, no-wrap
msgid ""
"B<pthread_attr_setinheritsched>(),\n"
"B<pthread_attr_getinheritsched>()"
msgstr ""
"B<pthread_attr_setinheritsched>(),\n"
"B<pthread_attr_getinheritsched>()"

#.  FIXME . Track status of the following bug:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7007
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:141
msgid ""
"As at glibc 2.8, if a thread attributes object is initialized using "
"B<pthread_attr_init>(3), then the scheduling policy of the attributes object "
"is set to B<SCHED_OTHER> and the scheduling priority is set to 0.  However, "
"if the inherit-scheduler attribute is then set to B<PTHREAD_EXPLICIT_SCHED>, "
"then a thread created using the attribute object wrongly inherits its "
"scheduling attributes from the creating thread.  This bug does not occur if "
"either the scheduling policy or scheduling priority attribute is explicitly "
"set in the thread attributes object before calling B<pthread_create>(3)."
msgstr ""
"glibc 2.8 の時点では、スレッド属性オブジェクトが B<pthread_attr_init>(3) を"
"使って初期化された場合、 スレッド属性オブジェクトのスケジューリングポリシー"
"が B<SCHED_OTHER> に、 スケジューリング優先度が 0 に設定される。一方、その後 "
"inherit-scheduler 属性に B<PTHREAD_EXPLICIT_SCHED> が設定されると、このスレッ"
"ド属性オブジェクトを使って作成されたスレッドでは、スレッドを作成するスレッド"
"のスケジューリング属性が間違って継承されてしまう。 B<pthread_create>(3) を呼"
"び出す前にスケジューリングポリシー属性かスケジューリング優先度属性のどちらか"
"が明示的に設定された場合には、 このバグは発生しない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:144
#: build/C/man3/pthread_attr_setschedparam.3:129
#: build/C/man3/pthread_attr_setschedpolicy.3:118
msgid "See B<pthread_setschedparam>(3)."
msgstr "B<pthread_setschedparam>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:156
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPARAM"
msgstr "PTHREAD_ATTR_SETSCHEDPARAM"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:30
msgid ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling "
"parameter attributes in thread attributes object"
msgstr ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - \n"
"スレッド属性オブジェクトのスケジューリングパラメーター属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:52
msgid ""
"The B<pthread_attr_setschedparam>()  function sets the scheduling parameter "
"attributes of the thread attributes object referred to by I<attr> to the "
"values specified in the buffer pointed to by I<param>.  These attributes "
"determine the scheduling parameters of a thread created using the thread "
"attributes object I<attr>."
msgstr ""
"B<pthread_attr_setschedparam>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスケジューリング\n"
"パラメーター属性を I<param> が指すバッファーで指定された値に設定する。\n"
"これらの属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドのスケジューリングパラメーターが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:59
msgid ""
"The B<pthread_attr_getschedparam>()  returns the scheduling parameter "
"attributes of the thread attributes object I<attr> in the buffer pointed to "
"by I<param>."
msgstr ""
"B<pthread_attr_getschedparam>() は、\n"
"スレッド属性オブジェクト I<attr> のスケジューリングパラメーター属性を\n"
"I<param> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:61
msgid "Scheduling parameters are maintained in the following structure:"
msgstr "スケジューリングパラメーターは以下の構造体で管理される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:67
#: build/C/man3/pthread_setschedparam.3:69
#, no-wrap
msgid ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"
msgstr ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:74
#: build/C/man3/pthread_setschedparam.3:76
msgid ""
"As can be seen, only one scheduling parameter is supported.  For details of "
"the permitted ranges for scheduling priorities in each scheduling policy, "
"see B<sched>(7)."
msgstr ""
"見て分かる通り、サポートされているスケジューリングパラメーターは一つだけであ"
"る。各スケジューリングポリシーで許可されるスケジューリング優先度の詳細につい"
"ては、B<sched>(7) を参照のこと。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:85
msgid ""
"In order for the parameter setting made by B<pthread_attr_setschedparam>()  "
"to have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""
"B<pthread_create>(3) を呼び出した際に B<pthread_attr_setschedparam>() で行っ"
"たパラメーター設定を有効にするには、 呼び出し側で "
"B<pthread_attr_setinheritsched>(3) を使って 属性オブジェクト I<attr> の "
"inherit-scheduler 属性を B<PTHREAD_EXPLICIT_SCHED> に設定しておかなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:91
msgid "B<pthread_attr_setschedparam>()  can fail with the following error:"
msgstr "B<pthread_attr_setschedparam>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:97
#, fuzzy
#| msgid ""
#| "I<policy> is not a recognized policy, or I<param> does not make sense for "
#| "the I<policy>."
msgid ""
"The priority specified in I<param> does not make sense for the current "
"scheduling policy of I<attr>."
msgstr ""
"I<policy> が認識できないポリシーであるか、\n"
"I<param> が I<policy> では意味を持たない値である。"

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:107
#, fuzzy
#| msgid ""
#| "POSIX.1 documents B<EINVAL> and B<ENOTSUP> errors for "
#| "B<pthread_attr_setschedparam>().  On Linux these functions always succeed "
#| "(but portable and future-proof applications should nevertheless handle a "
#| "possible error return)."
msgid ""
"POSIX.1 also documents an B<ENOTSUP> error for "
"B<pthread_attr_setschedparam>().  This value is never returned on Linux (but "
"portable and future-proof applications should nevertheless handle this error "
"return value)."
msgstr ""
"POSIX.1 では、\n"
"B<pthread_attr_setschedparam>() について\n"
"B<EINVAL> と B<ENOTSUP> が規定されている。\n"
"Linux では、これらの関数は常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#. type: tbl table
#: build/C/man3/pthread_attr_setschedparam.3:118
#, no-wrap
msgid ""
"B<pthread_attr_setschedparam>(),\n"
"B<pthread_attr_getschedparam>()"
msgstr ""
"B<pthread_attr_setschedparam>(),\n"
"B<pthread_attr_getschedparam>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:126
msgid ""
"See B<pthread_attr_setschedpolicy>(3)  for a list of the thread scheduling "
"policies supported on Linux."
msgstr ""
"Linux でサポートされているスレッドのスケジューリングポリシーのリストに\n"
"ついては、 B<pthread_attr_setschedpolicy>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:141
msgid ""
"B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setschedpolicy.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPOLICY"
msgstr "PTHREAD_ATTR_SETSCHEDPOLICY"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:30
msgid ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - set/get "
"scheduling policy attribute in thread attributes object"
msgstr ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - スレッド属性\n"
"オブジェクトのスケジューリングポリシー属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"
msgstr ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:52
msgid ""
"The B<pthread_attr_setschedpolicy>()  function sets the scheduling policy "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<policy>.  This attribute determines the scheduling "
"policy of a thread created using the thread attributes object I<attr>."
msgstr ""
"B<pthread_attr_setschedpolicy>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスケジューリング\n"
"ポリシー属性を I<policy> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドのスケジューリングポリシーが決定される。"

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:65
msgid ""
"The supported values for I<policy> are B<SCHED_FIFO>, B<SCHED_RR>, and "
"B<SCHED_OTHER>, with the semantics described in B<sched>(7)."
msgstr ""
"I<policy> に指定できる値は B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER> であ"
"る。それぞれの意味は B<sched>(7) で説明している通りである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:72
msgid ""
"The B<pthread_attr_getschedpolicy>()  returns the scheduling policy "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<policy>."
msgstr ""
"B<pthread_attr_getschedpolicy>() は、\n"
"スレッド属性オブジェクト I<attr> のスケジューリングポリシー属性を\n"
"I<policy> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:83
msgid ""
"In order for the policy setting made by B<pthread_attr_setschedpolicy>()  to "
"have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""
"B<pthread_create>(3) を呼び出した際に B<pthread_attr_setschedpolicy>() で行っ"
"たポリシー設定を有効にするには、 呼び出し側で "
"B<pthread_attr_setinheritsched>(3) を使って 属性オブジェクト I<attr> の "
"inherit-scheduler 属性を B<PTHREAD_EXPLICIT_SCHED> に設定しておかなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:89
msgid "B<pthread_attr_setschedpolicy>()  can fail with the following error:"
msgstr "B<pthread_attr_setschedpolicy>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:93
msgid "Invalid value in I<policy>."
msgstr "I<policy> に無効な値が指定された。"

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:100
msgid ""
"POSIX.1 also documents an optional B<ENOTSUP> error (\"attempt was made to "
"set the attribute to an unsupported value\") for "
"B<pthread_attr_setschedpolicy>()."
msgstr "POSIX.1 では、 B<pthread_attr_setschedpolicy>() に関してエラー B<ENOTSUP> (\"サポートされていない値を属性に設定しようとした\") も追加で規定されている。"

#. type: tbl table
#: build/C/man3/pthread_attr_setschedpolicy.3:111
#, no-wrap
msgid ""
"B<pthread_attr_setschedpolicy>(),\n"
"B<pthread_attr_getschedpolicy>()"
msgstr ""
"B<pthread_attr_setschedpolicy>(),\n"
"B<pthread_attr_getschedpolicy>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:129
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_create>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_create>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<pthreads>(7), "
"B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setscope.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCOPE"
msgstr "PTHREAD_ATTR_SETSCOPE"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:30
msgid ""
"pthread_attr_setscope, pthread_attr_getscope - set/get contention scope "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setscope, pthread_attr_getscope - \n"
"スレッド属性オブジェクトの contention scope 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"
msgstr ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:53
msgid ""
"The B<pthread_attr_setscope>()  function sets the contention scope attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<scope>.  The contention scope attribute defines the set of "
"threads against which a thread competes for resources such as the CPU.  "
"POSIX.1 specifies two possible values for I<scope>:"
msgstr "B<pthread_attr_setscope>() 関数は、 I<attr> が参照するスレッド属性オブジェクトの contention scope 属性を I<scope> で指定された値に設定する。 contention scope 属性により、スレッドが CPU などのリソースを取り合うスレッド集合が規定される。 POSIX.1 では I<scope> に指定する値として 2 つの値が規定されている。"

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:53
#, no-wrap
msgid "B<PTHREAD_SCOPE_SYSTEM>"
msgstr "B<PTHREAD_SCOPE_SYSTEM>"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:61
msgid ""
"The thread competes for resources with all other threads in all processes on "
"the system that are in the same scheduling allocation domain (a group of one "
"or more processors).  B<PTHREAD_SCOPE_SYSTEM> threads are scheduled relative "
"to one another according to their scheduling policy and priority."
msgstr ""
"スレッドは、同じスケジューリング割り当てドメイン (一つ以上のプロセッサ\n"
"のグループ) にある、システム上の全てのプロセスの自分以外の全ての\n"
"スレッドとリソースを取り合う。 \n"
"B<PTHREAD_SCOPE_SYSTEM> のスレッドは、スケジューリングポリシーと\n"
"優先度に基づき、互いに相対的にスケジューリングされる。"

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:61
#, no-wrap
msgid "B<PTHREAD_SCOPE_PROCESS>"
msgstr "B<PTHREAD_SCOPE_PROCESS>"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:76
msgid ""
"The thread competes for resources with all other threads in the same process "
"that were also created with the B<PTHREAD_SCOPE_PROCESS> contention scope.  "
"B<PTHREAD_SCOPE_PROCESS> threads are scheduled relative to other threads in "
"the process according to their scheduling policy and priority.  POSIX.1 "
"leaves it unspecified how these threads contend with other threads in other "
"process on the system or with other threads in the same process that were "
"created with the B<PTHREAD_SCOPE_SYSTEM> contention scope."
msgstr ""
"スレッドは、contention scope が B<PTHREAD_SCOPE_PROCESS> で作成された\n"
"同じプロセスの自分以外の全てのスレッドとリソースを取り合う。\n"
"B<PTHREAD_SCOPE_PROCESS> のスレッドは、スケジューリングポリシーと優先度\n"
"に基づき、同じプロセスの他のスレッドと相対的にスケジューリングされる。\n"
"POSIX.1 では、これらのスレッドがシステム上の他のプロセスのスレッド\n"
"や同じプロセス内の contention scope が B<PTHREAD_SCOPE_SYSTEM> で作成\n"
"された他のスレッドとどのようにリソースを取り合うかは、\n"
"規定されないままになっている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:83
msgid ""
"POSIX.1 requires that an implementation support at least one of these "
"contention scopes.  Linux supports B<PTHREAD_SCOPE_SYSTEM>, but not "
"B<PTHREAD_SCOPE_PROCESS>."
msgstr "POSIX.1 で求められているのは、スレッド実装がこれらの contention scope のうち少なくとも 1 つをサポートすることだけである。 Linux は B<PTHREAD_SCOPE_SYSTEM> をサポートしているが、 B<PTHREAD_SCOPE_PROCESS> はサポートしていない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:95
msgid ""
"On systems that support multiple contention scopes, then, in order for the "
"parameter setting made by B<pthread_attr_setscope>()  to have effect when "
"calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""
"複数の contention scope をサポートしているシステムで、 B<pthread_create>(3) "
"を呼び出した際に B<pthread_attr_setscope>() で行ったパラメーター設定を有効に"
"するには、 呼び出し側で B<pthread_attr_setinheritsched>(3) を使って 属性オブ"
"ジェクト I<attr> の inherit-scheduler 属性を B<PTHREAD_EXPLICIT_SCHED> に設定"
"しておかなければならない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:103
msgid ""
"The B<pthread_attr_getscope>()  function returns the contention scope "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<scope>."
msgstr ""
"B<pthread_attr_getscope>() は、\n"
"スレッド属性オブジェクト I<attr> の contention scope 属性を\n"
"I<scope> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:109
msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgstr "B<pthread_attr_setscope>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:113
msgid "An invalid value was specified in I<scope>."
msgstr "I<scope> に無効な値が指定された。"

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:113
#: build/C/man3/pthread_mutexattr_getpshared.3:87
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:119
msgid ""
"I<scope> specified the value B<PTHREAD_SCOPE_PROCESS>, which is not "
"supported on Linux."
msgstr ""
"I<scope> に値 B<PTHREAD_SCOPE_PROCESS> が指定された。\n"
"この値は Linux でサポートされていない。"

#. type: tbl table
#: build/C/man3/pthread_attr_setscope.3:130
#, no-wrap
msgid ""
"B<pthread_attr_setscope>(),\n"
"B<pthread_attr_getscope>()"
msgstr ""
"B<pthread_attr_setscope>(),\n"
"B<pthread_attr_getscope>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:142
msgid ""
"The B<PTHREAD_SCOPE_SYSTEM> contention scope typically indicates that a user-"
"space thread is bound directly to a single kernel-scheduling entity.  This "
"is the case on Linux for the obsolete LinuxThreads implementation and the "
"modern NPTL implementation, which are both 1:1 threading implementations."
msgstr ""
"B<PTHREAD_SCOPE_SYSTEM> contention scope では、通常は、一つの\n"
"ユーザー空間スレッドは一つのカーネルスケジューリングエンティティに\n"
"直接結び付けられる。\n"
"Linux では、廃止予定の LinuxThreads 実装も新しい NPTL 実装もこれに\n"
"該当し、両方とも 1:1 で結び付けられるスレッド実装となっている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:145
msgid ""
"POSIX.1 specifies that the default contention scope is implementation-"
"defined."
msgstr "POSIX.1 では、 contention scope 属性のデフォルト値は実装時で定義されるものと規定されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:155
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setstack.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACK"
msgstr "PTHREAD_ATTR_SETSTACK"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:30
msgid ""
"pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in "
"thread attributes object"
msgstr ""
"pthread_attr_setstack, pthread_attr_getstack - \n"
"スレッド属性オブジェクトのスタック属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(const pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(const pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:45
#: build/C/man3/pthread_cleanup_push_defer_np.3:44
#: build/C/man3/pthread_kill.3:41
#: build/C/man3/pthread_rwlockattr_setkind_np.3:44
#: build/C/man3/pthread_sigmask.3:42 build/C/man3/pthread_sigqueue.3:42
#: build/C/man3/pthread_mutex_consistent.3:41
#: build/C/man3/pthread_mutexattr_setrobust.3:45
#: build/C/man3/pthread_spin_init.3:41 build/C/man3/pthread_spin_lock.3:43
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:50
msgid "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"
msgstr "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:52
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:68
msgid ""
"The B<pthread_attr_setstack>()  function sets the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> to "
"the values specified in I<stackaddr> and I<stacksize>, respectively.  These "
"attributes specify the location and size of the stack that should be used by "
"a thread that is created using the thread attributes object I<attr>."
msgstr ""
"B<pthread_attr_setstack>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスタックアドレス属性と\n"
"スタックサイズ属性をそれぞれ I<stackaddr> と I<stacksize> で\n"
"指定された値に設定する。\n"
"これらの属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが使用すべきスタックの位置とサイズが指定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:74
msgid ""
"I<stackaddr> should point to the lowest addressable byte of a buffer of "
"I<stacksize> bytes that was allocated by the caller.  The pages of the "
"allocated buffer should be both readable and writable."
msgstr ""
"I<stackaddr> は、呼び出し側で割り当てた、大きさが I<stacksize> バイトの\n"
"バッファー内の指定できる最小のアドレスバイトを指すべきである。\n"
"割り当てられたバッファーのページは読み書き両方が可能なページとなっている\n"
"べきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:85
msgid ""
"The B<pthread_attr_getstack>()  function returns the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> in "
"the buffers pointed to by I<stackaddr> and I<stacksize>, respectively."
msgstr ""
"B<pthread_attr_getstack>() 関数は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性と\n"
"スタックサイズ属性をそれぞれ I<stackaddr> と I<stacksize> が\n"
"指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:91
msgid "B<pthread_attr_setstack>()  can fail with the following error:"
msgstr "B<pthread_attr_setstack>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:102
msgid ""
"I<stacksize> is less than B<PTHREAD_STACK_MIN> (16384) bytes.  On some "
"systems, this error may also occur if I<stackaddr> or I<stackaddr\\ +\\ "
"stacksize> is not suitably aligned."
msgstr ""
"I<stacksize> が B<PTHREAD_STACK_MIN> (16384) よりも小さい。\n"
"システムによっては、 I<stackaddr> か\n"
"I<stackaddr\\ +\\ stacksize> のアライメントが適切でない場合にも\n"
"このエラーが発生する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:110
msgid ""
"POSIX.1 also documents an B<EACCES> error if the stack area described by "
"I<stackaddr> and I<stacksize> is not both readable and writable by the "
"caller."
msgstr "POSIX.1 では エラー B<EACCES> も規定されており、このエラーは I<stackaddr> と I<stacksize> で規定されるスタック領域に呼び出し側から読み書き両方のアクセスができない状況を表す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:112
msgid "These functions are provided by glibc since version 2.2."
msgstr "これらの関数は glibc バージョン 2.2 以降で提供されている。"

#. type: tbl table
#: build/C/man3/pthread_attr_setstack.3:123
#, no-wrap
msgid ""
"B<pthread_attr_setstack>(),\n"
"B<pthread_attr_getstack>()"
msgstr ""
"B<pthread_attr_setstack>(),\n"
"B<pthread_attr_getstack>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:135
msgid ""
"These functions are provided for applications that must ensure that a "
"thread's stack is placed in a particular location.  For most applications, "
"this is not necessary, and the use of these functions should be avoided.  "
"(Use B<pthread_attr_setstacksize>(3)  if an application simply requires a "
"stack size other than the default.)"
msgstr ""
"これらの関数は、スレッドのスタックが特定の場所に配置されることを保証\n"
"しなければならないアプリケーションのために提供されている。\n"
"ほとんどのアプリケーションでは、このようなことは必要なく、\n"
"これらの関数を使うのは避けるべきである。\n"
"(アプリケーションが単にスタックサイズだけをデフォルトの値から変更する\n"
"必要がある場合には B<pthread_attr_setstacksize>(3) を使うこと)"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:146
msgid ""
"When an application employs B<pthread_attr_setstack>(), it takes over the "
"responsibility of allocating the stack.  Any guard size value that was set "
"using B<pthread_attr_setguardsize>(3)  is ignored.  If deemed necessary, it "
"is the application's responsibility to allocate a guard area (one or more "
"pages protected against reading and writing)  to handle the possibility of "
"stack overflow."
msgstr ""
"アプリケーションが B<pthread_attr_setstack>() を利用する際には、\n"
"スタックの割り当てに責任を持つ必要がある。\n"
"B<pthread_attr_setguardsize>(3) を使って設定された\n"
"guard size の値は無視される。\n"
"必要と思われる場合は、アプリケーションが責任を持ってガード領域 (読み書\n"
"きが行われないように保護された 1 個かそれ以上のページ) の割り当てを行い、\n"
"スタックオーバーフローの可能性に対処するようにする必要がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:157
msgid ""
"The address specified in I<stackaddr> should be suitably aligned: for full "
"portability, align it on a page boundary (I<sysconf(_SC_PAGESIZE)>).  "
"B<posix_memalign>(3)  may be useful for allocation.  Probably, I<stacksize> "
"should also be a multiple of the system page size."
msgstr ""
"I<stackaddr> に指定するアドレスは適切なアライメントとなっているべきである。\n"
"完全な移植性を持たせるためには、\n"
"ページ境界 (I<sysconf(_SC_PAGESIZE)>) に揃えること。\n"
"割り当てには B<posix_memalign>(3) を使うとよい。\n"
"たいていは、 I<stacksize> はシステムのページサイズの倍数とすべきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:165
msgid ""
"If I<attr> is used to create multiple threads, then the caller must change "
"the stack address attribute between calls to B<pthread_create>(3); "
"otherwise, the threads will attempt to use the same memory area for their "
"stacks, and chaos will ensue."
msgstr ""
"一つの I<attr> を使って複数のスレッドを作成する場合、\n"
"B<pthread_create>(3) の次の呼び出しを行う前に、\n"
"呼び出し側でスタックアドレス属性を変更しなければならない。\n"
"さもなければ、複数のスレッドがスタックとして同じメモリー領域を\n"
"使おうとするため、訳の分からない状況が発生してしまう。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:180
msgid ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setstackaddr.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKADDR"
msgstr "PTHREAD_ATTR_SETSTACKADDR"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:30
msgid ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - \n"
"スレッド属性オブジェクトのスタックアドレス属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              void **>I<stackaddr>B<);>\n"
msgstr ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              void **>I<stackaddr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:49
msgid ""
"These functions are obsolete: B<do not use them.> Use "
"B<pthread_attr_setstack>(3)  and B<pthread_attr_getstack>(3)  instead."
msgstr ""
"これらの関数は廃止予定であり、B<使用しないこと>。\n"
"代わりに B<pthread_attr_setstack>(3) と B<pthread_attr_getstack>(3) を使うこ"
"と。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:60
msgid ""
"The B<pthread_attr_setstackaddr>()  function sets the stack address "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<stackaddr>.  This attribute specifies the location of "
"the stack that should be used by a thread that is created using the thread "
"attributes object I<attr>."
msgstr ""
"B<pthread_attr_setstackaddr>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスタックアドレス\n"
"属性を I<stackaddr> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが使用すべきスタックの位置が指定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:66
msgid ""
"I<stackaddr> should point to a buffer of at least B<PTHREAD_STACK_MIN> bytes "
"that was allocated by the caller.  The pages of the allocated buffer should "
"be both readable and writable."
msgstr ""
"I<stackaddr> は呼び出し側が割り当てたバッファー (大きさは\n"
"少なくとも B<PTHREAD_STACK_MIN> バイト)を指すべきである。\n"
"割り当てられたバッファーのページは読み書き両方が可能なページと\n"
"なっているべきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:74
msgid ""
"The B<pthread_attr_getstackaddr>()  function returns the stack address "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stackaddr>."
msgstr ""
"B<pthread_attr_getstackaddr>() は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性を\n"
"I<stackaddr> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:81
msgid ""
"No errors are defined (but applications should nevertheless handle a "
"possible error return)."
msgstr ""
"エラーは定義されていない (ただし、アプリケーションは正のエラーの\n"
"返り値を処理するようにすべきである)。"

#. type: tbl table
#: build/C/man3/pthread_attr_setstackaddr.3:94
#, no-wrap
msgid ""
"B<pthread_attr_setstackaddr>(),\n"
"B<pthread_attr_getstackaddr>()"
msgstr ""
"B<pthread_attr_setstackaddr>(),\n"
"B<pthread_attr_getstackaddr>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:99
msgid ""
"POSIX.1-2001 specifies these functions but marks them as obsolete.  "
"POSIX.1-2008 removes the specification of these functions."
msgstr ""
"POSIX.1-2001 では、これらの関数が規定されているが、廃止予定となっている。\n"
"POSIX.1-2008 では、これらの関数の規定は削除されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:123
msgid ""
"I<Do not use these functions!> They cannot be portably used, since they "
"provide no way of specifying the direction of growth or the range of the "
"stack.  For example, on architectures with a stack that grows downward, "
"I<stackaddr> specifies the next address past the I<highest> address of the "
"allocated stack area.  However, on architectures with a stack that grows "
"upward, I<stackaddr> specifies the I<lowest> address in the allocated stack "
"area.  By contrast, the I<stackaddr> used by B<pthread_attr_setstack>(3)  "
"and B<pthread_attr_getstack>(3), is always a pointer to the lowest address "
"in the allocated stack area (and the I<stacksize> argument specifies the "
"range of the stack)."
msgstr ""
"I<これらの関数を使用しないこと!> これらの関数は移植性がある形では使用で\n"
"きない。なぜなら、これらの関数ではスタック領域がどちらの方向に伸びるの\n"
"かを指定する手段が提供されていないからである。\n"
"例えば、スタックが下向き (アドレスが小さい方向) に伸びるアーキテクチャー\n"
"では、I<stackaddr> には割り当てられたスタック領域のI<最も大きな>アドレ\n"
"スの次のアドレスを指定する。一方、スタックが上向き (アドレスが大きい\n"
"方向) に伸びるアーキテクチャーでは、I<stackaddr> には割り当てられた\n"
"スタック領域のI<最も小さい>アドレスを指定する。これに対して、\n"
"B<pthread_attr_setstack>(3) と B<pthread_attr_getstack>(3) が使用する\n"
"I<stackaddr> は、常に割り当てられたスタック領域の最も小さいアドレス\n"
"へのポインターである (I<stacksize> 引き数はスタックの範囲を指定する)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:129
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setstacksize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKSIZE"
msgstr "PTHREAD_ATTR_SETSTACKSIZE"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:30
msgid ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - \n"
"スレッド属性オブジェクトのスタックサイズ属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              size_t *>I<stacksize>B<);>\n"
msgstr ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              size_t *>I<stacksize>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:49
msgid ""
"The B<pthread_attr_setstacksize>()  function sets the stack size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<stacksize>."
msgstr ""
"B<pthread_attr_setstacksize>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスタックアドレス\n"
"属性を I<stacksize> で指定された値に設定する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:53
msgid ""
"The stack size attribute determines the minimum size (in bytes) that will be "
"allocated for threads created using the thread attributes object I<attr>."
msgstr ""
"スタックサイズ属性により、\n"
"スレッド属性オブジェクト I<attr> を使って作成されたスレッド\n"
"に割り当てられる最小サイズ (バイト単位) が決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:61
msgid ""
"The B<pthread_attr_getstacksize>()  function returns the stack size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stacksize>."
msgstr ""
"B<pthread_attr_getstacksize>() は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性を\n"
"I<stacksize> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:67
msgid "B<pthread_attr_setstacksize>()  can fail with the following error:"
msgstr "B<pthread_attr_setstacksize>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:72
msgid "The stack size is less than B<PTHREAD_STACK_MIN> (16384) bytes."
msgstr "スタックサイズが B<PTHREAD_STACK_MIN> (16384) バイト未満である。"

#.  e.g., MacOS
#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:81
msgid ""
"On some systems, B<pthread_attr_setstacksize>()  can fail with the error "
"B<EINVAL> if I<stacksize> is not a multiple of the system page size."
msgstr ""
"いくつかのシステムでは、 B<pthread_attr_setstacksize>() は\n"
"I<stacksize> がシステムのページサイズの倍数でない場合にも\n"
"エラー B<EINVAL> で失敗する。"

#. type: tbl table
#: build/C/man3/pthread_attr_setstacksize.3:94
#, no-wrap
msgid ""
"B<pthread_attr_setstacksize>(),\n"
"B<pthread_attr_getstacksize>()"
msgstr ""
"B<pthread_attr_setstacksize>(),\n"
"B<pthread_attr_getstacksize>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:101
msgid ""
"For details on the default stack size of new threads, see "
"B<pthread_create>(3)."
msgstr ""
"新しいスレッドのデフォルトのスタックサイズの詳細については\n"
"B<pthread_create>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:104
msgid ""
"A thread's stack size is fixed at the time of thread creation.  Only the "
"main thread can dynamically grow its stack."
msgstr ""
"スレッドのスタックサイズは、スレッド作成時点では固定である。\n"
"メインスレッドだけがスタックを動的に伸ばすことができる。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:109
msgid ""
"The B<pthread_attr_setstack>(3)  function allows an application to set both "
"the size and location of a caller-allocated stack that is to be used by a "
"thread."
msgstr ""
"B<pthread_attr_setstack>(3) 関数を使うと、\n"
"アプリケーションは、スレッドが使用するスタックとして、\n"
"呼び出し側で割り当てたスタックのサイズと場所を指定できる。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:121
msgid ""
"As at glibc 2.8, if the specified I<stacksize> is not a multiple of "
"B<STACK_ALIGN> (16 bytes on most architectures), it may be rounded "
"I<downward>, in violation of POSIX.1, which says that the allocated stack "
"will be at least I<stacksize> bytes."
msgstr "glibc 2.8 の時点では、指定された I<stacksize> が B<STACK_ALIGN> (ほとんどのアーキテクチャーでは 16 バイト) の倍数でない場合、 I<stacksize> はI<小さくなる方向に>に丸められる。これは POSIX.1 に違反している。 POSIX.1 では、割り当てらたスタックの大きさは少なくとも I<stacksize> バイトになると書かれている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:124 build/C/man3/pthread_join.3:143
msgid "See B<pthread_create>(3)."
msgstr "B<pthread_create>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:131
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_cancel.3:26
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr "PTHREAD_CANCEL"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:29
msgid "pthread_cancel - send a cancellation request to a thread"
msgstr "pthread_cancel - スレッドにキャンセル要求を送る"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:34
#, no-wrap
msgid "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"
msgstr "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:49
msgid ""
"The B<pthread_cancel>()  function sends a cancellation request to the thread "
"I<thread>.  Whether and when the target thread reacts to the cancellation "
"request depends on two attributes that are under the control of that thread: "
"its cancelability I<state> and I<type>."
msgstr ""
"B<pthread_cancel>() 関数は指定されたスレッド I<thread> にキャンセル要求\n"
"を送信する。対象のスレッドがキャンセル要求に反応するかどうか、いつ反応\n"
"するかは対象のスレッドの制御下にある 2 つの属性、cancelability\n"
"I<state> と I<type>により決まる。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:61
msgid ""
"A thread's cancelability state, determined by B<pthread_setcancelstate>(3), "
"can be I<enabled> (the default for new threads) or I<disabled>.  If a thread "
"has disabled cancellation, then a cancellation request remains queued until "
"the thread enables cancellation.  If a thread has enabled cancellation, then "
"its cancelability type determines when cancellation occurs."
msgstr ""
"あるスレッドの cancelability state は B<pthread_setcancelstate>(3) で\n"
"設定され、I<enabled> と I<disabled> のいずれとなる (I<enabled> が新しい\n"
"スレッドのデフォルト値である)。スレッドがキャンセルを無効にしていた場合、\n"
"キャンセル要求はそのスレッドがキャンセルを有効にするまでキューに入れら\n"
"れたままになる。スレッドがキャンセルを有効にしていた場合、\n"
"cancelability type によって、いつキャンセルが発生するかが決まる。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:77
msgid ""
"A thread's cancellation type, determined by B<pthread_setcanceltype>(3), may "
"be either I<asynchronous> or I<deferred> (the default for new threads).  "
"Asynchronous cancelability means that the thread can be canceled at any time "
"(usually immediately, but the system does not guarantee this).  Deferred "
"cancelability means that cancellation will be delayed until the thread next "
"calls a function that is a I<cancellation point>.  A list of functions that "
"are or may be cancellation points is provided in B<pthreads>(7)."
msgstr ""
"スレッドのキャンセル種別 (cancelability type) は\n"
"B<pthread_setcanceltype>(3) で設定され、I<asynchronous> か I<deferred>\n"
"のいずれかとなる(I<deferred> が新しいスレッドのデフォルト値である)。\n"
"非同期キャンセル (asynchronous cancelability) は、そのスレッドはいつで\n"
"もキャンセルされることを意味する (通常はすぐにキャンセルされるが、\n"
"システムがそのことを保証しているわけではない)。遅延キャンセル\n"
"(deferred cancelability) では、そのスレッドが I<取り消しポイント\n"
"(cancellation point)> となっている関数を次に呼び出すまでキャンセルが\n"
"遅延される。取り消しポイントに設定されていたり設定\n"
"したりできる関数のリストは B<pthreads>(7) に記載している。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:81
msgid ""
"When a cancellation requested is acted on, the following steps occur for "
"I<thread> (in this order):"
msgstr ""
"キャンセル要求が実行されると、\n"
"I<thread> では以下のステップが (この順序で) 行われる。"

#. type: IP
#: build/C/man3/pthread_cancel.3:81 build/C/man3/pthread_cleanup_push.3:69
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man3/pthread_cancel.3:86
msgid ""
"Cancellation clean-up handlers are popped (in the reverse of the order in "
"which they were pushed) and called.  (See B<pthread_cleanup_push>(3).)"
msgstr ""
"キャンセルクリーンアップハンドラーが (push されたのと逆順で)\n"
"取り出され (pop され)、呼び出される。\n"
"(B<pthread_cleanup_push>(3) 参照)"

#. type: IP
#: build/C/man3/pthread_cancel.3:86 build/C/man3/pthread_cleanup_push.3:73
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man3/pthread_cancel.3:91
msgid ""
"Thread-specific data destructors are called, in an unspecified order.  (See "
"B<pthread_key_create>(3).)"
msgstr ""
"スレッド固有データのデストラクタ (destructor) が呼び出される。\n"
"呼び出し順序は規定されていない。\n"
"(B<pthread_key_create>(3) 参照)"

#. type: IP
#: build/C/man3/pthread_cancel.3:91 build/C/man3/pthread_cleanup_push.3:83
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man3/pthread_cancel.3:95
msgid "The thread is terminated.  (See B<pthread_exit>(3).)"
msgstr "スレッドが終了される。 (B<pthread_exit>(3) 参照)"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:103
msgid ""
"The above steps happen asynchronously with respect to the "
"B<pthread_cancel>()  call; the return status of B<pthread_cancel>()  merely "
"informs the caller whether the cancellation request was successfully queued."
msgstr ""
"上記のステップは B<pthread_cancel>() の呼び出しとは非同期に行われる。\n"
"B<pthread_cancel>() の返却ステータスは単にキャンセル要求が正常に\n"
"キューに入れられたかどうかを呼び出し元に示すだけのものである。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:112
msgid ""
"After a canceled thread has terminated, a join with that thread using "
"B<pthread_join>(3)  obtains B<PTHREAD_CANCELED> as the thread's exit "
"status.  (Joining with a thread is the only way to know that cancellation "
"has completed.)"
msgstr ""
"キャンセルされたスレッドが終了された後に、\n"
"B<pthread_join>(3) でそのスレッドを join すると、\n"
"そのスレッドの終了ステータスとして B<PTHREAD_CANCELED> が得られる。\n"
"(スレッドの join はキャンセルが完了したかを知る唯一の方法である)"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:117
msgid ""
"On success, B<pthread_cancel>()  returns 0; on error, it returns a nonzero "
"error number."
msgstr ""
"成功すると、 B<pthread_cancel>() は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。"

#. type: TP
#: build/C/man3/pthread_cancel.3:118 build/C/man3/pthread_detach.3:59
#: build/C/man3/pthread_getcpuclockid.3:61 build/C/man3/pthread_join.3:93
#: build/C/man3/pthread_setaffinity_np.3:110
#: build/C/man3/pthread_setschedparam.3:114
#: build/C/man3/pthread_setschedprio.3:70 build/C/man3/pthread_sigqueue.3:86
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:125 build/C/man3/pthread_detach.3:64
#: build/C/man3/pthread_getcpuclockid.3:66 build/C/man3/pthread_join.3:98
#: build/C/man3/pthread_setaffinity_np.3:115
#: build/C/man3/pthread_setschedparam.3:119
#: build/C/man3/pthread_setschedprio.3:75
msgid "No thread with the ID I<thread> could be found."
msgstr "ID が I<thread> のスレッドが見つからなかった。"

#. type: tbl table
#: build/C/man3/pthread_cancel.3:135
#, no-wrap
msgid "B<pthread_cancel>()"
msgstr "B<pthread_cancel>()"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:148
msgid ""
"On Linux, cancellation is implemented using signals.  Under the NPTL "
"threading implementation, the first real-time signal (i.e., signal 32) is "
"used for this purpose.  On LinuxThreads, the second real-time signal is "
"used, if real-time signals are available, otherwise B<SIGUSR2> is used."
msgstr ""
"Linux では、キャンセルはシグナルを使って実装されている。NPTL スレッド実装で"
"は、\n"
"最初のリアルタイムシグナル (つまり、シグナル 32)がこのために使用される。\n"
"LinuxThreads では、リアルタイムシグナルが利用可能な場合は2 番目のリアルタイ"
"ム\n"
"シグナルが使用され、そうでない場合は B<SIGUSR2> が使用される。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:154
msgid ""
"The program below creates a thread and then cancels it.  The main thread "
"joins with the canceled thread to check that its exit status was "
"B<PTHREAD_CANCELED>.  The following shell session shows what happens when we "
"run the program:"
msgstr ""
"以下のプログラムは、スレッドを一つ作成してから、そのスレッドをキャンセルす"
"る。\n"
"メインスレッドはキャンセルされたスレッドをジョインし、\n"
"キャンセルされたスレッドの終了ステータスが B<PTHREAD_CANCELED> かどうかを\n"
"確認する。以下のシェルセッションはこのプログラムを実行した際の実行例である。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:162
#, no-wrap
msgid ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"
msgstr ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:172
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:180
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"
msgstr ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:183
#, no-wrap
msgid ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"
msgstr ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:187
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:191
#, no-wrap
msgid ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"
msgstr ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:195
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:197
#, no-wrap
msgid "    /* sleep() is a cancellation point */\n"
msgstr "    /* sleep() is a cancellation point */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:199
#, no-wrap
msgid "    sleep(1000);        /* Should get canceled while we sleep */\n"
msgstr "    sleep(1000);        /* Should get canceled while we sleep */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:201
#, no-wrap
msgid "    /* Should never get here */\n"
msgstr "    /* Should never get here */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:205
#, no-wrap
msgid ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:212
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:214
#, no-wrap
msgid "    /* Start a thread and then send it a cancellation request */\n"
msgstr "    /* Start a thread and then send it a cancellation request */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:218
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:220
#, no-wrap
msgid "    sleep(2);           /* Give thread a chance to get started */\n"
msgstr "    sleep(2);           /* Give thread a chance to get started */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:225
#, no-wrap
msgid ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"
msgstr ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:227
#, no-wrap
msgid "    /* Join with thread to see what its exit status was */\n"
msgstr "    /* Join with thread to see what its exit status was */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:231 build/C/man3/pthread_cleanup_push.3:321
#, no-wrap
msgid ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:238
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:251
msgid ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_cleanup_push.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH"
msgstr "PTHREAD_CLEANUP_PUSH"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:30
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation "
"clean-up handlers"
msgstr ""
"pthread_cleanup_push, pthread_cleanup_pop - スレッドの\n"
"キャンセルクリーンアップハンドラーの push/pop を行う"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"
msgstr ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:48
msgid ""
"These functions manipulate the calling thread's stack of thread-cancellation "
"clean-up handlers.  A clean-up handler is a function that is automatically "
"executed when a thread is canceled (or in various other circumstances "
"described below); it might, for example, unlock a mutex so that it becomes "
"available to other threads in the process."
msgstr ""
"これらの関数は、呼び出したスレッドのスレッドキャンセル時のクリーンアッ\n"
"プハンドラーのスタックの操作を行う。クリーンアップハンドラーは、スレッドが\n"
"キャンセルされた場合 (や以下で説明する他の種々の状況において) 自動的に\n"
"実行される関数である。例えば、mutex のロック解除を行い、プロセス内の\n"
"他のスレッドが利用できるようにする関数などが考えられる。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:59
msgid ""
"The B<pthread_cleanup_push>()  function pushes I<routine> onto the top of "
"the stack of clean-up handlers.  When I<routine> is later invoked, it will "
"be given I<arg> as its argument."
msgstr ""
"B<pthread_cleanup_push>() 関数は、 I<routine> をクリーンアップ\n"
"ハンドラーのスタックの一番上にプッシュする。 I<routine> が後で\n"
"起動される際には、 I<arg> が関数の引き数と渡される。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:66
msgid ""
"The B<pthread_cleanup_pop>()  function removes the routine at the top of the "
"stack of clean-up handlers, and optionally executes it if I<execute> is "
"nonzero."
msgstr ""
"B<pthread_cleanup_pop>() 関数は、クリーンアップハンドラーの\n"
"スタックの一番上のルーチンを削除する。\n"
"I<execute> が 0 以外の場合にはそのルーチンを追加で実行する。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:69
msgid ""
"A cancellation clean-up handler is popped from the stack and executed in the "
"following circumstances:"
msgstr ""
"キャンセルクリーンアップハンドラーは、以下に示す場合に\n"
"スタックから取り出され実行される。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:73
msgid ""
"When a thread is canceled, all of the stacked clean-up handlers are popped "
"and executed in the reverse of the order in which they were pushed onto the "
"stack."
msgstr ""
"スレッドがキャンセルされた際に、スタックに登録された全てのクリーン\n"
"アップハンドラーが取り出されて、実行される。クリーンアップハンドラーの\n"
"実行は、スタックに登録されたのと逆の順序で行われる。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:83
msgid ""
"When a thread terminates by calling B<pthread_exit>(3), all clean-up "
"handlers are executed as described in the preceding point.  (Clean-up "
"handlers are I<not> called if the thread terminates by performing a "
"I<return> from the thread start function.)"
msgstr ""
"スレッドが B<pthread_exit>(3) を呼び出して終了する際に、全てのクリーン\n"
"アップハンドラーが上の項目で述べたのと同様に実行される。\n"
"(スレッドがスレッド開始関数からの I<return> の実行により終了する場合に\n"
"は、クリーンアップハンドラーはI<呼び出されない>。)"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:89
msgid ""
"When a thread calls B<pthread_cleanup_pop>()  with a nonzero I<execute> "
"argument, the top-most clean-up handler is popped and executed."
msgstr ""
"スレッドが 0 以外の I<execute> 引き数で B<pthread_cleanup_pop>() を\n"
"呼び出した際に、スタックの一番上のクリーンアップハンドラーが取り出されて\n"
"実行される。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:101
msgid ""
"POSIX.1 permits B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  to "
"be implemented as macros that expand to text containing \\(aqB<{>\\(aq and "
"\\(aqB<}>\\(aq, respectively.  For this reason, the caller must ensure that "
"calls to these functions are paired within the same function, and at the "
"same lexical nesting level.  (In other words, a clean-up handler is "
"established only during the execution of a specified section of code.)"
msgstr ""
"POSIX.1 では、 B<pthread_cleanup_push>() と B<pthread_cleanup_pop>() を\n"
"それぞれ \\(aqB<{>\\(aq と \\(aqB<}>\\(aq を含むテキストに展開するマクロと\n"
"して実装することを許容している。\n"
"このため、呼び出し側では、これらの関数の呼び出しが同じ関数の中で対と\n"
"なり、かつ文法的に同じネストレベル (nesting level) になることを保証\n"
"しなければならない。 (言い換えると、クリーンアップハンドラーは、コード\n"
"の特定のセクションの実行の中でのみ設定するものであると言える。)"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:121
msgid ""
"Calling B<longjmp>(3)  (B<siglongjmp>(3))  produces undefined results if any "
"call has been made to B<pthread_cleanup_push>()  or "
"B<pthread_cleanup_pop>()  without the matching call of the pair since the "
"jump buffer was filled by B<setjmp>(3)  (B<sigsetjmp>(3)).  Likewise, "
"calling B<longjmp>(3)  (B<siglongjmp>(3))  from inside a clean-up handler "
"produces undefined results unless the jump buffer was also filled by "
"B<setjmp>(3)  (B<sigsetjmp>(3))  inside the handler."
msgstr ""
"B<longjmp>(3) (B<siglongjmp>(3)) の呼び出しは、\n"
"B<pthread_cleanup_push>() や B<pthread_cleanup_pop>() の呼び出しが対と\n"
"なる呼び出しがない状態で行われた場合には、どのような結果になるかは不定\n"
"である。これは jump バッファーは B<setjmp>(3) (B<sigsetjmp>(3)) により設\n"
"定されるからである。同様に、クリーンアップハンドラー内からの\n"
"B<longjmp>(3) (B<siglongjmp>(3)) の呼び出しも、jump バッファーがハンドラー\n"
"内で B<setjmp>(3) (B<sigsetjmp>(3)) で設定されていない限り、どのような\n"
"結果になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:123
msgid "These functions do not return a value."
msgstr "これらの関数は値を返さない。"

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:127
msgid "There are no errors."
msgstr "エラーはない。"

#. type: tbl table
#: build/C/man3/pthread_cleanup_push.3:138
#, no-wrap
msgid ""
"B<pthread_cleanup_push>(),\n"
"B<pthread_cleanup_pop>()"
msgstr ""
"B<pthread_cleanup_push>(),\n"
"B<pthread_cleanup_pop>()"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:154
msgid ""
"On Linux, the B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  "
"functions I<are> implemented as macros that expand to text containing "
"\\(aqB<{>\\(aq and \\(aqB<}>\\(aq, respectively.  This means that variables "
"declared within the scope of paired calls to these functions will be visible "
"within only that scope."
msgstr ""
"Linux では、関数 B<pthread_cleanup_push>() と B<pthread_cleanup_pop>()\n"
"は、それぞれ \\(aqB<{>\\(aq と \\(aqB<}>\\(aq を含むテキストに展開する\n"
"マクロとして実装されている。このことは、これらの関数を対で呼び出した\n"
"スコープ内で宣言された変数は、そのスコープの中でしか参照できない\n"
"ということを意味している。"

#.  The text was actually added in the 2004 TC2
#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:169
msgid ""
"POSIX.1 says that the effect of using I<return>, I<break>, I<continue>, or "
"I<goto> to prematurely leave a block bracketed B<pthread_cleanup_push>()  "
"and B<pthread_cleanup_pop>()  is undefined.  Portable applications should "
"avoid doing this."
msgstr ""
"POSIX.1 には、括弧を含む B<pthread_cleanup_push>() と\n"
"B<pthread_cleanup_pop>() のブロックをそのままにしたままで、 \n"
"I<return>, I<break>, I<continue>, I<goto> を使った場合の影響は\n"
"不定であると書かれている。\n"
"移植性が必要なアプリケーションではこれを行うのは避けるべきである。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:184
msgid ""
"The program below provides a simple example of the use of the functions "
"described in this page.  The program creates a thread that executes a loop "
"bracketed by B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>().  This "
"loop increments a global variable, I<cnt>, once each second.  Depending on "
"what command-line arguments are supplied, the main thread sends the other "
"thread a cancellation request, or sets a global variable that causes the "
"other thread to exit its loop and terminate normally (by doing a I<return>)."
msgstr ""
"以下のプログラムは、このページで説明した関数の簡単な使用例を示すもので\n"
"ある。このプログラムは B<pthread_cleanup_push>() と\n"
"B<pthread_cleanup_pop>() で囲まれたループを実行するスレッドを作成する。\n"
"このループではグローバル変数 I<cnt> を 1 秒に 1 ずつ増やしていく。\n"
"指定されたコマンドライン引き数の内容に基づいて、メインスレッドはもう一\n"
"つのスレッドにキャンセル要求を送ったり、もう一つのスレッドがループを\n"
"抜けて (I<return> を呼び出して) 正常終了するようにグローバル変数を\n"
"設定したりする。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:187
msgid ""
"In the following shell session, the main thread sends a cancellation request "
"to the other thread:"
msgstr ""
"以下のシェルセッションでは、メインスレッドはもう一つのスレッドに\n"
"キャンセル要求を送信する。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:197
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"
msgstr ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:205
msgid ""
"From the above, we see that the thread was canceled, and that the "
"cancellation clean-up handler was called and it reset the value of the "
"global variable I<cnt> to 0."
msgstr ""
"上記の実行例から、スレッドがキャンセルされ、\n"
"キャンセルクリーンアップハンドラーが呼び出され、\n"
"グローバル変数 I<cnt> の値が 0 にリセットされていることが確認できる。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:208
msgid ""
"In the next run, the main program sets a global variable that causes other "
"thread to terminate normally:"
msgstr ""
"次の実行例では、メインプログラムはグローバル変数を設定して、\n"
"もう一つのスレッドが正常終了するようにしている。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:216
#, no-wrap
msgid ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"
msgstr ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:224
msgid ""
"From the above, we see that the clean-up handler was not executed (because "
"I<cleanup_pop_arg> was 0), and therefore the value of I<cnt> was not reset."
msgstr ""
"上記では、 (I<cleanup_pop_arg> が 0 なので) クリーンアップハンドラーは\n"
"実行されておらず、その結果 I<cnt> の値はリセットされていないことが\n"
"分かる。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:229
msgid ""
"In the next run, the main program sets a global variable that causes the "
"other thread to terminate normally, and supplies a nonzero value for "
"I<cleanup_pop_arg>:"
msgstr ""
"次の実行例では、メインプログラムはグローバル変数を設定して、\n"
"もう一つのスレッドが正常終了するようにし、さらに\n"
"I<cleanup_pop_arg> に 0 以外の値を渡している。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:238
#, no-wrap
msgid ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"
msgstr ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:245
msgid ""
"In the above, we see that although the thread was not canceled, the clean-up "
"handler was executed, because the argument given to "
"B<pthread_cleanup_pop>()  was nonzero."
msgstr "上記では、スレッドはキャンセルされていないが、クリーンアップハンドラーが実行されたことが分かる。これは B<pthread_cleanup_pop>() の引き数に 0 以外を渡したからである。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:254
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:261
#, no-wrap
msgid ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"
msgstr ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:268
#, no-wrap
msgid ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"
msgstr ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:273
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:275
#, no-wrap
msgid "    printf(\"New thread started\\en\");\n"
msgstr "    printf(\"New thread started\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:277
#, no-wrap
msgid "    pthread_cleanup_push(cleanup_handler, NULL);\n"
msgstr "    pthread_cleanup_push(cleanup_handler, NULL);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:279
#, no-wrap
msgid "    curr = start = time(NULL);\n"
msgstr "    curr = start = time(NULL);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:288
#, no-wrap
msgid ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:292
#, no-wrap
msgid ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:299
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:303
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:305
#, no-wrap
msgid "    sleep(2);           /* Allow new thread to run a while */\n"
msgstr "    sleep(2);           /* Allow new thread to run a while */\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:310
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:317
#, no-wrap
msgid ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"
msgstr ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:328
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:335
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_cleanup_push_defer_np.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH_DEFER_NP"
msgstr "PTHREAD_CLEANUP_PUSH_DEFER_NP"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:30
msgid ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - push and pop "
"thread cancellation clean-up handlers while saving cancelability type"
msgstr ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - "
"cancelability type を保持したままでスレッドのキャンセルクリーンアップハンド"
"ラーの push/pop を行う"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"
msgstr ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:40
#: build/C/man3/pthread_create.3:38 build/C/man3/pthread_detach.3:37
#: build/C/man3/pthread_join.3:37 build/C/man3/pthread_kill.3:37
#: build/C/man3/pthread_setname_np.3:39 build/C/man3/pthread_sigmask.3:38
#: build/C/man3/pthread_sigqueue.3:38 build/C/man3/pthread_tryjoin_np.3:42
#: build/C/man3/pthread_yield.3:37 build/C/man3/pthread_mutex_consistent.3:37
#: build/C/man3/pthread_mutexattr_getpshared.3:40
#: build/C/man3/pthread_mutexattr_init.3:38
#: build/C/man3/pthread_mutexattr_setrobust.3:41
#: build/C/man3/pthread_spin_init.3:37 build/C/man3/pthread_spin_lock.3:39
msgid "Compile and link with I<-pthread>."
msgstr "I<-pthread> を付けてコンパイルとリンクを行う。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:49
msgid "B<pthread_cleanup_push_defer_np>(), B<pthread_cleanup_pop_defer_np>():"
msgstr "B<pthread_cleanup_push_defer_np>(), B<pthread_cleanup_pop_defer_np>():"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:51
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:59
msgid ""
"These functions are the same as B<pthread_cleanup_push>(3)  and "
"B<pthread_cleanup_pop>(3), except for the differences noted on this page."
msgstr ""
"これらの関数は B<pthread_cleanup_push>(3) と B<pthread_cleanup_pop>(3) と同じ"
"だが、このページで説明する点が異なる。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:72
msgid ""
"Like B<pthread_cleanup_push>(3), B<pthread_cleanup_push_defer_np>()  pushes "
"I<routine> onto the thread's stack of cancellation clean-up handlers.  In "
"addition, it also saves the thread's current cancelability type, and sets "
"the cancelability type to \"deferred\" (see B<pthread_setcanceltype>(3)); "
"this ensures that cancellation clean-up will occur even if the thread's "
"cancelability type was \"asynchronous\" before the call."
msgstr ""
"B<pthread_cleanup_push>(3) と同様に、\n"
"B<pthread_cleanup_push_defer_np>() は I<routine> をそのスレッドの\n"
"クリーンアップハンドラーのスタックに追加する。これに加えて、\n"
"B<pthread_cleanup_push_defer_np>() は現在の cancelability type も\n"
"保存し、cancelability type は \"deferred\" に設定する\n"
"(B<pthread_setcanceltype>(3) 参照)。\n"
"これにより、この関数が呼び出される前のスレッドの cancelability type が\n"
"\"asynchronous\" であったとしても、キャンセルクリーンアップが行われること\n"
"が保証される。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:81
msgid ""
"Like B<pthread_cleanup_pop>(3), B<pthread_cleanup_pop_restore_np>()  pops "
"the top-most clean-up handler from the thread's stack of cancellation clean-"
"up handlers.  In addition, it restores the thread's cancelability type to "
"its value at the time of the matching B<pthread_cleanup_push_defer_np>()."
msgstr ""
"B<pthread_cleanup_pop>(3) と同様に、\n"
"B<pthread_cleanup_pop_restore_np>() はそのスレッドのキャンセル\n"
"クリーンアップハンドラーのスタックから一番上にあるクリーンアップハンドラー\n"
"を取り出す。これに加えて、そのスレッドの cancelability type を、対応\n"
"する B<pthread_cleanup_push_defer_np>() が呼ばれた時点の値に戻す。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:87
msgid ""
"The caller must ensure that calls to these functions are paired within the "
"same function, and at the same lexical nesting level.  Other restrictions "
"apply, as described in B<pthread_cleanup_push>(3)."
msgstr ""
"呼び出し側では、これらの関数の呼び出しが同じ関数の中で対となり、かつ\n"
"文法的に同じネストレベル (nesting level) になることを保証しなければ\n"
"ならない。 B<pthread_cleanup_push>(3) で説明されている他の制限も\n"
"適用される。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:89
msgid "This sequence of calls:"
msgstr "以下の一連の呼び出し"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:94
#, no-wrap
msgid ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"
msgstr ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:98
msgid "is equivalent to (but shorter and more efficient than):"
msgstr "と以下は等価である (但し、上の方がより簡潔で効率的である)。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:104
#, no-wrap
msgid "int oldtype;\n"
msgstr "int oldtype;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:110
#, no-wrap
msgid ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"
msgstr ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:123
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_create.3:26
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr "PTHREAD_CREATE"

#. type: Plain text
#: build/C/man3/pthread_create.3:29
msgid "pthread_create - create a new thread"
msgstr "pthread_create - 新しいスレッドを作成する"

#. type: Plain text
#: build/C/man3/pthread_create.3:35
#, no-wrap
msgid ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"
msgstr ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:47
msgid ""
"The B<pthread_create>()  function starts a new thread in the calling "
"process.  The new thread starts execution by invoking I<start_routine>(); "
"I<arg> is passed as the sole argument of I<start_routine>()."
msgstr ""
"B<pthread_create>() 関数は、呼び出したプロセス内に新しいスレッドを作成す"
"る。\n"
"新しいスレッドの実行は、 I<start_routine>() を起動することで開始される。\n"
"I<start_routine>() は引き数を一つだけ取り、\n"
"I<arg> が I<start_routine>() の引き数として渡される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:49
msgid "The new thread terminates in one of the following ways:"
msgstr "新しく作成されたスレッドは、以下のいずれかで終了する。"

#. type: IP
#: build/C/man3/pthread_create.3:49 build/C/man3/pthread_create.3:55
#: build/C/man3/pthread_create.3:63 build/C/man3/pthread_create.3:66
#: build/C/man3/pthread_getattr_np.3:52 build/C/man3/pthread_getattr_np.3:55
#: build/C/man3/pthread_getattr_np.3:58 build/C/man3/pthread_atfork.3:47
#: build/C/man3/pthread_atfork.3:52 build/C/man3/pthread_atfork.3:57
#: build/C/man3/pthread_getattr_default_np.3:50
#: build/C/man3/pthread_getattr_default_np.3:52
#: build/C/man3/pthread_getattr_default_np.3:56 build/C/man7/nptl.7:49
#: build/C/man7/nptl.7:52 build/C/man7/nptl.7:60 build/C/man7/nptl.7:66
#: build/C/man7/nptl.7:75
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/pthread_create.3:55
msgid ""
"It calls B<pthread_exit>(3), specifying an exit status value that is "
"available to another thread in the same process that calls "
"B<pthread_join>(3)."
msgstr ""
"スレッドが B<pthread_exit>(3) を呼び出す。\n"
"B<pthread_exit>(3) を呼び出す際には終了ステータス値を指定する。\n"
"この値は B<pthread_join>(3) を呼び出した同じプロセス内の\n"
"別のスレッドで参照できる。"

#. type: Plain text
#: build/C/man3/pthread_create.3:63
msgid ""
"It returns from I<start_routine>().  This is equivalent to calling "
"B<pthread_exit>(3)  with the value supplied in the I<return> statement."
msgstr ""
"スレッドが I<start_routine>() から返る。これは、\n"
"I<return> 文に渡した値で B<pthread_exit>(3) を呼び出すのと等価である。"

#. type: Plain text
#: build/C/man3/pthread_create.3:66
msgid "It is canceled (see B<pthread_cancel>(3))."
msgstr "スレッドがキャンセルされる (B<pthread_cancel>(3) 参照)。"

#. type: Plain text
#: build/C/man3/pthread_create.3:72
msgid ""
"Any of the threads in the process calls B<exit>(3), or the main thread "
"performs a return from I<main>().  This causes the termination of all "
"threads in the process."
msgstr ""
"プロセス内のいずれかのスレッドで B<exit>(3) が呼ばれるか、\n"
"メインスレッドで I<main>() 内で return が実行される。\n"
"この場合は、プロセス内の全てのスレッドが終了される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:86
msgid ""
"The I<attr> argument points to a I<pthread_attr_t> structure whose contents "
"are used at thread creation time to determine attributes for the new thread; "
"this structure is initialized using B<pthread_attr_init>(3)  and related "
"functions.  If I<attr> is NULL, then the thread is created with default "
"attributes."
msgstr ""
"I<attr> 引き数は I<pthread_attr_t> 構造体へのポインターであり、\n"
"I<pthread_attr_t> 構造体の内容を使用して、スレッド作成時に\n"
"新しいスレッドの属性が決定される。\n"
"この構造体は B<pthread_attr_init>(3) や関連の関数を使って初期化される。\n"
"I<attr> が NULL の場合、新しいスレッドはデフォルトの属性で作成される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:93
msgid ""
"Before returning, a successful call to B<pthread_create>()  stores the ID of "
"the new thread in the buffer pointed to by I<thread>; this identifier is "
"used to refer to the thread in subsequent calls to other pthreads functions."
msgstr ""
"成功した場合は、 B<pthread_create>() は返る前に新しいスレッドの ID を\n"
"I<thread> が指すバッファーに格納する。この ID は、これ以降に他の\n"
"pthreads 関数の呼び出しでスレッドを参照するのに使用される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:101
msgid ""
"The new thread inherits a copy of the creating thread's signal mask "
"(B<pthread_sigmask>(3)).  The set of pending signals for the new thread is "
"empty (B<sigpending>(2)).  The new thread does not inherit the creating "
"thread's alternate signal stack (B<sigaltstack>(2))."
msgstr ""
"新しいスレッドは、スレッドを作成したスレッドのシグナルマスク\n"
"(B<pthread_sigmask>(3) 参照) のコピーを継承する。\n"
"新しいスレッドの処理待ちシグナル (B<sigpending>(2)) の集合は空となる。\n"
"新しいスレッドはスレッドを作成したスレッドの代替シグナルスタック\n"
"(B<sigaltstack>(2)) を継承しない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:104
msgid ""
"The new thread inherits the calling thread's floating-point environment "
"(B<fenv>(3))."
msgstr ""
"新しいスレッドは呼び出したスレッドの浮動小数点環境 (B<fenv>(3))\n"
"を継承する。"

#.  CLOCK_THREAD_CPUTIME_ID in clock_gettime(2)
#. type: Plain text
#: build/C/man3/pthread_create.3:109
msgid ""
"The initial value of the new thread's CPU-time clock is 0 (see "
"B<pthread_getcpuclockid>(3))."
msgstr ""
"新しいスレッドの CPU 時間時計の初期値は 0 である\n"
"(B<pthread_getcpuclockid>(3) 参照)。"

#. type: SS
#: build/C/man3/pthread_create.3:109
#, no-wrap
msgid "Linux-specific details"
msgstr "Linux 固有の詳細"

#. type: Plain text
#: build/C/man3/pthread_create.3:115
msgid ""
"The new thread inherits copies of the calling thread's capability sets (see "
"B<capabilities>(7))  and CPU affinity mask (see B<sched_setaffinity>(2))."
msgstr ""
"新しいスレッドは、呼び出したスレッドの\n"
"ケーパビリティセット (B<capabilities>(7) 参照) と \n"
"CPU affinity マスク (B<sched_setaffinity>(2) 参照) の\n"
"コピーをを継承しない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:122
msgid ""
"On success, B<pthread_create>()  returns 0; on error, it returns an error "
"number, and the contents of I<*thread> are undefined."
msgstr ""
"成功すると、 B<pthread_create>() は 0 を返す。\n"
"エラーの場合は、エラー番号が返され、 I<*thread> の内容は不定である。"

#. type: TP
#: build/C/man3/pthread_create.3:123 build/C/man3/pthread_create.3:126
#: build/C/man3/pthread_sigqueue.3:72 build/C/man3/pthread_spin_init.3:121
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man3/pthread_create.3:126
msgid "Insufficient resources to create another thread."
msgstr "別のスレッドを作成するのに十分なリソースがない。"

#.  NOTE! The following should match the description in fork(2)
#. type: Plain text
#: build/C/man3/pthread_create.3:144
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error: the B<RLIMIT_NPROC> soft "
"resource limit (set via B<setrlimit>(2)), which limits the number of "
"processes and threads for a real user ID, was reached; the kernel's system-"
"wide limit on the number of processes and threads, I</proc/sys/kernel/"
"threads-max>, was reached (see B<proc>(5)); or the maximum number of PIDs, "
"I</proc/sys/kernel/pid_max>, was reached (see B<proc>(5))."
msgstr ""
"システムで設定されたスレッド数の上限に達していた。 このエラーの原因となる上限"
"値はいくつかある。 実ユーザー ID 当たりのプロセス数とスレッド数の上限である、"
"ソフトリソース上限 B<RLIMIT_NPROC> に達していた (B<setrlimit>(2) で設定でき"
"る)。 カーネルのシステム全体のプロセスとスレッドの数の上限値である I</proc/"
"sys/kernel/threads-max> が達していた (B<proc>(5) 参照)。 PID の最大値 I</"
"proc/sys/kernel/pid_max> に達していた (B<proc>(5) 参照)。"

#. type: Plain text
#: build/C/man3/pthread_create.3:148
msgid "Invalid settings in I<attr>."
msgstr "I<attr> で指定された設定が不正である。"

#. type: TP
#: build/C/man3/pthread_create.3:148 build/C/man3/pthread_setschedparam.3:129
#: build/C/man3/pthread_setschedprio.3:66
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man3/pthread_create.3:153
msgid ""
"No permission to set the scheduling policy and parameters specified in "
"I<attr>."
msgstr ""
"I<attr> に指定されたスケジューリングポリシーとパラメーターを\n"
"設定する許可がない。"

#. type: tbl table
#: build/C/man3/pthread_create.3:163
#, no-wrap
msgid "B<pthread_create>()"
msgstr "B<pthread_create>()"

#. type: Plain text
#: build/C/man3/pthread_create.3:180
msgid ""
"See B<pthread_self>(3)  for further information on the thread ID returned in "
"I<*thread> by B<pthread_create>().  Unless real-time scheduling policies are "
"being employed, after a call to B<pthread_create>(), it is indeterminate "
"which thread\\(emthe caller or the new thread\\(emwill next execute."
msgstr ""
"B<pthread_create>() が I<*thread> で返すスレッド ID についての\n"
"詳しい情報は B<pthread_self>(3) を参照のこと。\n"
"リアルタイムスケジューリングポリシーが使用されない限り、\n"
"B<pthread_create>() の呼び出し後に、\n"
"どのスレッドが\\(em呼び出したスレッドか新しいスレッドか\\(em\n"
"次に実行されるかは決まっていない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:200
msgid ""
"A thread may either be I<joinable> or I<detached>.  If a thread is joinable, "
"then another thread can call B<pthread_join>(3)  to wait for the thread to "
"terminate and fetch its exit status.  Only when a terminated joinable thread "
"has been joined are the last of its resources released back to the system.  "
"When a detached thread terminates, its resources are automatically released "
"back to the system: it is not possible to join with the thread in order to "
"obtain its exit status.  Making a thread detached is useful for some types "
"of daemon threads whose exit status the application does not need to care "
"about.  By default, a new thread is created in a joinable state, unless "
"I<attr> was set to create the thread in a detached state (using "
"B<pthread_attr_setdetachstate>(3))."
msgstr ""
"スレッドは I<join 可能>か I<detached (切り離された状態)> のどちらかに\n"
"することができる。スレッドが join 可能な場合、別のスレッドが\n"
"B<pthread_join>(3) を使って終了したスレッドを待ち、終了ステータスを取得\n"
"することができる。終了した join 可能なスレッドは join された場合にのみ、\n"
"そのスレッドの最後に残ったリソースが解放されシステムに戻される。\n"
"detached 状態のスレッドが終了すると、そのスレッドのリソースは自動的に\n"
"システムに戻される。detached 状態のスレッドを join して、その終了\n"
"ステータスを取得することはできない。スレッドを detached 状態にするのは、\n"
"その終了ステータスをアプリケーションが気にする必要がないある種の\n"
"デーモン (daemon) スレッドでは有用である。\n"
"デフォルトでは、新しいスレッドは join 可能な状態で作成される。\n"
"(B<pthread_attr_setdetachstate>(3) を使って) I<attr> でスレッドが\n"
"detached 状態で作成されるように設定されていない限り、join 可能な状態で\n"
"作成される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:218
#, fuzzy
#| msgid ""
#| "On Linux/x86-32, the default stack size for a new thread is 2 megabytes.  "
#| "Under the NPTL threading implementation, if the B<RLIMIT_STACK> soft "
#| "resource limit I<at the time the program started> has any value other "
#| "than \"unlimited\", then it determines the default stack size of new "
#| "threads.  Using B<pthread_attr_setstacksize>(3), the stack size attribute "
#| "can be explicitly set in the I<attr> argument used to create a thread, in "
#| "order to obtain a stack size other than the default."
msgid ""
"Under the NPTL threading implementation, if the B<RLIMIT_STACK> soft "
"resource limit I<at the time the program started> has any value other than "
"\"unlimited\", then it determines the default stack size of new threads.  "
"Using B<pthread_attr_setstacksize>(3), the stack size attribute can be "
"explicitly set in the I<attr> argument used to create a thread, in order to "
"obtain a stack size other than the default.  If the B<RLIMIT_STACK> resource "
"limit is set to \"unlimited\", a per-architecture value is used for the "
"stack size.  Here is the value for a few architectures:"
msgstr ""
"Linux/x86-32 では、新しいスレッドのデフォルトのスタックサイズは 2MB で\n"
"ある。NPTL スレッド実装の下では、I<プログラム開始時の> B<RLIMIT_STACK>\n"
"ソフトリソース上限が\"unlimited\" 以外の場合、その値が新しいスレッドのデ\n"
"フォルトのスタックサイズとなる。\n"
"B<pthread_attr_setstacksize>(3) を使って、スレッドを作成する際の\n"
"I<attr> 引き数に明示的にスタックサイズ属性を設定することで、\n"
"デフォルト値以外のスタックサイズを得ることができる。"

#. type: tbl table
#: build/C/man3/pthread_create.3:223
#, no-wrap
msgid "Architecture"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:223
#, no-wrap
msgid "Default stack size"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:224
#, no-wrap
msgid "i386"
msgstr "i386"

#. type: tbl table
#: build/C/man3/pthread_create.3:224 build/C/man3/pthread_create.3:227
#: build/C/man3/pthread_create.3:228 build/C/man3/pthread_create.3:230
#, no-wrap
msgid "2 MB"
msgstr "2 MB"

#. type: tbl table
#: build/C/man3/pthread_create.3:225
#, no-wrap
msgid "IA-64"
msgstr "IA-64"

#. type: tbl table
#: build/C/man3/pthread_create.3:225
#, no-wrap
msgid "32 MB"
msgstr "32 MB"

#. type: tbl table
#: build/C/man3/pthread_create.3:226
#, no-wrap
msgid "PowerPC"
msgstr "PowerPC"

#. type: tbl table
#: build/C/man3/pthread_create.3:226 build/C/man3/pthread_create.3:229
#, no-wrap
msgid "4 MB"
msgstr "4 MB"

#. type: tbl table
#: build/C/man3/pthread_create.3:227
#, no-wrap
msgid "S/390"
msgstr "S/390"

#. type: tbl table
#: build/C/man3/pthread_create.3:228
#, no-wrap
msgid "Sparc-32"
msgstr "Sparc-32"

#. type: tbl table
#: build/C/man3/pthread_create.3:229
#, no-wrap
msgid "Sparc-64"
msgstr "Sparc-64"

#. type: tbl table
#: build/C/man3/pthread_create.3:230
#, no-wrap
msgid "x86_64"
msgstr "x86_64"

#. type: Plain text
#: build/C/man3/pthread_create.3:239
msgid ""
"In the obsolete LinuxThreads implementation, each of the threads in a "
"process has a different process ID.  This is in violation of the POSIX "
"threads specification, and is the source of many other nonconformances to "
"the standard; see B<pthreads>(7)."
msgstr ""
"廃止予定の LinuxThreads 実装では、プロセス内の各スレッドは異なる\n"
"プロセス ID を持つ。これは POSIX スレッドの規格に違反しており、\n"
"他の多くの標準非準拠の点の原因になっている。\n"
"B<pthreads>(7) を参照のこと。"

#. type: Plain text
#: build/C/man3/pthread_create.3:243
msgid ""
"The program below demonstrates the use of B<pthread_create>(), as well as a "
"number of other functions in the pthreads API."
msgstr ""
"以下のプログラムは、 B<pthread_create>() や\n"
"pthreads API の他のいろいろな関数の使用例を示している。"

#. type: Plain text
#: build/C/man3/pthread_create.3:248
msgid ""
"In the following run, on a system providing the NPTL threading "
"implementation, the stack size defaults to the value given by the \"stack "
"size\" resource limit:"
msgstr ""
"以下の実行例は、 NPTL スレッド実装が提供されているシステムでのもので、\n"
"スタックサイズがデフォルト値の \"stack size\" リソース上限で指定される値\n"
"になる。"

#. type: Plain text
#: build/C/man3/pthread_create.3:260
#, no-wrap
msgid ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x800000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x800000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:266
msgid ""
"In the next run, the program explicitly sets a stack size of 1\\ MB (using "
"B<pthread_attr_setstacksize>(3))  for the created threads:"
msgstr "次の実行例では、プログラム内で、作成されるスレッドに対して (B<pthread_attr_setstacksize>(3) を使って1\\ MB のスタックサイズを明示的に設定している。"

#. type: Plain text
#: build/C/man3/pthread_create.3:276
#, no-wrap
msgid ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:288
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:294 build/C/man3/pthread_getcpuclockid.3:127
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:300
#, no-wrap
msgid ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"
msgstr ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:303
#, no-wrap
msgid ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"
msgstr ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:309
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = arg;\n"
"    char *uargv;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = arg;\n"
"    char *uargv;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:312
#, no-wrap
msgid ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"
msgstr ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:316
#, no-wrap
msgid ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"
msgstr ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:319
#, no-wrap
msgid ""
"    for (char *p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"
msgstr ""
"    for (char *p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:322
#, no-wrap
msgid ""
"    return uargv;\n"
"}\n"
msgstr ""
"    return uargv;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:330
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, num_threads;\n"
"    pthread_attr_t attr;\n"
"    size_t stack_size;\n"
"    void *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, num_threads;\n"
"    pthread_attr_t attr;\n"
"    size_t stack_size;\n"
"    void *res;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:332
#, no-wrap
msgid "    /* The \"-s\" option specifies a stack size for our threads */\n"
msgstr "    /* The \"-s\" option specifies a stack size for our threads */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:339
#, no-wrap
msgid ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"
msgstr ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:346
#, no-wrap
msgid ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:348
#, no-wrap
msgid "    num_threads = argc - optind;\n"
msgstr "    num_threads = argc - optind;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:350
#, no-wrap
msgid "    /* Initialize thread creation attributes */\n"
msgstr "    /* Initialize thread creation attributes */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:354
#, no-wrap
msgid ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:360
#, no-wrap
msgid ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:362
#, no-wrap
msgid "    /* Allocate memory for pthread_create() arguments */\n"
msgstr "    /* Allocate memory for pthread_create() arguments */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:366
#, no-wrap
msgid ""
"    struct thread_info *tinfo = calloc(num_threads, sizeof(*tinfo));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"
msgstr ""
"    struct thread_info *tinfo = calloc(num_threads, sizeof(*tinfo));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:368
#, no-wrap
msgid "    /* Create one thread for each command-line argument */\n"
msgstr "    /* Create one thread for each command-line argument */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:372
#, no-wrap
msgid ""
"    for (int tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"
msgstr ""
"    for (int tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:375
#, no-wrap
msgid ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"
msgstr ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:381
#, no-wrap
msgid ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"
msgstr ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:384
#, no-wrap
msgid ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"
msgstr ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:388
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
msgstr ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:390
#, no-wrap
msgid "    /* Now join with each thread, and display its returned value */\n"
msgstr "    /* Now join with each thread, and display its returned value */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:395
#, no-wrap
msgid ""
"    for (int tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    for (int tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:400
#, no-wrap
msgid ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"
msgstr ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:404
#, no-wrap
msgid ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:419
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), "
"B<pthread_setattr_default_np>(3), B<pthreads>(7)"
msgstr "B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), B<pthread_setattr_default_np>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_detach.3:26
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr "PTHREAD_DETACH"

#. type: Plain text
#: build/C/man3/pthread_detach.3:29
msgid "pthread_detach - detach a thread"
msgstr "pthread_detach - スレッドを切り離す (detach する)"

#. type: Plain text
#: build/C/man3/pthread_detach.3:34
#, no-wrap
msgid "B<int pthread_detach(pthread_t >I<thread>B<);>\n"
msgstr "B<int pthread_detach(pthread_t >I<thread>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_detach.3:46
msgid ""
"The B<pthread_detach>()  function marks the thread identified by I<thread> "
"as detached.  When a detached thread terminates, its resources are "
"automatically released back to the system without the need for another "
"thread to join with the terminated thread."
msgstr ""
"B<pthread_detach>() 関数は I<thread> で識別されるスレッドに\n"
"detached (切り離された状態) という印を付ける。\n"
"detached 状態のスレッドが終了すると、\n"
"別のスレッドが終了されたスレッドを join しなくても、\n"
"そのスレッドのリソースは自動的に解放されてシステムに戻される。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:49
msgid ""
"Attempting to detach an already detached thread results in unspecified "
"behavior."
msgstr ""
"すでに detach 状態のスレッドを detach しようとした場合に\n"
"どのような結果となるかは規定されていない。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:54
msgid ""
"On success, B<pthread_detach>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、B<pthread_detach>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:59 build/C/man3/pthread_join.3:89
msgid "I<thread> is not a joinable thread."
msgstr "I<thread> が join 可能なスレッドではない。"

#. type: tbl table
#: build/C/man3/pthread_detach.3:74
#, no-wrap
msgid "B<pthread_detach>()"
msgstr "B<pthread_detach>()"

#. type: Plain text
#: build/C/man3/pthread_detach.3:83
msgid ""
"Once a thread has been detached, it can't be joined with B<pthread_join>(3)  "
"or be made joinable again."
msgstr ""
"いったんスレッドを detached 状態にすると、\n"
"そのスレッドを B<pthread_join>(3) で join したり、\n"
"もう一度 join 可能にしたりすることはできない。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:90
msgid ""
"A new thread can be created in a detached state using "
"B<pthread_attr_setdetachstate>(3)  to set the detached attribute of the "
"I<attr> argument of B<pthread_create>(3)."
msgstr ""
"B<pthread_attr_setdetachstate>(3) を使って\n"
"B<pthread_create>(3) の I<attr> 引き数の detached 属性を設定することで、\n"
"新しいスレッドを detached 状態で作成することができる。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:97
msgid ""
"The detached attribute merely determines the behavior of the system when the "
"thread terminates; it does not prevent the thread from being terminated if "
"the process terminates using B<exit>(3)  (or equivalently, if the main "
"thread returns)."
msgstr ""
"detached 属性は、スレッドが終了した際のシステムの動作を決めるだけである。\n"
"プロセスが B<exit>(3) を使って終了した場合に、そのスレッドが終了され\n"
"なくなるようなことはない (なお、メインスレッドが return した場合も\n"
"プロセスが B<exit>(3) を使って終了した場合と全く同じである)。 "

#. type: Plain text
#: build/C/man3/pthread_detach.3:106
#, fuzzy
#| msgid ""
#| "Either B<pthread_join>(3)  or B<pthread_detach>()  should be called for "
#| "each thread that an application creates, so that system resources for the "
#| "thread can be released.  (But note that the resources of all threads are "
#| "freed when the process terminates.)"
msgid ""
"Either B<pthread_join>(3)  or B<pthread_detach>()  should be called for each "
"thread that an application creates, so that system resources for the thread "
"can be released.  (But note that the resources of any threads for which one "
"of these actions has not been done will be freed when the process "
"terminates.)"
msgstr ""
"アプリケーションが作成した各スレッドについて、そのスレッドが使用して\n"
"いるシステムリソースを解放できるように、B<pthread_join>(3) か\n"
"B<pthread_detach>() のどちらかを呼び出すべきである (ただし、プロセスが\n"
"終了するときには、全てのスレッドのリソースが解放される)。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:108
msgid "The following statement detaches the calling thread:"
msgstr "以下の文は、呼び出したスレッド自身を detach する。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:110
#, no-wrap
msgid "    pthread_detach(pthread_self());\n"
msgstr "    pthread_detach(pthread_self());\n"

#. type: Plain text
#: build/C/man3/pthread_detach.3:117
msgid ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), "
"B<pthread_create>(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), "
"B<pthread_create>(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_equal.3:26
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr "PTHREAD_EQUAL"

#. type: TH
#: build/C/man3/pthread_equal.3:26 build/C/man3/pthread_setschedprio.3:26
#: build/C/man7/nptl.7:26
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: build/C/man3/pthread_equal.3:29
msgid "pthread_equal - compare thread IDs"
msgstr "pthread_equal - スレッド ID を比較する"

#. type: Plain text
#: build/C/man3/pthread_equal.3:34
#, no-wrap
msgid "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"
msgstr "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_equal.3:41
msgid "The B<pthread_equal>()  function compares two thread identifiers."
msgstr "B<pthread_equal>() 関数は 2 つのスレッド識別子の比較を行う。"

#. type: Plain text
#: build/C/man3/pthread_equal.3:45
msgid ""
"If the two thread IDs are equal, B<pthread_equal>()  returns a nonzero "
"value; otherwise, it returns 0."
msgstr ""
"B<pthread_equal>() は、2 つのスレッド ID が等しければ 0 以外の値を返し、\n"
"そうでなければ 0 を返す。"

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_equal.3:47 build/C/man3/pthread_exit.3:75
#: build/C/man3/pthread_self.3:50 build/C/man3/pthread_testcancel.3:58
msgid "This function always succeeds."
msgstr "この関数は常に成功する。"

#. type: tbl table
#: build/C/man3/pthread_equal.3:57
#, no-wrap
msgid "B<pthread_equal>()"
msgstr "B<pthread_equal>()"

#. type: Plain text
#: build/C/man3/pthread_equal.3:68
msgid ""
"The B<pthread_equal>()  function is necessary because thread IDs should be "
"considered opaque: there is no portable way for applications to directly "
"compare two I<pthread_t> values."
msgstr ""
"B<pthread_equal>() 関数が必要なのは、\n"
"スレッド ID はその内部構造を意識すべきではないためである。\n"
"アプリケーションが 2 つの I<pthread_t> の値を直接比較する場合、\n"
"移植性を確保できる形で比較する方法はない。"

#. type: Plain text
#: build/C/man3/pthread_equal.3:72
msgid "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_exit.3:26
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr "PTHREAD_EXIT"

#. type: Plain text
#: build/C/man3/pthread_exit.3:29
msgid "pthread_exit - terminate calling thread"
msgstr "pthread_exit - 呼び出したスレッドを終了する"

#. type: Plain text
#: build/C/man3/pthread_exit.3:34
#, no-wrap
msgid "B<void pthread_exit(void *>I<retval>B<);>\n"
msgstr "B<void pthread_exit(void *>I<retval>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_exit.3:45
msgid ""
"The B<pthread_exit>()  function terminates the calling thread and returns a "
"value via I<retval> that (if the thread is joinable)  is available to "
"another thread in the same process that calls B<pthread_join>(3)."
msgstr ""
"B<pthread_exit>() 関数は、呼び出したスレッドを終了し、\n"
"I<retval> 経由で値を返す。\n"
"この値は (そのスレッドが join 可能な場合に) B<pthread_join>(3) を\n"
"呼び出した同じプロセス内の別のスレッドが参照できる値と同じである。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:55
msgid ""
"Any clean-up handlers established by B<pthread_cleanup_push>(3)  that have "
"not yet been popped, are popped (in the reverse of the order in which they "
"were pushed)  and executed.  If the thread has any thread-specific data, "
"then, after the clean-up handlers have been executed, the corresponding "
"destructor functions are called, in an unspecified order."
msgstr ""
"B<pthread_cleanup_push>(3) で設定されたクリーンアップハンドラーのうち、\n"
"まだ pop (取り出されていない) ハンドラーを (push されたのと逆の順序で)\n"
"取り出して実行する。そのスレッドがスレッド固有のデータを持っている\n"
"場合は、クリーンアップハンドラーが実行された後に、スレッド固有のデータ\n"
"に対応するデストラクタ (destructor) 関数が呼び出される (呼び出し順序\n"
"は規定されていない)。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:62
msgid ""
"When a thread terminates, process-shared resources (e.g., mutexes, condition "
"variables, semaphores, and file descriptors) are not released, and functions "
"registered using B<atexit>(3)  are not called."
msgstr ""
"スレッドが終了する際に、プロセスの共有リソース (例えば、mutex、状態変数\n"
"(condition variables)、セマフォ、ファイルディスクリプター)が解放される。\n"
"B<atexit>(3) を使って登録された関数は呼び出されない。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:71
msgid ""
"After the last thread in a process terminates, the process terminates as by "
"calling B<exit>(3)  with an exit status of zero; thus, process-shared "
"resources are released and functions registered using B<atexit>(3)  are "
"called."
msgstr ""
"プロセスの最後のスレッドが終了すると、そのプロセスは、終了ステータス 0\n"
"で B<exit>(3) を呼び出した場合と全く同じように終了する。したがって、\n"
"プロセスの共有リソースは解放され、B<atexit>(3) を使って登録された関数\n"
"が呼び出される。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:73
msgid "This function does not return to the caller."
msgstr "この関数は呼び出し側には返らない。"

#. type: tbl table
#: build/C/man3/pthread_exit.3:85
#, no-wrap
msgid "B<pthread_exit>()"
msgstr "B<pthread_exit>()"

#. type: Plain text
#: build/C/man3/pthread_exit.3:94
msgid ""
"Performing a return from the start function of any thread other than the "
"main thread results in an implicit call to B<pthread_exit>(), using the "
"function's return value as the thread's exit status."
msgstr ""
"メインスレッド以外のスレッドの開始関数 (start function) がreturn を\n"
"行うと、暗黙のうちに B<pthread_exit>() が呼び出され、\n"
"関数の返り値がスレッドの終了ステータスとして使用される。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:100
msgid ""
"To allow other threads to continue execution, the main thread should "
"terminate by calling B<pthread_exit>()  rather than B<exit>(3)."
msgstr ""
"他のスレッドが実行を継続できるように、メインスレッドは B<exit>(3) では\n"
"なく B<pthread_exit>() を呼び出して終了すべきである。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:105
msgid ""
"The value pointed to by I<retval> should not be located on the calling "
"thread's stack, since the contents of that stack are undefined after the "
"thread terminates."
msgstr ""
"I<retval> が指す値は、呼び出したスレッドのスタックに置くべきではない。\n"
"呼び出したスレッドが終了した後は、そのスタックの内容が不定となるから\n"
"である。"

#.  Linux 2.6.27
#.  FIXME . review a later kernel to see if this gets fixed
#.  http://thread.gmane.org/gmane.linux.kernel/611611
#.  http://marc.info/?l=linux-kernel&m=122525468300823&w=2
#. type: Plain text
#: build/C/man3/pthread_exit.3:117
msgid ""
"Currently, there are limitations in the kernel implementation logic for "
"B<wait>(2)ing on a stopped thread group with a dead thread group leader.  "
"This can manifest in problems such as a locked terminal if a stop signal is "
"sent to a foreground process whose thread group leader has already called "
"B<pthread_exit>()."
msgstr ""
"現在のところ、停止 (stop) されたスレッドグループを、すでに終了した\n"
"(dead) スレッドグループリーダーで B<wait>(2) する場合の、\n"
"カーネル実装の論理には制限がある。\n"
"この制限は、すでにスレッドグループリーダーが B<pthread_exit>() を\n"
"呼び出しているようなフォアグラウンドプロセスにストップシグナルが送信\n"
"された場合に、端末がロックされてしまう、といった問題として表に見える\n"
"場合がある。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:121
msgid "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_getattr_np.3:26
#, no-wrap
msgid "PTHREAD_GETATTR_NP"
msgstr "PTHREAD_GETATTR_NP"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:29
msgid "pthread_getattr_np - get attributes of created thread"
msgstr "pthread_getattr_np - 作成されたスレッドの属性を取得する"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:35
#, no-wrap
msgid "B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t *>I<attr>B<);>\n"
msgstr "B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:45
msgid ""
"The B<pthread_getattr_np>()  function initializes the thread attributes "
"object referred to by I<attr> so that it contains actual attribute values "
"describing the running thread I<thread>."
msgstr ""
"B<pthread_getattr_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトを初期化し、\n"
"そのオブジェクトに実行中のスレッド I<thread> の実際の属性値を\n"
"格納して返す。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:52
msgid ""
"The returned attribute values may differ from the corresponding attribute "
"values passed in the I<attr> object that was used to create the thread using "
"B<pthread_create>(3).  In particular, the following attributes may differ:"
msgstr ""
"返される属性値は、B<pthread_create>(3) でスレッドを作成する際に\n"
"使われたI<attr> オブジェクトで渡された属性値と異なる場合がある。\n"
"特に、以下の属性は異なる場合がある。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:55
msgid ""
"the detach state, since a joinable thread may have detached itself after "
"creation;"
msgstr ""
"detach state. join 可能なスレッドは作成後に自分自身を\n"
"切り離す (detach する) ことができるからである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:58
msgid ""
"the stack size, which the implementation may align to a suitable boundary."
msgstr ""
"スタックサイズ。\n"
"スレッドの実装によって適切な境界に揃えられる可能があるためである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:63
msgid ""
"and the guard size, which the implementation may round upward to a multiple "
"of the page size, or ignore (i.e., treat as 0), if the application is "
"allocating its own stack."
msgstr ""
"guard size.\n"
"スレッドの実装によりページサイズの倍数に切り上げられたり、\n"
"アプリケーションが自分でスタックを割り当てる場合には無視される\n"
"(0 として扱われる) ことがあるからである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:68
msgid ""
"Furthermore, if the stack address attribute was not set in the thread "
"attributes object used to create the thread, then the returned thread "
"attributes object will report the actual stack address that the "
"implementation selected for the thread."
msgstr ""
"さらに、スレッドを作成する際に使用されたスレッド属性オブジェクトで\n"
"スタックアドレスが設定されていなかった場合、\n"
"返されたスレッド属性オブジェクトではスレッドの実装がそのスレッドに\n"
"割り当てた実際のスタックアドレスが報告される。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:73
msgid ""
"When the thread attributes object returned by B<pthread_getattr_np>()  is no "
"longer required, it should be destroyed using B<pthread_attr_destroy>(3)."
msgstr ""
"B<pthread_getattr_np>() が返したスレッド属性オブジェクトが\n"
"必要なくなった際には、  B<pthread_attr_destroy>(3) を使って\n"
"そのオブジェクトを破棄すべきである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:76 build/C/man3/pthread_getcpuclockid.3:52
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number."
msgstr ""
"成功すると、この関数は 0 を返す。\n"
"エラーの場合、 0 以外のエラー番号を返す。"

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:81
msgid "Insufficient memory."
msgstr "メモリーが十分になかった。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:96
msgid ""
"In addition, if I<thread> refers to the main thread, then "
"B<pthread_getattr_np>()  can fail because of errors from various underlying "
"calls: B<fopen>(3), if I</proc/self/maps> can't be opened; and "
"B<getrlimit>(2), if the B<RLIMIT_STACK> resource limit is not supported."
msgstr ""
"さらに、 I<thread> がメインスレッドを参照している場合には、\n"
"B<pthread_getattr_np>() は内部で行われる様々な呼び出しでの\n"
"エラーで失敗する可能性がある。\n"
"I</proc/self/maps> がオープンできない場合には B<fopen>(3)\n"
"でエラーが発生し、リソース上限 B<RLIMIT_STACK> が\n"
"サポートされていない場合には B<getrlimit>(2) でエラーが発生する。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:98
msgid "This function is available in glibc since version 2.2.3."
msgstr "この関数は glibc バージョン 2.2.3 以降で利用できる。"

#. type: tbl table
#: build/C/man3/pthread_getattr_np.3:109
#, no-wrap
msgid "B<pthread_getattr_np>()"
msgstr "B<pthread_getattr_np>()"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:115
#: build/C/man3/pthread_kill_other_threads_np.3:62
msgid ""
"This function is a nonstandard GNU extension; hence the suffix \"_np"
"\" (nonportable) in the name."
msgstr ""
"この関数は非標準の GNU による拡張である。\n"
"そのため、名前に \"_np\" (nonportable; 移植性がない) という接尾辞が\n"
"付いている。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:125
msgid ""
"The program below demonstrates the use of B<pthread_getattr_np>().  The "
"program creates a thread that then uses B<pthread_getattr_np>()  to retrieve "
"and display its guard size, stack address, and stack size attributes.  "
"Command-line arguments can be used to set these attributes to values other "
"than the default when creating the thread.  The shell sessions below "
"demonstrate the use of the program."
msgstr ""
"以下のプログラムは B<pthread_getattr_np>() の使用例を示したものである。\n"
"このプログラムは、スレッドを作成し、それから\n"
"B<pthread_getattr_np>() を使ってそのスレッドの属性 guard size、\n"
"スタックアドレス、スタックサイズを取得し表示する。\n"
"コマンドライン引き数での指定で、スレッドを作成する際に\n"
"上記の属性にデフォルト値以外の値を設定することができる。\n"
"下記のシェルのセッションはこのプログラムの使用例である。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:128
msgid ""
"In the first run, on an x86-32 system, a thread is created using default "
"attributes:"
msgstr ""
"最初の実行例は、デフォルトの属性でスレッドが作成されている\n"
"(x86-32 システム上で実行)。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:138
#, no-wrap
msgid ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:144
msgid ""
"In the following run, we see that if a guard size is specified, it is "
"rounded up to the next multiple of the system page size (4096 bytes on "
"x86-32):"
msgstr ""
"次の実行例では、guard size が指定された場合、\n"
"guard size はシステムのページサイズの倍数に切り上げられることが分かる\n"
"(x86-32 ではシステムのページサイズは 4096 バイトである)。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:152
#, no-wrap
msgid ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"
msgstr ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:157
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:176
msgid ""
"In the last run, the program manually allocates a stack for the thread.  In "
"this case, the guard size attribute is ignored."
msgstr ""
"最後の実行例では、プログラムでスレッド用のスタックを手動で割り当てている。\n"
"この場合には、guard size 属性は無視される。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:181
#, no-wrap
msgid ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"
msgstr ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:186
#, no-wrap
msgid ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:191
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:212
#, no-wrap
msgid ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
msgstr ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:217
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, guard_size);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, guard_size);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:228
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = %#zx (%zu) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"
msgstr ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = %#zx (%zu) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:234
#, no-wrap
msgid ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:238
#, no-wrap
msgid ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:240
#, no-wrap
msgid "    display_stack_related_attributes(&attr, prefix);\n"
msgstr "    display_stack_related_attributes(&attr, prefix);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:245
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"
msgstr ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:251
#, no-wrap
msgid ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"
msgstr ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:265
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:278
#, no-wrap
msgid ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"
msgstr ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:287
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:290
#, no-wrap
msgid ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"
msgstr ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:293
#, no-wrap
msgid ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"
msgstr ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:296
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"
msgstr ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:301
#, no-wrap
msgid ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:313
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"
msgstr ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:319
#, no-wrap
msgid ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"
msgstr ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:325
#, no-wrap
msgid ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:328
#, no-wrap
msgid ""
"    return ret_attrp;\n"
"}\n"
msgstr ""
"    return ret_attrp;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:337
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:339
#, no-wrap
msgid "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"
msgstr "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:345
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:375
#: build/C/man3/pthread_getattr_default_np.3:212
msgid ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_getcpuclockid.3:26
#, no-wrap
msgid "PTHREAD_GETCPUCLOCKID"
msgstr "PTHREAD_GETCPUCLOCKID"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:29
msgid "pthread_getcpuclockid - retrieve ID of a thread's CPU time clock"
msgstr "pthread_getcpuclockid - スレッドの CPU 時間時計の ID を取得する"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:33
#, no-wrap
msgid ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:35
#, no-wrap
msgid "B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t *>I<clockid>B<);>\n"
msgstr "B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t *>I<clockid>B<);>\n"

#.  The clockid is constructed as follows:
#.  *clockid = CLOCK_THREAD_CPUTIME_ID | (pd->tid << CLOCK_IDFIELD_SIZE)
#.  where CLOCK_IDFIELD_SIZE is 3.
#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:49
#, fuzzy
#| msgid ""
#| "The B<pthread_getcpuclockid>()  function returns the clock ID for the CPU "
#| "time clock of the thread I<thread>."
msgid ""
"The B<pthread_getcpuclockid>()  function obtains the ID of the CPU-time "
"clock of the thread whose ID is given in I<thread>, and returns it in the "
"location pointed to by I<clockid>."
msgstr ""
"B<pthread_getcpuclockid>() 関数は、\n"
"スレッド I<thread> の CPU 時間時計のクロック ID を返す。"

#. type: TP
#: build/C/man3/pthread_getcpuclockid.3:53
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#.  CLOCK_THREAD_CPUTIME_ID not defined
#.  Looking at nptl/pthread_getcpuclockid.c an ERANGE error would
#.  be possible if kernel thread IDs took more than 29 bits (which
#.  they currently cannot).
#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:61
msgid "Per-thread CPU time clocks are not supported by the system."
msgstr "スレッド単位の CPU 時間時計はこのシステムではサポートされていない。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:68
msgid "This function is available in glibc since version 2.2."
msgstr "この関数は glibc バージョン 2.2 以降で利用できる。"

#. type: tbl table
#: build/C/man3/pthread_getcpuclockid.3:78
#, no-wrap
msgid "B<pthread_getcpuclockid>()"
msgstr "B<pthread_getcpuclockid>()"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:93
msgid ""
"When I<thread> refers to the calling thread, this function returns an "
"identifier that refers to the same clock manipulated by B<clock_gettime>(2)  "
"and B<clock_settime>(2)  when given the clock ID B<CLOCK_THREAD_CPUTIME_ID>."
msgstr ""
"I<thread> が呼び出したスレッドを参照している場合、\n"
"クロック ID B<CLOCK_THREAD_CPUTIME_ID> が指定されていれば、\n"
"B<clock_gettime>(2) と B<clock_settime>(2) が操作するのと同じ時計\n"
"を参照する ID が返される。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:99
msgid ""
"The program below creates a thread and then uses B<clock_gettime>(2)  to "
"retrieve the total process CPU time, and the per-thread CPU time consumed by "
"the two threads.  The following shell session shows an example run:"
msgstr ""
"以下のプログラムは、スレッドを作成し、それから\n"
"B<clock_gettime>(2) を使ってプロセス全体の CPU 時間を取得し、\n"
"B<pthread_getcpuclockid>(3) を使って 2 つのスレッドが消費した\n"
"スレッド毎の CPU 時間を取得する。\n"
"下記のシェルのセッションは実行例である。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:109
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"
msgstr ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:115
#, no-wrap
msgid "/* Link with \"-lrt\" */\n"
msgstr "/* \"-lrt\" でリンクする */\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:124
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:138
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:143
#, no-wrap
msgid ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"
msgstr ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:149
#, no-wrap
msgid ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4jd.%03ld\\en\", (intmax_t) ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"
msgstr ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4jd.%03ld\\en\", (intmax_t) ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:156
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:160
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:163
#, no-wrap
msgid ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"
msgstr ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:167
#, no-wrap
msgid ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (int j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"
msgstr ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (int j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:169
#, no-wrap
msgid "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"
msgstr "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:174
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"
msgstr ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:177
#, no-wrap
msgid ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"
msgstr ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:182
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"
msgstr ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:185
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:194
msgid ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"

#. type: TH
#: build/C/man3/pthread_join.3:26
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr "PTHREAD_JOIN"

#. type: Plain text
#: build/C/man3/pthread_join.3:29
msgid "pthread_join - join with a terminated thread"
msgstr "pthread_join - 終了したスレッドを join する"

#. type: Plain text
#: build/C/man3/pthread_join.3:34
#, no-wrap
msgid "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_join.3:49
msgid ""
"The B<pthread_join>()  function waits for the thread specified by I<thread> "
"to terminate.  If that thread has already terminated, then "
"B<pthread_join>()  returns immediately.  The thread specified by I<thread> "
"must be joinable."
msgstr ""
"B<pthread_join>() 関数は、I<thread> で指定されたスレッドが\n"
"終了するのを待つ。そのスレッドがすでに終了している場合、\n"
"B<pthread_join>() はすぐに返る。\n"
"I<thread> で指定されたスレッドは join 可能でなければならない。"

#. type: Plain text
#: build/C/man3/pthread_join.3:63
msgid ""
"If I<retval> is not NULL, then B<pthread_join>()  copies the exit status of "
"the target thread (i.e., the value that the target thread supplied to "
"B<pthread_exit>(3))  into the location pointed to by I<retval>.  If the "
"target thread was canceled, then B<PTHREAD_CANCELED> is placed in the "
"location pointed to by I<retval>."
msgstr "I<retval> が NULL でない場合、 B<pthread_join>() は対象スレッドの終了ステータス (すなわち、対象スレッドが B<pthread_exit>(3) に渡した値) を I<retval> が指す場所にコピーする。対象スレッドがキャンセルされた場合、 I<retval> が指す場所には B<PTHREAD_CANCELED> が格納される。"

#. type: Plain text
#: build/C/man3/pthread_join.3:70
msgid ""
"If multiple threads simultaneously try to join with the same thread, the "
"results are undefined.  If the thread calling B<pthread_join>()  is "
"canceled, then the target thread will remain joinable (i.e., it will not be "
"detached)."
msgstr ""
"複数のスレッドが同時に同じスレッドを join しようとした場合、その結果\n"
"は不定である。B<pthread_join>() を呼び出しているスレッドがキャンセル\n"
"された場合、対象スレッドは join 可能のままとなる (detached 状態には\n"
"ならない)。"

#. type: Plain text
#: build/C/man3/pthread_join.3:75
msgid ""
"On success, B<pthread_join>()  returns 0; on error, it returns an error "
"number."
msgstr "成功すると、 B<pthread_join>() は 0 を返す。エラーの場合、エラー番号を返す。"

#. type: TP
#: build/C/man3/pthread_join.3:76
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#.  The following verified by testing on glibc 2.8/NPTL:
#.  The following verified by testing on glibc 2.8/NPTL:
#. type: Plain text
#: build/C/man3/pthread_join.3:85
msgid ""
"A deadlock was detected (e.g., two threads tried to join with each other); "
"or I<thread> specifies the calling thread."
msgstr ""
"デッドロックが検出された (例えば、二つのスレッドが互いに join しようと\n"
"した場合)、または I<thread> に呼び出したスレッドが指定されている。"

#.  POSIX.1-2001 does not specify this error case.
#. type: Plain text
#: build/C/man3/pthread_join.3:93
msgid "Another thread is already waiting to join with this thread."
msgstr "別のスレッドがすでにこのスレッドの join 待ちである。"

#. type: tbl table
#: build/C/man3/pthread_join.3:108
#, no-wrap
msgid "B<pthread_join>()"
msgstr "B<pthread_join>()"

#. type: Plain text
#: build/C/man3/pthread_join.3:120
msgid ""
"After a successful call to B<pthread_join>(), the caller is guaranteed that "
"the target thread has terminated.  The caller may then choose to do any "
"clean-up that is required after termination of the thread (e.g., freeing "
"memory or other resources that were allocated to the target thread)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:123
msgid ""
"Joining with a thread that has previously been joined results in undefined "
"behavior."
msgstr "すでに join されたスレッドを join した場合の結果は不定である。"

#. type: Plain text
#: build/C/man3/pthread_join.3:131
msgid ""
"Failure to join with a thread that is joinable (i.e., one that is not "
"detached), produces a \"zombie thread\".  Avoid doing this, since each "
"zombie thread consumes some system resources, and when enough zombie threads "
"have accumulated, it will no longer be possible to create new threads (or "
"processes)."
msgstr ""
"join 可能なスレッド (detached 状態でないスレッド) の join に失敗した場合、\n"
"\"ゾンビスレッド (zombie thread)\" が生成される。\n"
"各ゾンビスレッドはシステムリソースをいくらかは消費し、\n"
"ゾンビスレッドがたくさん生成されてしまうと、\n"
"新しいスレッド (やプロセス) がそれ以上作成できなくなってしまうので、\n"
"このようなことが起きるのは避けること。"

#. type: Plain text
#: build/C/man3/pthread_join.3:137
msgid ""
"There is no pthreads analog of I<waitpid(-1,\\ &status,\\ 0)>, that is, "
"\"join with any terminated thread\".  If you believe you need this "
"functionality, you probably need to rethink your application design."
msgstr ""
"pthreads には、 I<waitpid(-1,\\ &status,\\ 0)>、つまり\n"
"\"終了されたスレッドのどれかを join する\" といった機能はない。\n"
"この機能が必要だと思うような場合には、おそらく\n"
"自分のアプリケーションの設計を考え直す必要があるだろう。"

#. type: Plain text
#: build/C/man3/pthread_join.3:140
msgid ""
"All of the threads in a process are peers: any thread can join with any "
"other thread in the process."
msgstr ""
"プロセス内の全てのスレッドは対等であり、\n"
"どのスレッドでもプロセス内の他のスレッドを join できる。"

#. type: Plain text
#: build/C/man3/pthread_join.3:150
msgid ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_kill.3:26
#, no-wrap
msgid "PTHREAD_KILL"
msgstr "PTHREAD_KILL"

#. type: Plain text
#: build/C/man3/pthread_kill.3:29
msgid "pthread_kill - send a signal to a thread"
msgstr "pthread_kill - スレッドにシグナルを送信する"

#. type: Plain text
#: build/C/man3/pthread_kill.3:32 build/C/man3/pthread_sigmask.3:32
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_kill.3:34
#, no-wrap
msgid "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"
msgstr "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_kill.3:45
msgid "B<pthread_kill>():"
msgstr "B<pthread_kill>():"

#. type: Plain text
#: build/C/man3/pthread_kill.3:47 build/C/man3/pthread_sigmask.3:48
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 199506L || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 199506L || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man3/pthread_kill.3:59
msgid ""
"The B<pthread_kill>()  function sends the signal I<sig> to I<thread>, a "
"thread in the same process as the caller.  The signal is asynchronously "
"directed to I<thread>."
msgstr ""
"B<pthread_kill>() 関数は、呼び出したスレッドと同じプロセスの\n"
"スレッド I<thread> にシグナル I<sig> を送信する。\n"
"シグナルは非同期に I<thread> へ直接送られる。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:63
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed."
msgstr ""
"I<sig> が 0 の場合、シグナルは送信されないが、エラーチェックだけは実行され"
"る。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:68
msgid ""
"On success, B<pthread_kill>()  returns 0; on error, it returns an error "
"number, and no signal is sent."
msgstr ""
"成功すると、 B<pthread_kill>() は 0 を返す。\n"
"エラーの場合、エラー番号を返し、シグナルの送信は行わない。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:72
msgid "An invalid signal was specified."
msgstr "無効なシグナルが指定された。"

#. type: tbl table
#: build/C/man3/pthread_kill.3:82
#, no-wrap
msgid "B<pthread_kill>()"
msgstr "B<pthread_kill>()"

#. type: Plain text
#: build/C/man3/pthread_kill.3:93
msgid ""
"Signal dispositions are process-wide: if a signal handler is installed, the "
"handler will be invoked in the thread I<thread>, but if the disposition of "
"the signal is \"stop\", \"continue\", or \"terminate\", this action will "
"affect the whole process."
msgstr ""
"シグナルの配送はプロセス全体で行われる。\n"
"シグナルハンドラーが設定されている場合、\n"
"そのハンドラーがスレッド I<thread> で起動されるが、\n"
"シグナルの配送が \"stop\", \"continue\", \"terminate\" のいずれかの場合、\n"
"シグナルに対するアクションはプロセス全体に影響がある。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:103
msgid ""
"The glibc implementation of B<pthread_kill>()  gives an error (B<EINVAL>)  "
"on attempts to send either of the real-time signals used internally by the "
"NPTL threading implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:116
msgid ""
"POSIX.1-2008 recommends that if an implementation detects the use of a "
"thread ID after the end of its lifetime, B<pthread_kill>()  should return "
"the error B<ESRCH>.  The glibc implementation returns this error in the "
"cases where an invalid thread ID can be detected.  But note also that POSIX "
"says that an attempt to use a thread ID whose lifetime has ended produces "
"undefined behavior, and an attempt to use an invalid thread ID in a call to "
"B<pthread_kill>()  can, for example, cause a segmentation fault."
msgstr ""
"POSIX.1-2008 では、 スレッドが終了した後にそのスレッド ID が使用されたことを"
"検出した場合に、 B<pthread_kill>() はエラー B<ESRCH> を返すことを推奨されてい"
"る。 glibc の実装では、無効なスレッド ID を検出できる場合にはこのエラーを返"
"す。 しかし、 POSIX では、 終了したスレッド ID を使おうとした場合の動作は不定"
"であり、 B<pthread_kill>() で無効なスレッド ID を使おうとした場合には、 例え"
"ば、 セグメンテーションフォールトになる可能性もある点に注意すること。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:125
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/pthread_kill_other_threads_np.3:26
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr "PTHREAD_KILL_OTHER_THREADS_NP"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:29
msgid "pthread_kill_other_threads_np - terminate all other threads in process"
msgstr "pthread_kill_other_threads_np - プロセス内の他の全スレッドを終了する"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:34
#, no-wrap
msgid "B<void pthread_kill_other_threads_np(void);>\n"
msgstr "B<void pthread_kill_other_threads_np(void);>\n"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:47
msgid ""
"B<pthread_kill_other_threads_np>()  has an effect only in the LinuxThreads "
"threading implementation.  On that implementation, calling this function "
"causes the immediate termination of all threads in the application, except "
"the calling thread.  The cancellation state and cancellation type of the to-"
"be-terminated threads are ignored, and the cleanup handlers are not called "
"in those threads."
msgstr ""
"B<pthread_kill_other_threads_np>() は、\n"
"LinuxThreads スレッド実装においてのみ効果がある。\n"
"LinuxThreads スレッド実装では、この関数を呼び出すと\n"
"アプリケーション内の全てのスレッドがすぐに終了される。\n"
"終了対象のスレッドの cancelability state と cancelability type は\n"
"無視され、それらのスレッドのクリーンアップハンドラーは呼び出されない。"

#. type: tbl table
#: build/C/man3/pthread_kill_other_threads_np.3:57
#, no-wrap
msgid "B<pthread_kill_other_threads_np>()"
msgstr "B<pthread_kill_other_threads_np>()"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:71
msgid ""
"B<pthread_kill_other_threads_np>()  is intended to be called just before a "
"thread calls B<execve>(2)  or a similar function.  This function is designed "
"to address a limitation in the obsolete LinuxThreads implementation whereby "
"the other threads of an application are not automatically terminated (as "
"POSIX.1-2001 requires) during B<execve>(2)."
msgstr ""
"B<pthread_kill_other_threads_np>() は、\n"
"スレッドが B<execve>(2) や同様の関数を呼び出す直前に\n"
"呼ばれることを目的として用意されている。\n"
"この関数は、(廃止予定の) LinuxThreads スレッド実装における、\n"
"B<execve>(2) の際にアプリケーションの他のスレッドが自動的に\n"
"終了されないという制限を解決するために設計された。"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:78
msgid ""
"In the NPTL threading implementation, B<pthread_kill_other_threads_np>()  "
"exists, but does nothing.  (Nothing needs to be done, because the "
"implementation does the right thing during an B<execve>(2).)"
msgstr ""
"NPTL スレッド実装では、 B<pthread_kill_other_threads_np>() は存在するが、\n"
"何もしない(NPTL 実装は B<execve>(2) の際に適切な動作をするので、\n"
"何もする必要がないということだ)。"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:84
msgid ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"
msgstr ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_rwlockattr_setkind_np.3:25
#, no-wrap
msgid "PTHREAD_RWLOCKATTR_SETKIND_NP"
msgstr "PTHREAD_RWLOCKATTR_SETKIND_NP"

#. type: TH
#: build/C/man3/pthread_rwlockattr_setkind_np.3:25
#: build/C/man3/pthread_atfork.3:25
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:29
msgid ""
"pthread_rwlockattr_setkind_np, pthread_rwlockattr_getkind_np - set/get the "
"read-write lock kind of the thread read-write lock attribute object"
msgstr ""
"pthread_rwlockattr_setkind_np, pthread_rwlockattr_getkind_np - スレッドの読み"
"書きロック属性オブジェクトの読み書きロック種別の設定、取得を行う"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:37
#, no-wrap
msgid ""
"B<int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int >I<pref>B<);>\n"
"B<int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<pref>B<);>\n"
msgstr ""
"B<int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int >I<pref>B<);>\n"
"B<int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<pref>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:48
msgid "B<pthread_rwlockattr_setkind_np>(), B<pthread_rwlockattr_getkind_np>():"
msgstr ""
"B<pthread_rwlockattr_setkind_np>(), B<pthread_rwlockattr_getkind_np>():"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:52
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE E<gt>= 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE E<gt>= 200809L"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:65
msgid ""
"The B<pthread_rwlockattr_setkind_np>()  function sets the \"lock kind\" "
"attribute of the read-write lock attribute object referred to by I<attr> to "
"the value specified in I<pref>.  The argument I<pref> may be set to one of "
"the following:"
msgstr ""
"B<pthread_rwlockattr_setkind_np>() 関数は、 I<attr> が参照する読み書きロック"
"属性オブジェクトの「ロック種別 (lock kind)」を I<pref> で指定された値に設定す"
"る。 引き数 I<pref> には以下のいずれか一つを設定できる。"

#. type: TP
#: build/C/man3/pthread_rwlockattr_setkind_np.3:65
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_READER_NP>"
msgstr "B<PTHREAD_RWLOCK_PREFER_READER_NP>"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:78
msgid ""
"This is the default.  A thread may hold multiple read locks; that is, read "
"locks are recursive.  According to The Single Unix Specification, the "
"behavior is unspecified when a reader tries to place a lock, and there is no "
"write lock but writers are waiting.  Giving preference to the reader, as is "
"set by B<PTHREAD_RWLOCK_PREFER_READER_NP>, implies that the reader will "
"receive the requested lock, even if a writer is waiting.  As long as there "
"are readers, the writer will be starved."
msgstr ""
"これがデフォルトである。 スレッドは複数の読み出しロックを保持できる。 つま"
"り、読み出しロックは再帰的である。 Single Unix Specification では、 読み出し"
"側がロックをかけようとした際に、書き込みロックはないが書き込み側が待っていた"
"場合の、動作は規定されていない。 B<PTHREAD_RWLOCK_PREFER_READER_NP> に設定"
"し、読み出し側に優先度を与えるということは、 たとえ書き込み側が待っていたとし"
"ても、読み出し側が要求したロックを受け取ることを意味する。 読み出し側がいる限"
"り、書き込み側は待つことになる。"

#. type: TP
#: build/C/man3/pthread_rwlockattr_setkind_np.3:78
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_WRITER_NP>"
msgstr "B<PTHREAD_RWLOCK_PREFER_WRITER_NP>"

#
#
#
#.  ---
#.  Here is the relevant wording:
#.      A thread may hold multiple concurrent read locks on rwlock (that is,
#.      successfully call the pthread_rwlock_rdlock() function n times). If
#.      so, the thread must perform matching unlocks (that is, it must call
#.      the pthread_rwlock_unlock() function n times).
#.  By making write-priority work correctly, I broke the above requirement,
#.  because I had no clue that recursive read locks are permissible.
#.  If a thread which holds a read lock tries to acquire another read lock,
#.  and now one or more writers is waiting for a write lock, then the algorithm
#.  will lead to an obvious deadlock. The reader will be suspended, waiting for
#.  the writers to acquire and release the lock, and the writers will be
#.  suspended waiting for every existing read lock to be released.
#.  ---
#.  https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html
#.  https://sourceware.org/legacy-ml/libc-alpha/2000-01/msg00055.html
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=7057
#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:108
msgid ""
"This is intended as the write lock analog of "
"B<PTHREAD_RWLOCK_PREFER_READER_NP>.  This is ignored by glibc because the "
"POSIX requirement to support recursive read locks would cause this option to "
"create trivial deadlocks; instead use "
"B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP> which ensures the "
"application developer will not take recursive read locks thus avoiding "
"deadlocks."
msgstr ""

#. type: TP
#: build/C/man3/pthread_rwlockattr_setkind_np.3:108
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP>"
msgstr "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP>"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:113
msgid ""
"Setting the lock kind to this avoids writer starvation as long as any read "
"locking is not done in a recursive fashion."
msgstr ""
"ロック種別をこの値に設定すると、 読み出しロックが再帰的に行われない限りは、 "
"書き込み側の待ちを避けることができる。"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:121
msgid ""
"The B<pthread_rwlockattr_getkind_np>()  function returns the value of the "
"lock kind attribute of the read-write lock attribute object referred to by "
"I<attr> in the pointer I<pref>."
msgstr ""
"B<pthread_rwlockattr_getkind_np>() 関数は、 I<attr> が参照する読み書きロック"
"属性オブジェクトのロック種別属性の値をポインター I<pref> に入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:129
msgid ""
"On success, these functions return 0.  Given valid pointer arguments, "
"B<pthread_rwlockattr_getkind_np>()  always succeeds.  On error, "
"B<pthread_rwlockattr_setkind_np>()  returns a nonzero error number."
msgstr ""
"成功すると、これらの関数は 0 を返す。 有効なポインター引き数が渡された場合、 "
"B<pthread_rwlockattr_getkind_np>() は常に成功する。 エラーの場合、 "
"B<pthread_rwlockattr_setkind_np>() は 0 以外のエラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:134
msgid "I<pref> specifies an unsupported value."
msgstr "I<pref> にサポート外の値が指定された。"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:140
msgid ""
"The B<pthread_rwlockattr_getkind_np>()  and "
"B<pthread_rwlockattr_setkind_np>()  functions first appeared in glibc 2.1."
msgstr ""
"関数 B<pthread_rwlockattr_getkind_np>() と "
"B<pthread_rwlockattr_setkind_np>() は glibc 2.1 で初めて登場した。"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:143
msgid ""
"These functions are non-standard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in the names."
msgstr ""
"これらの関数は非標準の GNU による拡張である。 そのため、名前に \"_np\" (non-"
"portable; 移植性がない) という接尾辞が付いている。"

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:145
msgid "B<pthreads>(7)"
msgstr "B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_self.3:26
#, no-wrap
msgid "PTHREAD_SELF"
msgstr "PTHREAD_SELF"

#. type: Plain text
#: build/C/man3/pthread_self.3:29
msgid "pthread_self - obtain ID of the calling thread"
msgstr "pthread_self - 呼び出したスレッドの ID を取得する"

#. type: Plain text
#: build/C/man3/pthread_self.3:34
#, no-wrap
msgid "B<pthread_t pthread_self(void);>\n"
msgstr "B<pthread_t pthread_self(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_self.3:46
msgid ""
"The B<pthread_self>()  function returns the ID of the calling thread.  This "
"is the same value that is returned in I<*thread> in the "
"B<pthread_create>(3)  call that created this thread."
msgstr ""
"B<pthread_self>() 関数は、呼び出したスレッドの ID を返す。\n"
"得られる ID は、このスレッドが作成された B<pthread_create>(3) の\n"
"呼び出しで I<*thread> で返されるのと同じ値である。"

#. type: Plain text
#: build/C/man3/pthread_self.3:48
msgid "This function always succeeds, returning the calling thread's ID."
msgstr "この関数は常に成功し、呼び出したスレッドの ID を返す。"

#. type: tbl table
#: build/C/man3/pthread_self.3:60
#, no-wrap
msgid "B<pthread_self>()"
msgstr "B<pthread_self>()"

#. type: Plain text
#: build/C/man3/pthread_self.3:75
msgid ""
"POSIX.1 allows an implementation wide freedom in choosing the type used to "
"represent a thread ID; for example, representation using either an "
"arithmetic type or a structure is permitted.  Therefore, variables of type "
"I<pthread_t> can't portably be compared using the C equality operator "
"(B<==>); use B<pthread_equal>(3)  instead."
msgstr ""
"POSIX.1 では、スレッド ID を表現するのに使用する型は、\n"
"スレッド実装が完全に自由に選択してよいことになっている。\n"
"例えば、スレッド ID を表現するのに数値型を使っても構造体を使ってもよい。\n"
"そのため、移植性を確保しつつ、 C 言語の等価演算子 (B<==>) を使って、\n"
"I<pthread_t> 型の変数の比較を行うことはできない。\n"
"代わりに B<pthread_equal>(3) を使うこと。"

#. type: Plain text
#: build/C/man3/pthread_self.3:79
msgid ""
"Thread identifiers should be considered opaque: any attempt to use a thread "
"ID other than in pthreads calls is nonportable and can lead to unspecified "
"results."
msgstr ""
"スレッド識別子はその内部構造を意識すべきではない。\n"
"pthreads 関数以外でスレッド ID を利用しようとした場合、\n"
"移植性がなくなり、どのような結果が得られるかも分からない。"

#. type: Plain text
#: build/C/man3/pthread_self.3:83
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  A thread ID "
"may be reused after a terminated thread has been joined, or a detached "
"thread has terminated."
msgstr ""
"スレッド ID の一意性が保証されるのは、あるプロセス内においてのみである。\n"
"終了したスレッドが join されたり、\n"
"切り離された (detached) スレッドが終了されたりした後は、\n"
"そのスレッド ID は再利用されることがある。"

#. type: Plain text
#: build/C/man3/pthread_self.3:88
msgid ""
"The thread ID returned by B<pthread_self>()  is not the same thing as the "
"kernel thread ID returned by a call to B<gettid>(2)."
msgstr ""
"B<pthread_self>() が返すスレッド ID は、\n"
"B<gettid>(2) が返すカーネルスレッド ID とは違うものである。"

#. type: Plain text
#: build/C/man3/pthread_self.3:92
msgid "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_SETAFFINITY_NP"
msgstr "PTHREAD_SETAFFINITY_NP"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:30
msgid ""
"pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a "
"thread"
msgstr ""
"pthread_setaffinity_np, pthread_getaffinity_np - スレッドの\n"
"CPU affinity の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:54
msgid ""
"The B<pthread_setaffinity_np>()  function sets the CPU affinity mask of the "
"thread I<thread> to the CPU set pointed to by I<cpuset>.  If the call is "
"successful, and the thread is not currently running on one of the CPUs in "
"I<cpuset>, then it is migrated to one of those CPUs."
msgstr ""
"B<pthread_setaffinity_np>() 関数は、スレッド I<thread> の CPU affinity\n"
"マスクに I<cpuset> が指す CPU 集合を設定する。呼び出しが成功し、\n"
"そのスレッドが現在 I<cpuset> で指定された CPU 上でが実行されていない\n"
"場合は、スレッドは指定された CPU のいずれかに移動される。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:61
msgid ""
"The B<pthread_getaffinity_np>()  function returns the CPU affinity mask of "
"the thread I<thread> in the buffer pointed to by I<cpuset>."
msgstr ""
"B<pthread_getaffinity_np>() 関数は、スレッド I<thread> の CPU affinity\n"
"マスクを、I<cpuset> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:77
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>.  (It may be some other value, if using the macros "
"described in B<CPU_SET>(3)  for dynamically allocating a CPU set.)"
msgstr ""
"引き数 I<cpusetsize> は I<cpuset> が指すバッファーの長さ (バイト単位) で\n"
"ある。通常は、この引き数には I<sizeof(cpu_set_t)> を指定する\n"
"(B<CPU_SET>(3) に書かれているマクロを使って CPU 集合を動的に\n"
"割り当てている場合には、別の値になることもある)。"

#. type: TP
#: build/C/man3/pthread_setaffinity_np.3:81
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:84
msgid "A supplied memory address was invalid."
msgstr "指定されたメモリーアドレスが無効である。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:93
msgid ""
"(B<pthread_setaffinity_np>())  The affinity bit mask I<mask> contains no "
"processors that are currently physically on the system and permitted to the "
"thread according to any restrictions that may be imposed by the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""
"(B<pthread_setaffinity_np>()) affinity ビットマスク I<mask> に、\n"
"その時点でシステム上に物理的に存在して、かつそのスレッドに対して許可\n"
"されているプロセッサが一つも含まれていない。\n"
"スレッドに対してどのプロセッサの利用が許可されるかは、B<cpuset>(7) で\n"
"説明されている \"cpuset\" 機構に適用される制限に基づいて決まる。"

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:105
msgid ""
"(B<pthread_setaffinity_np>())  I<cpuset> specified a CPU that was outside "
"the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""
"(B<pthread_setaffinity_np>()) I<cpuset> が、カーネルがサポートする CPU\n"
"集合に含まれない CPU を指定していた。(カーネルの設定オプション\n"
"B<CONFIG_NR_CPUS> により、CPU 集合を表現するのに使われるカーネルの\n"
"データ型がサポートする CPU 集合の範囲が定義される。)"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:110
msgid ""
"(B<pthread_getaffinity_np>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""
"(B<pthread_getaffinity_np>()) I<cpusetsize> がカーネルが使用する\n"
"affinity マスクの大きさよりも小さい。"

#. type: tbl table
#: build/C/man3/pthread_setaffinity_np.3:128
#, no-wrap
msgid ""
"B<pthread_setaffinity_np>(),\n"
"B<pthread_getaffinity_np>()"
msgstr ""
"B<pthread_setaffinity_np>(),\n"
"B<pthread_getaffinity_np>()"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:146
msgid ""
"After a call to B<pthread_setaffinity_np>(), the set of CPUs on which the "
"thread will actually run is the intersection of the set specified in the "
"I<cpuset> argument and the set of CPUs actually present on the system.  The "
"system may further restrict the set of CPUs on which the thread runs if the "
"\"cpuset\" mechanism described in B<cpuset>(7)  is being used.  These "
"restrictions on the actual set of CPUs on which the thread will run are "
"silently imposed by the kernel."
msgstr ""
"B<pthread_setaffinity_np>() を呼び出した後、\n"
"そのスレッドが実際に実行される CPU 集合は、\n"
"I<cpuset> 引き数で指定された集合と\n"
"システムに実際に存在する CPU 集合の共通部分になる。\n"
"また、 B<cpuset>(7) で説明されている \"cpuset\" 機構が使われている場合\n"
"には、そのスレッドが実行される CPU 集合がシステムによってさらに制限\n"
"される場合がある。そのスレッドが実行される実際の CPU 集合に対する\n"
"これらの制限は、カーネルにより黙って適用される。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:152
msgid ""
"These functions are implemented on top of the B<sched_setaffinity>(2)  and "
"B<sched_getaffinity>(2)  system calls."
msgstr ""
"これらの関数は、システムコール B<sched_setaffinity>(2) と\n"
"B<sched_getaffinity>(2) を使って実装されている。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:163
msgid ""
"A new thread created by B<pthread_create>(3)  inherits a copy of its "
"creator's CPU affinity mask."
msgstr ""
"B<pthread_create>(3) で作成される新しいスレッドは、\n"
"作成者の CPU affinity マスクを継承する。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:171
msgid ""
"In the following program, the main thread uses B<pthread_setaffinity_np>()  "
"to set its CPU affinity mask to include CPUs 0 to 7 (which may not all be "
"available on the system), and then calls B<pthread_getaffinity_np>()  to "
"check the resulting CPU affinity mask of the thread."
msgstr ""
"以下のプログラムでは、メインスレッドは\n"
"B<pthread_setaffinity_np>() を使って自分の CPU affinity マスクに\n"
"CPU 0 から 7 が含まれるように設定し\n"
"(システム上には 0 から 7 に対応する CPU が全て存在するとは限らない)、\n"
"その後で B<pthread_getaffinity_np>() を使って\n"
"スレッドに実際に設定された CPU affinity マスクを確認している。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:178
#: build/C/man3/pthread_getattr_default_np.3:125
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:188
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:190
#, no-wrap
msgid "    thread = pthread_self();\n"
msgstr "    thread = pthread_self();\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:192
#, no-wrap
msgid "    /* Set affinity mask to include CPUs 0 to 7 */\n"
msgstr "    /* Set affinity mask to include CPUs 0 to 7 */\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:196
#, no-wrap
msgid ""
"    CPU_ZERO(&cpuset);\n"
"    for (int j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"
msgstr ""
"    CPU_ZERO(&cpuset);\n"
"    for (int j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:200
#, no-wrap
msgid ""
"    s = pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"
msgstr ""
"    s = pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:202
#, no-wrap
msgid "    /* Check the actual affinity mask assigned to the thread */\n"
msgstr "    /* Check the actual affinity mask assigned to the thread */\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:206
#, no-wrap
msgid ""
"    s = pthread_getaffinity_np(thread, sizeof(cpuset), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"
msgstr ""
"    s = pthread_getaffinity_np(thread, sizeof(cpuset), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:211
#, no-wrap
msgid ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (int j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"
msgstr ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (int j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:214
#: build/C/man3/pthread_setschedparam.3:445
#: build/C/man3/pthread_getattr_default_np.3:195
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:224
msgid ""
"B<sched_setaffinity>(2), B<CPU_SET>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_self>(3), B<sched_getcpu>(3), B<cpuset>(7), B<pthreads>(7), "
"B<sched>(7)"
msgstr "B<sched_setaffinity>(2), B<CPU_SET>(3), B<pthread_attr_setaffinity_np>(3), B<pthread_self>(3), B<sched_getcpu>(3), B<cpuset>(7), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_setcancelstate.3:26
#, no-wrap
msgid "PTHREAD_SETCANCELSTATE"
msgstr "PTHREAD_SETCANCELSTATE"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:30
msgid ""
"pthread_setcancelstate, pthread_setcanceltype - set cancelability state and "
"type"
msgstr ""
"pthread_setcancelstate, pthread_setcanceltype - cancelability state と "
"cancelability type を設定する"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:36
#, no-wrap
msgid ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"
msgstr ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:51
msgid ""
"The B<pthread_setcancelstate>()  sets the cancelability state of the calling "
"thread to the value given in I<state>.  The previous cancelability state of "
"the thread is returned in the buffer pointed to by I<oldstate>.  The "
"I<state> argument must have one of the following values:"
msgstr ""
"B<pthread_setcancelstate>() は、呼び出したスレッドの\n"
"cancelability state に I<state> で指定された\n"
"値を設定する。変更前のスレッドの cancelability state は\n"
"I<oldstate> が指すバッファーで返される。\n"
"I<state> 引き数には以下の値のいずれか一つを指定しなければならない。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:51
#, no-wrap
msgid "B<PTHREAD_CANCEL_ENABLE>"
msgstr "B<PTHREAD_CANCEL_ENABLE>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:58
msgid ""
"The thread is cancelable.  This is the default cancelability state in all "
"new threads, including the initial thread.  The thread's cancelability type "
"determines when a cancelable thread will respond to a cancellation request."
msgstr ""
"スレッドは取り消し可能 (cancelable) である。\n"
"これが全ての新しく作成されるスレッドでのデフォルトの\n"
"cancelability state である。これには最初のスレッドも含まれる。\n"
"スレッドの cancelability type により、取り消し可能なスレッドが\n"
"取り消し要求にいつ反応するかが決まる。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:58
#, no-wrap
msgid "B<PTHREAD_CANCEL_DISABLE>"
msgstr "B<PTHREAD_CANCEL_DISABLE>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:63
msgid ""
"The thread is not cancelable.  If a cancellation request is received, it is "
"blocked until cancelability is enabled."
msgstr ""
"スレッドは取り消しできない。取り消し要求を受信した際は、\n"
"取り消し可能に設定されるまでその要求はブロックされる。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:75
msgid ""
"The B<pthread_setcanceltype>()  sets the cancelability type of the calling "
"thread to the value given in I<type>.  The previous cancelability type of "
"the thread is returned in the buffer pointed to by I<oldtype>.  The I<type> "
"argument must have one of the following values:"
msgstr ""
"B<pthread_setcanceltype>() は、呼び出したスレッドの\n"
"cancelability type に I<type> で指定された値を設定する。\n"
"変更前のスレッドの cancelability type は\n"
"I<oldtype> が指すバッファーで返される。\n"
"I<type> 引き数には以下の値のいずれか一つを指定しなければならない。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:75
#, no-wrap
msgid "B<PTHREAD_CANCEL_DEFERRED>"
msgstr "B<PTHREAD_CANCEL_DEFERRED>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:82
msgid ""
"A cancellation request is deferred until the thread next calls a function "
"that is a cancellation point (see B<pthreads>(7)).  This is the default "
"cancelability type in all new threads, including the initial thread."
msgstr ""
"そのスレッドが次に取り消しポイント (cancellation point) の関数を\n"
"呼び出すまで取り消し要求が遅延される。これが全ての新しく作成される\n"
"スレッドでのデフォルトの cancelability type である。\n"
"これには最初のスレッドも含まれる。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:87
msgid ""
"Even with deferred cancellation, a cancellation point in an asynchronous "
"signal handler may still be acted upon and the effect is as if it was an "
"asynchronous cancellation."
msgstr ""

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:87
#, no-wrap
msgid "B<PTHREAD_CANCEL_ASYNCHRONOUS>"
msgstr "B<PTHREAD_CANCEL_ASYNCHRONOUS>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:93
msgid ""
"The thread can be canceled at any time.  (Typically, it will be canceled "
"immediately upon receiving a cancellation request, but the system doesn't "
"guarantee this.)"
msgstr ""
"スレッドはいつでも取り消すことができる (通常はすぐにキャンセルされるが、\n"
"システムがそのことを保証しているわけではない)。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:97
msgid ""
"The set-and-get operation performed by each of these functions is atomic "
"with respect to other threads in the process calling the same function."
msgstr ""
"これらの関数により実行される「設定と取得」操作 (set-and-get operation) は、\n"
"同じ関数を呼び出したプロセス内の他のスレッドがあっても、\n"
"アトミックに行われる。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:104
msgid "The B<pthread_setcancelstate>()  can fail with the following error:"
msgstr "B<pthread_setcancelstate>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:108
msgid "Invalid value for I<state>."
msgstr "I<state> に無効な値が指定された。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:112
msgid "The B<pthread_setcanceltype>()  can fail with the following error:"
msgstr "B<pthread_setcanceltype>() は以下のエラーで失敗する場合がある。"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:118
msgid "Invalid value for I<type>."
msgstr "I<type> に無効な値が指定された。"

#. type: tbl table
#: build/C/man3/pthread_setcancelstate.3:130
#: build/C/man3/pthread_setcancelstate.3:136
#, no-wrap
msgid ""
"B<pthread_setcancelstate>(),\n"
"B<pthread_setcanceltype>()"
msgstr ""
"B<pthread_setcancelstate>(),\n"
"B<pthread_setcanceltype>()"

#. type: tbl table
#: build/C/man3/pthread_setcancelstate.3:136
#, no-wrap
msgid "Async-cancel-safety"
msgstr "Async-cancel-safety"

#. type: tbl table
#: build/C/man3/pthread_setcancelstate.3:138
#, no-wrap
msgid "AC-Safe"
msgstr "AC-Safe"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:147
msgid ""
"For details of what happens when a thread is canceled, see "
"B<pthread_cancel>(3)."
msgstr ""
"スレッドが取り消された場合に何が起こるかの詳細については\n"
"B<pthread_cancel>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:154
msgid ""
"Briefly disabling cancelability is useful if a thread performs some critical "
"action that must not be interrupted by a cancellation request.  Beware of "
"disabling cancelability for long periods, or around operations that may "
"block for long periods, since that will render the thread unresponsive to "
"cancellation requests."
msgstr ""
"取り消し要求により中断されてはならない重要なアクションをスレッドが\n"
"実行する場合、短い時間だけ cancelability を無効にするのは有用である。\n"
"長い時間 cancelability を無効にしたり、長い時間停止 (block) される\n"
"可能性のある操作の前後で cancelability を無効にしたりする際には\n"
"注意すること。なぜなら、無効にしてしまうと、キャンセル要求に対して\n"
"スレッドが応答しない状態になってしまうからである。"

#. type: SS
#: build/C/man3/pthread_setcancelstate.3:154
#, no-wrap
msgid "Asynchronous cancelability"
msgstr "非同期キャンセル"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:173
msgid ""
"Setting the cancelability type to B<PTHREAD_CANCEL_ASYNCHRONOUS> is rarely "
"useful.  Since the thread could be canceled at I<any> time, it cannot safely "
"reserve resources (e.g., allocating memory with B<malloc>(3)), acquire "
"mutexes, semaphores, or locks, and so on.  Reserving resources is unsafe "
"because the application has no way of knowing what the state of these "
"resources is when the thread is canceled; that is, did cancellation occur "
"before the resources were reserved, while they were reserved, or after they "
"were released? Furthermore, some internal data structures (e.g., the linked "
"list of free blocks managed by the B<malloc>(3)  family of functions) may be "
"left in an inconsistent state if cancellation occurs in the middle of the "
"function call.  Consequently, clean-up handlers cease to be useful."
msgstr ""
"cancelability type を B<PTHREAD_CANCEL_ASYNCHRONOUS> に設定して役に立つことは"
"めったにない。スレッドはI<いつでも>キャンセルすることができることになるので、"
"スレッドが安全にリソースの確保 (例えば B<malloc>(3) でメモリーを割り当てる) "
"や mutex、セマフォ、ロックなどの獲得を行うことができない。アプリケーション"
"は、スレッドがキャンセルされる際に、これらのリソースがどのような状態にあるか"
"を知る術はないので、リソースの確保が安全ではなくなる。つまり、キャンセルが起"
"こったのが、リソースの確保前なのか、確保中なのか、確保後なのかが分からない。"
"さらに、関数呼び出しの最中にキャンセルが発生すると、いくつかの内部データ構造 "
"(例えば、B<malloc>(3) 関連の関数が管理している未使用ブロックのリンクリスト) "
"が一貫性のない状態のままになってしまう可能性がある。その結果、クリーンアップ"
"ハンドラーが役に立たないものになってしまう。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:184
msgid ""
"Functions that can be safely asynchronously canceled are called I<async-"
"cancel-safe functions>.  POSIX.1-2001 and POSIX.1-2008 require only that "
"B<pthread_cancel>(3), B<pthread_setcancelstate>(), and "
"B<pthread_setcanceltype>()  be async-cancel-safe.  In general, other library "
"functions can't be safely called from an asynchronously cancelable thread."
msgstr "非同期で安全にキャンセルできる関数は I<async-cancel-safe functions> と呼ばれる。 POSIX.1-2001 と POSIX.1-2008 で、非同期で安全にキャンセルできるように求められている関数は B<pthread_cancel>(3), B<pthread_setcancelstate>(), B<pthread_setcanceltype>() だけである。 一般的には、それ以外のライブラリ関数は、非同期にキャンセルできるスレッドから安全に呼び出すことはできない。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:187
msgid ""
"One of the few circumstances in which asynchronous cancelability is useful "
"is for cancellation of a thread that is in a pure compute-bound loop."
msgstr ""
"非同期でのキャンセルが有効な数少ない状況としては、純粋に計算だけを行うループ"
"に入っているスレッドをキャンセルするといった場面がある。"

#. type: SS
#: build/C/man3/pthread_setcancelstate.3:187
#, no-wrap
msgid "Portability notes"
msgstr "移植性に関する注意"

#.  It looks like at least Solaris, FreeBSD and Tru64 support this.
#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:205
msgid ""
"The Linux threading implementations permit the I<oldstate> argument of "
"B<pthread_setcancelstate>()  to be NULL, in which case the information about "
"the previous cancelability state is not returned to the caller.  Many other "
"implementations also permit a NULL I<oldstat> argument, but POSIX.1 does not "
"specify this point, so portable applications should always specify a non-"
"NULL value in I<oldstate>.  A precisely analogous set of statements applies "
"for the I<oldtype> argument of B<pthread_setcanceltype>()."
msgstr "Linux のスレッド実装では、 B<pthread_setcancelstate>() の I<oldstate> 引き数に NULL を指定することを認めている。 NULL が指定された場合、変更前の cancelability state の情報が呼び出し側に返されない。他の多くの実装でも I<oldstate> 引き数に NULL を指定することを認めているが、 POSIX.1 ではこの点については規定されていない。したがって、移植性が必要なアプリケーションでは常に I<oldstate> に NULL 以外の値を指定するようにすべきである。 B<pthread_setcanceltype>() の I<oldtype> 引き数についても、全く同じことが言える。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:208
msgid "See B<pthread_cancel>(3)."
msgstr "B<pthread_cancel>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:213
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setconcurrency.3:25
#, no-wrap
msgid "PTHREAD_SETCONCURRENCY"
msgstr "PTHREAD_SETCONCURRENCY"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:29
msgid ""
"pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency "
"level"
msgstr ""
"pthread_setconcurrency, pthread_getconcurrency - 並列処理レベルの設定/取得を"
"行う"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:35
#, no-wrap
msgid ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(>I<void>B<);>\n"
msgstr ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(>I<void>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:48
msgid ""
"The B<pthread_setconcurrency>()  function informs the implementation of the "
"application's desired concurrency level, specified in I<new_level>.  The "
"implementation takes this only as a hint: POSIX.1 does not specify the level "
"of concurrency that should be provided as a result of calling "
"B<pthread_setconcurrency>()."
msgstr ""
"B<pthread_setconcurrency>() 関数は、アプリケーションが希望する\n"
"並列処理レベル (concurrency level) をスレッド実装に通知する。\n"
"希望する並列処理レベルは I<new_level> で指定する。\n"
"スレッド実装はこの情報をヒントとしてのみ利用する。\n"
"POSIX.1 では、 B<pthread_setconcurrency>() の呼び出した結果、\n"
"どのような並列度になるべきかは規定されていない。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:53
msgid ""
"Specifying I<new_level> as 0 instructs the implementation to manage the "
"concurrency level as it deems appropriate."
msgstr ""
"I<new_level> に 0 を指定すると、スレッド実装は並列処理レベルを\n"
"実装側で適切とみなしたレベルに設定するようになる。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:56
msgid ""
"B<pthread_getconcurrency>()  returns the current value of the concurrency "
"level for this process."
msgstr ""
"B<pthread_getconcurrency>() は、このプロセスの concurrency level\n"
"の現在値を返す。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:61
msgid ""
"On success, B<pthread_setconcurrency>()  returns 0; on error, it returns a "
"nonzero error number."
msgstr ""
"成功すると、 B<pthread_setconcurrency>() は 0 を返す。\n"
"エラーの場合、 0 以外のエラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:68
msgid ""
"B<pthread_getconcurrency>()  always succeeds, returning the concurrency "
"level set by a previous call to B<pthread_setconcurrency>(), or 0, if "
"B<pthread_setconcurrency>()  has not previously been called."
msgstr ""
"B<pthread_getconcurrency>() は常に成功し、最後の\n"
"B<pthread_getconcurrency>() の呼び出しで設定された \n"
"concurrency level を返す。 B<pthread_getconcurrency>() が\n"
"それまでに一度も呼び出されていない場合は 0 が返る。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:71
msgid "B<pthread_setconcurrency>()  can fail with the following error:"
msgstr "B<pthread_setconcurrency>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:75
msgid "I<new_level> is negative."
msgstr "I<new_level> が負である。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:81
#, fuzzy
#| msgid ""
#| "POSIX.1-2001 also documents an B<EAGAIN> error (\"the value specified by "
#| "I<new_level> would cause a system resource to be exceeded\")."
msgid ""
"POSIX.1 also documents an B<EAGAIN> error (\"the value specified by "
"I<new_level> would cause a system resource to be exceeded\")."
msgstr ""
"POSIX.1-2001 には、エラー B<EAGAIN> も記載されている\n"
"(「I<new_level> に指定された値を適用すると、システムリソースが\n"
"超過してしまう」)。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:83
msgid "These functions are available in glibc since version 2.1."
msgstr "これらの関数は glibc バージョン 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/pthread_setconcurrency.3:94
#, no-wrap
msgid ""
"B<pthread_setconcurrency>(),\n"
"B<pthread_getconcurrency>()"
msgstr ""
"B<pthread_setconcurrency>(),\n"
"B<pthread_getconcurrency>()"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:100
msgid "The default concurrency level is 0."
msgstr "デフォルトの concurrency level は 0 である。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:107
msgid ""
"Concurrency levels are meaningful only for M:N threading implementations, "
"where at any moment a subset of a process's set of user-level threads may be "
"bound to a smaller number of kernel-scheduling entities.  Setting the "
"concurrency level allows the application to give the system a hint as to the "
"number of kernel-scheduling entities that should be provided for efficient "
"execution of the application."
msgstr ""
"並列処理レベルが意味を持つのは M:N スレッド実装の場合のみである。\n"
"M:N スレッド実装では、ある瞬間において、あるプロセスのユーザーレベルスレッ\n"
"ドの集合のサブ集合が、そのサブ集合のサイズよりも少ない数のカーネルの\n"
"スケジューリング実体 (kernel-scheduling entity) に結び付けられる。\n"
"並列処理レベルを設定すると、そのアプリケーションの効率的な実行に必要な\n"
"カーネルのスケジューリング実体の数のヒントを、アプリケーションはシステ\n"
"ムに伝えることができる。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:113
msgid ""
"Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the "
"concurrency level has no meaning.  In other words, on Linux these functions "
"merely exist for compatibility with other systems, and they have no effect "
"on the execution of a program."
msgstr ""
"LinuxThreads と NPTL のどちらも 1:1 スレッド実装であり、\n"
"並列処理レベルを設定しても何の意味もない。\n"
"言い換えると、 Linux では、これらの関数は、\n"
"他のシステムとの互換性のためだけに存在し、\n"
"プログラムの実行には何の影響も与えないということである。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:116
msgid "B<pthread_attr_setscope>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_setscope>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setname_np.3:26
#, no-wrap
msgid "PTHREAD_SETNAME_NP"
msgstr "PTHREAD_SETNAME_NP"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:29
msgid "pthread_setname_np, pthread_getname_np - set/get the name of a thread"
msgstr "pthread_setname_np, pthread_getname_np - スレッド名の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:36
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
"B<int pthread_setname_np(pthread_t >I<thread>B<, const char *>I<name>B<);>\n"
"B<int pthread_getname_np(pthread_t >I<thread>B<,>\n"
"B<                       char *>I<name>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
"B<int pthread_setname_np(pthread_t >I<thread>B<, const char *>I<name>B<);>\n"
"B<int pthread_getname_np(pthread_t >I<thread>B<,>\n"
"B<                       char *>I<name>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:55
msgid ""
"By default, all the threads created using B<pthread_create>()  inherit the "
"program name.  The B<pthread_setname_np>()  function can be used to set a "
"unique name for a thread, which can be useful for debugging multithreaded "
"applications.  The thread name is a meaningful C language string, whose "
"length is restricted to 16 characters, including the terminating null byte "
"(\\(aq\\e0\\(aq).  The I<thread> argument specifies the thread whose name is "
"to be changed; I<name> specifies the new name."
msgstr ""
"デフォルトでは、 B<pthread_create>() で作成されたすべてのスレッドはプログラム"
"名を継承する。 B<pthread_setname_np>() 関数を使うとスレッドに固有の名前を設定"
"することができる。 スレッド固有の名前はマルチスレッドアプリケーションのデバッ"
"グに便利である。 スレッド名は意味のある C 言語の文字列である。 その長さは 16 "
"文字に限定されており、 終端のヌルバイト (\\(aq\\e0\\(aq) も 16 文字に含まれ"
"る。 I<thread> 引き数で名前を変更するスレッドを指定する。 I<name> には新しい"
"名前を指定する。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:72
msgid ""
"The B<pthread_getname_np>()  function can be used to retrieve the name of "
"the thread.  The I<thread> argument specifies the thread whose name is to be "
"retrieved.  The buffer I<name> is used to return the thread name; I<len> "
"specifies the number of bytes available in I<name>.  The buffer specified by "
"I<name> should be at least 16 characters in length.  The returned thread "
"name in the output buffer will be null terminated."
msgstr ""
"B<pthread_getname_np>() 関数を使うと、 スレッド名を取得することができる。 "
"I<thread> 引き数は名前を取得するスレッドを指定する。 バッファー I<name> はス"
"レッド名を返すのに使用される。 I<len> には I<name> の大きさをバイトで指定す"
"る。 I<name> で指定されたバッファーの大きさは最低でも 16 文字とすべきであ"
"る。 出力バッファーに返されたスレッド名はヌル終端される。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:79
msgid ""
"The B<pthread_setname_np>()  function can fail with the following error:"
msgstr "B<pthread_setname_np>() は以下のエラーで失敗する場合がある。"

#. type: TP
#: build/C/man3/pthread_setname_np.3:79 build/C/man3/pthread_setname_np.3:88
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:84
msgid ""
"The length of the string specified pointed to by I<name> exceeds the allowed "
"limit."
msgstr "I<name> で指定された文字列の長さが、許可されている上限を超えている。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:88
msgid ""
"The B<pthread_getname_np>()  function can fail with the following error:"
msgstr "B<pthread_getname_np>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:95
msgid ""
"The buffer specified by I<name> and I<len> is too small to hold the thread "
"name."
msgstr ""
"I<name> と I<len> で指定されたバッファーが、 スレッド名を格納するには短かすぎ"
"る。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:100
msgid ""
"If either of these functions fails to open I</proc/self/task/[tid]/comm>, "
"then the call may fail with one of the errors described in B<open>(2)."
msgstr ""
"I</proc/self/task/[tid]/comm> のオープンに失敗した場合、 これらの関数は "
"B<open>(2) で説明されているエラーのいずれかで失敗する。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:102
msgid "These functions first appeared in glibc in version 2.12."
msgstr "これらの関数は glibc バージョン 2.12 で初めて登場した。"

#. type: tbl table
#: build/C/man3/pthread_setname_np.3:113
#, no-wrap
msgid ""
"B<pthread_setname_np>(),\n"
"B<pthread_getname_np>()"
msgstr ""
"B<pthread_setname_np>(),\n"
"B<pthread_getname_np>()"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:129
msgid ""
"B<pthread_setname_np>()  internally writes to the thread-specific I<comm> "
"file under the I</proc> filesystem: I</proc/self/task/[tid]/comm>.  "
"B<pthread_getname_np>()  retrieves it from the same location."
msgstr ""
"B<pthread_setname_np>() は内部で I</proc> ファイルシステムのスレッド固有の "
"I<comm> ファイル (I</proc/self/task/[tid]/comm>) に書き込みを行う。 "
"B<pthread_getname_np>() はこのファイルから読み出しを行う。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:134
msgid ""
"The program below demonstrates the use of B<pthread_setname_np>()  and "
"B<pthread_getname_np>()."
msgstr ""
"以下のプログラムは、 B<pthread_setname_np>() と B<pthread_getname_np>()\n"
"の使用例を示している。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:136
msgid "The following shell session shows a sample run of the program:"
msgstr "以下のシェルセッションは、このプログラムの実行例である。"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:152
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Created a thread. Default name is: a.out\n"
"The thread name after setting it is THREADFOO.\n"
"B<\\(haZ>                           # Suspend the program\n"
"[1]+  Stopped           ./a.out\n"
"$ B<ps H -C a.out -o \\(aqpid tid cmd comm\\(aq>\n"
"  PID   TID CMD                         COMMAND\n"
" 5990  5990 ./a.out                     a.out\n"
" 5990  5991 ./a.out                     THREADFOO\n"
"$ B<cat /proc/5990/task/5990/comm>\n"
"a.out\n"
"$ B<cat /proc/5990/task/5991/comm>\n"
"THREADFOO\n"
msgstr ""
"$B< ./a.out>\n"
"Created a thread. Default name is: a.out\n"
"The thread name after setting it is THREADFOO.\n"
"B<\\(haZ>                           # Suspend the program\n"
"[1]+  Stopped           ./a.out\n"
"$ B<ps H -C a.out -o \\(aqpid tid cmd comm\\(aq>\n"
"  PID   TID CMD                         COMMAND\n"
" 5990  5990 ./a.out                     a.out\n"
" 5990  5991 ./a.out                     THREADFOO\n"
"$ B<cat /proc/5990/task/5990/comm>\n"
"a.out\n"
"$ B<cat /proc/5990/task/5991/comm>\n"
"THREADFOO\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:164
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:166
#, no-wrap
msgid "#define NAMELEN 16\n"
msgstr "#define NAMELEN 16\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:170
#: build/C/man3/pthread_getattr_default_np.3:129
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:177
#, no-wrap
msgid ""
"static void *\n"
"threadfunc(void *parm)\n"
"{\n"
"    sleep(5);          // allow main program to set the thread name\n"
"    return NULL;\n"
"}\n"
msgstr ""
"static void *\n"
"threadfunc(void *parm)\n"
"{\n"
"    sleep(5);          // allow main program to set the thread name\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:184
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    pthread_t thread;\n"
"    int rc;\n"
"    char thread_name[NAMELEN];\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    pthread_t thread;\n"
"    int rc;\n"
"    char thread_name[NAMELEN];\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:188
#, no-wrap
msgid ""
"    rc = pthread_create(&thread, NULL, threadfunc, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_create\");\n"
msgstr ""
"    rc = pthread_create(&thread, NULL, threadfunc, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:192
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name, NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
msgstr ""
"    rc = pthread_getname_np(thread, thread_name, NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:197
#, no-wrap
msgid ""
"    printf(\"Created a thread. Default name is: %s\\en\", thread_name);\n"
"    rc = pthread_setname_np(thread, (argc E<gt> 1) ? argv[1] : \"THREADFOO\");\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_setname_np\");\n"
msgstr ""
"    printf(\"Created a thread. Default name is: %s\\en\", thread_name);\n"
"    rc = pthread_setname_np(thread, (argc E<gt> 1) ? argv[1] : \"THREADFOO\");\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_setname_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:199
#: build/C/man3/pthread_mutexattr_setrobust.3:250
#, no-wrap
msgid "    sleep(2);\n"
msgstr "    sleep(2);\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:205
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name,\n"
"                            (argc E<gt> 2) ? atoi(argv[1]) : NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
"    printf(\"The thread name after setting it is %s.\\en\", thread_name);\n"
msgstr ""
"    rc = pthread_getname_np(thread, thread_name,\n"
"                            (argc E<gt> 2) ? atoi(argv[1]) : NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
"    printf(\"The thread name after setting it is %s.\\en\", thread_name);\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:209
#, no-wrap
msgid ""
"    rc = pthread_join(thread, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_join\");\n"
msgstr ""
"    rc = pthread_join(thread, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:213
#, no-wrap
msgid ""
"    printf(\"Done\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Done\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:220
msgid "B<prctl>(2), B<pthread_create>(3), B<pthreads>(7)"
msgstr "B<prctl>(2), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr "PTHREAD_SETSCHEDPARAM"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:30
msgid ""
"pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and "
"parameters of a thread"
msgstr ""
"pthread_setschedparam, pthread_getschedparam - スレッドの\n"
"スケジューリングポリシーとパラメーターを設定/取得する"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                          const struct sched_param *>I<param>B<);>\n"
"B<int pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                          struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<int pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                          const struct sched_param *>I<param>B<);>\n"
"B<int pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                          struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:46
msgid ""
"The B<pthread_setschedparam>()  function sets the scheduling policy and "
"parameters of the thread I<thread>."
msgstr ""
"B<pthread_setschedparam>() 関数は、スレッド I<thread> の\n"
"スケジューリングポリシーとスケジューリングパラメーターを設定する。"

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:57
msgid ""
"I<policy> specifies the new scheduling policy for I<thread>.  The supported "
"values for I<policy>, and their semantics, are described in B<sched>(7)."
msgstr ""
"I<policy> は I<thread> の新しいスケジューリングポリシーを指定する。 "
"I<policy> に指定できる値とその意味は B<sched>(7) で説明されている。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:63
msgid ""
"The structure pointed to by I<param> specifies the new scheduling parameters "
"for I<thread>.  Scheduling parameters are maintained in the following "
"structure:"
msgstr ""
"I<param> が指す構造体は I<thread> の新しいスケジューリングパラメーターを\n"
"指定する。スケジューリングパラメーターは以下の構造体で管理される。"

#.  FIXME . nptl/pthread_setschedparam.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:104
msgid ""
"The B<pthread_getschedparam>()  function returns the scheduling policy and "
"parameters of the thread I<thread>, in the buffers pointed to by I<policy> "
"and I<param>, respectively.  The returned priority value is that set by the "
"most recent B<pthread_setschedparam>(), B<pthread_setschedprio>(3), or "
"B<pthread_create>(3)  call that affected I<thread>.  The returned priority "
"does not reflect any temporary priority adjustments as a result of calls to "
"any priority inheritance or priority ceiling functions (see, for example, "
"B<pthread_mutexattr_setprioceiling>(3)  and "
"B<pthread_mutexattr_setprotocol>(3))."
msgstr ""
"B<pthread_getschedparam>() 関数は、スレッド I<thread> の\n"
"スケジューリングポリシーとパラメーターを、\n"
"それぞれ I<policy> と I<param> が指すバッファーに入れて返す。\n"
"返された優先度の値は、最も最近実行した I<thread> に影響を与える\n"
"B<pthread_setschedparam>(), B<pthread_setschedprio>,\n"
"B<pthread_create> で設定された値となる。\n"
"返された優先度は、優先度の継承や優先度の上限を設定する関数\n"
"(例えば B<pthread_mutexattr_setprioceiling>(3) や\n"
"B<pthread_mutexattr_setprotocol>(3) を参照) の呼び出しの結果\n"
"行われる一時的な優先度の調整の影響を受けない。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:112
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number.  If B<pthread_setschedparam>()  fails, the scheduling policy and "
"parameters of I<thread> are not changed."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。\n"
"B<pthread_setschedparam>() が失敗した場合、 I<thread> の\n"
"スケジューリングポリシーとパラメーターは変更されない。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:114
msgid "Both of these functions can fail with the following error:"
msgstr "これらの関数はどちらも以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:122
msgid ""
"B<pthread_setschedparam>()  may additionally fail with the following errors:"
msgstr "B<pthread_setschedparam>() はさらに以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:129
msgid ""
"I<policy> is not a recognized policy, or I<param> does not make sense for "
"the I<policy>."
msgstr ""
"I<policy> が認識できないポリシーであるか、\n"
"I<param> が I<policy> では意味を持たない値である。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:133
msgid ""
"The caller does not have appropriate privileges to set the specified "
"scheduling policy and parameters."
msgstr ""
"呼び出し側が、指定されたスケジューリングポリシーやパラメーターを設定する\n"
"のに必要な特権を持たない。"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:141
msgid ""
"POSIX.1 also documents an B<ENOTSUP> (\"attempt was made to set the policy "
"or scheduling parameters to an unsupported value\") error for "
"B<pthread_setschedparam>()."
msgstr ""
"POSIX.1 では、 B<pthread_setschedparam>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値をスケジューリングポリシーや\n"
"パラメーターに設定しようとした\") も追加で規定されている。"

#. type: tbl table
#: build/C/man3/pthread_setschedparam.3:152
#, no-wrap
msgid ""
"B<pthread_setschedparam>(),\n"
"B<pthread_getschedparam>()"
msgstr ""
"B<pthread_setschedparam>(),\n"
"B<pthread_getschedparam>()"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:162
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling policy and priority, and details of the "
"permitted ranges for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""
"スレッドのスケジューリングポリシーや優先度を変更するために必要な許可や変更し"
"た場合の影響、および各スケジューリングポリシーで認められる優先度の範囲の詳細"
"については、 B<sched>(7) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:169
msgid ""
"The program below demonstrates the use of B<pthread_setschedparam>()  and "
"B<pthread_getschedparam>(), as well as the use of a number of other "
"scheduling-related pthreads functions."
msgstr ""
"以下のプログラムは B<pthread_setschedparam>() と\n"
"B<pthread_getschedparam>() やスケジューリングに関連する pthreads の\n"
"他のいろいろな関数の使用例を示すものである。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:185
msgid ""
"In the following run, the main thread sets its scheduling policy to "
"B<SCHED_FIFO> with a priority of 10, and initializes a thread attributes "
"object with a scheduling policy attribute of B<SCHED_RR> and a scheduling "
"priority attribute of 20.  The program then sets (using "
"B<pthread_attr_setinheritsched>(3))  the inherit scheduler attribute of the "
"thread attributes object to B<PTHREAD_EXPLICIT_SCHED>, meaning that threads "
"created using this attributes object should take their scheduling attributes "
"from the thread attributes object.  The program then creates a thread using "
"the thread attributes object, and that thread displays its scheduling policy "
"and priority."
msgstr ""
"以下の実行例では、メインスレッドは、自分のスケジューリングポリシーを\n"
"優先度 10 の B<SCHED_FIFO> を設定し、スレッド属性オブジェクトを\n"
"スケジューリングポリシー属性 B<SCHED_RR> とスケジューリング優先度\n"
"属性 20 で初期化する。\n"
"次に、このプログラムは (B<pthread_attr_setinheritsched>(3) を使って) \n"
"そのスレッド属性オブジェクトの inherit scheduler 属性に\n"
"B<PTHREAD_EXPLICIT_SCHED> を設定する。B<PTHREAD_EXPLICIT_SCHED> は、\n"
"そのスレッド属性オブジェクトを使って作成されたスレッドはスレッド属性\n"
"オブジェクトからスケジューリング属性を取得して使うことを意味する。\n"
"それから、このスレッド属性オブジェクトを使ってスレッドを作成し、\n"
"作成したスレッドのスケジューリングポリシーと優先度を表示する。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:193
#, no-wrap
msgid ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:197
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"
msgstr ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:200
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"
msgstr ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:205
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the values specified in the thread attributes object."
msgstr ""
"上記の出力では、スケジューリングポリシーと優先度がスレッド属性\n"
"オブジェクトで指定された値から取られていることが分かる。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:212
msgid ""
"The next run is the same as the previous, except that the inherit scheduler "
"attribute is set to B<PTHREAD_INHERIT_SCHED>, meaning that threads created "
"using the thread attributes object should ignore the scheduling attributes "
"specified in the attributes object and instead take their scheduling "
"attributes from the creating thread."
msgstr ""
"次の実行例は前のものと同じだが、 inherit scheduler 属性が \n"
"B<PTHREAD_INHERIT_SCHED> に設定される点が異なる。\n"
"B<PTHREAD_INHERIT_SCHED> は、そのスレッド属性オブジェクトを使って作成\n"
"されたスレッドは、スレッド属性オブジェクトからスケジューリング属性を\n"
"無視し、代わりに呼び出したスレッドからスケジューリング属性を取得する\n"
"ことを意味する。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:218
#, no-wrap
msgid ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:222
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"
msgstr ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:225
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:231
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the creating thread, rather than the thread attributes "
"object."
msgstr ""
"上記の出力では、スケジューリングポリシーと優先度が、\n"
"スレッド属性オブジェクトからではなく、\n"
"スレッドを作成したスレッドから取れれていることが分かる。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:237
msgid ""
"Note that if we had omitted the I<-i\\ i> option, the output would have been "
"the same, since B<PTHREAD_INHERIT_SCHED> is the default for the inherit "
"scheduler attribute."
msgstr ""
"なお、 I<-i\\ i> を省略した場合でも、\n"
"B<PTHREAD_INHERIT_SCHED> が inherit scheduler 属性のデフォルト値なので、\n"
"出力は同じになる。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:241
#, no-wrap
msgid "/* pthreads_sched_test.c */\n"
msgstr "/* pthreads_sched_test.c */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:247
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:256
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:273
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|i}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|i}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:284
#, no-wrap
msgid ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"
msgstr ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:295
#, no-wrap
msgid ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"
msgstr ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:301
#, no-wrap
msgid ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"
msgstr ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:305
#, no-wrap
msgid ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"
msgstr ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:309
#, no-wrap
msgid ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"
msgstr ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:314
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:317
#, no-wrap
msgid ""
"    return NULL;\n"
"}\n"
msgstr ""
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:327
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:329
#, no-wrap
msgid "    /* Process command-line options */\n"
msgstr "    /* Process command-line options */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:334
#, no-wrap
msgid ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"
msgstr ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:344
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:348
#, no-wrap
msgid ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"
msgstr ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:351
#, no-wrap
msgid ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"
msgstr ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:356
#, no-wrap
msgid ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-m)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"
msgstr ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-m)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:361
#, no-wrap
msgid ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"
msgstr ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:364
#, no-wrap
msgid ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"
msgstr ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:366
#, no-wrap
msgid "    /* Initialize thread attributes object according to options */\n"
msgstr "    /* Initialize thread attributes object according to options */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:375
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"
msgstr ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:383
#, no-wrap
msgid ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or \\(aqi\\(aq\\en\");\n"
msgstr ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or \\(aqi\\(aq\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:388
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:394
#, no-wrap
msgid ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"
msgstr ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:402
#, no-wrap
msgid ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:405
#, no-wrap
msgid ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"
msgstr ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:413
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:416
#, no-wrap
msgid ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"
msgstr ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:424
#, no-wrap
msgid ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:426
#, no-wrap
msgid "    /* Create a thread that will display its scheduling attributes */\n"
msgstr "    /* Create a thread that will display its scheduling attributes */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:430
#, no-wrap
msgid ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:432
#, no-wrap
msgid "    /* Destroy unneeded thread attributes object */\n"
msgstr "    /* Destroy unneeded thread attributes object */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:438
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"      s = pthread_attr_destroy(&attr);\n"
"      if (s != 0)\n"
"          handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""
"    if (!use_null_attrib) {\n"
"      s = pthread_attr_destroy(&attr);\n"
"      if (s != 0)\n"
"          handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:442
#, no-wrap
msgid ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:460
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_setschedprio.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPRIO"
msgstr "PTHREAD_SETSCHEDPRIO"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:29
msgid "pthread_setschedprio - set scheduling priority of a thread"
msgstr "pthread_setschedprio - スレッドのスケジューリング優先度を設定する"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:34
#, no-wrap
msgid "B<int pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"
msgstr "B<int pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"

#.  FIXME . nptl/pthread_setschedprio.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#.  nptl/pthread_setschedparam.c has a similar case.
#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:53
msgid ""
"The B<pthread_setschedprio>()  function sets the scheduling priority of the "
"thread I<thread> to the value specified in I<prio>.  (By contrast "
"B<pthread_setschedparam>(3)  changes both the scheduling policy and priority "
"of a thread.)"
msgstr ""
"B<pthread_setschedprio>() 関数は、スレッド I<thread> のスケジューリング\n"
"優先度に I<prio> で指定された値を設定する\n"
"(一方、B<pthread_setschedparam>(3) はスレッドのスケジューリングポリシー\n"
"と優先度の両方を変更する)。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:61
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number.  If B<pthread_setschedprio>()  fails, the scheduling priority of "
"I<thread> is not changed."
msgstr ""
"成功すると、この関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。\n"
"B<pthread_setschedprio>() が失敗した場合、 I<thread> の\n"
"スケジューリング優先度は変更されない。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:66
msgid "I<prio> is not valid for the scheduling policy of the specified thread."
msgstr ""
"指定されたスレッドのスケジューリングポリシーでは、 I<prio> は無効である。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:70
msgid ""
"The caller does not have appropriate privileges to set the specified "
"priority."
msgstr "呼び出し側が、指定された優先度を設定するのに必要な特権を持っていない。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:81
msgid ""
"POSIX.1 also documents an B<ENOTSUP> (\"attempt was made to set the priority "
"to an unsupported value\") error for B<pthread_setschedparam>(3)."
msgstr ""
"POSIX.1 では、 B<pthread_setschedprio>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値を優先度\n"
"に設定しようとした\") も追加で規定されている。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:83
msgid "This function is available in glibc since version 2.3.4."
msgstr "この関数は glibc バージョン 2.3.4 以降で利用できる。"

#. type: tbl table
#: build/C/man3/pthread_setschedprio.3:93
#, no-wrap
msgid "B<pthread_setschedprio>()"
msgstr "B<pthread_setschedprio>()"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:103
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling priority, and details of the permitted ranges "
"for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""
"スレッドのスケジューリング優先度を変更するために必要な許可や変更した場合の影"
"響、および各スケジューリングポリシーで認められる優先度の範囲の詳細について"
"は、 B<sched>(7) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:117
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedparam>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedparam>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_sigmask.3:26
#, no-wrap
msgid "PTHREAD_SIGMASK"
msgstr "PTHREAD_SIGMASK"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:29
msgid "pthread_sigmask - examine and change mask of blocked signals"
msgstr "pthread_sigmask - 禁止するシグナルマスクの確認と変更を行う"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:35
#, no-wrap
msgid "B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"
msgstr "B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:46
msgid "B<pthread_sigmask>():"
msgstr "B<pthread_sigmask>():"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:58
msgid ""
"The B<pthread_sigmask>()  function is just like B<sigprocmask>(2), with the "
"difference that its use in multithreaded programs is explicitly specified by "
"POSIX.1.  Other differences are noted in this page."
msgstr "B<pthread_sigmask>() 関数は B<sigprocmask>(2) と全く同様だが、マルチスレッドプログラムでの利用が POSIX.1 で明示的に規定されている点が異なる。他の違いはこのマニュアルページで説明する。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:61
msgid ""
"For a description of the arguments and operation of this function, see "
"B<sigprocmask>(2)."
msgstr "この関数の引き数と動作の説明は B<sigprocmask>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:66
msgid ""
"On success, B<pthread_sigmask>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_sigmask>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:69
msgid "See B<sigprocmask>(2)."
msgstr "B<sigprocmask>(2) を参照。"

#. type: tbl table
#: build/C/man3/pthread_sigmask.3:79
#, no-wrap
msgid "B<pthread_sigmask>()"
msgstr "B<pthread_sigmask>()"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:85
msgid "A new thread inherits a copy of its creator's signal mask."
msgstr ""
"新しいスレッドは、スレッドを作成したスレッドのシグナルマスクのコピーを\n"
"継承する。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:93
msgid ""
"The glibc B<pthread_sigmask>()  function silently ignores attempts to block "
"the two real-time signals that are used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:98
msgid ""
"The program below blocks some signals in the main thread, and then creates a "
"dedicated thread to fetch those signals via B<sigwait>(3).  The following "
"shell session demonstrates its use:"
msgstr ""
"以下のプログラムは、メインスレッドでシグナルのいくつかを禁止 (block)\n"
"するように設定を行い、 B<sigwait>(3) 経由でそれらのシグナルを集める\n"
"専用のスレッドを作成する。\n"
"下記のシェルのセッションはその利用例を示したものである。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:109
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"
msgstr ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:120
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:122
#, no-wrap
msgid "/* Simple error handling functions */\n"
msgstr "/* Simple error handling functions */\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:131
#, no-wrap
msgid ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = arg;\n"
"    int s, sig;\n"
msgstr ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = arg;\n"
"    int s, sig;\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:139
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"
msgstr ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:146
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:149
#, no-wrap
msgid ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"
msgstr ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:156
#, no-wrap
msgid ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"
msgstr ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:160
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, &sig_thread, &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, NULL, &sig_thread, &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:163
#, no-wrap
msgid ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"
msgstr ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:166
#, no-wrap
msgid ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"
msgstr ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:177
msgid ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<pthread_attr_setsigmask_np>(3), B<pthread_create>(3), B<pthread_kill>(3), "
"B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"
msgstr "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<pthread_attr_setsigmask_np>(3), B<pthread_create>(3), B<pthread_kill>(3), B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/pthread_sigqueue.3:25
#, no-wrap
msgid "PTHREAD_SIGQUEUE"
msgstr "PTHREAD_SIGQUEUE"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:28
msgid "pthread_sigqueue - queue a signal and data to a thread"
msgstr "pthread_sigqueue - スレッドに対するシグナルとデータをキューに入れる"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:32
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:35
#, no-wrap
msgid ""
"B<int pthread_sigqueue(pthread_t >I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"
msgstr ""
"B<int pthread_sigqueue(pthread_t >I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:46
msgid "B<pthread_sigqueue>(): _GNU_SOURCE"
msgstr "B<pthread_sigqueue>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:54
msgid ""
"The B<pthread_sigqueue>()  function performs a similar task to "
"B<sigqueue>(3), but, rather than sending a signal to a process, it sends a "
"signal to a thread in the same process as the calling thread."
msgstr ""
"B<pthread_sigqueue>() 関数は B<sigqueue>(3) と同様の処理を実行するが、\n"
"プロセスにシグナルを送信するのではなく、呼び出したスレッドと\n"
"同じプロセス内のスレッドにシグナルを送信する。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:66
msgid ""
"The I<thread> argument is the ID of a thread in the same process as the "
"caller.  The I<sig> argument specifies the signal to be sent.  The I<value> "
"argument specifies data to accompany the signal; see B<sigqueue>(3)  for "
"details."
msgstr ""
"I<thread> 引き数は、呼び出し側と同じプロセスのスレッドの ID である。\n"
"I<sig> 引き数は送信するシグナルを指定する。\n"
"I<value> 引き数はシグナルと一緒に渡すデータを指定する。\n"
"詳細は B<sigqueue>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:71
msgid ""
"On success, B<pthread_sigqueue>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_sigmask>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:78
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""
"キューに入れられるシグナル数が上限に達していた\n"
"(詳しい情報は (B<signal>(7) を参照)。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:82
msgid "I<sig> was invalid."
msgstr "I<sig> が無効であった。"

#. type: TP
#: build/C/man3/pthread_sigqueue.3:82
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:86
msgid "B<pthread_sigqueue>()  is not supported on this system."
msgstr "B<pthread_sigqueue>() がこのシステムではサポートされていない。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:90
msgid "I<thread> is not valid."
msgstr "I<thread> が無効である。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:94
msgid "The B<pthread_sigqueue>()  function first appeared in glibc 2.11."
msgstr "B<pthread_sigqueue>() 関数は glibc 2.11 で初めて登場した。"

#. type: tbl table
#: build/C/man3/pthread_sigqueue.3:104
#, no-wrap
msgid "B<pthread_sigqueue>()"
msgstr "B<pthread_sigqueue>()"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:108
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:118
msgid ""
"The glibc implementation of B<pthread_sigqueue>()  gives an error "
"(B<EINVAL>)  on attempts to send either of the real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:126
msgid ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), "
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), \n"
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/pthread_testcancel.3:26
#, no-wrap
msgid "PTHREAD_TESTCANCEL"
msgstr "PTHREAD_TESTCANCEL"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:29
msgid ""
"pthread_testcancel - request delivery of any pending cancellation request"
msgstr "pthread_testcancel - 処理待ちの取り消し要求の配送を要求する"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:34
#, no-wrap
msgid "B<void pthread_testcancel(void);>\n"
msgstr "B<void pthread_testcancel(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:43
msgid ""
"Calling B<pthread_testcancel>()  creates a cancellation point within the "
"calling thread, so that a thread that is otherwise executing code that "
"contains no cancellation points will respond to a cancellation request."
msgstr ""
"B<pthread_testcancel>() を呼び出すと、呼び出したスレッド内に取り消し\n"
"ポイント (cancellation point) が作成される。\n"
"これにより、これ以外には取り消しポイントを含まないコードを実行して\n"
"いるスレッドが取り消し要求に対応することができるようになる。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:50
msgid ""
"If cancelability is disabled (using B<pthread_setcancelstate>(3)), or no "
"cancellation request is pending, then a call to B<pthread_testcancel>()  has "
"no effect."
msgstr ""
"(B<pthread_setcancelstate>(3) を使って) キャンセルが無効になっている\n"
"場合や処理待ちの取り消し要求がない場合は、B<pthread_testcancel>() を\n"
"呼び出しても何の影響もない。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:54
msgid ""
"This function does not return a value.  If the calling thread is canceled as "
"a consequence of a call to this function, then the function does not return."
msgstr ""
"この関数は値を返さない。この関数の呼び出しの結果、呼び出したスレッドが\n"
"キャンセルされた場合、この関数が返ることはない。"

#. type: tbl table
#: build/C/man3/pthread_testcancel.3:68
#, no-wrap
msgid "B<pthread_testcancel>()"
msgstr "B<pthread_testcancel>()"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:75
msgid "See B<pthread_cleanup_push>(3)."
msgstr "B<pthread_cleanup_push>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:80
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_tryjoin_np.3:26
#, no-wrap
msgid "PTHREAD_TRYJOIN_NP"
msgstr "PTHREAD_TRYJOIN_NP"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:30
msgid ""
"pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated "
"thread"
msgstr ""
"pthread_tryjoin_np, pthread_timedjoin_np - 終了したスレッドの join を\n"
"試みる"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:36
#, no-wrap
msgid "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:39
#, no-wrap
msgid ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"
msgstr ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:46
msgid ""
"These functions operate in the same way as B<pthread_join>(3), except for "
"the differences described on this page."
msgstr ""
"これらの関数は B<pthread_join>(3) と同じように動作するが、\n"
"このページで説明する違いがある。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:58
msgid ""
"The B<pthread_tryjoin_np>()  function performs a nonblocking join with the "
"thread I<thread>, returning the exit status of the thread in I<*retval>.  If "
"I<thread> has not yet terminated, then instead of blocking, as is done by "
"B<pthread_join>(3), the call returns an error."
msgstr ""
"B<pthread_tryjoin_np>() 関数は、スレッド I<thread> の非停止\n"
"(nonblocking) での join を実行し、スレッドの終了ステータスを\n"
"I<*retval> に入れて返す。I<thread> がまだ終了していない場合は、\n"
"B<pthread_join>(3) のように停止 (block) せずに、エラーを返す。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:79
#, fuzzy
#| msgid ""
#| "The B<pthread_timedjoin_np>()  function performs a join-with-timeout.  If "
#| "I<thread> has not yet terminated, then the call blocks until a maximum "
#| "time, specified in I<abstime>.  If the timeout expires before I<thread> "
#| "terminates, the call returns an error.  The I<abstime> argument is a "
#| "structure of the following form, specifying an absolute time measured "
#| "since the Epoch (see B<time>(2)):"
msgid ""
"The B<pthread_timedjoin_np>()  function performs a join-with-timeout.  If "
"I<thread> has not yet terminated, then the call blocks until a maximum time, "
"specified in I<abstime>, measured against the B<CLOCK_REALTIME> clock.  If "
"the timeout expires before I<thread> terminates, the call returns an error.  "
"The I<abstime> argument is a structure of the following form, specifying an "
"absolute time measured since the Epoch (see B<time>(2)):"
msgstr ""
"B<pthread_timedjoin_np>() 関数は、タイムアウト付きの join を行う。\n"
"I<thread> がまだ終了していない場合、 I<abstime> で指定された最大時間\n"
"まで停止する。 I<thread> が終了する前にタイムアウト時間が経過した場合は、\n"
"エラーを返す。I<abstime> 引き数は以下に示す構造体であり、\n"
"Epoch (時刻紀元; B<time>(2) 参照) から測った絶対時刻を指定する。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:86
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:92
msgid ""
"On success, these functions return 0; on error, they return an error number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:97
msgid ""
"These functions can fail with the same errors as B<pthread_join>(3).  "
"B<pthread_tryjoin_np>()  can in addition fail with the following error:"
msgstr ""
"これらの関数は B<pthread_join>(3) と同じエラーで失敗する。\n"
"B<pthread_tryjoin_np>() はさらに以下のエラーで失敗する場合がある。"

#. type: TP
#: build/C/man3/pthread_tryjoin_np.3:97 build/C/man3/pthread_spin_lock.3:104
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:101
msgid "I<thread> had not yet terminated at the time of the call."
msgstr "呼び出しを行った時点では I<thread> はまだ終了していない。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:104
msgid ""
"B<pthread_timedjoin_np>()  can in addition fail with the following errors:"
msgstr "B<pthread_timedjoin_np>() はさらに以下のエラーで失敗する場合がある。"

#. type: TP
#: build/C/man3/pthread_tryjoin_np.3:104
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:109
msgid "The call timed out before I<thread> terminated."
msgstr "I<thread> が終了する前に呼び出しがタイムアウトとなった。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:117
msgid ""
"I<abstime> value is invalid (I<tv_sec> is less than 0 or I<tv_nsec> is "
"greater than 1e9)."
msgstr ""
"I<abstime> の値が無効である (I<tv_sec> が 0 より小さいか、 I<tv_nsec> 1e9 が"
"より大きい)。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:121
msgid "B<pthread_timedjoin_np>()  never returns the error B<EINTR>."
msgstr "B<pthread_timedjoin_np>() がエラー B<EINTR> を返すことはない。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:123
msgid "These functions first appeared in glibc in version 2.3.3."
msgstr "これらの関数は glibc バージョン 2.3.3 で初めて登場した。"

#. type: tbl table
#: build/C/man3/pthread_tryjoin_np.3:135
#, no-wrap
msgid ""
"B<pthread_tryjoin_np>(),\n"
"B<pthread_timedjoin_np>()"
msgstr ""
"B<pthread_tryjoin_np>(),\n"
"B<pthread_timedjoin_np>()"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:143
msgid "The following code waits to join for up to 5 seconds:"
msgstr "以下のコードは、最大 5 秒まで join を待つ。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:148
#, no-wrap
msgid ""
"struct timespec ts;\n"
"int s;\n"
msgstr ""
"struct timespec ts;\n"
"int s;\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:150
#, no-wrap
msgid "\\&...\n"
msgstr "\\&...\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:154
#, no-wrap
msgid ""
"if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"    /* Handle error */\n"
"}\n"
msgstr ""
"if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"    /* Handle error */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:156
#, no-wrap
msgid "ts.tv_sec += 5;\n"
msgstr "ts.tv_sec += 5;\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:161
#, no-wrap
msgid ""
"s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"if (s != 0) {\n"
"    /* Handle error */\n"
"}\n"
msgstr ""
"s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"if (s != 0) {\n"
"    /* Handle error */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:175
msgid ""
"The B<pthread_timedjoin_np>()  function measures time by internally "
"calculating a relative sleep interval that is then measured against the "
"B<CLOCK_MONOTONIC> clock instead of the B<CLOCK_REALTIME> clock.  "
"Consequently, the timeout is unaffected by discontinuous changes to the "
"B<CLOCK_REALTIME> clock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:180
msgid ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_yield.3:25
#, no-wrap
msgid "PTHREAD_YIELD"
msgstr "PTHREAD_YIELD"

#. type: TH
#: build/C/man3/pthread_yield.3:25
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: build/C/man3/pthread_yield.3:28
msgid "pthread_yield - yield the processor"
msgstr "pthread_yield - プロセッサを明け渡す (yield)"

#. type: Plain text
#: build/C/man3/pthread_yield.3:34
#, no-wrap
msgid "B<int pthread_yield(void);>\n"
msgstr "B<int pthread_yield(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_yield.3:44
msgid ""
"B<pthread_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is placed at the end of the run queue for its static priority and "
"another thread is scheduled to run.  For further details, see "
"B<sched_yield>(2)"
msgstr ""
"B<pthread_yield>() を呼び出すと、呼び出したスレッドは CPU を手放す。\n"
"スレッドはそのスレッドの静的優先度の実行キューの末尾に回り、\n"
"別のスレッドが実行されるようにスケジューリングされる。\n"
"詳細は B<sched_yield>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:49
msgid ""
"On success, B<pthread_yield>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_yield>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:53
msgid ""
"On Linux, this call always succeeds (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""
"Linux では、この関数の呼び出しは常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#. type: tbl table
#: build/C/man3/pthread_yield.3:63
#, no-wrap
msgid "B<pthread_yield>()"
msgstr "B<pthread_yield>()"

#.  e.g., the BSDs, Tru64, AIX, and Irix.
#. type: Plain text
#: build/C/man3/pthread_yield.3:71
msgid ""
"This call is nonstandard, but present on several other systems.  Use the "
"standardized B<sched_yield>(2)  instead."
msgstr ""
"この関数は非標準だが、他のいくつかのシステムにも存在する。\n"
"代わりに、標準化されている B<sched_yield>(2) を使うこと。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:74
msgid "On Linux, this function is implemented as a call to B<sched_yield>(2)."
msgstr ""
"Linux では、この関数は B<sched_yield>(2) を呼び出す形で実装されている。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:85
msgid ""
"B<pthread_yield>()  is intended for use with real-time scheduling policies "
"(i.e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<pthread_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""

#.  FIXME . .BR pthread_cond_wait (3),
#. type: Plain text
#: build/C/man3/pthread_yield.3:90
msgid "B<sched_yield>(2), B<pthreads>(7), B<sched>(7)"
msgstr "B<sched_yield>(2), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: build/C/man3/pthread_atfork.3:25
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr "PTHREAD_ATFORK"

#. type: Plain text
#: build/C/man3/pthread_atfork.3:28
msgid "pthread_atfork - register fork handlers"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:34
#, no-wrap
msgid ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void (*>I<parent>B<)(void),>\n"
"B<                   void (*>I<child>B<)(void));>\n"
msgstr ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void (*>I<parent>B<)(void),>\n"
"B<                   void (*>I<child>B<)(void));>\n"

#. type: Plain text
#: build/C/man3/pthread_atfork.3:37
msgid "Link with I<-pthread>."
msgstr "I<-pthread> を付けてリンクする。"

#. type: Plain text
#: build/C/man3/pthread_atfork.3:45
msgid ""
"The B<pthread_atfork>()  function registers fork handlers that are to be "
"executed when B<fork>(2)  is called by this thread.  The handlers are "
"executed in the context of the thread that calls B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:47
msgid "Three kinds of handler can be registered:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:52
msgid ""
"I<prepare> specifies a handler that is executed before B<fork>(2)  "
"processing starts."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:57
msgid ""
"I<parent> specifies a handler that is executed in the parent process after "
"B<fork>(2)  processing completes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:62
msgid ""
"I<child> specifies a handler that is executed in the child process after "
"B<fork>(2)  processing completes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:67
msgid ""
"Any of the three arguments may be NULL if no handler is needed in the "
"corresponding phase of B<fork>(2)  processing."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:82
msgid ""
"On success, B<pthread_atfork>()  returns zero.  On error, it returns an "
"error number.  B<pthread_atfork>()  may be called multiple times by a "
"thread, to register multiple handlers for each phase.  The handlers for each "
"phase are called in a specified order: the I<prepare> handlers are called in "
"reverse order of registration; the I<parent> and I<child> handlers are "
"called in the order of registration."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:86
msgid "Could not allocate memory to record the form handler entry."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:108
msgid ""
"When B<fork>(2)  is called in a multithreaded process, only the calling "
"thread is duplicated in the child process.  The original intention of "
"B<pthread_atfork>()  was to allow the calling thread to be returned to a "
"consistent state.  For example, at the time of the call to B<fork>(2), other "
"threads may have locked mutexes that are visible in the user-space memory "
"duplicated in the child.  Such mutexes would never be unlocked, since the "
"threads that placed the locks are not duplicated in the child.  The intent "
"of B<pthread_atfork>()  was to provide a mechanism whereby the application "
"(or a library)  could ensure that mutexes and other process and thread state "
"would be restored to a consistent state.  In practice, this task is "
"generally too difficult to be practicable."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:117
msgid ""
"After a B<fork>(2)  in a multithreaded process returns in the child, the "
"child should call only async-signal-safe functions (see B<signal-"
"safety>(7))  until such time as it calls B<execve>(2)  to execute a new "
"program."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:122
msgid ""
"POSIX.1 specifies that B<pthread_atfork>()  shall not fail with the error "
"B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:126
msgid "B<fork>(2), B<atexit>(3), B<pthreads>(7)"
msgstr "B<fork>(2), B<atexit>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setsigmask_np.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSIGMASK_NP"
msgstr "PTHREAD_ATTR_SETSIGMASK_NP"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:30
#, fuzzy
#| msgid ""
#| "pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes "
#| "in thread attributes object"
msgid ""
"pthread_attr_setsigmask_np, pthread_attr_getsigmask_np - set/get signal mask "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstack, pthread_attr_getstack - \n"
"スレッド属性オブジェクトのスタック属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:39
#, no-wrap
msgid ""
"B<int pthread_attr_setsigmask_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const sigset_t *>I<sigmask>B<);>\n"
"B<int pthread_attr_getsigmask_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pthread_attr_setsigmask_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const sigset_t *>I<sigmask>B<);>\n"
"B<int pthread_attr_getsigmask_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:55
#, fuzzy
#| msgid ""
#| "The B<pthread_attr_setaffinity_np>()  function sets the CPU affinity mask "
#| "attribute of the thread attributes object referred to by I<attr> to the "
#| "value specified in I<cpuset>.  This attribute determines the CPU affinity "
#| "mask of a thread created using the thread attributes object I<attr>."
msgid ""
"The B<pthread_attr_setsigmask_np>()  function sets the signal mask attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<*sigmask>.  If I<sigmask> is specified as NULL, then any "
"existing signal mask attribute in I<attr> is unset."
msgstr ""
"B<pthread_attr_setaffinity_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの CPU affinity マスク属性を\n"
"I<cpuset> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されたスレッドの CPU affinity マスクが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:67
#, fuzzy
#| msgid ""
#| "The B<pthread_attr_getstack>()  function returns the stack address and "
#| "stack size attributes of the thread attributes object referred to by "
#| "I<attr> in the buffers pointed to by I<stackaddr> and I<stacksize>, "
#| "respectively."
msgid ""
"The B<pthread_attr_getsigmask_np>()  function returns the signal mask "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<sigmask>.  If the signal mask attribute is currently "
"unset, then this function returns the special value "
"B<PTHREAD_ATTR_NO_SIGMASK_NP> as its result."
msgstr ""
"B<pthread_attr_getstack>() 関数は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性と\n"
"スタックサイズ属性をそれぞれ I<stackaddr> と I<stacksize> が\n"
"指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:71
#, fuzzy
#| msgid ""
#| "On success, B<pthread_cancel>()  returns 0; on error, it returns a "
#| "nonzero error number."
msgid ""
"The B<pthread_attr_setsigmask_np>()  function returns 0 on success, or a "
"nonzero error number on failure."
msgstr ""
"成功すると、 B<pthread_cancel>() は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:82
msgid ""
"the B<pthread_attr_getsigmask_np>()  function returns either 0 or "
"B<PTHREAD_ATTR_NO_SIGMASK_NP>.  When 0 is returned, the signal mask "
"attribute is returned via I<sigmask>.  A return value of "
"B<PTHREAD_ATTR_NO_SIGMASK_NP> indicates that the signal mask attribute is "
"not set in I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:84
#, fuzzy
#| msgid ""
#| "On success, these functions return 0; on error, they return an error "
#| "number."
msgid "On error, these functions return a positive error number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:89
#, fuzzy
#| msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgid "(B<pthread_attr_setsigmask_np>())  Could not allocate memory."
msgstr ""
"(B<pthread_attr_setaffinity_np>()) メモリーを割り当てることができなかった。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:91
#, fuzzy
#| msgid "These functions are provided by glibc since version 2.2."
msgid "These functions are provided by glibc since version 2.32."
msgstr "これらの関数は glibc バージョン 2.2 以降で提供されている。"

#. type: tbl table
#: build/C/man3/pthread_attr_setsigmask_np.3:102
#, no-wrap
msgid ""
"B<pthread_attr_setsigmask_np>(),\n"
"B<pthread_attr_getsigmask_np>()"
msgstr ""
"B<pthread_attr_setsigmask_np>(),\n"
"B<pthread_attr_getsigmask_np>()"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:115
msgid ""
"The signal mask attribute determines the signal mask that will be assigned "
"to a thread created using the thread attributes object I<attr>.  If this "
"attribute is not set, then a thread created using I<attr> will inherit a "
"copy of the creating thread's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:121
#, fuzzy
#| msgid ""
#| "For more details on CPU affinity masks, see B<sched_setaffinity>(2).  For "
#| "a description of a set of macros that can be used to manipulate and "
#| "inspect CPU sets, see B<CPU_SET>(3)."
msgid ""
"For more details on signal masks, see B<sigprocmask>(2).  For a description "
"of a set of macros that can be used to manipulate and inspect signals sets, "
"see B<sigsetops>(3)."
msgstr ""
"CPU affinity マスクの詳細については、 \n"
"B<sched_setaffinity>(2) を参照してほしい。\n"
"CPU 集合の操作や取得を行う際に利用できるマクロ群の説明は \n"
"B<CPU_SET>(3) を参照してほしい。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:125
msgid ""
"In the absence of B<pthread_attr_setsigmask_np>()  it is possible to create "
"a thread with a desired signal mask as follows:"
msgstr ""

#. type: IP
#: build/C/man3/pthread_attr_setsigmask_np.3:125
#: build/C/man3/pthread_attr_setsigmask_np.3:129
#: build/C/man3/pthread_attr_setsigmask_np.3:133
#: build/C/man3/pthread_attr_setsigmask_np.3:136
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:129
msgid ""
"The creating thread uses B<pthread_sigmask>(3)  to save its current signal "
"mask and set its mask to block all signals."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:133
#, fuzzy
#| msgid ""
#| "A new thread created by B<pthread_create>(3)  inherits a copy of its "
#| "creator's CPU affinity mask."
msgid ""
"The new thread is then created using B<pthread_create>(); the new thread "
"will inherit the creating thread's signal mask."
msgstr ""
"B<pthread_create>(3) で作成される新しいスレッドは、\n"
"作成者の CPU affinity マスクを継承する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:136
msgid ""
"The new thread sets its signal mask to the desired value using "
"B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:138
msgid "The creating thread restores its signal mask to the original value."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:142
msgid ""
"Following the above steps, there is no possibility for the new thread to "
"receive a signal before it has adjusted its signal mask to the desired value."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:148
msgid ""
"B<sigprocmask>(2), B<pthread_attr_init>(3), B<pthread_sigmask>(3), "
"B<pthreads>(7), B<signals>(7)"
msgstr "B<sigprocmask>(2), B<pthread_attr_init>(3), B<pthread_sigmask>(3), B<pthreads>(7), B<signals>(7)"

#. type: TH
#: build/C/man3/pthread_getattr_default_np.3:25
#, no-wrap
msgid "PTHREAD_GETATTR_DEFAULT_NP"
msgstr "PTHREAD_GETATTR_DEFAULT_NP"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:29
#, fuzzy
#| msgid ""
#| "pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU "
#| "affinity attribute in thread attributes object"
msgid ""
"pthread_getattr_default_np, pthread_setattr_default_np, - get or set default "
"thread-creation attributes"
msgstr ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - \n"
"スレッド属性オブジェクトの CPU affinity 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:36
#, no-wrap
msgid ""
"B<int pthread_getattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_setattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_getattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_setattr_default_np(pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:50
msgid ""
"The B<pthread_setattr_default_np>()  function sets the default attributes "
"used for creation of a new thread\\(emthat is, the attributes that are used "
"when B<pthread_create>(3)  is called with a second argument that is NULL.  "
"The default attributes are set using the attributes supplied in I<*attr>, a "
"previously initialized thread attributes object.  Note the following details "
"about the supplied attributes object:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:52
msgid "The attribute settings in the object must be valid."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:56
msgid "The I<stack address> attribute must not be set in the object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:60
msgid ""
"Setting the I<stack size> attribute to zero means leave the default stack "
"size unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:66
#, fuzzy
#| msgid ""
#| "The B<pthread_getattr_np>()  function initializes the thread attributes "
#| "object referred to by I<attr> so that it contains actual attribute values "
#| "describing the running thread I<thread>."
msgid ""
"The B<pthread_getattr_default_np>()  function initializes the thread "
"attributes object referred to by I<attr> so that it contains the default "
"attributes used for thread creation."
msgstr ""
"B<pthread_getattr_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトを初期化し、\n"
"そのオブジェクトに実行中のスレッド I<thread> の実際の属性値を\n"
"格納して返す。"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:74
msgid ""
"(B<pthread_setattr_default_np>())  One of the attribute settings in I<attr> "
"is invalid, or the stack address attribute is set in I<attr>."
msgstr ""

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:79
#, fuzzy
#| msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgid "(B<pthread_setattr_default_np>())  Insufficient memory."
msgstr ""
"(B<pthread_attr_setaffinity_np>()) メモリーを割り当てることができなかった。"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:81
msgid "These functions are available in glibc since version 2.18."
msgstr "これらの関数は glibc バージョン 2.18 以降で利用できる。"

#. type: tbl table
#: build/C/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid ""
"B<pthread_getattr_default_np>(),\n"
"B<pthread_setattr_default_np>()"
msgstr ""
"B<pthread_getattr_default_np>(),\n"
"B<pthread_setattr_default_np>()"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:99
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in their names."
msgstr "これらの関数は非標準の GNU による拡張である。そのため、名前に \"_np\" (nonportable; 移植性がない) という接尾辞が付いている。"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:105
msgid ""
"The program below uses B<pthread_getattr_default_np>()  to fetch the default "
"thread-creation attributes and then displays various settings from the "
"returned thread attributes object.  When running the program, we see the "
"following output:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:115
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Stack size:          8388608\n"
"Guard size:          4096\n"
"Scheduling policy:   SCHED_OTHER\n"
"Scheduling priority: 0\n"
"Detach state:        JOINABLE\n"
"Inherit scheduler:   INHERIT\n"
msgstr ""
"$ B<./a.out>\n"
"Stack size:          8388608\n"
"Guard size:          4096\n"
"Scheduling policy:   SCHED_OTHER\n"
"Scheduling priority: 0\n"
"Detach state:        JOINABLE\n"
"Inherit scheduler:   INHERIT\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:140
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr)\n"
"{\n"
"    int s;\n"
"    size_t stacksize;\n"
"    size_t guardsize;\n"
"    int policy;\n"
"    struct sched_param schedparam;\n"
"    int detachstate;\n"
"    int inheritsched;\n"
msgstr ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr)\n"
"{\n"
"    int s;\n"
"    size_t stacksize;\n"
"    size_t guardsize;\n"
"    int policy;\n"
"    struct sched_param schedparam;\n"
"    int detachstate;\n"
"    int inheritsched;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:145
#, no-wrap
msgid ""
"    s = pthread_attr_getstacksize(attr, &stacksize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getstacksize\");\n"
"    printf(\"Stack size:          %zd\\en\", stacksize);\n"
msgstr ""
"    s = pthread_attr_getstacksize(attr, &stacksize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getstacksize\");\n"
"    printf(\"Stack size:          %zd\\en\", stacksize);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:150
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guardsize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"Guard size:          %zd\\en\", guardsize);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &guardsize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"Guard size:          %zd\\en\", guardsize);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:158
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &policy);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"Scheduling policy:   %s\\en\",\n"
"            (policy == SCHED_FIFO) ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR) ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" : \"[unknown]\");\n"
msgstr ""
"    s = pthread_attr_getschedpolicy(attr, &policy);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"Scheduling policy:   %s\\en\",\n"
"            (policy == SCHED_FIFO) ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR) ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" : \"[unknown]\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:163
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &schedparam);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"Scheduling priority: %d\\en\", schedparam.sched_priority);\n"
msgstr ""
"    s = pthread_attr_getschedparam(attr, &schedparam);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"Scheduling priority: %d\\en\", schedparam.sched_priority);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:171
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &detachstate);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"Detach state:        %s\\en\",\n"
"            (detachstate == PTHREAD_CREATE_DETACHED) ? \"DETACHED\" :\n"
"            (detachstate == PTHREAD_CREATE_JOINABLE) ? \"JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getdetachstate(attr, &detachstate);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"Detach state:        %s\\en\",\n"
"            (detachstate == PTHREAD_CREATE_DETACHED) ? \"DETACHED\" :\n"
"            (detachstate == PTHREAD_CREATE_JOINABLE) ? \"JOINABLE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:180
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &inheritsched);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"Inherit scheduler:   %s\\en\",\n"
"            (inheritsched == PTHREAD_INHERIT_SCHED) ? \"INHERIT\" :\n"
"            (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""
"    s = pthread_attr_getinheritsched(attr, &inheritsched);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"Inherit scheduler:   %s\\en\",\n"
"            (inheritsched == PTHREAD_INHERIT_SCHED) ? \"INHERIT\" :\n"
"            (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"            \"???\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:186
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:190
#, no-wrap
msgid ""
"    s = pthread_getattr_default_np(&attr);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_getattr_default_np\");\n"
msgstr ""
"    s = pthread_getattr_default_np(&attr);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_getattr_default_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:192
#, no-wrap
msgid "    display_pthread_attr(&attr);\n"
msgstr "    display_pthread_attr(&attr);\n"

#. type: TH
#: build/C/man3/pthread_mutex_consistent.3:26
#, no-wrap
msgid "PTHREAD_MUTEX_CONSISTENT"
msgstr "PTHREAD_MUTEX_CONSISTENT"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:29
msgid "pthread_mutex_consistent - make a robust mutex consistent"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:34
#, no-wrap
msgid "B<int pthread_mutex_consistent(pthread_mutex_t *>I<mutex>B<);>\n"
msgstr "B<int pthread_mutex_consistent(pthread_mutex_t *>I<mutex>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:44
msgid "B<pthread_mutex_consistent>():"
msgstr "B<pthread_mutex_consistent>():"

#.  FIXME .
#.  But see https://sourceware.org/bugzilla/show_bug.cgi?id=22125
#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:48
#: build/C/man3/pthread_mutexattr_setrobust.3:55
msgid "_POSIX_C_SOURCE E<gt>= 200809L"
msgstr "_POSIX_C_SOURCE E<gt>= 200809L"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:59
msgid ""
"This function makes a robust mutex consistent if it is in an inconsistent "
"state.  A mutex can be left in an inconsistent state if its owner terminates "
"while holding the mutex, in which case the next owner who acquires the mutex "
"will succeed and be notified by a return value of B<EOWNERDEAD> from a call "
"to B<pthread_mutex_lock>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:65
#, fuzzy
#| msgid ""
#| "On success, B<pthread_create>()  returns 0; on error, it returns an error "
#| "number, and the contents of I<*thread> are undefined."
msgid ""
"On success, I<pthread_mutex_consistent>()  returns 0.  Otherwise, it returns "
"a positive error number to indicate the cause of the error."
msgstr ""
"成功すると、 B<pthread_create>() は 0 を返す。\n"
"エラーの場合は、エラー番号が返され、 I<*thread> の内容は不定である。"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:69
msgid "The mutex is either not robust or is not in an inconsistent state."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:72
#, fuzzy
#| msgid "These functions first appeared in glibc in version 2.12."
msgid "B<pthread_mutex_consistent>()  was added to glibc in version 2.12."
msgstr "これらの関数は glibc バージョン 2.12 で初めて登場した。"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:74
#: build/C/man3/pthread_mutexattr_setrobust.3:152
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:82
msgid ""
"B<pthread_mutex_consistent>()  simply informs the implementation that the "
"state (shared data)  guarded by the mutex has been restored to a consistent "
"state and that normal operations can now be performed with the mutex.  It is "
"the application's responsibility to ensure that the shared data has been "
"restored to a consistent state before calling B<pthread_mutex_consistent>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:89
msgid ""
"Before the addition of B<pthread_mutex_consistent>()  to POSIX, glibc "
"defined the following equivalent nonstandard function if B<_GNU_SOURCE> was "
"defined:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:92
#, no-wrap
msgid "B<int pthread_mutex_consistent(const pthread_mutex_t *>I<mutex>B<);>\n"
msgstr "B<int pthread_mutex_consistent(const pthread_mutex_t *>I<mutex>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:96
msgid ""
"This GNU-specific API, which first appeared in glibc 2.4, is nowadays "
"obsolete and should not be used in new programs."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:99
msgid "See B<pthread_mutexattr_setrobust>(3)."
msgstr "B<pthread_mutexattr_setrobust>(3) 参照。"

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:107
msgid ""
"B<pthread_mutex_lock>(3), B<pthread_mutexattr_init>(3), "
"B<pthread_mutexattr_getrobust>(3), B<pthread_mutexattr_setrobust>(3), "
"B<pthreads>(7)"
msgstr "B<pthread_mutex_lock>(3), B<pthread_mutexattr_init>(3), B<pthread_mutexattr_getrobust>(3), B<pthread_mutexattr_setrobust>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_mutexattr_getpshared.3:25
#, no-wrap
msgid "PTHREAD_MUTEXATTR_GETPSHARED"
msgstr "PTHREAD_MUTEXATTR_GETPSHARED"

#. type: TH
#: build/C/man3/pthread_mutexattr_getpshared.3:25
#, no-wrap
msgid "2017-09-13"
msgstr "2017-09-13"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:29
#, fuzzy
#| msgid ""
#| "pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack "
#| "address attribute in thread attributes object"
msgid ""
"pthread_mutexattr_getpshared, pthread_mutexattr_setpshared - get/set process-"
"shared mutex attribute"
msgstr ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - \n"
"スレッド属性オブジェクトのスタックアドレス属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:37
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getpshared(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int *>I<pshared>B<);>\n"
"B<int pthread_mutexattr_setpshared(pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int >I<pshared>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_getpshared(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int *>I<pshared>B<);>\n"
"B<int pthread_mutexattr_setpshared(pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int >I<pshared>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:45
msgid ""
"These functions get and set the process-shared attribute in a mutex "
"attributes object.  This attribute must be appropriately set to ensure "
"correct, efficient operation of a mutex created using this attributes object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:47
#, fuzzy
#| msgid "The new thread terminates in one of the following ways:"
msgid "The process-shared attribute can have one of the following values:"
msgstr "新しく作成されたスレッドは、以下のいずれかで終了する。"

#. type: TP
#: build/C/man3/pthread_mutexattr_getpshared.3:47
#: build/C/man3/pthread_spin_init.3:68
#, no-wrap
msgid "B<PTHREAD_PROCESS_PRIVATE>"
msgstr "B<PTHREAD_PROCESS_PRIVATE>"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:52
msgid ""
"Mutexes created with this attributes object are to be shared only among "
"threads in the same process that initialized the mutex.  This is the default "
"value for the process-shared mutex attribute."
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_getpshared.3:52
#: build/C/man3/pthread_spin_init.3:75
#, no-wrap
msgid "B<PTHREAD_PROCESS_SHARED>"
msgstr "B<PTHREAD_PROCESS_SHARED>"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:57
msgid ""
"Mutexes created with this attributes object can be shared between any "
"threads that have access to the memory containing the object, including "
"threads in different processes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:64
#, fuzzy
#| msgid ""
#| "The B<pthread_attr_getstackaddr>()  function returns the stack address "
#| "attribute of the thread attributes object referred to by I<attr> in the "
#| "buffer pointed to by I<stackaddr>."
msgid ""
"B<pthread_mutexattr_getpshared>()  places the value of the process-shared "
"attribute of the mutex attributes object referred to by I<attr> in the "
"location pointed to by I<pshared>."
msgstr ""
"B<pthread_attr_getstackaddr>() は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性を\n"
"I<stackaddr> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:71
#, fuzzy
#| msgid ""
#| "The B<pthread_attr_setguardsize>()  function sets the guard size "
#| "attribute of the thread attributes object referred to by I<attr> to the "
#| "value specified in I<guardsize>."
msgid ""
"B<pthread_mutexattr_setpshared>()  sets the value of the process-shared "
"attribute of the mutex attributes object referred to by I<attr> to the value "
"specified in B<pshared>."
msgstr ""
"B<pthread_attr_setguardsize>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの guard size 属性を\n"
"I<guardsize> で指定された値に設定する。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:76
msgid ""
"If I<attr> does not refer to an initialized mutex attributes object, the "
"behavior is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:79
#: build/C/man3/pthread_mutexattr_init.3:59
#: build/C/man3/pthread_mutexattr_setrobust.3:132
#, fuzzy
#| msgid ""
#| "On success, these functions return 0; on error, they return an error "
#| "number."
msgid ""
"On success, these functions return 0.  On error, they return a positive "
"error number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:82
#, fuzzy
#| msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgid "B<pthread_mutexattr_setpshared>()  can fail with the following errors:"
msgstr "B<pthread_attr_setscope>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:87
msgid "The value specified in I<pshared> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:92
msgid ""
"I<pshared is> B<PTHREAD_PROCESS_SHARED> but the implementation does not "
"support process-shared mutexes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:99
msgid "B<pthread_mutexattr_init>(3), B<pthreads>(7)"
msgstr "B<pthread_mutexattr_init>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_mutexattr_init.3:25
#, no-wrap
msgid "PTHREAD_MUTEXATTR_INIT"
msgstr "PTHREAD_MUTEXATTR_INIT"

#. type: TH
#: build/C/man3/pthread_mutexattr_init.3:25
#, no-wrap
msgid "2019-10-10"
msgstr "2019-10-10"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:29
#, fuzzy
#| msgid ""
#| "pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
#| "attributes object"
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy - initialize and destroy a "
"mutex attributes object"
msgstr ""
"pthread_attr_init, pthread_attr_destroy - \n"
"スレッド属性オブジェクトの初期化と破棄を行う"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:35
#, no-wrap
msgid ""
"B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>\n"
"B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>\n"
"B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:44
#, fuzzy
#| msgid ""
#| "The B<pthread_getattr_np>()  function initializes the thread attributes "
#| "object referred to by I<attr> so that it contains actual attribute values "
#| "describing the running thread I<thread>."
msgid ""
"The B<pthread_mutexattr_init>()  function initializes the mutex attributes "
"object pointed to by I<attr> with default values for all attributes defined "
"by the implementation."
msgstr ""
"B<pthread_getattr_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトを初期化し、\n"
"そのオブジェクトに実行中のスレッド I<thread> の実際の属性値を\n"
"格納して返す。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:47
msgid ""
"The results of initializing an already initialized mutex attributes object "
"are undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:53
msgid ""
"The B<pthread_mutexattr_destroy>()  function destroys a mutex attribute "
"object (making it uninitialized).  Once a mutex attributes object has been "
"destroyed, it can be reinitialized with B<pthread_mutexattr_init>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:56
msgid ""
"The results of destroying an uninitialized mutex attributes object are "
"undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:64
msgid ""
"Subsequent changes to a mutex attributes object do not affect mutex that "
"have already been initialized using that object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:71
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutexattr_getpshared>(3), "
"B<pthread_mutexattr_getrobust>(3), B<pthreads>(7)"
msgstr "B<pthread_mutex_init>(3), B<pthread_mutexattr_getpshared>(3), B<pthread_mutexattr_getrobust>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_mutexattr_setrobust.3:26
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETROBUST"
msgstr "PTHREAD_MUTEXATTR_SETROBUST"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:30
#, fuzzy
#| msgid ""
#| "pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes "
#| "in thread attributes object"
msgid ""
"pthread_mutexattr_getrobust, pthread_mutexattr_setrobust - get and set the "
"robustness attribute of a mutex attributes object"
msgstr ""
"pthread_attr_setstack, pthread_attr_getstack - \n"
"スレッド属性オブジェクトのスタック属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:38
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int >I<robustness>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_getrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int >I<robustness>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:49
msgid "B<pthread_mutexattr_getrobust>(), B<pthread_mutexattr_setrobust>():"
msgstr "B<pthread_mutexattr_getrobust>(), B<pthread_mutexattr_setrobust>():"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:72
#, fuzzy
#| msgid ""
#| "The B<pthread_attr_setdetachstate>()  function sets the detach state "
#| "attribute of the thread attributes object referred to by I<attr> to the "
#| "value specified in I<detachstate>.  The detach state attribute determines "
#| "whether a thread created using the thread attributes object I<attr> will "
#| "be created in a joinable or a detached state."
msgid ""
"The B<pthread_mutexattr_getrobust>()  function places the value of the "
"robustness attribute of the mutex attributes object referred to by I<attr> "
"in I<*robustness>.  The B<pthread_mutexattr_setrobust>()  function sets the "
"value of the robustness attribute of the mutex attributes object referred to "
"by I<attr> to the value specified in I<*robustness>."
msgstr ""
"B<pthread_attr_setdetachstate>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの detach state 属性を\n"
"I<detachstate> で指定された値に設定する。\n"
"detach state 属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが、 join 可能な状態で作成されるか、\n"
"detached (切り離された) 状態で作成されるかが決定される。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:77
msgid ""
"The robustness attribute specifies the behavior of the mutex when the owning "
"thread dies without unlocking the mutex.  The following values are valid for "
"I<robustness>:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_setrobust.3:77
#, no-wrap
msgid "B<PTHREAD_MUTEX_STALLED>"
msgstr "B<PTHREAD_MUTEX_STALLED>"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:86
msgid ""
"This is the default value for a mutex attributes object.  If a mutex is "
"initialized with the B<PTHREAD_MUTEX_STALLED> attribute and its owner dies "
"without unlocking it, the mutex remains locked afterwards and any future "
"attempts to call B<pthread_mutex_lock>(3)  on the mutex will block "
"indefinitely."
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_setrobust.3:86
#, no-wrap
msgid "B<PTHREAD_MUTEX_ROBUST>"
msgstr "B<PTHREAD_MUTEX_ROBUST>"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:102
msgid ""
"If a mutex is initialized with the B<PTHREAD_MUTEX_ROBUST> attribute and its "
"owner dies without unlocking it, any future attempts to call "
"B<pthread_mutex_lock>(3)  on this mutex will succeed and return "
"B<EOWNERDEAD> to indicate that the original owner no longer exists and the "
"mutex is in an inconsistent state.  Usually after B<EOWNERDEAD> is returned, "
"the next owner should call B<pthread_mutex_consistent>(3)  on the acquired "
"mutex to make it consistent again before using it any further."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:112
msgid ""
"If the next owner unlocks the mutex using B<pthread_mutex_unlock>(3)  before "
"making it consistent, the mutex will be permanently unusable and any "
"subsequent attempts to lock it using B<pthread_mutex_lock>(3)  will fail "
"with the error B<ENOTRECOVERABLE>.  The only permitted operation on such a "
"mutex is B<pthread_mutex_destroy>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:119
msgid ""
"If the next owner terminates before calling B<pthread_mutex_consistent>(3), "
"further B<pthread_mutex_lock>(3)  operations on this mutex will still return "
"B<EOWNERDEAD>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:129
msgid ""
"Note that the I<attr> argument of B<pthread_mutexattr_getrobust>()  and "
"B<pthread_mutexattr_setrobust>()  should refer to a mutex attributes object "
"that was initialized by B<pthread_mutexattr_init>(3), otherwise the behavior "
"is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:136
msgid ""
"In the glibc implementation, B<pthread_mutexattr_getrobust>()  always return "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:145
msgid ""
"A value other than B<PTHREAD_MUTEX_STALLED> or B<PTHREAD_MUTEX_ROBUST> was "
"passed to B<pthread_mutexattr_setrobust>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:150
#, fuzzy
#| msgid ""
#| "B<makecontext>()  and B<swapcontext>()  are provided in glibc since "
#| "version 2.1."
msgid ""
"B<pthread_mutexattr_getrobust>()  and B<pthread_mutexattr_setrobust>()  were "
"added to glibc in version 2.12."
msgstr ""
"B<makecontext>()  と B<swapcontext>()  は、バージョン 2.1 以降の glibc で提供"
"されている。"

#.  E.g., Solaris, according to its manual page
#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:163
msgid ""
"In the Linux implementation, when using process-shared robust mutexes, a "
"waiting thread also receives the B<EOWNERDEAD> notification if the owner of "
"a robust mutex performs an B<execve>(2)  without first unlocking the mutex.  "
"POSIX.1 does not specify this detail, but the same behavior also occurs in "
"at least some other implementations."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:172
msgid ""
"Before the addition of B<pthread_mutexattr_getrobust>()  and "
"B<pthread_mutexattr_setrobust>()  to POSIX, glibc defined the following "
"equivalent nonstandard functions if B<_GNU_SOURCE> was defined:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:178
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int >I<robustness>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int >I<robustness>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:185
msgid ""
"Correspondingly, the constants B<PTHREAD_MUTEX_STALLED_NP> and "
"B<PTHREAD_MUTEX_ROBUST_NP> were also defined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:188
msgid ""
"These GNU-specific APIs, which first appeared in glibc 2.4, are nowadays "
"obsolete and should not be used in new programs."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:197
msgid ""
"The program below demonstrates the use of the robustness attribute of a "
"mutex attributes object.  In this program, a thread holding the mutex dies "
"prematurely without unlocking the mutex.  The main thread subsequently "
"acquires the mutex successfully and gets the error B<EOWNERDEAD>, after "
"which it makes the mutex consistent."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:199
#, fuzzy
#| msgid "The following shell session shows a sample run of the program:"
msgid ""
"The following shell session shows what we see when running this program:"
msgstr "以下のシェルセッションは、このプログラムの実行例である。"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:209
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"[original owner] Setting lock...\n"
"[original owner] Locked. Now exiting without unlocking.\n"
"[main] Attempting to lock the robust mutex.\n"
"[main] pthread_mutex_lock() returned EOWNERDEAD\n"
"[main] Now make the mutex consistent\n"
"[main] Mutex is now consistent; unlocking\n"
msgstr ""
"$ B<./a.out>\n"
"[original owner] Setting lock...\n"
"[original owner] Locked. Now exiting without unlocking.\n"
"[main] Attempting to lock the robust mutex.\n"
"[main] pthread_mutex_lock() returned EOWNERDEAD\n"
"[main] Now make the mutex consistent\n"
"[main] Mutex is now consistent; unlocking\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:218
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:223
#, no-wrap
msgid "static pthread_mutex_t mtx;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:232
#, no-wrap
msgid ""
"static void *\n"
"original_owner_thread(void *ptr)\n"
"{\n"
"    printf(\"[original owner] Setting lock...\\en\");\n"
"    pthread_mutex_lock(&mtx);\n"
"    printf(\"[original owner] Locked. Now exiting without unlocking.\\en\");\n"
"    pthread_exit(NULL);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:239
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_mutexattr_t attr;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_mutexattr_t attr;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:244
#, no-wrap
msgid ""
"    pthread_mutexattr_init(&attr);\n"
"                                /* initialize the attributes object */\n"
"    pthread_mutexattr_setrobust(&attr, PTHREAD_MUTEX_ROBUST);\n"
"                               /* set robustness */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:246
#, no-wrap
msgid "    pthread_mutex_init(&mtx, &attr);   /* initialize the mutex */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:248
#, no-wrap
msgid "    pthread_create(&thr, NULL, original_owner_thread, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:252
#, no-wrap
msgid "    /* \"original_owner_thread\" should have exited by now */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:265
#, no-wrap
msgid ""
"    printf(\"[main] Attempting to lock the robust mutex.\\en\");\n"
"    s = pthread_mutex_lock(&mtx);\n"
"    if (s == EOWNERDEAD) {\n"
"        printf(\"[main] pthread_mutex_lock() returned EOWNERDEAD\\en\");\n"
"        printf(\"[main] Now make the mutex consistent\\en\");\n"
"        s = pthread_mutex_consistent(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_consistent\");\n"
"        printf(\"[main] Mutex is now consistent; unlocking\\en\");\n"
"        s = pthread_mutex_unlock(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_unlock\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:275
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    } else if (s == 0) {\n"
"        printf(\"[main] pthread_mutex_lock() unexpectedly succeeded\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    } else {\n"
"        printf(\"[main] pthread_mutex_lock() unexpectedly failed\\en\");\n"
"        handle_error_en(s, \"pthread_mutex_lock\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:285
msgid ""
"B<get_robust_list>(2), B<set_robust_list>(2), "
"B<pthread_mutex_consistent>(3), B<pthread_mutex_init>(3), "
"B<pthread_mutex_lock>(3), B<pthreads>(7)"
msgstr "B<get_robust_list>(2), B<set_robust_list>(2), B<pthread_mutex_consistent>(3), B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_spin_init.3:25
#, no-wrap
msgid "PTHREAD_SPIN_INIT"
msgstr "PTHREAD_SPIN_INIT"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:28
#, fuzzy
#| msgid ""
#| "pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
#| "attributes object"
msgid ""
"pthread_spin_init, pthread_spin_destroy - initialize or destroy a spin lock"
msgstr ""
"pthread_attr_init, pthread_attr_destroy - \n"
"スレッド属性オブジェクトの初期化と破棄を行う"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:34
#, no-wrap
msgid ""
"B<int pthread_spin_init(pthread_spinlock_t *>I<lock>B<, int >I<pshared>B<);>\n"
"B<int pthread_spin_destroy(pthread_spinlock_t *>I<lock>B<);>\n"
msgstr ""
"B<int pthread_spin_init(pthread_spinlock_t *>I<lock>B<, int >I<pshared>B<);>\n"
"B<int pthread_spin_destroy(pthread_spinlock_t *>I<lock>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:45
msgid "B<pthread_spin_init>(), B<pthread_spin_destroy>():"
msgstr "B<pthread_spin_init>(), B<pthread_spin_destroy>():"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:49 build/C/man3/pthread_spin_lock.3:51
msgid "_POSIX_C_SOURCE E<gt>= 200112L"
msgstr "_POSIX_C_SOURCE E<gt>= 200112L"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:58
msgid ""
"I<General note>: Most programs should use mutexes instead of spin locks.  "
"Spin locks are primarily useful in conjunction with real-time scheduling "
"policies.  See NOTES."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:68
msgid ""
"The B<pthread_spin_init>()  function allocates any resources required for "
"the use of the spin lock referred to by I<lock> and initializes the lock to "
"be in the unlocked state.  The I<pshared> argument must have one of the "
"following values:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:75
msgid ""
"The spin lock is to be operated on only by threads in the same process as "
"the thread that calls B<pthread_spin_init>().  (Attempting to share the spin "
"lock between processes results in undefined behavior.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:81
msgid ""
"The spin lock may be operated on by any thread in any process that has "
"access to the memory containing the lock (i.e., the lock may be in a shared "
"memory object that is shared among multiple processes)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:86
#, fuzzy
#| msgid ""
#| "Calling B<pthread_attr_init>()  on a thread attributes object that has "
#| "already been initialized results in undefined behavior."
msgid ""
"Calling B<pthread_spin_init>()  on a spin lock that has already been "
"initialized results in undefined behavior."
msgstr ""
"すでに初期化されているスレッド属性オブジェクトに対して\n"
"B<pthread_attr_init>() を呼び出した場合、\n"
"どのような動作になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:94
msgid ""
"The B<pthread_spin_destroy>()  function destroys a previously initialized "
"spin lock, freeing any resources that were allocated for that lock.  "
"Destroying a spin lock that has not been previously been initialized or "
"destroying a spin lock while another thread holds the lock results in "
"undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:100
msgid ""
"Once a spin lock has been destroyed, performing any operation on the lock "
"other than once more initializing it with B<pthread_spin_init>()  results in "
"undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:111
msgid ""
"The result of performing operations such as B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), and B<pthread_spin_destroy>()  on I<copies> of "
"the object referred to by I<lock> is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:117
#, fuzzy
#| msgid ""
#| "On success, these functions return 0; on error, they return a nonzero "
#| "error number.  If B<pthread_setschedparam>()  fails, the scheduling "
#| "policy and parameters of I<thread> are not changed."
msgid ""
"On success, there functions return zero.  On failure, they return an error "
"number.  In the event that B<pthread_spin_init>()  fails, the lock is not "
"initialized."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。\n"
"B<pthread_setschedparam>() が失敗した場合、 I<thread> の\n"
"スケジューリングポリシーとパラメーターは変更されない。"

#.  These errors don't occur on the glibc implementation
#. type: Plain text
#: build/C/man3/pthread_spin_init.3:121
#, fuzzy
#| msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgid "B<pthread_spin_init>()  may fail with the following errors:"
msgstr "B<pthread_attr_setscope>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:125
msgid "The system has insufficient resources to initialize a new spin lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:128
msgid "Insufficient memory to initialize the spin lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:130 build/C/man3/pthread_spin_lock.3:109
#, fuzzy
#| msgid "These functions first appeared in glibc in version 2.12."
msgid "These functions first appeared in glibc in version 2.2."
msgstr "これらの関数は glibc バージョン 2.12 で初めて登場した。"

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:132 build/C/man3/pthread_spin_lock.3:111
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:135
msgid ""
"Support for process-shared spin locks is a POSIX option.  The option is "
"supported in the glibc implementation."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:148
msgid ""
"Spin locks should be employed in conjunction with real-time scheduling "
"policies (B<SCHED_FIFO>, or possibly B<SCHED_RR>).  Use of spin locks with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> probably "
"indicates a design mistake.  The problem is that if a thread operating under "
"such a policy is scheduled off the CPU while it holds a spin lock, then "
"other threads will waste time spinning on the lock until the lock holder is "
"once more rescheduled and releases the lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:151
msgid ""
"If threads create a deadlock situation while employing spin locks, those "
"threads will spin forever consuming CPU time."
msgstr ""

#.  FIXME . When PTHREAD_MUTEX_ADAPTIVE_NP is one day document
#.  make reference to it here
#. type: Plain text
#: build/C/man3/pthread_spin_init.3:162
msgid ""
"User-space spin locks are I<not> applicable as a general locking solution.  "
"They are, by definition, prone to priority inversion and unbounded spin "
"times.  A programmer using spin locks must be exceptionally careful not only "
"in the code, but also in terms of system configuration, thread placement, "
"and priority assignment."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:170
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), B<pthreads>(7)"
msgstr "B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthread_spin_lock>(3), B<pthread_spin_unlock>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_spin_lock.3:25
#, no-wrap
msgid "PTHREAD_SPIN_LOCK"
msgstr "PTHREAD_SPIN_LOCK"

#. type: TH
#: build/C/man3/pthread_spin_lock.3:25
#, no-wrap
msgid "2017-09-30"
msgstr "2017-09-30"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:29
msgid ""
"pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock - lock and "
"unlock a spin lock"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:36
#, no-wrap
msgid ""
"B<int pthread_spin_lock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_trylock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_unlock(pthread_spinlock_t *>I<lock>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:47
msgid "B<pthread_spin_lock>(), B<pthread_spin_trylock>():"
msgstr "B<pthread_spin_lock>(), B<pthread_spin_trylock>():"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:63
msgid ""
"The B<pthread_spin_lock>()  function locks the spin lock referred to by "
"I<lock>.  If the spin lock is currently unlocked, the calling thread "
"acquires the lock immediately.  If the spin lock is currently locked by "
"another thread, the calling thread spins, testing the lock until it becomes "
"available, at which point the calling thread acquires the lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:70
#, fuzzy
#| msgid ""
#| "Calling B<pthread_attr_init>()  on a thread attributes object that has "
#| "already been initialized results in undefined behavior."
msgid ""
"Calling B<pthread_spin_lock>()  on a lock that is already held by the caller "
"or a lock that has not been initialized with B<pthread_spin_init>(3)  "
"results in undefined behavior."
msgstr ""
"すでに初期化されているスレッド属性オブジェクトに対して\n"
"B<pthread_attr_init>() を呼び出した場合、\n"
"どのような動作になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:80
msgid ""
"The B<pthread_spin_trylock>()  function is like B<pthread_spin_lock>(), "
"except that if the spin lock referred to by I<lock> is currently locked, "
"then, instead of spinning, the call returns immediately with the error "
"B<EBUSY>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:87
msgid ""
"The B<pthread_spin_unlock>()  function unlocks the spin lock referred to "
"I<lock>.  If any threads are spinning on the lock, one of those threads will "
"then acquire the lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:91
#, fuzzy
#| msgid ""
#| "Calling B<pthread_attr_init>()  on a thread attributes object that has "
#| "already been initialized results in undefined behavior."
msgid ""
"Calling B<pthread_spin_unlock>()  on a lock that is not held by the caller "
"results in undefined behavior."
msgstr ""
"すでに初期化されているスレッド属性オブジェクトに対して\n"
"B<pthread_attr_init>() を呼び出した場合、\n"
"どのような動作になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:94
#, fuzzy
#| msgid ""
#| "On success, these functions return 0; on error, they return an error "
#| "number."
msgid ""
"On success, these functions return zero.  On failure, they return an error "
"number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:97
#, fuzzy
#| msgid "B<pthread_attr_setstack>()  can fail with the following error:"
msgid "B<pthread_spin_lock>()  may fail with the following errors:"
msgstr "B<pthread_attr_setstack>() は以下のエラーで失敗する場合がある。"

#. type: TP
#: build/C/man3/pthread_spin_lock.3:97
#, no-wrap
msgid "B<EDEADLOCK>"
msgstr "B<EDEADLOCK>"

#.  Not detected in glibc
#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:101
msgid "The system detected a deadlock condition."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:104
msgid "B<pthread_spin_trylock>()  fails with the following errors:"
msgstr "B<pthread_spin_trylock>() は以下のエラーで失敗する。"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:107
msgid "The spin lock is currently locked by another thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:114
#, fuzzy
#| msgid ""
#| "Calling B<pthread_attr_init>()  on a thread attributes object that has "
#| "already been initialized results in undefined behavior."
msgid ""
"Applying any of the functions described on this page to an uninitialized "
"spin lock results in undefined behavior."
msgstr ""
"すでに初期化されているスレッド属性オブジェクトに対して\n"
"B<pthread_attr_init>() を呼び出した場合、\n"
"どのような動作になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:117
#, fuzzy
#| msgid "See B<pthread_attr_init>(3)."
msgid "Carefully read NOTES in B<pthread_spin_init>(3)."
msgstr "B<pthread_attr_init>(3) を参照。"

#.  FIXME . .BR pthread_mutex_lock (3),
#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:124
msgid "B<pthread_spin_destroy>(3), B<pthread_spin_init>(3), B<pthreads>(7)"
msgstr "B<pthread_spin_destroy>(3), B<pthread_spin_init>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man7/pthreads.7:25
#, no-wrap
msgid "PTHREADS"
msgstr "PTHREADS"

#. type: Plain text
#: build/C/man7/pthreads.7:28
msgid "pthreads - POSIX threads"
msgstr "pthreads - POSIX スレッド"

#. type: Plain text
#: build/C/man7/pthreads.7:35
msgid ""
"POSIX.1 specifies a set of interfaces (functions, header files) for threaded "
"programming commonly known as POSIX threads, or Pthreads.  A single process "
"can contain multiple threads, all of which are executing the same program.  "
"These threads share the same global memory (data and heap segments), but "
"each thread has its own stack (automatic variables)."
msgstr ""
"POSIX.1 は、一般に POSIX スレッドや Pthreads として知られる スレッドプログラ"
"ミングのインターフェース群 (関数、ヘッダーファイル)  を規定している。一つのプ"
"ロセスは複数のスレッドを持つことができ、 全てのスレッドは同じプログラムを実行"
"する。 これらのスレッドは同じ大域メモリー (データとヒープ領域) を共有する"
"が、 各スレッドは自分専用のスタック (自動変数) を持つ。"

#. type: Plain text
#: build/C/man7/pthreads.7:38
msgid ""
"POSIX.1 also requires that threads share a range of other attributes (i.e., "
"these attributes are process-wide rather than per-thread):"
msgstr ""
"POSIX.1 はスレッド間でどのような属性を共有するかについても定めている (つま"
"り、これらの属性はスレッド単位ではなくプロセス全体で共通である):"

#. type: IP
#: build/C/man7/pthreads.7:38 build/C/man7/pthreads.7:40
#: build/C/man7/pthreads.7:42 build/C/man7/pthreads.7:44
#: build/C/man7/pthreads.7:46 build/C/man7/pthreads.7:48
#: build/C/man7/pthreads.7:50 build/C/man7/pthreads.7:53
#: build/C/man7/pthreads.7:55 build/C/man7/pthreads.7:58
#: build/C/man7/pthreads.7:64 build/C/man7/pthreads.7:69
#: build/C/man7/pthreads.7:72 build/C/man7/pthreads.7:75
#: build/C/man7/pthreads.7:83 build/C/man7/pthreads.7:87
#: build/C/man7/pthreads.7:90 build/C/man7/pthreads.7:94
#: build/C/man7/pthreads.7:97 build/C/man7/pthreads.7:102
#: build/C/man7/pthreads.7:105 build/C/man7/pthreads.7:704
#: build/C/man7/pthreads.7:711 build/C/man7/pthreads.7:723
#: build/C/man7/pthreads.7:733 build/C/man7/pthreads.7:737
#: build/C/man7/pthreads.7:746 build/C/man7/pthreads.7:756
#: build/C/man7/pthreads.7:763 build/C/man7/pthreads.7:770
#: build/C/man7/pthreads.7:772 build/C/man7/pthreads.7:775
#: build/C/man7/pthreads.7:781 build/C/man7/pthreads.7:784
#: build/C/man7/pthreads.7:786 build/C/man7/pthreads.7:788
#: build/C/man7/pthreads.7:798 build/C/man7/pthreads.7:820
#: build/C/man7/pthreads.7:829 build/C/man7/pthreads.7:835
#: build/C/man7/pthreads.7:837 build/C/man7/pthreads.7:839
#: build/C/man7/pthreads.7:843 build/C/man7/pthreads.7:848
#: build/C/man7/pthreads.7:856
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: build/C/man7/pthreads.7:40
msgid "process ID"
msgstr "プロセス ID"

#. type: Plain text
#: build/C/man7/pthreads.7:42
msgid "parent process ID"
msgstr "親プロセス ID"

#. type: Plain text
#: build/C/man7/pthreads.7:44
msgid "process group ID and session ID"
msgstr "プロセスグループ ID とセッション ID"

#. type: Plain text
#: build/C/man7/pthreads.7:46
msgid "controlling terminal"
msgstr "制御端末"

#. type: Plain text
#: build/C/man7/pthreads.7:48
msgid "user and group IDs"
msgstr "ユーザー ID とグループ ID"

#. type: Plain text
#: build/C/man7/pthreads.7:50
msgid "open file descriptors"
msgstr "オープンするファイルディスクリプター"

#. type: Plain text
#: build/C/man7/pthreads.7:53
msgid "record locks (see B<fcntl>(2))"
msgstr "レコードのロック (B<fcntl>(3)  参照)"

#. type: Plain text
#: build/C/man7/pthreads.7:55
msgid "signal dispositions"
msgstr "シグナルの配置"

#. type: Plain text
#: build/C/man7/pthreads.7:58
msgid "file mode creation mask (B<umask>(2))"
msgstr "ファイルモード作成マスク (B<umask>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:64
msgid "current directory (B<chdir>(2))  and root directory (B<chroot>(2))"
msgstr ""
"カレントディレクトリ (B<chdir>(2))  とルートディレクトリ (B<chroot>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:69
msgid ""
"interval timers (B<setitimer>(2))  and POSIX timers (B<timer_create>(2))"
msgstr ""
"インターバルタイマー (B<setitimer>(2))  と POSIX タイマー "
"(B<timer_create>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:72
msgid "nice value (B<setpriority>(2))"
msgstr "nice 値 (B<setpriority>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:75
msgid "resource limits (B<setrlimit>(2))"
msgstr "リソース制限 (B<setrlimit>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:80
msgid ""
"measurements of the consumption of CPU time (B<times>(2))  and resources "
"(B<getrusage>(2))"
msgstr "CPU 時間 (B<times>(2))  とリソース (B<getrusage>(2))  の消費状況の計測"

#. type: Plain text
#: build/C/man7/pthreads.7:83
msgid ""
"As well as the stack, POSIX.1 specifies that various other attributes are "
"distinct for each thread, including:"
msgstr ""
"スタックについても、POSIX.1 はどのような属性が 個々のスレッドで独立に管理され"
"るかを規定している:"

#. type: Plain text
#: build/C/man7/pthreads.7:87
msgid "thread ID (the I<pthread_t> data type)"
msgstr "スレッド ID (B<pthread_t> データ型)"

#. type: Plain text
#: build/C/man7/pthreads.7:90
msgid "signal mask (B<pthread_sigmask>(3))"
msgstr "シグナルマスク (B<pthread_sigmask>(3))"

#. type: Plain text
#: build/C/man7/pthreads.7:94
msgid "the I<errno> variable"
msgstr "I<errno> 変数"

#. type: Plain text
#: build/C/man7/pthreads.7:97
msgid "alternate signal stack (B<sigaltstack>(2))"
msgstr "代替シグナルスタック (B<sigaltstack>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:100
msgid "real-time scheduling policy and priority (B<sched>(7))"
msgstr "リアルタイムスケジューリングのポリシーと優先度 (B<sched>(7))"

#. type: Plain text
#: build/C/man7/pthreads.7:102
msgid "The following Linux-specific features are also per-thread:"
msgstr "以下の Linux 特有の機能もスレッド単位である:"

#. type: Plain text
#: build/C/man7/pthreads.7:105
msgid "capabilities (see B<capabilities>(7))"
msgstr "ケーパビリティ (B<capabilities>(7)  参照)"

#. type: Plain text
#: build/C/man7/pthreads.7:108
msgid "CPU affinity (B<sched_setaffinity>(2))"
msgstr "CPU affinity (親和度)  (B<sched_setaffinity>(2))"

#. type: SS
#: build/C/man7/pthreads.7:108
#, no-wrap
msgid "Pthreads function return values"
msgstr "pthreads 関数の返り値"

#. type: Plain text
#: build/C/man7/pthreads.7:119
#, fuzzy
#| msgid ""
#| "Most pthreads functions return 0 on success, and an error number of "
#| "failure.  Note that the pthreads functions do not set I<errno>.  For each "
#| "of the pthreads functions that can return an error, POSIX.1-2001 "
#| "specifies that the function can never fail with the error B<EINTR>."
msgid ""
"Most pthreads functions return 0 on success, and an error number on "
"failure.  The error numbers that can be returned have the same meaning as "
"the error numbers returned in I<errno> by conventional system calls and C "
"library functions.  Note that the pthreads functions do not set I<errno>.  "
"For each of the pthreads functions that can return an error, POSIX.1-2001 "
"specifies that the function can never fail with the error B<EINTR>."
msgstr ""
"ほとんどの pthreads 関数は成功すると 0 を返し、 失敗した場合エラー番号を返"
"す。 pthreads 関数は I<errno> をセットしない点に注意すること。 POSIX.1-2001 "
"では、 エラーを返す可能性のある pthreads 関数がエラー B<EINTR> で失敗すること"
"は決してないと規定している。"

#. type: SS
#: build/C/man7/pthreads.7:119
#, no-wrap
msgid "Thread IDs"
msgstr "スレッド ID"

#. type: Plain text
#: build/C/man7/pthreads.7:127
msgid ""
"Each of the threads in a process has a unique thread identifier (stored in "
"the type I<pthread_t>).  This identifier is returned to the caller of "
"B<pthread_create>(3), and a thread can obtain its own thread identifier "
"using B<pthread_self>(3)."
msgstr "あるプロセス内の各スレッドは (I<pthread_t> 型の) 一意なスレッド識別子を持つ。 この識別子は、 B<pthread_create>(3)  の呼び出し元に返される。また、スレッドは自身のスレッド識別子を B<pthread_self>(3) を使って取得できる。"

#. type: Plain text
#: build/C/man7/pthreads.7:132
#, fuzzy
#| msgid ""
#| "Thread IDs are guaranteed to be unique only within a process.  A thread "
#| "ID may be reused after a terminated thread has been joined, or a detached "
#| "thread has terminated."
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  (In all "
"pthreads functions that accept a thread ID as an argument, that ID by "
"definition refers to a thread in the same process as the caller.)"
msgstr ""
"スレッド ID の一意性が保証されるのは、あるプロセス内においてのみである。\n"
"終了したスレッドが join されたり、\n"
"切り離された (detached) スレッドが終了されたりした後は、\n"
"そのスレッド ID は再利用されることがある。"

#. type: Plain text
#: build/C/man7/pthreads.7:137
msgid ""
"The system may reuse a thread ID after a terminated thread has been joined, "
"or a detached thread has terminated.  POSIX says: \"If an application "
"attempts to use a thread ID whose lifetime has ended, the behavior is "
"undefined.\""
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:137
#, no-wrap
msgid "Thread-safe functions"
msgstr "スレッドセーフな関数"

#. type: Plain text
#: build/C/man7/pthreads.7:141
msgid ""
"A thread-safe function is one that can be safely (i.e., it will deliver the "
"same results regardless of whether it is)  called from multiple threads at "
"the same time."
msgstr ""
"スレッドセーフな関数は、複数のスレッドから同時に呼び出しても安全な (すなわ"
"ち、同時に呼び出されたかに関わらず、同じ結果を返す) 関数のことである。"

#. type: Plain text
#: build/C/man7/pthreads.7:145
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that all functions specified in the "
"standard shall be thread-safe, except for the following functions:"
msgstr ""
"POSIX.1-2001 と POSIX.1-2008では、一部の例外を除き、 標準で規定されている全て"
"の関数がスレッドセーフであることを要求している。 以下の関数が例外である。"

#. type: Plain text
#: build/C/man7/pthreads.7:241
#, no-wrap
msgid ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() if passed a non-NULL argument\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [Added in POSIX.1-2008]\n"
"strtok()\n"
"system() [Added in POSIX.1-2008]\n"
"tmpnam() if passed a non-NULL argument\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() if its final argument is NULL\n"
"wcsrtombs() if its final argument is NULL\n"
"wcstombs()\n"
"wctomb()\n"
msgstr ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() (NULL でない引き数を渡された場合)\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"gethostbyname() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [POSIX.1-2008 で追加された]\n"
"strtok()\n"
"system() [POSIX.1-2008 で追加された]\n"
"tmpnam() (NULL でない引き数を渡された場合)\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() (最後の引き数が NULL の場合)\n"
"wcsrtombs() (最後の引き数が NULL の場合)\n"
"wcstombs()\n"
"wctomb()\n"

#. type: SS
#: build/C/man7/pthreads.7:243
#, no-wrap
msgid "Async-cancel-safe functions"
msgstr "async-cancel-safe 関数"

#. type: Plain text
#: build/C/man7/pthreads.7:247
msgid ""
"An async-cancel-safe function is one that can be safely called in an "
"application where asynchronous cancelability is enabled (see "
"B<pthread_setcancelstate>(3))."
msgstr ""
"async-cancel-safe 関数は、\n"
"非同期キャンセル機能が有効になっているアプリケーションで\n"
"安全に呼び出すことができる関数のことである\n"
"(B<pthread_setcancelstate>(3) を参照)。"

#. type: Plain text
#: build/C/man7/pthreads.7:250
msgid ""
"Only the following functions are required to be async-cancel-safe by "
"POSIX.1-2001 and POSIX.1-2008:"
msgstr ""
"以下の関数だけが、POSIX.1-2001 と POSIX.1-2008 で async-cancel-safe で\n"
"なければならないとされている。"

#. type: Plain text
#: build/C/man7/pthreads.7:256
#, no-wrap
msgid ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"
msgstr ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"

#. type: SS
#: build/C/man7/pthreads.7:258
#, no-wrap
msgid "Cancellation points"
msgstr "取り消しポイント (cancellation points)"

#. type: Plain text
#: build/C/man7/pthreads.7:265
msgid ""
"POSIX.1 specifies that certain functions must, and certain other functions "
"may, be cancellation points.  If a thread is cancelable, its cancelability "
"type is deferred, and a cancellation request is pending for the thread, then "
"the thread is canceled when it calls a function that is a cancellation point."
msgstr ""
"POSIX.1 の規定では、特定の関数は取り消しポイントでなければならず、 他の特定の"
"関数は取り消しポイントであってもよいとされている。 あるスレッドが取り消し可能"
"で、その取り消し種別 (cancelability type)  が延期 (deferred) で、そのスレッド"
"に対する取り消し要求が処理待ちの場合、 取り消しポイントである関数を呼び出した"
"時点で、そのスレッドのキャンセルが 行われる。"

#. type: Plain text
#: build/C/man7/pthreads.7:268
msgid ""
"The following functions are required to be cancellation points by "
"POSIX.1-2001 and/or POSIX.1-2008:"
msgstr ""
"POSIX.1-2001 と POSIX.1-2008 の両方、もしくはいずれか一方では、 以下の関数"
"は、取り消しポイント (cancellation points) で あることが必須となっている。"

#. type: Plain text
#: build/C/man7/pthreads.7:331
#, no-wrap
msgid ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [Added in POSIX.1-2008]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"
msgstr ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [POSIX.1-2008 で追加された]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"

#. type: Plain text
#: build/C/man7/pthreads.7:336
msgid ""
"The following functions may be cancellation points according to POSIX.1-2001 "
"and/or POSIX.1-2008:"
msgstr ""
"POSIX.1-2001 と POSIX.1-2008 の両方、もしくはいずれか一方では、 以下の関数"
"は、取り消しポイント (cancellation points) で あってもよいことになっている。"

#. type: Plain text
#: build/C/man7/pthreads.7:566
#, no-wrap
msgid ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [Added in POSIX.1-2008]\n"
"chown() [Added in POSIX.1-2008]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [Added in POSIX.1-2008]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [Added in POSIX.1-2008]\n"
"fchmod() [Added in POSIX.1-2008]\n"
"fchmodat() [Added in POSIX.1-2008]\n"
"fchown() [Added in POSIX.1-2008]\n"
"fchownat() [Added in POSIX.1-2008]\n"
"fclose()\n"
"fcntl() (for any value of cmd argument)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [Added in POSIX.1-2008]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [Added in POSIX.1-2008]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [Added in POSIX.1-2008]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [Added in POSIX.1-2008]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (if opterr is nonzero)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [Added in POSIX.1-2008]\n"
"lio_listio() [Added in POSIX.1-2008]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [Added in POSIX.1-2008]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [Added in POSIX.1-2008]\n"
"mkdirat() [Added in POSIX.1-2008]\n"
"mkdtemp() [Added in POSIX.1-2008]\n"
"mkfifo() [Added in POSIX.1-2008]\n"
"mkfifoat() [Added in POSIX.1-2008]\n"
"mknod() [Added in POSIX.1-2008]\n"
"mknodat() [Added in POSIX.1-2008]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [Added in POSIX.1-2008]\n"
"psignal() [Added in POSIX.1-2008]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [Added in POSIX.1-2008]\n"
"readlinkat() [Added in POSIX.1-2008]\n"
"remove()\n"
"rename()\n"
"renameat() [Added in POSIX.1-2008]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [Added in POSIX.1-2008]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [Added in POSIX.1-2008]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [Added in POSIX.1-2008]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [Added in POSIX.1-2008]\n"
"utime() [Added in POSIX.1-2008]\n"
"utimensat() [Added in POSIX.1-2008]\n"
"utimes() [Added in POSIX.1-2008]\n"
"vdprintf() [Added in POSIX.1-2008]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"
msgstr ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [POSIX.1-2008 で追加された]\n"
"chown() [POSIX.1-2008 で追加された]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [POSIX.1-2008 で追加された]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [POSIX.1-2008 で追加された]\n"
"fchmod() [POSIX.1-2008 で追加された]\n"
"fchmodat() [POSIX.1-2008 で追加された]\n"
"fchown() [POSIX.1-2008 で追加された]\n"
"fchownat() [POSIX.1-2008 で追加された]\n"
"fclose()\n"
"fcntl() (cmd 引き数が何であっても)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [POSIX.1-2008 で追加された]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [POSIX.1-2008 で追加された]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [POSIX.1-2008 で追加された]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [POSIX.1-2001 のみ (この関数は\n"
"                 POSIX.1-2008 で削除されている)]\n"
"gethostbyname() [POSIX.1-2001 のみ (この関数は\n"
"                 POSIX.1-2008 で削除されている)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [POSIX.1-2008 で追加された]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (opterr が 0 以外の場合)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [POSIX.1-2001 のみ (この関数は\n"
"         POSIX.1-2008 で削除されている)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [POSIX.1-2008 で追加された]\n"
"lio_listio() [POSIX.1-2008 で追加された]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [POSIX.1-2008 で追加された]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [POSIX.1-2008 で追加された]\n"
"mkdirat() [POSIX.1-2008 で追加された]\n"
"mkdtemp() [POSIX.1-2008 で追加された]\n"
"mkfifo() [POSIX.1-2008 で追加された]\n"
"mkfifoat() [POSIX.1-2008 で追加された]\n"
"mknod() [POSIX.1-2008 で追加された]\n"
"mknodat() [POSIX.1-2008 で追加された]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [POSIX.1-2008 で追加された]\n"
"psignal() [POSIX.1-2008 で追加された]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [POSIX.1-2008 で追加された]\n"
"readlinkat() [POSIX.1-2008 で追加された]\n"
"remove()\n"
"rename()\n"
"renameat() [POSIX.1-2008 で追加された]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [POSIX.1-2008 で追加された]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [POSIX.1-2008 で追加された]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [POSIX.1-2008 で追加された]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [POSIX.1-2008 で追加された]\n"
"utime() [POSIX.1-2008 で追加された]\n"
"utimensat() [POSIX.1-2008 で追加された]\n"
"utimes() [POSIX.1-2008 で追加された]\n"
"vdprintf() [POSIX.1-2008 で追加された]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"

#. type: Plain text
#: build/C/man7/pthreads.7:574
msgid ""
"An implementation may also mark other functions not specified in the "
"standard as cancellation points.  In particular, an implementation is likely "
"to mark any nonstandard function that may block as a cancellation point.  "
"(This includes most functions that can touch files.)"
msgstr ""
"実装時に、標準規格で規定されていないその他の関数を取り消しポイント とすること"
"も認められている。 特に、停止 (block) する可能性がある非標準の関数を取り消し"
"ポイントと する実装はあり得ることだろう (ファイルを扱う可能性のあるほとんどの"
"関数がこれに含まれる)。"

#.  So, scanning "cancellation point" comments in the glibc 2.8 header
#.  files, it looks as though at least the following nonstandard
#.  functions are cancellation points:
#.  endnetgrent
#.  endspent
#.  epoll_pwait
#.  epoll_wait
#.  fcloseall
#.  fdopendir
#.  fflush_unlocked
#.  fgetc_unlocked
#.  fgetgrent
#.  fgetgrent_r
#.  fgetpwent
#.  fgetpwent_r
#.  fgets_unlocked
#.  fgetspent
#.  fgetspent_r
#.  fgetwc_unlocked
#.  fgetws_unlocked
#.  fputc_unlocked
#.  fputs_unlocked
#.  fputwc_unlocked
#.  fputws_unlocked
#.  fread_unlocked
#.  fwrite_unlocked
#.  gai_suspend
#.  getaddrinfo_a
#.  getdate_r
#.  getgrent_r
#.  getgrouplist
#.  gethostbyaddr_r
#.  gethostbyname2
#.  gethostbyname2_r
#.  gethostbyname_r
#.  gethostent_r
#.  getnetbyaddr_r
#.  getnetbyname_r
#.  getnetent_r
#.  getnetgrent
#.  getnetgrent_r
#.  getprotobyname_r
#.  getprotobynumber_r
#.  getprotoent_r
#.  getpw
#.  getpwent_r
#.  getservbyname_r
#.  getservbyport_r
#.  getservent_r
#.  getspent
#.  getspent_r
#.  getspnam
#.  getspnam_r
#.  getutmp
#.  getutmpx
#.  getw
#.  getwc_unlocked
#.  getwchar_unlocked
#.  initgroups
#.  innetgr
#.  mkostemp
#.  mkostemp64
#.  mkstemp64
#.  ppoll
#.  pthread_timedjoin_np
#.  putgrent
#.  putpwent
#.  putspent
#.  putw
#.  putwc_unlocked
#.  putwchar_unlocked
#.  rcmd
#.  rcmd_af
#.  rexec
#.  rexec_af
#.  rresvport
#.  rresvport_af
#.  ruserok
#.  ruserok_af
#.  setnetgrent
#.  setspent
#.  sgetspent
#.  sgetspent_r
#.  updwtmpx
#.  utmpxname
#.  vfscanf
#.  vfwscanf
#.  vscanf
#.  vsyslog
#.  vwscanf
#. type: Plain text
#: build/C/man7/pthreads.7:674
msgid ""
"It should be noted that even if an application is not using asynchronous "
"cancellation, that calling a function from the above list from an "
"asynchronous signal handler may cause the equivalent of asynchronous "
"cancellation.  The underlying user code may not expect asynchronous "
"cancellation and the state of the user data may become inconsistent.  "
"Therefore signals should be used with caution when entering a region of "
"deferred cancellation."
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:674
#, no-wrap
msgid "Compiling on Linux"
msgstr "Linux でのコンパイル"

#. type: Plain text
#: build/C/man7/pthreads.7:677
msgid ""
"On Linux, programs that use the Pthreads API should be compiled using I<cc -"
"pthread>."
msgstr ""
"Linux では、Pthreads API を用いたプログラムは I<cc -pthread> でコンパイルすべ"
"きである。"

#. type: SS
#: build/C/man7/pthreads.7:677
#, no-wrap
msgid "Linux implementations of POSIX threads"
msgstr "POSIX スレッドの Linux での実装"

#. type: Plain text
#: build/C/man7/pthreads.7:680
msgid ""
"Over time, two threading implementations have been provided by the GNU C "
"library on Linux:"
msgstr ""
"これまで、2つのスレッドの実装が Linux の GNU C ライブラリにより 提供されてき"
"た。"

#. type: TP
#: build/C/man7/pthreads.7:680
#, no-wrap
msgid "B<LinuxThreads>"
msgstr "B<LinuxThreads>"

#. type: Plain text
#: build/C/man7/pthreads.7:684
msgid ""
"This is the original Pthreads implementation.  Since glibc 2.4, this "
"implementation is no longer supported."
msgstr ""
"最初の Pthreads の実装。\n"
"glibc 2.4 以降は、この実装はもはやサポートされていない。"

#. type: TP
#: build/C/man7/pthreads.7:684
#, no-wrap
msgid "B<NPTL> (Native POSIX Threads Library)"
msgstr "B<NPTL> (Native POSIX Threads Library)"

#. type: Plain text
#: build/C/man7/pthreads.7:692
msgid ""
"This is the modern Pthreads implementation.  By comparison with "
"LinuxThreads, NPTL provides closer conformance to the requirements of the "
"POSIX.1 specification and better performance when creating large numbers of "
"threads.  NPTL is available since glibc 2.3.2, and requires features that "
"are present in the Linux 2.6 kernel."
msgstr ""
"新しい Pthreads の実装。LinuxThreads と比べると、 NPTL は POSIX.1 の要求仕様"
"への準拠の度合いが高く、 多数のスレッドを作成した際の性能も高い。 NPTL は "
"glibc 2.3.2 以降で利用可能である。 NPTL を利用するには Linux 2.6 カーネルに実"
"装されている機能が必要である。"

#. type: Plain text
#: build/C/man7/pthreads.7:702
msgid ""
"Both of these are so-called 1:1 implementations, meaning that each thread "
"maps to a kernel scheduling entity.  Both threading implementations employ "
"the Linux B<clone>(2)  system call.  In NPTL, thread synchronization "
"primitives (mutexes, thread joining, and so on) are implemented using the "
"Linux B<futex>(2)  system call."
msgstr ""
"どちらの実装もいわゆる 1:1 実装、すなわち個々のスレッドが カーネルのスケ"
"ジューリング実体にマッピングされる。 どちらのスレッドの実装も Linux の "
"B<clone>(2)  システムコールを利用している。 NPTL では、スレッド同期の基本機"
"構 (mutex や スレッドの join 等) は Linux の B<futex>(2)  システムコールを"
"使って実装されている。"

#. type: SS
#: build/C/man7/pthreads.7:702
#, no-wrap
msgid "LinuxThreads"
msgstr "LinuxThreads"

#. type: Plain text
#: build/C/man7/pthreads.7:704
msgid "The notable features of this implementation are the following:"
msgstr "この実装の大きな特徴は以下の通りである:"

#. type: Plain text
#: build/C/man7/pthreads.7:711
msgid ""
"In addition to the main (initial) thread, and the threads that the program "
"creates using B<pthread_create>(3), the implementation creates a \"manager\" "
"thread.  This thread handles thread creation and termination.  (Problems can "
"result if this thread is inadvertently killed.)"
msgstr ""
"メインスレッド (最初のスレッド) とプログラムが B<pthread_create>(3)  を使って"
"作成したスレッドに加え、 この実装では「管理 (manager)」スレッドが作成され"
"る。 管理スレッドはスレッドの作成と終了を取り扱う (このスレッドがうっかり "
"kill されると、問題が起こることがある)。"

#. type: Plain text
#: build/C/man7/pthreads.7:723
msgid ""
"Signals are used internally by the implementation.  On Linux 2.2 and later, "
"the first three real-time signals are used (see also B<signal>(7)).  On "
"older Linux kernels, B<SIGUSR1> and B<SIGUSR2> are used.  Applications must "
"avoid the use of whichever set of signals is employed by the implementation."
msgstr ""
"この実装では内部でシグナルを使用している。 Linux 2.2 以降では、リアルタイムシ"
"グナルのうち最初の 3つが使われる (B<signal>(7)  参照)。 それ以前のカーネルで"
"は B<SIGUSR1> と B<SIGUSR2> が使われる。 アプリケーションは、スレッド実装で利"
"用されているシグナルを どれも使わないようにしなければならない。"

#. type: Plain text
#: build/C/man7/pthreads.7:730
msgid ""
"Threads do not share process IDs.  (In effect, LinuxThreads threads are "
"implemented as processes which share more information than usual, but which "
"do not share a common process ID.)  LinuxThreads threads (including the "
"manager thread)  are visible as separate processes using B<ps>(1)."
msgstr ""
"スレッド間でプロセス ID を共有しない (実際には LinuxThreads のスレッドは通常"
"よりは情報を共有するプロセスとして 実装されているが、一つの共通のプロセス ID "
"を共有してはいない)。 (管理スレッドを含む) LinuxThreads スレッドは B<ps>(1)  "
"を使うと別のプロセスのように見える。"

#. type: Plain text
#: build/C/man7/pthreads.7:733
msgid ""
"The LinuxThreads implementation deviates from the POSIX.1 specification in a "
"number of ways, including the following:"
msgstr ""
"LinuxThreads の実装では POSIX.1 仕様から逸脱している点が いくつかある。以下に"
"示すような点がある:"

#. type: Plain text
#: build/C/man7/pthreads.7:737
msgid "Calls to B<getpid>(2)  return a different value in each thread."
msgstr "B<getpid>(2)  を呼び出したときに、スレッド毎に異なる値が返される。"

#. type: Plain text
#: build/C/man7/pthreads.7:746
msgid ""
"Calls to B<getppid>(2)  in threads other than the main thread return the "
"process ID of the manager thread; instead B<getppid>(2)  in these threads "
"should return the same value as B<getppid>(2)  in the main thread."
msgstr ""
"メインスレッド以外のスレッドで B<getppid>(2)  を呼び出すと、管理スレッドのプ"
"ロセス ID が返される。 本当は、これらのスレッドで B<getppid>(2)  を呼んだ場合"
"にはメインスレッドでの B<getppid>(2)  と同じ値が返るべきである。"

#. type: Plain text
#: build/C/man7/pthreads.7:756
msgid ""
"When one thread creates a new child process using B<fork>(2), any thread "
"should be able to B<wait>(2)  on the child.  However, the implementation "
"allows only the thread that created the child to B<wait>(2)  on it."
msgstr ""
"あるスレッドが B<fork>(2)  を使って新しい子プロセスを作成した場合、 どのス"
"レッドでもこの子プロセスを B<wait>(2)  できるべきである。しかしながら、この実"
"装では子プロセスを作成した スレッドだけがこの子プロセスを B<wait>(2)  でき"
"る。"

#. type: Plain text
#: build/C/man7/pthreads.7:763
msgid ""
"When a thread calls B<execve>(2), all other threads are terminated (as "
"required by POSIX.1).  However, the resulting process has the same PID as "
"the thread that called B<execve>(2): it should have the same PID as the main "
"thread."
msgstr ""
"あるスレッドが B<execve>(2)  を呼び出した場合、他のスレッドは全て終了される "
"(POSIX.1 の仕様通り)。 しかしながら、新しいプロセスは B<execve>(2)  を呼んだ"
"スレッドと同じ PID を持つ。正しくは メインスレッドと同じ PID を持つべきであ"
"る。"

#. type: Plain text
#: build/C/man7/pthreads.7:770
msgid ""
"Threads do not share user and group IDs.  This can cause complications with "
"set-user-ID programs and can cause failures in Pthreads functions if an "
"application changes its credentials using B<seteuid>(2)  or similar."
msgstr ""
"スレッド間でユーザー ID とグループ ID が共有されない このことは、set-user-ID "
"プログラムで面倒な事態を招いたり、 アプリケーションが B<seteuid>(2)  などを"
"使って信用情報 (credentials) を変更した場合に Pthreads 関数が失敗する原因とな"
"る。"

#. type: Plain text
#: build/C/man7/pthreads.7:772
msgid "Threads do not share a common session ID and process group ID."
msgstr "スレッド間で共通のセッション ID やプロセスグループ ID を共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:775
msgid "Threads do not share record locks created using B<fcntl>(2)."
msgstr ""
"スレッド間で B<fcntl>(2)  を使って作成されるレコードロックを共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:781
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide."
msgstr ""
"B<times>(2)  と B<getrusage>(2)  が返す情報がプロセス全体の情報でなくスレッド"
"単位の情報である。"

#. type: Plain text
#: build/C/man7/pthreads.7:784
msgid "Threads do not share semaphore undo values (see B<semop>(2))."
msgstr "スレッド間でセマフォのアンドゥ値 (B<semop>(2)  参照) を共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:786
msgid "Threads do not share interval timers."
msgstr "スレッド間でインターバルタイマーを共有しない。"

#.  FIXME . bug report filed for NPTL nice nonconformance
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6258
#.  Sep 08: there is a patch by Denys Vlasenko to address this
#.  "make setpriority POSIX compliant; introduce PRIO_THREAD extension"
#.  Monitor this to see if it makes it into mainline.
#. type: Plain text
#: build/C/man7/pthreads.7:788 build/C/man7/pthreads.7:827
msgid "Threads do not share a common nice value."
msgstr "スレッドは共通の nice 値を共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:798
msgid ""
"POSIX.1 distinguishes the notions of signals that are directed to the "
"process as a whole and signals that are directed to individual threads.  "
"According to POSIX.1, a process-directed signal (sent using B<kill>(2), for "
"example) should be handled by a single, arbitrarily selected thread within "
"the process.  LinuxThreads does not support the notion of process-directed "
"signals: signals may be sent only to specific threads."
msgstr ""
"POSXI.1 では、全体としてのプロセスに送られるシグナルと、 個別のスレッドに送ら"
"れるシグナルを区別して考えている。 POSIX.1 によると、プロセスに送られたシグナ"
"ル (例えば B<kill>(2)  を使って送る) は、そのプロセスに属すスレッドのうち 勝"
"手に (arbitrarily) に選択された一つのスレッドにより処理される ことになってい"
"る。LinuxThreads はプロセスに送られるシグナルの 概念に対応しておらず、シグナ"
"ルは特定のスレッドにだけ送ることができる。"

#. type: Plain text
#: build/C/man7/pthreads.7:807
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack.  "
"(A new thread should start with no alternate signal stack defined.  If two "
"threads handle signals on their shared alternate signal stack at the same "
"time, unpredictable program failures are likely to occur.)"
msgstr ""
"スレッドはそれぞれの独自の代替シグナルスタックの設定を持つ。 しかし、新しいス"
"レッドの代替シグナルスタックの設定は そのスレッドを作成したスレッドからコピー"
"され、そのため スレッドは最初は一つの代替シグナルスタックを共有する。 (仕様で"
"は、新しいスレッドは代替シグナルスタックが定義されていない状態 で開始されるべ"
"きとされている。 2つのスレッドが共有されている代替シグナルスタック上で同時に "
"シグナルの処理を行った場合、予測不可能なプログラムのエラーが 起こり得る。)"

#. type: TH
#: build/C/man7/pthreads.7:807 build/C/man7/nptl.7:26
#, no-wrap
msgid "NPTL"
msgstr "NPTL"

#. type: Plain text
#: build/C/man7/pthreads.7:812
msgid ""
"With NPTL, all of the threads in a process are placed in the same thread "
"group; all members of a thread group share the same PID.  NPTL does not "
"employ a manager thread."
msgstr "NPTL では、一つのプロセスの全てのスレッドは同じスレッドグループ に属する; スレッドグループの全メンバーは同じ PID を共有する。 NPTL は管理スレッド (manager thread) を利用しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:818
msgid ""
"NPTL makes internal use of the first two real-time signals; these signals "
"cannot be used in applications.  See B<nptl>(7)  for further details."
msgstr " NPTL は内部でリアルタイムシグナルのうち最初の 2つの番号を使用しており、これらのシグナルはアプリケーションでは使用できない。詳細は B<nptl>(7) を参照のこと。"

#. type: Plain text
#: build/C/man7/pthreads.7:820
msgid "NPTL still has at least one nonconformance with POSIX.1:"
msgstr "NPTL にも POSIX.1 に準拠していない点が少なくとも一つある:"

#. type: Plain text
#: build/C/man7/pthreads.7:829
msgid "Some NPTL nonconformances occur only with older kernels:"
msgstr "NPTL の標準非準拠な点のうちいくつかは以前のカーネルでのみ発生する:"

#. type: Plain text
#: build/C/man7/pthreads.7:835
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide (fixed in kernel 2.6.9)."
msgstr ""
"B<times>(2)  と B<getrusage>(2)  が返す情報がプロセス全体の情報でなくスレッド"
"単位の情報である (カーネル 2.6.9 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:837
msgid "Threads do not share resource limits (fixed in kernel 2.6.10)."
msgstr "スレッド間でリソース制限を共有しない (カーネル 2.6.10 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:839
msgid "Threads do not share interval timers (fixed in kernel 2.6.12)."
msgstr ""
"スレッド間でインターバルタイマーを共有しない (カーネル 2.6.12 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:843
msgid ""
"Only the main thread is permitted to start a new session using B<setsid>(2)  "
"(fixed in kernel 2.6.16)."
msgstr ""
"メインスレッドだけが B<setsid>(2)  を使って新しいセッションを開始することがで"
"きる (カーネル 2.6.16 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:848
msgid ""
"Only the main thread is permitted to make the process into a process group "
"leader using B<setpgid>(2)  (fixed in kernel 2.6.16)."
msgstr ""
"メインスレッドだけが B<setpgid>(2)  を使ってそのプロセスをプロセスグループ"
"リーダーにすることができる (カーネル 2.6.16 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:854
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack "
"(fixed in kernel 2.6.16)."
msgstr ""
"スレッドはそれぞれの独自の代替シグナルスタックの設定を持つ。 しかし、新しいス"
"レッドの代替シグナルスタックの設定は そのスレッドを作成したスレッドからコピー"
"され、そのため スレッドは最初は一つの代替シグナルスタックを共有する (カーネ"
"ル 2.6.16 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:856
msgid "Note the following further points about the NPTL implementation:"
msgstr "NPTL の実装では以下の点についても注意すること:"

#. type: Plain text
#: build/C/man7/pthreads.7:870
msgid ""
"If the stack size soft resource limit (see the description of "
"B<RLIMIT_STACK> in B<setrlimit>(2))  is set to a value other than "
"I<unlimited>, then this value defines the default stack size for new "
"threads.  To be effective, this limit must be set before the program is "
"executed, perhaps using the I<ulimit -s> shell built-in command (I<limit "
"stacksize> in the C shell)."
msgstr ""
"スタックサイズのリソースのソフトリミット (B<setrlimit>(2)  の "
"B<RLIMIT_STACK> の説明を参照) が I<unlimited> 以外の値に設定されている場合、"
"ソフトリミットの値が 新しいスレッドのデフォルトのスタックサイズとなる。 設定"
"を有効にするためには、プログラムを実行する前にリミット値を 設定しておかなけれ"
"ばならない。たいていは、シェルの組み込みコマンドの I<ulimit -s> (C シェルで"
"は I<limit stacksize>)  を使って設定する。"

#. type: SS
#: build/C/man7/pthreads.7:870
#, no-wrap
msgid "Determining the threading implementation"
msgstr "スレッド実装の判定"

#. type: Plain text
#: build/C/man7/pthreads.7:875
msgid ""
"Since glibc 2.3.2, the B<getconf>(1)  command can be used to determine the "
"system's threading implementation, for example:"
msgstr ""
"glibc 2.3.2 以降では、 B<getconf>(1)  コマンドを使って、 システムのスレッド実"
"装を判定することができる。 以下に例を示す:"

#. type: Plain text
#: build/C/man7/pthreads.7:880
#, no-wrap
msgid ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"
msgstr ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"

#. type: Plain text
#: build/C/man7/pthreads.7:885
msgid ""
"With older glibc versions, a command such as the following should be "
"sufficient to determine the default threading implementation:"
msgstr ""
"ぞれ以前の glibc のバージョンでは、以下のようなコマンドで デフォルトのスレッ"
"ド実装を判定することができる。"

#. type: Plain text
#: build/C/man7/pthreads.7:891
#, no-wrap
msgid ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|nptl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"
msgstr ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|ntpl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"

#. type: SS
#: build/C/man7/pthreads.7:893
#, no-wrap
msgid "Selecting the threading implementation: LD_ASSUME_KERNEL"
msgstr "スレッドの実装の選択: LD_ASSUME_KERNEL"

#. type: Plain text
#: build/C/man7/pthreads.7:908
msgid ""
"On systems with a glibc that supports both LinuxThreads and NPTL (i.e., "
"glibc 2.3.I<x>), the B<LD_ASSUME_KERNEL> environment variable can be used to "
"override the dynamic linker's default choice of threading implementation.  "
"This variable tells the dynamic linker to assume that it is running on top "
"of a particular kernel version.  By specifying a kernel version that does "
"not provide the support required by NPTL, we can force the use of "
"LinuxThreads.  (The most likely reason for doing this is to run a (broken) "
"application that depends on some nonconformant behavior in LinuxThreads.)  "
"For example:"
msgstr ""
"LinuxThreads と NPTL の両方をサポートしている glibc (glibc 2.3.I<x>) があるシ"
"ステムでは、 B<LD_ASSUME_KERNEL> 環境変数を使うことで、動的リンカーがデフォル"
"トで 選択するスレッド実装を上書きすることができる。 この変数により、動的リン"
"カーが特定のバージョンのカーネル上で 動作していると仮定するように指定する。 "
"NPTL が必要とするサポート機能を提供していないカーネルバージョンを 指定するこ"
"とで、強制的に LinuxThreads を使うことができる (このようなことをする最もあり"
"そうな場面は、 LinuxThreads の標準非準拠な振舞いに依存する (壊れた) アプリ"
"ケーション を動作させる場合だろう)。 以下に例を示す:"

#. type: Plain text
#: build/C/man7/pthreads.7:914
#, no-wrap
msgid ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|nptl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"
msgstr ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|nptl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"

#. type: Plain text
#: build/C/man7/pthreads.7:929
msgid ""
"B<clone>(2), B<fork>(2), B<futex>(2), B<gettid>(2), B<proc>(5), "
"B<attributes>(7), B<futex>(7), B<nptl>(7), B<sigevent>(7), B<signal>(7)"
msgstr "B<clone>(2), B<fork>(2), B<futex>(2), B<gettid>(2), B<proc>(5), B<attributes>(7), B<futex>(7), B<nptl>(7), B<sigevent>(7), B<signal>(7)"

#. type: Plain text
#: build/C/man7/pthreads.7:958
msgid ""
"Various Pthreads manual pages, for example: B<pthread_atfork>(3), "
"B<pthread_attr_init>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<pthread_mutexattr_destroy>(3), "
"B<pthread_mutexattr_init>(3), B<pthread_once>(3), B<pthread_spin_init>(3), "
"B<pthread_spin_lock>(3), B<pthread_rwlockattr_setkind_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3), "
"and B<pthread_testcancel>(3)"
msgstr "pthreads の各種マニュアルページ、例えば: B<pthread_atfork>(3), B<pthread_attr_init>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), B<pthread_mutex_unlock>(3), B<pthread_mutexattr_destroy>(3), B<pthread_mutexattr_init>(3), B<pthread_once>(3), B<pthread_spin_init>(3), B<pthread_spin_lock>(3), B<pthread_rwlockattr_setkind_np>(3), B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3), and B<pthread_testcancel>(3)"

#. type: Plain text
#: build/C/man7/attributes.7:27
msgid "attributes - POSIX safety concepts"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:35
msgid ""
"I<Note>: the text of this man page is based on the material taken from the "
"\"POSIX Safety Concepts\" section of the GNU C Library manual.  Further "
"details on the topics described here can be found in that manual."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:39
msgid ""
"Various function manual pages include a section ATTRIBUTES that describes "
"the safety of calling the function in various contexts.  This section "
"annotates functions with the following safety markings:"
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:39
#, no-wrap
msgid "I<MT-Safe>"
msgstr "I<MT-Safe>"

#. type: Plain text
#: build/C/man7/attributes.7:46
msgid ""
"I<MT-Safe> or Thread-Safe functions are safe to call in the presence of "
"other threads.  MT, in MT-Safe, stands for Multi Thread."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:55
msgid ""
"Being MT-Safe does not imply a function is atomic, nor that it uses any of "
"the memory synchronization mechanisms POSIX exposes to users.  It is even "
"possible that calling MT-Safe functions in sequence does not yield an MT-"
"Safe combination.  For example, having a thread call two MT-Safe functions "
"one right after the other does not guarantee behavior equivalent to atomic "
"execution of a combination of both functions, since concurrent calls in "
"other threads may interfere in a destructive way."
msgstr ""

#
#
#
#.  .TP
#.  .I AS-Safe
#.  .I AS-Safe
#.  or Async-Signal-Safe functions are safe to call from
#.  asynchronous signal handlers.
#.  AS, in AS-Safe, stands for Asynchronous Signal.
#.  Many functions that are AS-Safe may set
#.  .IR errno ,
#.  or modify the floating-point environment,
#.  because their doing so does not make them
#.  unsuitable for use in signal handlers.
#.  However, programs could misbehave should asynchronous signal handlers
#.  modify this thread-local state,
#.  and the signal handling machinery cannot be counted on to
#.  preserve it.
#.  Therefore, signal handlers that call functions that may set
#.  .I errno
#.  or modify the floating-point environment
#.  .I must
#.  save their original values, and restore them before returning.
#.  .TP
#.  .I AC-Safe
#.  .I AC-Safe
#.  or Async-Cancel-Safe functions are safe to call when
#.  asynchronous cancellation is enabled.
#.  AC in AC-Safe stands for Asynchronous Cancellation.
#.  The POSIX standard defines only three functions to be AC-Safe, namely
#.  .BR pthread_cancel (3),
#.  .BR pthread_setcancelstate (3),
#.  and
#.  .BR pthread_setcanceltype (3).
#.  At present the GNU C Library provides no
#.  guarantees beyond these three functions,
#.  but does document which functions are presently AC-Safe.
#.  This documentation is provided for use
#.  by the GNU C Library developers.
#.  Just like signal handlers, cancellation cleanup routines must configure
#.  the floating point environment they require.
#.  The routines cannot assume a floating point environment,
#.  particularly when asynchronous cancellation is enabled.
#.  If the configuration of the floating point
#.  environment cannot be performed atomically then it is also possible that
#.  the environment encountered is internally inconsistent.
#. type: Plain text
#: build/C/man7/attributes.7:109
msgid ""
"Whole-program optimizations that could inline functions across library "
"interfaces may expose unsafe reordering, and so performing inlining across "
"the GNU C Library interface is not recommended.  The documented MT-Safety "
"status is not guaranteed under whole-program optimization.  However, "
"functions defined in user-visible headers are designed to be safe for "
"inlining."
msgstr ""

#.  ", " AS-Unsafe ", " AC-Unsafe
#. type: TP
#: build/C/man7/attributes.7:109
#, no-wrap
msgid "I<MT-Unsafe>"
msgstr "I<MT-Unsafe>"

#
#
#
#
#
#
#.  ", " AS-Unsafe ", " AC-Unsafe
#.  functions are not
#.  safe to call within the safety contexts described above.
#.  Calling them
#.  within such contexts invokes undefined behavior.
#.  Functions not explicitly documented as safe in a safety context should
#.  be regarded as Unsafe.
#.  .TP
#.  .I Preliminary
#.  .I Preliminary
#.  safety properties are documented, indicating these
#.  properties may
#.  .I not
#.  be counted on in future releases of
#.  the GNU C Library.
#.  Such preliminary properties are the result of an assessment of the
#.  properties of our current implementation,
#.  rather than of what is mandated and permitted
#.  by current and future standards.
#.  Although we strive to abide by the standards, in some cases our
#.  implementation is safe even when the standard does not demand safety,
#.  and in other cases our implementation does not meet the standard safety
#.  requirements.
#.  The latter are most likely bugs; the former, when marked
#.  as
#.  .IR Preliminary ,
#.  should not be counted on: future standards may
#.  require changes that are not compatible with the additional safety
#.  properties afforded by the current implementation.
#.  Furthermore,
#.  the POSIX standard does not offer a detailed definition of safety.
#.  We assume that, by "safe to call", POSIX means that,
#.  as long as the program does not invoke undefined behavior,
#.  the "safe to call" function behaves as specified,
#.  and does not cause other functions to deviate from their specified behavior.
#.  We have chosen to use its loose
#.  definitions of safety, not because they are the best definitions to use,
#.  but because choosing them harmonizes this manual with POSIX.
#.  Please keep in mind that these are preliminary definitions and annotations,
#.  and certain aspects of the definitions are still under
#.  discussion and might be subject to clarification or change.
#.  Over time,
#.  we envision evolving the preliminary safety notes into stable commitments,
#.  as stable as those of our interfaces.
#.  As we do, we will remove the
#.  .I Preliminary
#.  keyword from safety notes.
#.  As long as the keyword remains, however,
#.  they are not to be regarded as a promise of future behavior.
#. type: Plain text
#: build/C/man7/attributes.7:167
msgid ""
"I<MT-Unsafe> functions are not safe to call in a multithreaded programs."
msgstr ""

#
#
#
#
#
#
#
#
#
#
#
#.  .SS Unsafe features
#.  Functions that are unsafe to call in certain contexts are annotated with
#.  keywords that document their features that make them unsafe to call.
#.  AS-Unsafe features in this section indicate the functions are never safe
#.  to call when asynchronous signals are enabled.
#.  AC-Unsafe features
#.  indicate they are never safe to call when asynchronous cancellation is
#.  .\" enabled.
#.  There are no MT-Unsafe marks in this section.
#.  .TP
#.  .\" .I code
#.  Functions marked with
#.  .I lock
#.  as an AS-Unsafe feature may be
#.  .\" interrupted by a signal while holding a non-recursive lock.
#.  If the signal handler calls another such function that takes the same lock,
#.  the result is a deadlock.
#.  Functions annotated with
#.  .I lock
#.  as an AC-Unsafe feature may, if canceled asynchronously,
#.  fail to release a lock that would have been released if their execution
#.  had not been interrupted by asynchronous thread cancellation.
#.  Once a lock is left taken,
#.  attempts to take that lock will block indefinitely.
#.  .TP
#.  .I corrupt
#.  Functions marked with
#.  .\" .I corrupt
#.  as an AS-Unsafe feature may corrupt
#.  data structures and misbehave when they interrupt,
#.  or are interrupted by, another such function.
#.  Unlike functions marked with
#.  .IR lock ,
#.  these take recursive locks to avoid MT-Safety problems,
#.  but this is not enough to stop a signal handler from observing
#.  a partially-updated data structure.
#.  Further corruption may arise from the interrupted function's
#.  failure to notice updates made by signal handlers.
#.  Functions marked with
#.  .I corrupt
#.  as an AC-Unsafe feature may leave
#.  data structures in a corrupt, partially updated state.
#.  Subsequent uses of the data structure may misbehave.
#.  .\" A special case, probably not worth documenting separately, involves
#.  .\" reallocing, or even freeing pointers.  Any case involving free could
#.  .\" be easily turned into an ac-safe leak by resetting the pointer before
#.  .\" releasing it; I don't think we have any case that calls for this sort
#.  .\" of fixing.  Fixing the realloc cases would require a new interface:
#.  .\" instead of @code{ptr=realloc(ptr,size)} we'd have to introduce
#.  .\" @code{acsafe_realloc(&ptr,size)} that would modify ptr before
#.  .\" releasing the old memory.  The ac-unsafe realloc could be implemented
#.  .\" in terms of an internal interface with this semantics (say
#.  .\" __acsafe_realloc), but since realloc can be overridden, the function
#.  .\" we call to implement realloc should not be this internal interface,
#.  .\" but another internal interface that calls __acsafe_realloc if realloc
#.  .\" was not overridden, and calls the overridden realloc with async
#.  .\" cancel disabled.  --lxoliva
#.  .TP
#.  .I heap
#.  Functions marked with
#.  .I heap
#.  may call heap memory management functions from the
#.  .BR malloc (3)/ free (3)
#.  family of functions and are only as safe as those functions.
#.  This note is thus equivalent to:
#.      | AS-Unsafe lock | AC-Unsafe lock fd mem |
#.  .\" @sampsafety{@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{} @acsmem{}}}
#.  .\"
#.  .\" Check for cases that should have used plugin instead of or in
#.  .\" addition to this.  Then, after rechecking gettext, adjust i18n if
#.  .\" needed.
#.  .TP
#.  .I dlopen
#.  Functions marked with
#.  .I dlopen
#.  use the dynamic loader to load
#.  shared libraries into the current execution image.
#.  This involves opening files, mapping them into memory,
#.  allocating additional memory, resolving symbols,
#.  applying relocations and more,
#.  all of this while holding internal dynamic loader locks.
#.  The locks are enough for these functions to be AS-Unsafe and AC-Unsafe,
#.  but other issues may arise.
#.  At present this is a placeholder for all
#.  potential safety issues raised by
#.  .BR dlopen (3).
#.  .\" dlopen runs init and fini sections of the module; does this mean
#.  .\" dlopen always implies plugin?
#.  .TP
#.  .I plugin
#.  Functions annotated with
#.  .I plugin
#.  may run code from plugins that
#.  may be external to the GNU C Library.
#.  Such plugin functions are assumed to be
#.  MT-Safe, AS-Unsafe and AC-Unsafe.
#.  Examples of such plugins are stack unwinding libraries,
#.  name service switch (NSS) and character set conversion (iconv) back-ends.
#.  Although the plugins mentioned as examples are all brought in by means
#.  of dlopen, the
#.  .I plugin
#.  keyword does not imply any direct
#.  involvement of the dynamic loader or the
#.  .I libdl
#.  interfaces,
#.  those are covered by
#.  .IR dlopen .
#.  For example, if one function loads a module and finds the addresses
#.  of some of its functions,
#.  while another just calls those already-resolved functions,
#.  the former will be marked with
#.  .IR dlopen ,
#.  whereas the latter will get the
#.  .IR plugin .
#.  When a single function takes all of these actions, then it gets both marks.
#.  .TP
#.  .I i18n
#.  Functions marked with
#.  .I i18n
#.  may call internationalization
#.  functions of the
#.  .BR gettext (3)
#.  family and will be only as safe as those
#.  functions.
#.  This note is thus equivalent to:
#.      | MT-Safe env | AS-Unsafe corrupt heap dlopen | AC-Unsafe corrupt |
#.  .\" @sampsafety{@mtsafe{@mtsenv{}}@asunsafe{@asucorrupt{} @ascuheap{} @ascudlopen{}}@acunsafe{@acucorrupt{}}}
#.  .TP
#.  .I timer
#.  Functions marked with
#.  .I timer
#.  use the
#.  .BR alarm (3)
#.  function or
#.  similar to set a time-out for a system call or a long-running operation.
#.  In a multi-threaded program, there is a risk that the time-out signal
#.  will be delivered to a different thread,
#.  thus failing to interrupt the intended thread.
#.  Besides being MT-Unsafe, such functions are always
#.  AS-Unsafe, because calling them in signal handlers may interfere with
#.  timers set in the interrupted code, and AC-Unsafe,
#.  because there is no safe way to guarantee an earlier timer
#.  will be reset in case of asynchronous cancellation.
#. type: Plain text
#: build/C/man7/attributes.7:325
msgid ""
"Other keywords that appear in safety notes are defined in subsequent "
"sections."
msgstr ""

#. type: SS
#: build/C/man7/attributes.7:325
#, no-wrap
msgid "Conditionally safe features"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:337
msgid ""
"For some features that make functions unsafe to call in certain contexts, "
"there are known ways to avoid the safety problem other than refraining from "
"calling the function altogether.  The keywords that follow refer to such "
"features, and each of their definitions indicates how the whole program "
"needs to be constrained in order to remove the safety problem indicated by "
"the keyword.  Only when all the reasons that make a function unsafe are "
"observed and addressed, by applying the documented constraints, does the "
"function become safe to call in a context."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:337
#, no-wrap
msgid "I<init>"
msgstr "I<init>"

#. type: Plain text
#: build/C/man7/attributes.7:343
msgid ""
"Functions marked with I<init> as an MT-Unsafe feature perform MT-Unsafe "
"initialization when they are first called."
msgstr ""

#
#
#
#
#
#.  Functions marked with
#.  .I init
#.  as an AS-Unsafe or AC-Unsafe feature use the GNU C Library internal
#.  .I libc_once
#.  machinery or similar to initialize internal data structures.
#.  If a signal handler interrupts such an initializer,
#.  and calls any function that also performs
#.  .I libc_once
#.  initialization, it will deadlock if the thread library has been loaded.
#.  Furthermore, if an initializer is partially complete before it is canceled
#.  or interrupted by a signal whose handler requires the same initialization,
#.  some or all of the initialization may be performed more than once,
#.  leaking resources or even resulting in corrupt internal data.
#.  Applications that need to call functions marked with
#.  .I init
#.  as an AS-Safety or AC-Unsafe feature should ensure
#.  the initialization is performed
#.  before configuring signal handlers or enabling cancellation,
#.  so that the AS-Safety and AC-Safety issues related with
#.  .I libc_once
#.  do not arise.
#.  .\" We may have to extend the annotations to cover conditions in which
#.  .\" initialization may or may not occur, since an initial call in a safe
#.  .\" context is no use if the initialization doesn't take place at that
#.  .\" time: it doesn't remove the risk for later calls.
#. type: Plain text
#: build/C/man7/attributes.7:378
msgid ""
"Calling such a function at least once in single-threaded mode removes this "
"specific cause for the function to be regarded as MT-Unsafe.  If no other "
"cause for that remains, the function can then be safely called after other "
"threads are started."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:378
#, no-wrap
msgid "I<race>"
msgstr "I<race>"

#
#
#
#
#
#
#
#.  We consider access to objects passed as (indirect) arguments to
#.  functions to be data race free.
#.  The assurance of data race free objects
#.  is the caller's responsibility.
#.  We will not mark a function as MT-Unsafe or AS-Unsafe
#.  if it misbehaves when users fail to take the measures required by
#.  POSIX to avoid data races when dealing with such objects.
#.  As a general rule, if a function is documented as reading from
#.  an object passed (by reference) to it, or modifying it,
#.  users ought to use memory synchronization primitives
#.  to avoid data races just as they would should they perform
#.  the accesses themselves rather than by calling the library function.
#.  Standard I/O
#.  .RI ( "FILE *" )
#.  streams are the exception to the general rule,
#.  in that POSIX mandates the library to guard against data races
#.  in many functions that manipulate objects of this specific opaque type.
#.  We regard this as a convenience provided to users,
#.  rather than as a general requirement whose expectations
#.  should extend to other types.
#.  In order to remind users that guarding certain arguments is their
#.  responsibility, we will annotate functions that take objects of certain
#.  types as arguments.
#.  We draw the line for objects passed by users as follows:
#.  objects whose types are exposed to users,
#.  and that users are expected to access directly,
#.  such as memory buffers, strings,
#.  and various user-visible structured types, do
#.  .I not
#.  give reason for functions to be annotated with
#.  .IR race .
#.  It would be noisy and redundant with the general requirement,
#.  and not many would be surprised by the library's lack of internal
#.  guards when accessing objects that can be accessed directly by users.
#.  As for objects that are opaque or opaque-like,
#.  in that they are to be manipulated only by passing them
#.  to library functions (e.g.,
#.  .IR FILE ,
#.  .IR DIR ,
#.  .IR obstack ,
#.  .IR iconv_t ),
#.  there might be additional expectations as to internal coordination
#.  of access by the library.
#.  We will annotate, with
#.  .I race
#.  followed by a colon and the argument name,
#.  functions that take such objects but that do not take
#.  care of synchronizing access to them by default.
#.  For example,
#.  .I FILE
#.  stream
#.  .I unlocked
#.  functions
#.  .RB ( unlocked_stdio (3))
#.  will be annotated,
#.  but those that perform implicit locking on
#.  .I FILE
#.  streams by default will not,
#.  even though the implicit locking may be disabled on a per-stream basis.
#.  In either case, we will not regard as MT-Unsafe functions that may
#.  access user-supplied objects in unsafe ways should users fail to ensure
#.  the accesses are well defined.
#.  The notion prevails that users are expected to safeguard against
#.  data races any user-supplied objects that the library accesses
#.  on their behalf.
#.  .\" The above describes @mtsrace; @mtasurace is described below.
#.  This user responsibility does not apply, however,
#.  to objects controlled by the library itself,
#.  such as internal objects and static buffers used
#.  to return values from certain calls.
#.  When the library doesn't guard them against concurrent uses,
#.  these cases are regarded as MT-Unsafe and AS-Unsafe (although the
#.  .I race
#.  mark under AS-Unsafe will be omitted
#.  as redundant with the one under MT-Unsafe).
#.  As in the case of user-exposed objects,
#.  the mark may be followed by a colon and an identifier.
#.  The identifier groups all functions that operate on a
#.  certain unguarded object; users may avoid the MT-Safety issues related
#.  with unguarded concurrent access to such internal objects by creating a
#.  non-recursive mutex related with the identifier,
#.  and always holding the mutex when calling any function marked
#.  as racy on that identifier,
#.  as they would have to should the identifier be
#.  an object under user control.
#.  The non-recursive mutex avoids the MT-Safety issue,
#.  but it trades one AS-Safety issue for another,
#.  so use in asynchronous signals remains undefined.
#.  When the identifier relates to a static buffer used to hold return values,
#.  the mutex must be held for as long as the buffer remains in use
#.  by the caller.
#.  Many functions that return pointers to static buffers offer reentrant
#.  variants that store return values in caller-supplied buffers instead.
#.  In some cases, such as
#.  .BR tmpname (3),
#.  the variant is chosen not by calling an alternate entry point,
#.  but by passing a non-NULL pointer to the buffer in which the
#.  returned values are to be stored.
#.  These variants are generally preferable in multi-threaded programs,
#.  although some of them are not MT-Safe because of other internal buffers,
#.  also documented with
#.  .I race
#.  notes.
#. type: Plain text
#: build/C/man7/attributes.7:499
msgid ""
"Functions annotated with I<race> as an MT-Safety issue operate on objects in "
"ways that may cause data races or similar forms of destructive interference "
"out of concurrent execution.  In some cases, the objects are passed to the "
"functions by users; in others, they are used by the functions to return "
"values to users; in others, they are not even exposed to users."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:499
#, no-wrap
msgid "I<const>"
msgstr "I<const>"

#.  and AS-Unsafe,
#.  equally
#.  and AS-Unsafe
#.  and AS-Safe
#. type: Plain text
#: build/C/man7/attributes.7:520
msgid ""
"Functions marked with I<const> as an MT-Safety issue non-atomically modify "
"internal objects that are better regarded as constant, because a substantial "
"portion of the GNU C Library accesses them without synchronization.  Unlike "
"I<race>, which causes both readers and writers of internal objects to be "
"regarded as MT-Unsafe, this mark is applied to writers only.  Writers remain "
"MT-Unsafe to call, but the then-mandatory constness of objects they modify "
"enables readers to be regarded as MT-Safe (as long as no other reasons for "
"them to be unsafe remain), since the lack of synchronization is not a "
"problem when the objects are effectively constant."
msgstr ""

#
#.  The non-recursive locking removes the MT-Safety problem,
#.  but it trades one AS-Safety problem for another,
#.  so use in asynchronous signals remains undefined.
#.  .\" But what if, instead of marking modifiers with const:id and readers
#.  .\" with just id, we marked writers with race:id and readers with ro:id?
#.  .\" Instead of having to define each instance of 'id', we'd have a
#.  .\" general pattern governing all such 'id's, wherein race:id would
#.  .\" suggest the need for an exclusive/write lock to make the function
#.  .\" safe, whereas ro:id would indicate 'id' is expected to be read-only,
#.  .\" but if any modifiers are called (while holding an exclusive lock),
#.  .\" then ro:id-marked functions ought to be guarded with a read lock for
#.  .\" safe operation.  ro:env or ro:locale, for example, seems to convey
#.  .\" more clearly the expectations and the meaning, than just env or
#.  .\" locale.
#. type: Plain text
#: build/C/man7/attributes.7:550
msgid ""
"The identifier that follows the I<const> mark will appear by itself as a "
"safety note in readers.  Programs that wish to work around this safety "
"issue, so as to call writers, may use a non-recursive read-write lock "
"associated with the identifier, and guard I<all> calls to functions marked "
"with I<const> followed by the identifier with a write lock, and I<all> calls "
"to functions marked with the identifier by itself with a read lock."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:550
#, no-wrap
msgid "I<sig>"
msgstr "I<sig>"

#.  (that implies an identical AS-Safety issue, omitted for brevity)
#. type: Plain text
#: build/C/man7/attributes.7:559
msgid ""
"Functions marked with I<sig> as a MT-Safety issue may temporarily install a "
"signal handler for internal purposes, which may interfere with other uses of "
"the signal, identified after a colon."
msgstr ""

#
#
#
#.  There is no safe way to guarantee the original signal handler is
#.  restored in case of asynchronous cancellation,
#.  therefore so-marked functions are also AC-Unsafe.
#.  .\" fixme: at least deferred cancellation should get it right, and would
#.  .\" obviate the restoring bit below, and the qualifier above.
#.  Besides the measures recommended to work around the
#.  MT-Safety and AS-Safety problem,
#.  in order to avert the cancellation problem,
#.  disabling asynchronous cancellation
#.  .I and
#.  installing a cleanup handler to restore the signal to the desired state
#.  and to release the mutex are recommended.
#. type: Plain text
#: build/C/man7/attributes.7:581
msgid ""
"This safety problem can be worked around by ensuring that no other uses of "
"the signal will take place for the duration of the call.  Holding a non-"
"recursive mutex while calling all functions that use the same temporary "
"signal; blocking that signal before the call and resetting its handler "
"afterwards is recommended."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:581
#, no-wrap
msgid "I<term>"
msgstr "I<term>"

#.  The same window enables changes made by asynchronous signals to be lost.
#.  These functions are also AS-Unsafe,
#.  but the corresponding mark is omitted as redundant.
#. type: Plain text
#: build/C/man7/attributes.7:597
msgid ""
"Functions marked with I<term> as an MT-Safety issue may change the terminal "
"settings in the recommended way, namely: call B<tcgetattr>(3), modify some "
"flags, and then call B<tcsetattr>(3), this creates a window in which changes "
"made by other threads are lost.  Thus, functions marked with I<term> are MT-"
"Unsafe."
msgstr ""

#
#
#
#.  Functions marked with
#.  .I term
#.  as an AC-Safety issue are supposed to
#.  restore terminal settings to their original state,
#.  after temporarily changing them, but they may fail to do so if canceled.
#.  .\" fixme: at least deferred cancellation should get it right, and would
#.  .\" obviate the restoring bit below, and the qualifier above.
#.  Besides the measures recommended to work around the
#.  MT-Safety and AS-Safety problem,
#.  in order to avert the cancellation problem,
#.  disabling asynchronous cancellation
#.  .I and
#.  installing a cleanup handler to
#.  restore the terminal settings to the original state and to release the
#.  mutex are recommended.
#. type: Plain text
#: build/C/man7/attributes.7:632
msgid ""
"It is thus advisable for applications using the terminal to avoid concurrent "
"and reentrant interactions with it, by not using it in signal handlers or "
"blocking signals that might use it, and holding a lock while calling these "
"functions and interacting with the terminal.  This lock should also be used "
"for mutual exclusion with functions marked with I<race:tcattr(fd)>, where "
"I<fd> is a file descriptor for the controlling terminal.  The caller may use "
"a single mutex for simplicity, or use one mutex per terminal, even if "
"referenced by different file descriptors."
msgstr ""

#. type: SS
#: build/C/man7/attributes.7:632
#, no-wrap
msgid "Other safety remarks"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:636
msgid ""
"Additional keywords may be attached to functions, indicating features that "
"do not make a function unsafe to call, but that may need to be taken into "
"account in certain classes of programs:"
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:636
#, no-wrap
msgid "I<locale>"
msgstr "I<locale>"

#. type: Plain text
#: build/C/man7/attributes.7:648
msgid ""
"Functions annotated with I<locale> as an MT-Safety issue read from the "
"locale object without any form of synchronization.  Functions annotated with "
"I<locale> called concurrently with locale changes may behave in ways that do "
"not correspond to any of the locales active during their execution, but an "
"unpredictable mix thereof."
msgstr ""

#.  or AS-Unsafe,
#.  Should the locking strategy suggested under @code{const} be used,
#.  failure to guard locale uses is not as fatal as data races in
#.  general: unguarded uses will @emph{not} follow dangling pointers or
#.  access uninitialized, unmapped or recycled memory.  Each access will
#.  read from a consistent locale object that is or was active at some
#.  point during its execution.  Without synchronization, however, it
#.  cannot even be assumed that, after a change in locale, earlier
#.  locales will no longer be used, even after the newly-chosen one is
#.  used in the thread.  Nevertheless, even though unguarded reads from
#.  the locale will not violate type safety, functions that access the
#.  locale multiple times may invoke all sorts of undefined behavior
#.  because of the unexpected locale changes.
#. type: Plain text
#: build/C/man7/attributes.7:671
msgid ""
"We do not mark these functions as MT-Unsafe, however, because functions that "
"modify the locale object are marked with I<const:locale> and regarded as "
"unsafe.  Being unsafe, the latter are not to be called when multiple threads "
"are running or asynchronous signals are enabled, and so the locale can be "
"considered effectively constant in these contexts, which makes the former "
"safe."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:671
#, no-wrap
msgid "I<env>"
msgstr "I<env>"

#. type: Plain text
#: build/C/man7/attributes.7:680
msgid ""
"Functions marked with I<env> as an MT-Safety issue access the environment "
"with B<getenv>(3)  or similar, without any guards to ensure safety in the "
"presence of concurrent modifications."
msgstr ""

#.  or AS-Unsafe,
#. type: Plain text
#: build/C/man7/attributes.7:691
msgid ""
"We do not mark these functions as MT-Unsafe, however, because functions that "
"modify the environment are all marked with I<const:env> and regarded as "
"unsafe.  Being unsafe, the latter are not to be called when multiple threads "
"are running or asynchronous signals are enabled, and so the environment can "
"be considered effectively constant in these contexts, which makes the former "
"safe."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:691
#, no-wrap
msgid "I<hostid>"
msgstr "I<hostid>"

#. type: Plain text
#: build/C/man7/attributes.7:710
msgid ""
"The function marked with I<hostid> as an MT-Safety issue reads from the "
"system-wide data structures that hold the \"host ID\" of the machine.  These "
"data structures cannot generally be modified atomically.  Since it is "
"expected that the \"host ID\" will not normally change, the function that "
"reads from it (B<gethostid>(3))  is regarded as safe, whereas the function "
"that modifies it (B<sethostid>(3))  is marked with I<const:hostid>, "
"indicating it may require special care if it is to be called.  In this "
"specific case, the special care amounts to system-wide (not merely intra-"
"process) coordination."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:710
#, no-wrap
msgid "I<sigintr>"
msgstr "I<sigintr>"

#. type: Plain text
#: build/C/man7/attributes.7:719
msgid ""
"Functions marked with I<sigintr> as an MT-Safety issue access the GNU C "
"Library I<_sigintr> internal data structure without any guards to ensure "
"safety in the presence of concurrent modifications."
msgstr ""

#
#
#
#
#
#.  or AS-Unsafe,
#.  .TP
#.  .I fd
#.  Functions annotated with
#.  .I fd
#.  as an AC-Safety issue may leak file
#.  descriptors if asynchronous thread cancellation interrupts their
#.  execution.
#.  Functions that allocate or deallocate file descriptors will generally be
#.  marked as such.
#.  Even if they attempted to protect the file descriptor
#.  allocation and deallocation with cleanup regions,
#.  allocating a new descriptor and storing its number where the cleanup region
#.  could release it cannot be performed as a single atomic operation.
#.  Similarly,
#.  releasing the descriptor and taking it out of the data structure
#.  normally responsible for releasing it cannot be performed atomically.
#.  There will always be a window in which the descriptor cannot be released
#.  because it was not stored in the cleanup handler argument yet,
#.  or it was already taken out before releasing it.
#.  .\" It cannot be taken out after release:
#.  an open descriptor could mean either that the descriptor still
#.  has to be closed,
#.  or that it already did so but the descriptor was
#.  reallocated by another thread or signal handler.
#.  Such leaks could be internally avoided, with some performance penalty,
#.  by temporarily disabling asynchronous thread cancellation.
#.  However,
#.  since callers of allocation or deallocation functions would have to do
#.  this themselves, to avoid the same sort of leak in their own layer,
#.  it makes more sense for the library to assume they are taking care of it
#.  than to impose a performance penalty that is redundant when the problem
#.  is solved in upper layers, and insufficient when it is not.
#.  This remark by itself does not cause a function to be regarded as
#.  AC-Unsafe.
#.  However, cumulative effects of such leaks may pose a
#.  problem for some programs.
#.  If this is the case,
#.  suspending asynchronous cancellation for the duration of calls
#.  to such functions is recommended.
#.  .TP
#.  .I mem
#.  Functions annotated with
#.  .I mem
#.  as an AC-Safety issue may leak
#.  memory if asynchronous thread cancellation interrupts their execution.
#.  The problem is similar to that of file descriptors: there is no atomic
#.  interface to allocate memory and store its address in the argument to a
#.  cleanup handler,
#.  or to release it and remove its address from that argument,
#.  without at least temporarily disabling asynchronous cancellation,
#.  which these functions do not do.
#.  This remark does not by itself cause a function to be regarded as
#.  generally AC-Unsafe.
#.  However, cumulative effects of such leaks may be
#.  severe enough for some programs that disabling asynchronous cancellation
#.  for the duration of calls to such functions may be required.
#. type: Plain text
#: build/C/man7/attributes.7:792
msgid ""
"We do not mark these functions as MT-Unsafe, however, because functions that "
"modify this data structure are all marked with I<const:sigintr> and regarded "
"as unsafe.  Being unsafe, the latter are not to be called when multiple "
"threads are running or asynchronous signals are enabled, and so the data "
"structure can be considered effectively constant in these contexts, which "
"makes the former safe."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:792
#, no-wrap
msgid "I<cwd>"
msgstr "I<cwd>"

#. type: Plain text
#: build/C/man7/attributes.7:800
msgid ""
"Functions marked with I<cwd> as an MT-Safety issue may temporarily change "
"the current working directory during their execution, which may cause "
"relative pathnames to be resolved in unexpected ways in other threads or "
"within asynchronous signal or cancellation handlers."
msgstr ""

#
#.  or AS-Unsafe,
#.  .TP
#.  .I !posix
#.  This remark, as an MT-Safety, AS-Safety or AC-Safety
#.  note to a function,
#.  indicates the safety status of the function is known to differ
#.  from the specified status in the POSIX standard.
#.  For example, POSIX does not require a function to be Safe,
#.  but our implementation is, or vice-versa.
#.  For the time being, the absence of this remark does not imply the safety
#.  properties we documented are identical to those mandated by POSIX for
#.  the corresponding functions.
#. type: Plain text
#: build/C/man7/attributes.7:823
msgid ""
"This is not enough of a reason to mark so-marked functions as MT-Unsafe, but "
"when this behavior is optional (e.g., B<nftw>(3)  with B<FTW_CHDIR>), "
"avoiding the option may be a good alternative to using full pathnames or "
"file descriptor-relative (e.g., B<openat>(2))  system calls."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:823
#, no-wrap
msgid "I<:identifier>"
msgstr "I<:identifier>"

#. type: Plain text
#: build/C/man7/attributes.7:839
msgid ""
"Annotations may sometimes be followed by identifiers, intended to group "
"several functions that, for example, access the data structures in an unsafe "
"way, as in I<race> and I<const>, or to provide more specific information, "
"such as naming a signal in a function marked with I<sig>.  It is envisioned "
"that it may be applied to I<lock> and I<corrupt> as well in the future."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:851
msgid ""
"In most cases, the identifier will name a set of functions, but it may name "
"global objects or function arguments, or identifiable properties or logical "
"components associated with them, with a notation such as, for example, I<:"
"buf(arg)> to denote a buffer associated with the argument I<arg>, or I<:"
"tcattr(fd)> to denote the terminal attributes of a file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:856
msgid ""
"The most common use for identifiers is to provide logical groups of "
"functions and arguments that need to be protected by the same "
"synchronization primitive in order to ensure safe operation in a given "
"context."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:856
#, no-wrap
msgid "I</condition>"
msgstr "I</condition>"

#.  Such conditions as
#.  .I /hurd
#.  or
#.  .I /!linux!bsd
#.  indicate the preceding marker only
#.  applies when the underlying kernel is the HURD,
#.  or when it is neither Linux nor a BSD kernel, respectively.
#. type: Plain text
#: build/C/man7/attributes.7:877
msgid ""
"Some safety annotations may be conditional, in that they only apply if a "
"boolean expression involving arguments, global variables or even the "
"underlying kernel evaluates to true.  For example, I</!ps> and I</"
"one_per_line> indicate the preceding marker only applies when argument I<ps> "
"is NULL, or global variable I<one_per_line> is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:882
msgid ""
"When all marks that render a function unsafe are adorned with such "
"conditions, and none of the named conditions hold, then the function can be "
"regarded as safe."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:885
msgid "B<pthreads>(7), B<signal-safety>(7)"
msgstr "B<pthreads>(7), B<signal-safety>(7)"

#. type: Plain text
#: build/C/man7/nptl.7:29
#, fuzzy
#| msgid "B<NPTL> (Native POSIX Threads Library)"
msgid "nptl - Native POSIX Threads Library"
msgstr "B<NPTL> (Native POSIX Threads Library)"

#. type: Plain text
#: build/C/man7/nptl.7:34
msgid ""
"NPTL (Native POSIX Threads Library)  is the GNU C library POSIX threads "
"implementation that is used on modern Linux systems."
msgstr ""

#. type: SS
#: build/C/man7/nptl.7:34
#, no-wrap
msgid "NPTL and signals"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:43
msgid ""
"NPTL makes internal use of the first two real-time signals (signal numbers "
"32 and 33).  One of these signals is used to support thread cancellation and "
"POSIX timers (see B<timer_create>(2)); the other is used as part of a "
"mechanism that ensures all threads in a process always have the same UIDs "
"and GIDs, as required by POSIX.  These signals cannot be used in "
"applications."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:49
msgid ""
"To prevent accidental use of these signals in applications, which might "
"interfere with the operation of the NPTL implementation, various glibc "
"library functions and system call wrapper functions attempt to hide these "
"signals from applications, as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:52
msgid "B<SIGRTMIN> is defined with the value 34 (rather than 32)."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:60
msgid ""
"The B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  interfaces "
"silently ignore requests to wait for these two signals if they are specified "
"in the signal set argument of these calls."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:66
msgid ""
"The B<sigprocmask>(2)  and B<pthread_sigmask>(3)  interfaces silently ignore "
"attempts to block these two signals."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:75
msgid ""
"The B<sigaction>(2), B<pthread_kill>(3), and B<pthread_sigqueue>(3)  "
"interfaces fail with the error B<EINVAL> (indicating an invalid signal "
"number) if these signals are specified."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:79
msgid ""
"B<sigfillset>(3)  does not include these two signals when it creates a full "
"signal set."
msgstr ""

#. type: SS
#: build/C/man7/nptl.7:79
#, no-wrap
msgid "NPTL and process credential changes"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:89
msgid ""
"At the Linux kernel level, credentials (user and group IDs) are a per-thread "
"attribute.  However, POSIX requires that all of the POSIX threads in a "
"process have the same credentials.  To accommodate this requirement, the "
"NPTL implementation wraps all of the system calls that change process "
"credentials with functions that, in addition to invoking the underlying "
"system call, arrange for all other threads in the process to also change "
"their credentials."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:99
msgid ""
"The implementation of each of these system calls involves the use of a real-"
"time signal that is sent (using B<tgkill>(2))  to each of the other threads "
"that must change its credentials.  Before sending these signals, the thread "
"that is changing credentials saves the new credential(s) and records the "
"system call being employed in a global buffer.  A signal handler in the "
"receiving thread(s) fetches this information and then uses the same system "
"call to change its credentials."
msgstr ""

#.  FIXME .
#.  Maybe say something about vfork() not being serialized wrt set*id() APIs?
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14749
#. type: Plain text
#: build/C/man7/nptl.7:114
msgid ""
"Wrapper functions employing this technique are provided for B<setgid>(2), "
"B<setuid>(2), B<setegid>(2), B<seteuid>(2), B<setregid>(2), B<setreuid>(2), "
"B<setresgid>(2), B<setresuid>(2), and B<setgroups>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:117
#, fuzzy
#| msgid ""
#| "For details on the default stack size of new threads, see "
#| "B<pthread_create>(3)."
msgid ""
"For details of the conformance of NPTL to the POSIX standard, see "
"B<pthreads>(7)."
msgstr ""
"新しいスレッドのデフォルトのスタックサイズの詳細については\n"
"B<pthread_create>(3) を参照。"

#.  See POSIX.1-2008 specification of pthread_mutexattr_init()
#.  See sysdeps/x86/bits/pthreadtypes.h
#. type: Plain text
#: build/C/man7/nptl.7:128
msgid ""
"POSIX says that any thread in any process with access to the memory "
"containing a process-shared (B<PTHREAD_PROCESS_SHARED>)  mutex can operate "
"on that mutex.  However, on 64-bit x86 systems, the mutex definition for "
"x86-64 is incompatible with the mutex definition for i386, meaning that 32-"
"bit and 64-bit binaries can't share mutexes on x86-64 systems."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:133
msgid "B<credentials>(7), B<pthreads>(7), B<signal>(7), B<standards>(7)"
msgstr "B<credentials>(7), B<pthreads>(7), B<signal>(7), B<standards>(7)"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid "For the type and the first two functions, see B<getcontext>(3)."
#~ msgstr ""
#~ "これらの型と、最初の 2 つの関数については、 B<getcontext>(3) を参照のこ"
#~ "と。"

#~ msgid ""
#~ "After a successful call to B<pthread_join>(), the caller is guaranteed "
#~ "that the target thread has terminated."
#~ msgstr ""
#~ "B<pthread_join>() の呼び出しが成功した場合は、\n"
#~ "呼び出し側には、対象スレッドが終了していることが保証される。"

#~ msgid ""
#~ "This is intended as the write lock analog of "
#~ "B<PTHREAD_RWLOCK_PREFER_READER_NP>.  But see BUGS."
#~ msgstr ""
#~ "これは B<PTHREAD_RWLOCK_PREFER_READER_NP> の書き込みロック版である。 ただ"
#~ "し「バグ」を参照のこと。"

#~ msgid ""
#~ "Setting the value read-write lock kind to "
#~ "B<PTHREAD_RWLOCK_PREFER_WRITER_NP> results in the same behavior as "
#~ "setting the value to B<PTHREAD_RWLOCK_PREFER_READER_NP>.  As long as a "
#~ "reader thread holds the lock, the thread holding a write lock will be "
#~ "starved.  Setting the lock kind to "
#~ "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP> allows writers to run, "
#~ "but, as the name implies a writer may not lock recursively."
#~ msgstr ""
#~ "読み書きロック種別の値を B<PTHREAD_RWLOCK_PREFER_WRITER_NP> に設定すること"
#~ "は、 値を B<PTHREAD_RWLOCK_PREFER_READER_NP> に設定するのと同じ動作とな"
#~ "る。 読み出しスレッドがロックを保持する限り、書き込みロックを保持している"
#~ "スレッドは停止することになる。 ロック種別を "
#~ "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP> に設定すると、 書き込み側"
#~ "が動作できるようになるが、変数名から分かるように、 書き込み側はロックを再"
#~ "帰的に行うことはできない。"
