# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: man-pages-ja\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-03-25 19:43+0900\n"
"Last-Translator: Akihiro MOTOKI <amotoki@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.net/projects/p/man-pages-ja/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0\n"

#. type: TH
#: build/C/man2/bdflush.2:27
#, no-wrap
msgid "BDFLUSH"
msgstr "BDFLUSH"

#. type: TH
#: build/C/man2/bdflush.2:27
#, no-wrap
msgid "2016-10-08"
msgstr "2016-10-08"

#. type: TH
#: build/C/man2/bdflush.2:27 build/C/man7/boot.7:15 build/C/man7/bootparam.7:28
#: build/C/man2/reboot.2:28 build/C/man2/sync.2:36
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/bdflush.2:27 build/C/man7/boot.7:15 build/C/man7/bootparam.7:28
#: build/C/man2/reboot.2:28 build/C/man2/sync.2:36
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/bdflush.2:28 build/C/man7/boot.7:16 build/C/man7/bootparam.7:29
#: build/C/man2/reboot.2:29 build/C/man2/sync.2:37
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/bdflush.2:30
msgid "bdflush - start, flush, or tune buffer-dirty-flush daemon"
msgstr ""
"bdflush - バッファーダーティーフラッシュデーモンを起動、フラッシュ、調整する"

#. type: SH
#: build/C/man2/bdflush.2:30 build/C/man2/reboot.2:31 build/C/man2/sync.2:39
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/bdflush.2:33
#, no-wrap
msgid "B<#include E<lt>sys/kdaemon.hE<gt>>\n"
msgstr "B<#include E<lt>sys/kdaemon.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/bdflush.2:36
#, no-wrap
msgid ""
"B<int bdflush(int >I<func>B<, long *>I<address>B<);>\n"
"B<int bdflush(int >I<func>B<, long >I<data>B<);>\n"
msgstr ""
"B<int bdflush(int >I<func>B<, long *>I<address>B<);>\n"
"B<int bdflush(int >I<func>B<, long >I<data>B<);>\n"

#. type: SH
#: build/C/man2/bdflush.2:37 build/C/man7/boot.7:18 build/C/man7/bootparam.7:31
#: build/C/man2/reboot.2:51 build/C/man2/sync.2:67
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#.  As noted in a changes in the 2.5.12 source
#. type: Plain text
#: build/C/man2/bdflush.2:48
msgid ""
"I<Note>: Since Linux 2.6, this system call is deprecated and does nothing.  "
"It is likely to disappear altogether in a future kernel release.  Nowadays, "
"the task performed by B<bdflush>()  is handled by the kernel I<pdflush> "
"thread."
msgstr ""
"I<注意>: Linux 2.6 以降では、このシステムコールは非推奨であり、何も行わな"
"い。\n"
"将来のカーネルのリリースで完全になくなる可能性が高い。現在は、B<bdflush>() "
"が\n"
"実行していた処理はカーネルの I<pdflush> スレッドによって行われている。"

#. type: Plain text
#: build/C/man2/bdflush.2:55
msgid ""
"B<bdflush>()  starts, flushes, or tunes the buffer-dirty-flush daemon.  Only "
"a privileged process (one with the B<CAP_SYS_ADMIN> capability) may call "
"B<bdflush>()."
msgstr ""
"B<bdflush>()  はバッファーダーティーフラッシュ (buffer-dirty-flush) デーモン "
"(daemon) を起動、フラッシュ (flush)、調整 (tune) する。 (B<CAP_SYS_ADMIN> "
"ケーパビリティ (capability) を持つ) 特権プロセスのみが B<bdflush>()  を呼び出"
"すことができる。"

#. type: Plain text
#: build/C/man2/bdflush.2:61
msgid ""
"If I<func> is negative or 0, and no daemon has been started, then "
"B<bdflush>()  enters the daemon code and never returns."
msgstr ""
"I<func> が負か 0 でデーモンが起動されていなれば、 B<bdflush>()  はデーモンの"
"コードへ入り、戻ってこない。"

#. type: Plain text
#: build/C/man2/bdflush.2:66
msgid "If I<func> is 1, some dirty buffers are written to disk."
msgstr ""
"I<func> が 1 ならば、 汚れた (dirty) バッファーがディスクへと書き込まれる。"

#. type: Plain text
#: build/C/man2/bdflush.2:75
msgid ""
"If I<func> is 2 or more and is even (low bit is 0), then I<address> is the "
"address of a long word, and the tuning parameter numbered (I<func>-2)/2 is "
"returned to the caller in that address."
msgstr ""
"I<func> が 2 以上で偶数 (最小ビットが 0) ならば、 I<address> にロングワードで"
"アドレスを指定し、そのアドレスに (I<func>-2)/2 で指定された調節パラメーターが"
"返される。"

#. type: Plain text
#: build/C/man2/bdflush.2:84
msgid ""
"If I<func> is 3 or more and is odd (low bit is 1), then I<data> is a long "
"word, and the kernel sets tuning parameter numbered (I<func>-3)/2 to that "
"value."
msgstr ""
"I<func> が 3 以上で奇数 (最小ビットが 1) ならば、 I<data> をロングワードで指"
"定し、その値を (I<func>-3)/2 で指定された調節パラメーターに設定する。"

#. type: Plain text
#: build/C/man2/bdflush.2:88
msgid ""
"The set of parameters, their values, and their valid ranges are defined in "
"the Linux kernel source file I<fs/buffer.c>."
msgstr ""
"パラメーターの集合やその値、有効な範囲は Linux カーネルソースの I<fs/buffer."
"c> に定義されている。"

#. type: SH
#: build/C/man2/bdflush.2:88 build/C/man2/reboot.2:212 build/C/man2/sync.2:78
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/bdflush.2:97
msgid ""
"If I<func> is negative or 0 and the daemon successfully starts, "
"B<bdflush>()  never returns.  Otherwise, the return value is 0 on success "
"and -1 on failure, with I<errno> set to indicate the error."
msgstr ""
"I<func> が負か 0 で、デモーンの起動に成功した場合は B<bdflush>()  は返ってこ"
"ない。 そうでなければ成功した場合には 0 が返される。失敗した場合には -1 が返"
"され、 I<errno> にそのエラーが指示される。"

#. type: SH
#: build/C/man2/bdflush.2:97 build/C/man2/reboot.2:225 build/C/man2/sync.2:84
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/bdflush.2:98
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/bdflush.2:102
msgid ""
"An attempt was made to enter the daemon code after another process has "
"already entered."
msgstr "他のプロセスが既にデーモンコードに入っているのに、入ろうと試みた。"

#. type: TP
#: build/C/man2/bdflush.2:102 build/C/man2/reboot.2:226
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/bdflush.2:106
msgid "I<address> points outside your accessible address space."
msgstr "I<address> がアクセス可能なアドレス空間の外部を指している。"

#. type: TP
#: build/C/man2/bdflush.2:106 build/C/man2/reboot.2:230
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/bdflush.2:110
msgid ""
"An attempt was made to read or write an invalid parameter number, or to "
"write an invalid value to a parameter."
msgstr ""
"不正なパラメーターの読み書きを試みたか、パラメーターへ不正な値を 書き込もうと"
"した。"

#. type: TP
#: build/C/man2/bdflush.2:110 build/C/man2/reboot.2:233
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/bdflush.2:115
msgid "Caller does not have the B<CAP_SYS_ADMIN> capability."
msgstr "呼び出し元に B<CAP_SYS_ADMIN> ケーパビリティがない。"

#. type: SH
#: build/C/man2/bdflush.2:115 build/C/man2/sync.2:109
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/bdflush.2:117
msgid "Since version 2.23, glibc no longer supports this obsolete system call."
msgstr "バージョン 2.23 以降の glibc では、この廃止予定のシステムコールはサポートされていない。"

#. type: SH
#: build/C/man2/bdflush.2:117 build/C/man2/reboot.2:240 build/C/man2/sync.2:113
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/bdflush.2:121
msgid ""
"B<bdflush>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<bdflush>()  は Linux 特有であり移植を意図したプログラムで使用すべきではな"
"い。"

#. type: SH
#: build/C/man2/bdflush.2:121 build/C/man7/boot.7:222
#: build/C/man7/bootparam.7:676 build/C/man2/reboot.2:244
#: build/C/man2/sync.2:157
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/bdflush.2:125
msgid "B<sync>(1), B<fsync>(2), B<sync>(2)"
msgstr "B<sync>(1), B<fsync>(2), B<sync>(2)"

#. type: SH
#: build/C/man2/bdflush.2:125 build/C/man7/boot.7:230
#: build/C/man7/bootparam.7:682 build/C/man2/reboot.2:254
#: build/C/man2/sync.2:161
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/bdflush.2:133 build/C/man7/boot.7:238
#: build/C/man7/bootparam.7:690 build/C/man2/reboot.2:262
#: build/C/man2/sync.2:169
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man7/boot.7:15
#, no-wrap
msgid "BOOT"
msgstr "BOOT"

#. type: TH
#: build/C/man7/boot.7:15
#, no-wrap
msgid "2015-03-11"
msgstr "2015-03-11"

#. type: Plain text
#: build/C/man7/boot.7:18
msgid "boot - System bootup process based on UNIX System V Release 4"
msgstr "boot - UNIX System V Release 4 に基づくシステムのブートアッププロセス"

#. type: Plain text
#: build/C/man7/boot.7:23
msgid ""
"The B<bootup process> (or \"B<boot sequence>\") varies in details among "
"systems, but can be roughly divided into phases controlled by the following "
"components:"
msgstr ""

#. type: IP
#: build/C/man7/boot.7:23
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/boot.7:25
msgid "hardware"
msgstr "ハードウェア"

#. type: IP
#: build/C/man7/boot.7:25
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/boot.7:27
msgid "operating system (OS) loader"
msgstr "OS (オペレーティングシステム) ローダー"

#. type: IP
#: build/C/man7/boot.7:27
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/boot.7:29
msgid "kernel"
msgstr "カーネル"

#. type: IP
#: build/C/man7/boot.7:29
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/boot.7:31
msgid "root user-space process (I<init> and I<inittab>)"
msgstr ""

#. type: IP
#: build/C/man7/boot.7:31
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man7/boot.7:33
msgid "boot scripts"
msgstr "ブートスクリプト"

#. type: Plain text
#: build/C/man7/boot.7:35
msgid "Each of these is described below in more detail."
msgstr ""

#. type: SS
#: build/C/man7/boot.7:35
#, no-wrap
msgid "Hardware"
msgstr "ハードウェア"

#. type: Plain text
#: build/C/man7/boot.7:40
msgid ""
"After power-on or hard reset, control is given to a program stored in read-"
"only memory (normally PROM); for historical reasons involving the personal "
"computer, this program is often called \"the B<BIOS>\"."
msgstr "電源投入やハードリセットが行われると、 読み出し専用メモリ (通常は PROM) に保存されているプログラムに制御が渡される。 PC などの歴史的な理由により、このプログラムはしばしば B<BIOS> と呼ばれる。"

#. type: Plain text
#: build/C/man7/boot.7:49
msgid ""
"This program normally performs a basic self-test of the machine and accesses "
"nonvolatile memory to read further parameters.  This memory in the PC is "
"battery-backed CMOS memory, so most people refer to it as \"the B<CMOS>\"; "
"outside of the PC world, it is usually called \"the B<NVRAM>\" (nonvolatile "
"RAM)."
msgstr "普通このプログラムは、まずマシンの基本的な自己診断を行い、不揮発性メモリーにアクセスして各種のパラメーターを読み込む。 PC では、このメモリーはバッテリーがつながれた CMOS メモリーであり、そのため B<CMOS> と呼ばれることが多い。 PC 以外の世界では、通常 B<NVRAM> (nonvolatile ram; 不揮発性 RAM) と呼ばれている。"

#. type: Plain text
#: build/C/man7/boot.7:57
msgid ""
"The parameters stored in the NVRAM vary among systems, but as a minimum, "
"they should specify which device can supply an OS loader, or at least which "
"devices may be probed for one; such a device is known as \"the B<boot device>"
"\".  The hardware boot stage loads the OS loader from a fixed position on "
"the boot device, and then transfers control to it."
msgstr ""

#. type: TP
#: build/C/man7/boot.7:57 build/C/man7/boot.7:118 build/C/man7/boot.7:152
#, no-wrap
msgid "Note:"
msgstr "注意:"

#. type: Plain text
#: build/C/man7/boot.7:62
msgid ""
"The device from which the OS loader is read may be attached via a network, "
"in which case the details of booting are further specified by protocols such "
"as DHCP, TFTP, PXE, Etherboot, etc."
msgstr ""

#. type: SS
#: build/C/man7/boot.7:62
#, no-wrap
msgid "OS loader"
msgstr "OS ローダー"

#. type: Plain text
#: build/C/man7/boot.7:70
msgid ""
"The main job of the OS loader is to locate the kernel on some device, load "
"it, and run it.  Most OS loaders allow interactive use, in order to enable "
"specification of an alternative kernel (maybe a backup in case the one last "
"compiled isn't functioning) and to pass optional parameters to the kernel."
msgstr "OS ローダーの主な仕事は、カーネルのデバイス上の位置を特定し、 ロードして起動することである。ほとんどの OS ローダーは、 対話モードで使用することもでき、追加のパラメーターをカーネルに渡したり、 デフォルトとは別のカーネルを指定したりすることができる (例えば、最後にコンパイルしたカーネルが機能しなかった時に バックアップのカーネルを指定して起動するといったことができる)。"

#. type: Plain text
#: build/C/man7/boot.7:74
msgid ""
"In a traditional PC, the OS loader is located in the initial 512-byte block "
"of the boot device; this block is known as \"the B<MBR>\" (Master Boot "
"Record)."
msgstr "昔ながらの PC では、OS ローダーはブートデバイスの最初の 512 バイトブロックに置かれる。このブロックは \"B<MBR>\" (Master Boot Record) と呼ばれる。"

#. type: Plain text
#: build/C/man7/boot.7:82
#, fuzzy
#| msgid ""
#| "In most systems, this primary loader is very limited due to various "
#| "constraints.  Even on non-PC systems there are some limitations to the "
#| "size and complexity of this loader, but the size limitation of the PC MBR "
#| "(512 bytes including the partition table) makes it almost impossible to "
#| "squeeze a full OS loader into it."
msgid ""
"In most systems, the OS loader is very limited due to various constraints.  "
"Even on non-PC systems, there are some limitations on the size and "
"complexity of this loader, but the size limitation of the PC MBR (512 bytes, "
"including the partition table) makes it almost impossible to squeeze much "
"functionality into it."
msgstr ""
"様々な制約のため、 ほとんどのシステムで第一ローダーは非常に簡単な機能しか持っ"
"ていない。 PC 以外のシステムでも、 サイズの制限やローダーの機能などにある程度"
"の制限は存在する。 しかしパーティションテーブルを含めて 512 バイトという PC "
"の MBR では、OS ローダーの全機能をここに押し込むのはまず不可能だ。"

#. type: Plain text
#: build/C/man7/boot.7:87
#, fuzzy
#| msgid ""
#| "Therefore, most operating systems make the primary loader call a "
#| "secondary OS loader which may be located on a specified disk partition."
msgid ""
"Therefore, most systems split the role of loading the OS between a primary "
"OS loader and a secondary OS loader; this secondary OS loader may be located "
"within a larger portion of persistent storage, such as a disk partition."
msgstr ""
"したがって大抵の OS では、第一ローダーは第二ローダーを呼ぶようになっており、 "
"後者はあらかじめ指定されたディスクパーティションに置けるようになっている。"

#. type: Plain text
#: build/C/man7/boot.7:92
msgid "In Linux, the OS loader is often either B<lilo>(8)  or B<grub>(8)."
msgstr "Linux では、多くの場合 OS ローダーは B<lilo>(8) か B<grub>(8) のどちらかである。"

#. type: SS
#: build/C/man7/boot.7:92
#, no-wrap
msgid "Kernel"
msgstr "カーネル"

#. type: Plain text
#: build/C/man7/boot.7:101
#, fuzzy
#| msgid ""
#| "When the kernel is loaded, it initializes the devices (via their "
#| "drivers), starts the swapper (it is a \"kernel process\", called kswapd "
#| "in modern Linux kernels), and mounts the root filesystem (/)."
msgid ""
"When the kernel is loaded, it initializes various components of the computer "
"and operating system; each portion of software responsible for such a task "
"is usually consider \"a B<driver>\" for the applicable component.  The "
"kernel starts the virtual memory swapper (it is a kernel process, called "
"\"kswapd\" in a modern Linux kernel), and mounts some filesystem at the root "
"path, I</>."
msgstr ""
"カーネルはロードされると、デバイスを (ドライバによって)  初期化し、スワッパを"
"起動し (最近の Linux カーネルでは、 スワッパは kswapd という「カーネルプロセ"
"ス」になる)、 ルートファイルシステム (/) をマウントする。"

#. type: Plain text
#: build/C/man7/boot.7:107
#, fuzzy
#| msgid ""
#| "Some of the parameters that may be passed to the kernel relate to these "
#| "activities (e.g: You can override the default root filesystem).  For "
#| "further information on Linux kernel parameters read B<bootparam>(7)."
msgid ""
"Some of the parameters that may be passed to the kernel relate to these "
"activities (for example, the default root filesystem can be overridden); for "
"further information on Linux kernel parameters, read B<bootparam>(7)."
msgstr ""
"カーネルに渡すことのできるパラメーターのいくつかは、 これらの動作に関係す"
"る。 (例えばデフォルトのルートファイルシステムを変更したりできる)。 Linux "
"カーネルパラメーターに関するより詳しい情報は B<bootparam>(7)  を読んでほし"
"い。"

#. type: Plain text
#: build/C/man7/boot.7:117
#, fuzzy
#| msgid ""
#| "Only then the kernel creates the first (user land)  process which is "
#| "numbered 1.  This process executes the program I</sbin/init>, passing any "
#| "parameters that weren't handled by the kernel already."
msgid ""
"Only then does the kernel create the initial userland process, which is "
"given the number 1 as its B<PID> (process ID).  Traditionally, this process "
"executes the program I</sbin/init>, to which are passed the parameters that "
"haven't already been handled by the kernel."
msgstr ""
"これらが済んではじめて、 カーネルは最初の (ユーザーランドの) プロセスを生成"
"し、 番号 1 を与える。このプロセスは I</sbin/init> プログラムを実行する。 "
"カーネルによって解釈されていないパラメーターはすべて I</sbin/init> に渡され"
"る。"

#. type: SS
#: build/C/man7/boot.7:117
#, no-wrap
msgid "Root user-space process"
msgstr ""

#. type: Plain text
#: build/C/man7/boot.7:126
msgid ""
"The following description applies to an OS based on UNIX System V Release "
"4.  However, a number of widely used systems have adopted a related but "
"fundamentally different approach known as B<systemd>(1), for which the "
"bootup process is detailed in its associated B<bootup>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/boot.7:139
msgid ""
"When I</sbin/init> starts, it reads I</etc/inittab> for further "
"instructions.  This file defines what should be run when the I</sbin/init> "
"program is instructed to enter a particular I<run-level>, giving the "
"administrator an easy way to establish an environment for some usage; each "
"run-level is associated with a set of services (for example, run-level B<S> "
"is I<single-user> mode, and run-level B<2> entails running most network "
"services)."
msgstr ""

#. type: Plain text
#: build/C/man7/boot.7:145
msgid ""
"The administrator may change the current run-level via B<init>(1), and query "
"the current run-level via B<runlevel>(8)."
msgstr ""

#. type: Plain text
#: build/C/man7/boot.7:151
#, fuzzy
#| msgid ""
#| "However, since it is not convenient to manage individual services by "
#| "editing this file, inittab only bootstraps a set of scripts that actually "
#| "start/stop the individual services."
msgid ""
"However, since it is not convenient to manage individual services by editing "
"this file, I</etc/inittab> only bootstraps a set of scripts that actually "
"start/stop the individual services."
msgstr ""
"しかし、このファイルを編集して個々のサービスを管理するのは不便なので、 "
"inittab は単にスクリプトの集合に対するブートストラップになっている。 実際の"
"個々のサービスの起動や停止は、これらのスクリプトで行う。"

#. type: SS
#: build/C/man7/boot.7:151
#, no-wrap
msgid "Boot scripts"
msgstr "ブートスクリプト"

#. type: Plain text
#: build/C/man7/boot.7:157
#, fuzzy
#| msgid ""
#| "The following description applies to System V release 4-based systems, "
#| "which currently covers most commercial UNIX systems (Solaris, HP-UX, "
#| "Irix, Tru64)  as well as the major Linux distributions (Red Hat, Debian, "
#| "Mandriva, SUSE, Ubuntu).  Some systems (Slackware Linux, FreeBSD, "
#| "OpenBSD)  have a somewhat different scheme of boot scripts."
msgid ""
"The following description applies to an OS based on UNIX System V Release "
"4.  However, a number of widely used systems (Slackware Linux, FreeBSD, "
"OpenBSD)  have a somewhat different scheme for boot scripts."
msgstr ""
"以下の説明は System V Release 4 をベースとしたシステムに関するものである。 現"
"在の大抵の商用 UNIX システム (Solaris, HP-UX, Irix, Tru64) や、 メジャーな "
"Linux ディストリビューション (Red Hat, Debian, Mandriva, SUSE, Ubuntu) はこれ"
"をベースにしたものである。 システムによっては、ブートスクリプトの機構が いく"
"らか異なることもある (Slackware Linux, FreeBSD, OpenBSD など)。"

#. type: Plain text
#: build/C/man7/boot.7:170
#, fuzzy
#| msgid ""
#| "For each managed service (mail, nfs server, cron, etc.) there is a single "
#| "startup script located in a specific directory (I</etc/init.d> in most "
#| "versions of Linux).  Each of these scripts accepts as a single argument "
#| "the word \"start\" -- causing it to start the service, or the word \\&"
#| "\"stop\" -- causing it to stop the service.  The script may optionally "
#| "accept other \"convenience\" parameters (e.g: \"restart\", to stop and "
#| "then start, \"status\" to display the service status).  Running the "
#| "script without parameters displays the possible arguments."
msgid ""
"For each managed service (mail, nfs server, cron, etc.), there is a single "
"startup script located in a specific directory (I</etc/init.d> in most "
"versions of Linux).  Each of these scripts accepts as a single argument the "
"word \"start\" (causing it to start the service) or the word \\&\"stop"
"\" (causing it to stop the service).  The script may optionally accept other "
"\"convenience\" parameters (e.g., \"restart\" to stop and then start, "
"\"status\" to display the service status, etc.).  Running the script without "
"parameters displays the possible arguments."
msgstr ""
"管理すべき各サービス (メール、nfs サーバ、cron などなど)  それぞれに対して、"
"ブートスクリプトがひとつずつ特定のディレクトリ (ほとんどの Linux で I</etc/"
"init.d>)  に配置される。これらのスクリプトは、 それぞれ引数としてひとつの単語"
"を取る。\"start\" が指定されると そのサービスを起動し、\"stop\" が指定される"
"とサービスを停止する。 スクリプトは他の「便利な」引数を取ってもよい (例えば "
"\"restart\" で停止・起動を順番に行ったり、\"status\" でサービスの状態を表示す"
"るなど)。 スクリプトを引数なしで実行すると、 指定できる引数の一覧が表示され"
"る。"

#. type: SS
#: build/C/man7/boot.7:170
#, no-wrap
msgid "Sequencing directories"
msgstr "順序づけディレクトリ"

#. type: Plain text
#: build/C/man7/boot.7:177
#, fuzzy
#| msgid ""
#| "To make specific scripts start/stop at specific run-levels and in "
#| "specific order, there are I<sequencing directories>.  These are normally "
#| "in I</etc/rc[0-6S].d>.  In each of these directories there are links "
#| "(usually symbolic) to the scripts in the I</etc/init.d> directory."
msgid ""
"To make specific scripts start/stop at specific run-levels and in a specific "
"order, there are I<sequencing directories>, normally of the form I</etc/"
"rc[0-6S].d>.  In each of these directories, there are links (usually "
"symbolic) to the scripts in the I</etc/init.d> directory."
msgstr ""
"あるランレベルで、特定のスクリプトを指定した順序で実行させるため、 I<順序付け"
"ディレクトリ (sequencing directory)> という仕組みが存在する。 これらはふつう "
"I</etc/rc[0-6S].d> である。各ディレクトリの内部には、 I</etc/init.d> ディレク"
"トリに置かれたスクリプトへのリンク (ふつうはシンボリックリンク)  が置かれる。"

#. type: Plain text
#: build/C/man7/boot.7:186
#, fuzzy
#| msgid ""
#| "A primary script (usually I</etc/rc>) is called from B<inittab>(5)  and "
#| "calls the services scripts via the links in the sequencing directories.  "
#| "All links with names that begin with \\(aqS\\(aq are being called with "
#| "the argument \"start\" (thereby starting the service).  All links with "
#| "names that begin with \\(aqK\\(aq are being called with the argument "
#| "\"stop\" (thereby stopping the service)."
msgid ""
"A primary script (usually I</etc/rc>) is called from B<inittab>(5); this "
"primary script calls each service's script via a link in the relevant "
"sequencing directory.  Each link whose name begins with \\(aqS\\(aq is "
"called with the argument \"start\" (thereby starting the service).  Each "
"link whose name begins with \\(aqK\\(aq is called with the argument \"stop"
"\" (thereby stopping the service)."
msgstr ""
"第一スクリプト (通常 I</etc/rc>)  は B<inittab>(5)  から呼ばれ、 順序付けディ"
"レクトリに置かれたリンク経由で各サービススクリプトを呼び出す。 名前が \\(aqS"
"\\(aq ではじまるリンクは \"start\" という引数をつけて呼び出され (すなわちサー"
"ビスが起動し)。名前が \\(aqK\\(aq ではじまるリンクは \"stop\" という引数をつ"
"けて呼び出される (すなわちサービスが停止する)。"

#. type: Plain text
#: build/C/man7/boot.7:196
#, fuzzy
#| msgid ""
#| "To define the starting or stopping order within the same run-level, the "
#| "names of the links contain order-numbers.  Also, to make the names "
#| "clearer, they usually end with the name of the service they refer to.  "
#| "Example: the link I</etc/rc2.d/S80sendmail> starts the sendmail service "
#| "on runlevel 2.  This happens after I</etc/rc2.d/S12syslog> is run but "
#| "before I</etc/rc2.d/S90xfs> is run."
msgid ""
"To define the starting or stopping order within the same run-level, the name "
"of a link contains an B<order-number>.  Also, for clarity, the name of a "
"link usually ends with the name of the service to which it refers.  For "
"example, the link I</etc/rc2.d/S80sendmail> starts the sendmail service on "
"runlevel 2.  This happens after I</etc/rc2.d/S12syslog> is run but before I</"
"etc/rc2.d/S90xfs> is run."
msgstr ""
"同じランレベルの内部での起動や停止の順序を規定するために、 リンクの名前には順"
"序を示す数字が含まれる。 また、名前をわかりやすくするため、 リンク名の末尾に"
"は対応するサービスの名前がつけられる。 例えば、 I</etc/rc2.d/S80sendmail> と"
"いうリンクは、sendmail サービスをランレベル 2 において起動する。 これは、 I</"
"etc/rc2.d/S12syslog> よりも後に、また I</etc/rc2.d/S90xfs> よりも先に実行され"
"る。"

#. type: Plain text
#: build/C/man7/boot.7:201
#, fuzzy
#| msgid ""
#| "To manage the boot order and run-levels, we have to manage these links.  "
#| "However, on many versions of Linux, there are tools to help with this "
#| "task (e.g: B<chkconfig>(8))."
msgid ""
"To manage these links is to manage the boot order and run-levels; under many "
"systems, there are tools to help with this task (e.g., B<chkconfig>(8))."
msgstr ""
"ブートの順序とランレベルを管理するには、 これらのリンクを管理しなければならな"
"い。 しかし多くの Linux ディストリビューションでは、 これらの作業を手助けして"
"くれるツールが存在する (例えば B<chkconfig>(8)  など)。"

#. type: SS
#: build/C/man7/boot.7:201
#, no-wrap
msgid "Boot configuration"
msgstr "ブートの設定"

#. type: Plain text
#: build/C/man7/boot.7:210
#, fuzzy
#| msgid ""
#| "Usually the daemons started may optionally receive command-line options "
#| "and parameters.  To allow system administrators to change these "
#| "parameters without editing the boot scripts themselves, configuration "
#| "files are used.  These are located in a specific directory (I</etc/"
#| "sysconfig> on Red Hat systems) and are used by the boot scripts."
msgid ""
"A program that provides a service is often called a \"B<daemon>\".  Usually, "
"a daemon may receive various command-line options and parameters.  To allow "
"a system administrator to change these inputs without editing an entire boot "
"script, some separate configuration file is used, and is located in a "
"specific directory where an associated boot script may find it (I</etc/"
"sysconfig> on older Red Hat systems)."
msgstr ""
"デーモンの起動時には、 コマンドラインオプションやパラメーターを指定できるのが"
"普通である。 システム管理者がこれらのパラメーターを変更したいと思ったとき"
"に、 ブートスクリプトそのものを編集しなくてもすむよう、 設定ファイルが用いら"
"れる。これらは特定のディレクトリ (Red Hat システムでは I</etc/sysconfig>)  に"
"置かれ、ブートスクリプトから参照される。"

#. type: Plain text
#: build/C/man7/boot.7:217
#, fuzzy
#| msgid ""
#| "In older UNIX systems, these files contained the actual command line "
#| "options for the daemons, but in modern Linux systems (and also in HP-UX), "
#| "these files just contain shell variables.  The boot scripts in I</etc/"
#| "init.d> B<source> the configuration files, and then use the variable "
#| "values."
msgid ""
"In older UNIX systems, such a file contained the actual command line options "
"for a daemon, but in modern Linux systems (and also in HP-UX), it just "
"contains shell variables.  A boot script in I</etc/init.d> reads and "
"includes its configuration file (that is, it \"B<sources>\" its "
"configuration file) and then uses the variable values."
msgstr ""
"古い UNIX システムでは、これらのファイルには デーモンに与える実際のコマンドラ"
"インオプションが書かれていた。 しかし最近の Linux システム (や HP-UX) では、 "
"これらのファイルには単にシェル変数が書かれているだけである。 I</etc/init.d> "
"に置かれたブートスクリプトは、これらの設定ファイルを B<source> し、その変数の"
"値を用いる。"

#. type: SH
#: build/C/man7/boot.7:217
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man7/boot.7:222
msgid "I</etc/init.d/>, I</etc/rc[S0-6].d/>, I</etc/sysconfig/>"
msgstr "I</etc/init.d/>, I</etc/rc[S0-6].d/>, I</etc/sysconfig/>"

#. type: Plain text
#: build/C/man7/boot.7:230
msgid ""
"B<init>(1), B<systemd>(1), B<inittab>(5), B<bootparam>(7), B<bootup>(7), "
"B<runlevel>(8), B<shutdown>(8)"
msgstr "B<init>(1), B<systemd>(1), B<inittab>(5), B<bootparam>(7), B<bootup>(7), B<runlevel>(8), B<shutdown>(8)"

#. type: TH
#: build/C/man7/bootparam.7:28
#, no-wrap
msgid "BOOTPARAM"
msgstr "BOOTPARAM"

#. type: TH
#: build/C/man7/bootparam.7:28
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man7/bootparam.7:31
msgid "bootparam - introduction to boot time parameters of the Linux kernel"
msgstr "bootparam - Linux カーネル起動時パラメーターの解説"

#. type: Plain text
#: build/C/man7/bootparam.7:38
msgid ""
"The Linux kernel accepts certain 'command-line options' or 'boot time "
"parameters' at the moment it is started.  In general, this is used to supply "
"the kernel with information about hardware parameters that the kernel would "
"not be able to determine on its own, or to avoid/override the values that "
"the kernel would otherwise detect."
msgstr ""
"Linux カーネルは起動するときに「コマンドラインオプション」あるいは 「起動時パ"
"ラメーター」を受け付ける。 これは一般に、 カーネルには決定できないハードウェ"
"アのパラメーターをカーネルに渡したい場合や、 カーネルが検出するであろう値を意"
"図的に無効にしたり変更したりする場合に用いる。"

#. type: Plain text
#: build/C/man7/bootparam.7:43
#, fuzzy
#| msgid ""
#| "When the kernel is booted directly by the BIOS (say from a floppy to "
#| "which you copied a kernel using 'cp zImage /dev/fd0'), you have no "
#| "opportunity to specify any parameters.  So, in order to take advantage of "
#| "this possibility you have to use a boot loader that is able to pass "
#| "parameters, such as GRUB."
msgid ""
"When the kernel is booted directly by the BIOS, you have no opportunity to "
"specify any parameters.  So, in order to take advantage of this possibility "
"you have to use a boot loader that is able to pass parameters, such as GRUB."
msgstr ""
"カーネルが BIOS から直接起動されるとき (たとえば 'cp zImage /dev/fd0' でフ"
"ロッピーにコピーしたカーネルから起動するなど) は、 パラメーターを指定する機会"
"はない。 そのため、この起動時パラメーター機能を利用するためには、 GRUB のよう"
"なパラメーターを指定できるブートローダーを使用しなければならない。"

#. type: SS
#: build/C/man7/bootparam.7:43
#, no-wrap
msgid "The argument list"
msgstr "引数リスト"

#. type: Plain text
#: build/C/man7/bootparam.7:47
#, fuzzy
#| msgid ""
#| "The kernel command line is parsed into a list of strings (boot arguments) "
#| "separated by spaces.  Most of the boot arguments take have the form:"
msgid ""
"The kernel command line is parsed into a list of strings (boot arguments) "
"separated by spaces.  Most of the boot arguments have the form:"
msgstr ""
"カーネルのコマンドラインはパースされ、スペースで区切られた文字列 (I<起動時引"
"数: boot arguments>)  のリストとなる。 ほとんどの起動時引数は次の書式である。"

#. type: Plain text
#: build/C/man7/bootparam.7:51
#, no-wrap
msgid "name[=value_1][,value_2]...[,value_10]\n"
msgstr "name[=value_1][,value_2]...[,value_10]\n"

#. type: Plain text
#: build/C/man7/bootparam.7:61
msgid ""
"where 'name' is a unique keyword that is used to identify what part of the "
"kernel the associated values (if any) are to be given to.  Note the limit of "
"10 is real, as the present code handles only 10 comma separated parameters "
"per keyword.  (However, you can reuse the same keyword with up to an "
"additional 10 parameters in unusually complicated situations, assuming the "
"setup function supports it.)"
msgstr ""
"ここで 'name' は、それに対応する値がカーネルのどの部分に渡されるものなのかを "
"識別するための、他と重ならないキーワードである。 書式中の 10 という制限は実際"
"に存在する。 現在のコードは、キーワードひとつあたり、コンマで区切られたパラ"
"メーターを 10 個までしか取り扱うことができない。 (しかし、事情が非常に複雑な"
"場合には、同じキーワードを再度利用して 10 個以上のパラメーターを与えることが"
"できるかもしれない。 対象となるハードウェアの設定関数がそれをサポートしていれ"
"ば、だが。)"

#. type: Plain text
#: build/C/man7/bootparam.7:68
msgid ""
"Most of the sorting is coded in the kernel source file I<init/main.c>.  "
"First, the kernel checks to see if the argument is any of the special "
"arguments 'root=', \\&'nfsroot=', 'nfsaddrs=', 'ro', 'rw', 'debug' or "
"'init'.  The meaning of these special arguments is described below."
msgstr ""
"カーネルコマンドラインの識別はほとんどがカーネルソースファイル I<init/main."
"c> に書かれている。 最初に、カーネルは \\&'root=', 'nfsroot=', 'nfsaddrs=', "
"'ro', 'rw', 'debug', 'init' といった特別な引数があるかをチェックする。 これら"
"の意味については後述する。"

#. type: Plain text
#: build/C/man7/bootparam.7:79
#, fuzzy
#| msgid ""
#| "Then it walks a list of setup functions (contained in the bootsetups "
#| "array) to see if the specified argument string (such as 'foo') has been "
#| "associated with a setup function ('foo_setup()') for a particular device "
#| "or part of the kernel.  If you passed the kernel the line foo=3,4,5,6 "
#| "then the kernel would search the bootsetups array to see if 'foo' was "
#| "registered.  If it was, then it would call the setup function associated "
#| "with 'foo' (foo_setup()) and hand it the arguments 3, 4, 5, and 6 as "
#| "given on the kernel command line."
msgid ""
"Then it walks a list of setup functions to see if the specified argument "
"string (such as 'foo') has been associated with a setup function "
"('foo_setup()') for a particular device or part of the kernel.  If you "
"passed the kernel the line foo=3,4,5,6 then the kernel would search the "
"bootsetups array to see if 'foo' was registered.  If it was, then it would "
"call the setup function associated with 'foo' (foo_setup()) and hand it the "
"arguments 3, 4, 5, and 6 as given on the kernel command line."
msgstr ""
"カーネルは次に設定関数のリスト (配列 bootsetups に含まれている) をスキャン"
"し、 指定された引数文字列 (例えば 'foo') が 特定のデバイスやカーネルの一部に"
"対する設定関数 ('foo_setup()') に関連付けられているかを調べる。 例えばカーネ"
"ルに foo=3,4,5,6 のようなパラメーターを与えたとすると、 カーネルは配列 "
"bootsetups を調べて、 'foo' が登録されているか調べる。 登録されていた"
"ら、'foo' に対応する設定関数 ('foo_setup()') をコールし、 カーネルコマンドラ"
"インに与えられた引数である 3, 4, 5, 6 を設定関数に渡す。"

#. type: Plain text
#: build/C/man7/bootparam.7:85
msgid ""
"Anything of the form 'foo=bar' that is not accepted as a setup function as "
"described above is then interpreted as an environment variable to be set.  A "
"(useless?) example would be to use 'TERM=vt100' as a boot argument."
msgstr ""
"\\&'foo=bar' という形式の引数のうち、 上記のように設定関数に受け入れられな"
"かったものは、 環境変数と解釈されて設定される。 (あまり役に立たない?) 例とし"
"ては、'TERM=VT100' がある。"

#. type: Plain text
#: build/C/man7/bootparam.7:101
#, fuzzy
#| msgid ""
#| "Any remaining arguments that were not picked up by the kernel and were "
#| "not interpreted as environment variables are then passed onto process "
#| "one, which is usually the B<init>(1)  program.  The most common argument "
#| "that is passed to the I<init> process is the word 'single' which "
#| "instructs it to boot the computer in single user mode, and not launch all "
#| "the usual daemons.  Check the manual page for the version of B<init>(1)  "
#| "installed on your system to see what arguments it accepts."
msgid ""
"Any remaining arguments that were not picked up by the kernel and were not "
"interpreted as environment variables are then passed onto PID 1, which is "
"usually the B<init>(1)  program.  The most common argument that is passed to "
"the I<init> process is the word 'single' which instructs it to boot the "
"computer in single user mode, and not launch all the usual daemons.  Check "
"the manual page for the version of B<init>(1)  installed on your system to "
"see what arguments it accepts."
msgstr ""
"カーネルによって処理されず、環境変数としても解釈されなかった 残りの引数は、プ"
"ロセス 1 に渡されることになる。 通常このプロセス 1 は B<init>(1) プログラムで"
"ある。 I<init> プロセスに渡される引数で最もよく使われるのは、 'single' という"
"キーワードである。 これを指定すると init はシングルユーザーモードでコンピュー"
"タを起動し、 通常使われるデーモンは一切起動しない。 システムにインストールさ"
"れている B<init>(1) が どんな引数を受け付けるかは、 マニュアルページで調べる"
"こと。"

#. type: SS
#: build/C/man7/bootparam.7:101
#, no-wrap
msgid "General non-device-specific boot arguments"
msgstr "一般的な、デバイス固有ではない起動時引き数"

#. type: TP
#: build/C/man7/bootparam.7:102
#, no-wrap
msgid "B<'init=...'>"
msgstr "B<'init=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:114
msgid ""
"This sets the initial command to be executed by the kernel.  If this is not "
"set, or cannot be found, the kernel will try I</sbin/init>, then I</etc/"
"init>, then I</bin/init>, then I</bin/sh> and panic if all of this fails."
msgstr ""
"カーネルが実行する初期コマンドを設定する。 この指定がなされなかったり、指定し"
"たコマンドが見つからなかった場合には、 カーネルは I</sbin/init>, I</etc/"
"init>, I</bin/init>, I</bin/sh> の順で実行を試み、すべてに失敗したら panic を"
"起こす。"

#. type: TP
#: build/C/man7/bootparam.7:114
#, no-wrap
msgid "B<'nfsaddrs=...'>"
msgstr "B<'nfsaddrs=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:118
#, fuzzy
#| msgid ""
#| "This sets the nfs boot address to the given string.  This boot address is "
#| "used in case of a net boot."
msgid ""
"This sets the NFS boot address to the given string.  This boot address is "
"used in case of a net boot."
msgstr ""
"nfs のブートアドレスを指定した文字列に設定する。 このブートアドレスはネット"
"ワークブートの場合に用いられる。"

#. type: TP
#: build/C/man7/bootparam.7:118
#, no-wrap
msgid "B<'nfsroot=...'>"
msgstr "B<'nfsroot=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:125
#, fuzzy
#| msgid ""
#| "This sets the nfs root name to the given string.  If this string does not "
#| "begin with '/' or ',' or a digit, then it is prefixed by \\&'/"
#| "tftpboot/'.  This root name is used in case of a net boot."
msgid ""
"This sets the NFS root name to the given string.  If this string does not "
"begin with '/' or ',' or a digit, then it is prefixed by \\&'/tftpboot/'.  "
"This root name is used in case of a net boot."
msgstr ""
"nfs ルートの名前を設定する。 この文字列の先頭が '/'、','、数字のいずれでもで"
"ないときは、 \\&'/tftpboot/' が先頭に付加される。 この名前はネットワークブー"
"トの場合に用いられる。"

#. type: TP
#: build/C/man7/bootparam.7:125
#, no-wrap
msgid "B<'root=...'>"
msgstr "B<'root=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:135
msgid ""
"This argument tells the kernel what device is to be used as the root "
"filesystem while booting.  The default of this setting is determined at "
"compile time, and usually is the value of the root device of the system that "
"the kernel was built on.  To override this value, and select the second "
"floppy drive as the root device, one would use 'root=/dev/fd1'."
msgstr ""
"起動時にルートファイルシステムとして使われるデバイスをカーネルに指定する。 デ"
"フォルトはコンパイル時に決定され、 通常はカーネルを構築したシステムのルートデ"
"バイスになる。 この値を無効にして、 例えば 2 番目のフロッピーディスクドライブ"
"をルートデバイスに指定する場合は、 \\&'root=/dev/fd1' とする。"

#. type: Plain text
#: build/C/man7/bootparam.7:144
msgid ""
"The root device can be specified symbolically or numerically.  A symbolic "
"specification has the form I</dev/XXYN>, where XX designates the device type "
"(e.g., 'hd' for ST-506 compatible hard disk, with Y in \\&'a'\\(en'd'; 'sd' "
"for SCSI compatible disk, with Y in 'a'\\(en'e'), Y the driver letter or "
"number, and N the number (in decimal) of the partition on this device."
msgstr ""

#. type: Plain text
#: build/C/man7/bootparam.7:148
msgid ""
"Note that this has nothing to do with the designation of these devices on "
"your filesystem.  The '/dev/' part is purely conventional."
msgstr ""
"なお、これらはファイルシステム上でのデバイスの指定方法とは全く関係ない。 "
"\\&'/dev/' を用いるのは単に慣習に過ぎない。"

#. type: Plain text
#: build/C/man7/bootparam.7:155
msgid ""
"The more awkward and less portable numeric specification of the above "
"possible root devices in major/minor format is also accepted.  (For example, "
"I</dev/sda3> is major 8, minor 3, so you could use 'root=0x803' as an "
"alternative.)"
msgstr ""
"扱いにくいし移植性も良くないが、 上記のデバイスを major/minor 番号の数値で指"
"定してもよい。 (例えば I</dev/sda3> は major 番号 8、minor 番号 3 なので、 "
"\\&'root=0x803' と記述できる。)"

#. type: TP
#: build/C/man7/bootparam.7:155
#, no-wrap
msgid "B<'rootdelay='>"
msgstr "B<'rootdelay='>"

#. type: Plain text
#: build/C/man7/bootparam.7:159
msgid ""
"This parameter sets the delay (in seconds) to pause before attempting to "
"mount the root filesystem."
msgstr ""
"このパラメーターは root ファイルシステムのマウントを行う前に停止する遅延時間 "
"(秒単位) を指定する。"

#. type: TP
#: build/C/man7/bootparam.7:159
#, no-wrap
msgid "B<'rootflags=...'>"
msgstr "B<'rootflags=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:164
msgid ""
"This parameter sets the mount option string for the root filesystem (see "
"also B<fstab>(5))."
msgstr ""
"このパラメーターは root ファイルシステムのマウントオプション文字列を指定する "
"(B<fstab>(5) も参照)。"

#. type: TP
#: build/C/man7/bootparam.7:164
#, no-wrap
msgid "B<'rootfstype=...'>"
msgstr "B<'rootfstype=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:172
msgid ""
"The 'rootfstype' option tells the kernel to mount the root filesystem as if "
"it where of the type specified.  This can be useful (for example) to mount "
"an ext3 filesystem as ext2 and then remove the journal in the root "
"filesystem, in fact reverting its format from ext3 to ext2 without the need "
"to boot the box from alternate media."
msgstr ""
"'rootfstype' オプションが指定されると、 カーネルは、 指定されたタイプであると"
"みなしてルートファイルシステムをマウントする。 このオプションは、 例えば、"
"ext3 ファイルシステムを ext2 としてマウントし、 ルートファイルシステムの"
"ジャーナルを削除する場合に便利である。 こうすると、 別のメディアからマシンを"
"起動することなく ext3 から ext2 へ戻すことができる。"

#. type: TP
#: build/C/man7/bootparam.7:172
#, no-wrap
msgid "B<'ro'> and B<'rw'>"
msgstr "B<'ro'> と B<'rw'>"

#. type: Plain text
#: build/C/man7/bootparam.7:182
msgid ""
"The 'ro' option tells the kernel to mount the root filesystem as 'read-only' "
"so that filesystem consistency check programs (fsck)  can do their work on a "
"quiescent filesystem.  No processes can write to files on the filesystem in "
"question until it is 'remounted' as read/write capable, for example, by "
"'mount -w -n -o remount /'.  (See also B<mount>(8).)"
msgstr ""
"\\&'ro' オプションは、 ルートファイルシステムを 「読み出し専用」でマウントす"
"るようカーネルに指示し、 fsck プログラムがファイルシステムの矛盾を検査できる"
"ようにする。 ファイルシステムが「読み書き可能」として再マウントされる (つま"
"り 'mount -w -n -o remount /') までの間は、 いかなるプロセスもこのファイルシ"
"ステム上のファイルに書き込むことはできない。 (B<mount>(8)  も参照。)"

#. type: Plain text
#: build/C/man7/bootparam.7:185
msgid ""
"The 'rw' option tells the kernel to mount the root filesystem read/write.  "
"This is the default."
msgstr ""
"rw オプションはルートファイルシステムを 「読み書き可能」でマウントするよう"
"カーネルに指示する。 こちらがデフォルトである。"

#. type: TP
#: build/C/man7/bootparam.7:185
#, no-wrap
msgid "B<'resume=...'>"
msgstr "B<'resume=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:190
#, fuzzy
#| msgid ""
#| "This tells the kernel the location of the suspend-to-disk data that you "
#| "want the machine to resume from after hibernation.  Usually, it is the "
#| "same as your swap partition or file. Example:"
msgid ""
"This tells the kernel the location of the suspend-to-disk data that you want "
"the machine to resume from after hibernation.  Usually, it is the same as "
"your swap partition or file.  Example:"
msgstr ""
"このオプションは、 マシンを休止状態 (ハイバネーション) から再起動する際の、"
"ディスク上に保存したデータの起動位置をカーネルに指示する。 通常は、スワップ"
"パーティションやスワップファイルと同じである。例えば、"

#. type: Plain text
#: build/C/man7/bootparam.7:194
#, no-wrap
msgid "resume=/dev/hda2\n"
msgstr "resume=/dev/hda2\n"

#. type: TP
#: build/C/man7/bootparam.7:196
#, no-wrap
msgid "B<'reserve=...'>"
msgstr "B<'reserve=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:200
msgid ""
"This is used to protect I/O port regions from probes.  The form of the "
"command is:"
msgstr ""
"デバイスの自動検出から I/O ポートを保護するために用いる。 コマンドの形式は以"
"下の通り。"

#. type: Plain text
#: build/C/man7/bootparam.7:204
#, no-wrap
msgid "B<reserve=>I<iobase,extent[,iobase,extent]...>\n"
msgstr "B<reserve=>I<iobase,extent[,iobase,extent]...>\n"

#. type: Plain text
#: build/C/man7/bootparam.7:213
msgid ""
"In some machines it may be necessary to prevent device drivers from checking "
"for devices (auto-probing) in a specific region.  This may be because of "
"hardware that reacts badly to the probing, or hardware that would be "
"mistakenly identified, or merely hardware you don't want the kernel to "
"initialize."
msgstr ""
"機種によっては、 デバイスドライバによるデバイスの自動検出を、 特定の範囲に対"
"しては禁止しなければならないことがある。 ハードウェアが検出動作によって深刻な"
"問題を引き起こす場合や、 誤認識される可能性がある場合、 また単にカーネルに"
"ハードウェアを初期化させたくない場合などがありうるだろう。"

#. type: Plain text
#: build/C/man7/bootparam.7:218
msgid ""
"The reserve boot-time argument specifies an I/O port region that shouldn't "
"be probed.  A device driver will not probe a reserved region, unless another "
"boot argument explicitly specifies that it do so."
msgstr ""
"この起動時引数 reserve は、自動検出の対象外とする I/O ポートの範囲を指定す"
"る。 デバイスドライバは、 他の起動時引数によって明示的に指定されない限り、 予"
"約された範囲に対して自動検出動作を行わない。"

#. type: Plain text
#: build/C/man7/bootparam.7:220
msgid "For example, the boot line"
msgstr "例えばブート時のコマンドラインに"

#. type: Plain text
#: build/C/man7/bootparam.7:224
#, no-wrap
msgid "reserve=0x300,32  blah=0x300\n"
msgstr "reserve=0x300,32  blah=0x300\n"

#. type: Plain text
#: build/C/man7/bootparam.7:229
msgid ""
"keeps all device drivers except the driver for 'blah' from probing "
"0x300-0x31f."
msgstr ""
"と指定すると、'blah' を除くすべてのデバイスドライバは 0x300 から 0x31f の範囲"
"を自動検出の対象外とする。"

#. type: TP
#: build/C/man7/bootparam.7:229
#, no-wrap
msgid "B<'panic=N'>"
msgstr "B<'panic=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:234
#, fuzzy
#| msgid ""
#| "By default the kernel will not reboot after a panic, but this option will "
#| "cause a kernel reboot after N seconds (if N is greater than zero).  This "
#| "panic timeout can also be set by"
msgid ""
"By default, the kernel will not reboot after a panic, but this option will "
"cause a kernel reboot after N seconds (if N is greater than zero).  This "
"panic timeout can also be set by"
msgstr ""
"デフォルトでは、カーネルはパニックの後リブートしない。 このオプションを用い"
"て (N を 0 より大きな値とすれば)  N 秒後にリブートするようになる。 この値は、"
"起動後に以下のようにして設定することもできる。"

#. type: Plain text
#: build/C/man7/bootparam.7:238
#, no-wrap
msgid "echo N E<gt> /proc/sys/kernel/panic\n"
msgstr "echo N E<gt> /proc/sys/kernel/panic\n"

#. type: TP
#: build/C/man7/bootparam.7:240
#, no-wrap
msgid "B<'reboot=[warm|cold][,[bios|hard]]'>"
msgstr "B<'reboot=[warm|cold][,[bios|hard]]'>"

#. type: Plain text
#: build/C/man7/bootparam.7:252
#, fuzzy
#| msgid ""
#| "(Only when B<CONFIG_BUGi386> is defined.)  Since 2.0.22 a reboot is by "
#| "default a cold reboot.  One asks for the old default with 'reboot=warm'.  "
#| "(A cold reboot may be required to reset certain hardware, but might "
#| "destroy not yet written data in a disk cache.  A warm reboot may be "
#| "faster.)  By default a reboot is hard, by asking the keyboard controller "
#| "to pulse the reset line low, but there is at least one type of "
#| "motherboard where that doesn't work.  The option 'reboot=bios' will "
#| "instead jump through the BIOS."
msgid ""
"Since Linux 2.0.22, a reboot is by default a cold reboot.  One asks for the "
"old default with 'reboot=warm'.  (A cold reboot may be required to reset "
"certain hardware, but might destroy not yet written data in a disk cache.  A "
"warm reboot may be faster.)  By default, a reboot is hard, by asking the "
"keyboard controller to pulse the reset line low, but there is at least one "
"type of motherboard where that doesn't work.  The option 'reboot=bios' will "
"instead jump through the BIOS."
msgstr ""
"(カーネルコンパイル時に B<CONFIG_BUGi386> が指定されたときのみ有効。)  カーネ"
"ルバージョン 2.0.22 から、 リブートのデフォルトはコールドブートになった。 以"
"前のデフォルトであるウォームブートをするには \\&'reboot=warm' と指定しなけれ"
"ばならない。 (ある種のハードウェアをリセットするにはコールドブートが必要にな"
"るが、 ディスクキャッシュにある書き込んでいないデータは破壊される。 ウォーム"
"ブートでは、より素早くリブートできる。)  デフォルトではリブートは 'hard' で行"
"われる。 すなわちリセットラインに low を出力するようキーボードコントローラー"
"に要求して、 リブートを行う。 しかし一部のマザーボードではこれができない。 "
"\\&'reboot=bios' オプションを指定すると、 代わりに BIOS を経由するようにな"
"る。"

#. type: TP
#: build/C/man7/bootparam.7:252
#, no-wrap
msgid "B<'nosmp'> and B<'maxcpus=N'>"
msgstr "B<'nosmp'> と B<'maxcpus=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:258
msgid ""
"(Only when __SMP__ is defined.)  A command-line option of 'nosmp' or "
"'maxcpus=0' will disable SMP activation entirely; an option 'maxcpus=N' "
"limits the maximum number of CPUs activated in SMP mode to N."
msgstr ""
"(カーネルのコンパイル時に __SMP__ が指定されたときのみ有効。)  コマンドライン"
"オプションに 'nosmp' または 'maxcpus=0' を指定すると、 SMP (Symmetric Multi "
"Processing) を完全に無効にする。 \\&'maxcpus=N' オプションは、 SMP モードで有"
"効にする CPU の最大数を N に制限する。"

#. type: SS
#: build/C/man7/bootparam.7:258
#, no-wrap
msgid "Boot arguments for use by kernel developers"
msgstr "カーネル開発者用の起動時引数"

#. type: TP
#: build/C/man7/bootparam.7:259
#, no-wrap
msgid "B<'debug'>"
msgstr "B<'debug'>"

#. type: Plain text
#: build/C/man7/bootparam.7:285
#, fuzzy
#| msgid ""
#| "Kernel messages are handed off to the kernel log daemon klogd so that "
#| "they may be logged to disk.  Messages with a priority above "
#| "I<console_loglevel> are also printed on the console.  (For these levels, "
#| "see I<E<lt>linux/kernel.hE<gt>>.)  By default this variable is set to log "
#| "anything more important than debug messages.  This boot argument will "
#| "cause the kernel to also print the messages of DEBUG priority.  The "
#| "console loglevel can also be set at run time via an option to klogd.  See "
#| "B<klogd>(8)."
msgid ""
"Kernel messages are handed off to a daemon (e.g., B<klogd>(8)  or similar) "
"so that they may be logged to disk.  Messages with a priority above "
"I<console_loglevel> are also printed on the console.  (For a discussion of "
"log levels, see B<syslog>(2).)  By default, I<console_loglevel> is set to "
"log messages at levels higher than B<KERN_DEBUG>.  This boot argument will "
"cause the kernel to also print messages logged at level B<KERN_DEBUG>.  The "
"console loglevel can also be set on a booted system via the I</proc/sys/"
"kernel/printk> file (described in B<syslog>(2)), the B<syslog>(2)  "
"B<SYSLOG_ACTION_CONSOLE_LEVEL> operation, or B<dmesg>(8)."
msgstr ""
"カーネルが出力するメッセージはカーネルログデーモン klogd に渡され、 ディスク"
"に記録できるようになる。 プライオリティが I<console_loglevel> のメッセージは"
"コンソールにも表示される。 (これらのレベルについては、I<E<lt>linux/kernel."
"hE<gt>> を参照。)  デフォルトではこの変数は、 デバッグメッセージよりも重要な"
"あらゆるメッセージを記録するよう設定されている (デバッグメッセージは含まな"
"い)。 この起動時引数を指定すると、 カーネルはプライオリティが DEBUG のメッ"
"セージも出力するようになる。 I<console_loglevel> も klogd にオプションを渡せ"
"ば実行時に設定できる。 B<klogd>(8)  を参照。"

#. type: TP
#: build/C/man7/bootparam.7:285
#, no-wrap
msgid "B<'profile=N'>"
msgstr "B<'profile=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:303
msgid ""
"It is possible to enable a kernel profiling function, if one wishes to find "
"out where the kernel is spending its CPU cycles.  Profiling is enabled by "
"setting the variable I<prof_shift> to a nonzero value.  This is done either "
"by specifying B<CONFIG_PROFILE> at compile time, or by giving the 'profile=' "
"option.  Now the value that I<prof_shift> gets will be N, when given, or "
"B<CONFIG_PROFILE_SHIFT>, when that is given, or 2, the default.  The "
"significance of this variable is that it gives the granularity of the "
"profiling: each clock tick, if the system was executing kernel code, a "
"counter is incremented:"
msgstr ""
"カーネルがどこで CPU サイクルを消費しているか調べたい場合には、 カーネルのプ"
"ロファイリング機能を有効にすればこれを実現できる。 カーネルプロファイリング"
"は、変数 I<prof_shift> を 0 以外の値にセットすると有効になる。 この値はコンパ"
"イル時に B<CONFIG_PROFILE> で指定するか、 この 'prifile=N' オプションで指定で"
"きる。 I<prof_shift> の値は N が指定されれば N となり、N が指定されなかった場"
"合は B<CONFIG_PROFILE_SHIFT> の値が用いられる。 どちらも指定されなければデ"
"フォルト値の 2 が用いられる。 この変数が重要なのは、 カーネルプロファイリング"
"の粒度を決定するところにある。 すなわち、各クロックの割込みごとに、システムが"
"カーネルコードを実行していれば、 以下のようにカウンターの値がインクリメントさ"
"れる。"

#. type: Plain text
#: build/C/man7/bootparam.7:307
#, no-wrap
msgid "profile[address E<gt>E<gt> prof_shift]++;\n"
msgstr "profile[address E<gt>E<gt> prof_shift]++;\n"

#. type: Plain text
#: build/C/man7/bootparam.7:316
msgid ""
"The raw profiling information can be read from I</proc/profile>.  Probably "
"you'll want to use a tool such as readprofile.c to digest it.  Writing to I</"
"proc/profile> will clear the counters."
msgstr ""
"生のプロファイリング情報は、 I</proc/profile> から見ることができるが、"
"readprofile.c のような情報を加工するツールを使ったほうが良いだろう。 I</proc/"
"profile> に任意のデータを書込むと、 カウンターはリセットされる。"

#. type: SS
#: build/C/man7/bootparam.7:316
#, no-wrap
msgid "Boot arguments for ramdisk use"
msgstr "RAM ディスク関連の起動時引数"

#. type: Plain text
#: build/C/man7/bootparam.7:327
#, fuzzy
#| msgid ""
#| "(Only if the kernel was compiled with B<CONFIG_BLK_DEV_RAM>.)  In general "
#| "it is a bad idea to use a ramdisk under Linux\\(emthe system will use "
#| "available memory more efficiently itself.  But while booting (or while "
#| "constructing boot floppies)  it is often useful to load the floppy "
#| "contents into a ramdisk.  One might also have a system in which first "
#| "some modules (for filesystem or hardware) must be loaded before the main "
#| "disk can be accessed."
msgid ""
"(Only if the kernel was compiled with B<CONFIG_BLK_DEV_RAM>.)  In general it "
"is a bad idea to use a ramdisk under Linux\\(emthe system will use available "
"memory more efficiently itself.  But while booting, it is often useful to "
"load the floppy contents into a ramdisk.  One might also have a system in "
"which first some modules (for filesystem or hardware) must be loaded before "
"the main disk can be accessed."
msgstr ""
"(カーネルのコンパイル時に B<CONFIG_BLK_DEV_RAM> オプションが指定されたときの"
"み有効。)  一般的には、Linux で RAM ディスクを使用するのはあまり良い考えでは"
"ない。 システムに任せておけばもっと効率的にメモリーを使用する。 しかしブート"
"時 (またはブートフロッピーの作成中) には、 フロッピーの内容を RAM ディスクに"
"ロードすると便利かもしれない。 メインディスクがアクセス可能になる前に、 (ファ"
"イルシステムやハードウェアに関する)  モジュールをいくつかロードしなければなら"
"ないシステムもあるだろう。"

#. type: Plain text
#: build/C/man7/bootparam.7:338
#, fuzzy
#| msgid ""
#| "In Linux 1.3.48, ramdisk handling was changed drastically.  Earlier, the "
#| "memory was allocated statically, and there was a 'ramdisk=N' parameter to "
#| "tell its size.  (This could also be set in the kernel image at compile "
#| "time.)  These days ram disks use the buffer cache, and grow dynamically.  "
#| "For a lot of information in conjunction with the new ramdisk setup, see "
#| "the kernel source file I<Documentation/blockdev/ramdisk.txt> "
#| "(I<Documentation/ramdisk.txt> in older kernels)."
msgid ""
"In Linux 1.3.48, ramdisk handling was changed drastically.  Earlier, the "
"memory was allocated statically, and there was a 'ramdisk=N' parameter to "
"tell its size.  (This could also be set in the kernel image at compile "
"time.)  These days ram disks use the buffer cache, and grow dynamically.  "
"For a lot of information on the current ramdisk setup, see the kernel source "
"file I<Documentation/blockdev/ramdisk.txt> (I<Documentation/ramdisk.txt> in "
"older kernels)."
msgstr ""
"Linux のバージョン 1.3.48 において、 RAM ディスクの取り扱いが根底から変化し"
"た。 それ以前までは、メモリーは静的に割り当てられ、 \\&'ramdisk=N' パラメー"
"ターでそのサイズを指定していた (この値はコンパイル時にカーネルイメージに指定"
"することもできた)。  現在は RAM ディスクはバッファーキャッシュを使用してお"
"り、 動的に拡張される。 新しい RAM ディスクの動作に関する多くの情報が、 カー"
"ネルソースファイル I<Documentation/blockdev/ramdisk.txt> (古いカーネルでは "
"I<Documentation/ramdisk.txt>) にある。"

#. type: Plain text
#: build/C/man7/bootparam.7:340
msgid "There are four parameters, two boolean and two integral."
msgstr ""
"4 つのパラメーターがある。論理値をとるものが 2 つ、整数値をとるものが 2 つ。"

#. type: TP
#: build/C/man7/bootparam.7:340
#, no-wrap
msgid "B<'load_ramdisk=N'>"
msgstr "B<'load_ramdisk=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:345
msgid ""
"If N=1, do load a ramdisk.  If N=0, do not load a ramdisk.  (This is the "
"default.)"
msgstr "N=1 なら RAM ディスクをロードする。N=0 ならロードしない (デフォルト)。"

#. type: TP
#: build/C/man7/bootparam.7:345
#, no-wrap
msgid "B<'prompt_ramdisk=N'>"
msgstr "B<'prompt_ramdisk=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:351
msgid ""
"If N=1, do prompt for insertion of the floppy.  (This is the default.)  If "
"N=0, do not prompt.  (Thus, this parameter is never needed.)"
msgstr ""
"N=1 ならフロッピー挿入を促すプロンプトを出す (デフォルト)。 N=0 ならプロンプ"
"トを出さない。 (従って、このパラメーターを指定する必要はまず無いであろう。)"

#. type: TP
#: build/C/man7/bootparam.7:351
#, no-wrap
msgid "B<'ramdisk_size=N'> or (obsolete) B<'ramdisk=N'>"
msgstr "B<'ramdisk_size=N'> もしくは (古い形式の) B<'ramdisk=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:355
#, fuzzy
#| msgid ""
#| "Set the maximal size of the ramdisk(s) to N kB.  The default is 4096 (4 "
#| "MB)."
msgid ""
"Set the maximal size of the ramdisk(s) to N kB.  The default is 4096 (4\\ "
"MB)."
msgstr ""
"ラムディスクの最大サイズを N kB (キロバイト) にセットする。 省略時は 4096 (4 "
"MB)。"

#. type: TP
#: build/C/man7/bootparam.7:355
#, no-wrap
msgid "B<'ramdisk_start=N'>"
msgstr "B<'ramdisk_start=N'>"

#. type: Plain text
#: build/C/man7/bootparam.7:360
msgid ""
"Sets the starting block number (the offset on the floppy where the ramdisk "
"starts) to N.  This is needed in case the ramdisk follows a kernel image."
msgstr ""
"開始ブロック番号 (フロッピー先頭からのオフセットで指定した RAM ディスクの開始"
"点)  を N にセットする。 これはカーネルイメージのあとに RAM ディスクイメージ"
"を置く場合に必要となる。"

#. type: TP
#: build/C/man7/bootparam.7:360
#, no-wrap
msgid "B<'noinitrd'>"
msgstr "B<'noinitrd'>"

#. type: Plain text
#: build/C/man7/bootparam.7:379
msgid ""
"(Only if the kernel was compiled with B<CONFIG_BLK_DEV_RAM> and "
"B<CONFIG_BLK_DEV_INITRD>.)  These days it is possible to compile the kernel "
"to use initrd.  When this feature is enabled, the boot process will load the "
"kernel and an initial ramdisk; then the kernel converts initrd into a "
"\"normal\" ramdisk, which is mounted read-write as root device; then I</"
"linuxrc> is executed; afterward the \"real\" root filesystem is mounted, and "
"the initrd filesystem is moved over to I</initrd>; finally the usual boot "
"sequence (e.g., invocation of I</sbin/init>)  is performed."
msgstr ""
"(カーネルのコンパイル時に B<CONFIG_BLK_DEV_RAM> と B<CONFIG_BLK_DEV_INITRD> "
"が指定されているときのみ有効。)  最近は initrd を使用するようにカーネルをコン"
"パイルできる。 このオプションが指定されると、 ブートプロセスはカーネルと RAM "
"ディスクをロードし、 カーネルは initrd を「普通の」 RAM ディスクに変換し、 こ"
"の RAM ディスクがルートデバイスとして「読み書き可能」でマウントされる。 次に "
"I</linuxrc> が実行される。 その後「真の」ルートファイルシステムがマウントさ"
"れ、 initrd ファイルシステムは I</initrd> に移される。 最後に通常のブートシー"
"ケンス (具体的には I</sbin/init> の呼び出し) が実行される。"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: build/C/man7/bootparam.7:386
#, fuzzy
#| msgid ""
#| "For a detailed description of the initrd feature, see the kernel source "
#| "file I<Documentation/initrd.txt>."
msgid ""
"For a detailed description of the initrd feature, see the kernel source file "
"I<Documentation/admin-guide/initrd.rst> (or I<Documentation/initrd.txt> "
"before Linux 4.10)."
msgstr ""
"initrd に関する詳細な解説はカーネルソースファイル I<Documentation/initrd."
"txt> を参照。"

#. type: Plain text
#: build/C/man7/bootparam.7:394
msgid ""
"The 'noinitrd' option tells the kernel that although it was compiled for "
"operation with initrd, it should not go through the above steps, but leave "
"the initrd data under I</dev/initrd>.  (This device can be used only once: "
"the data is freed as soon as the last process that used it has closed I</dev/"
"initrd>.)"
msgstr ""
"\\&'noinitrd' オプションを用いると、 カーネルは (initrd 動作を行うようにコン"
"パイルされている場合でも)  上記の動作を行なわず、代わりに initrd のデータを "
"I</dev/initrd> に残す。 (このデバイスは一度しか使えない。 データは、そのデー"
"タを使った最後のプロセスが I</dev/initrd> をクローズするとすぐに解放される。)"

#. type: SS
#: build/C/man7/bootparam.7:394
#, no-wrap
msgid "Boot arguments for SCSI devices"
msgstr "SCSI デバイス用の起動時引数"

#. type: Plain text
#: build/C/man7/bootparam.7:396
msgid "General notation for this section:"
msgstr "この節における用語："

#. type: Plain text
#: build/C/man7/bootparam.7:401
msgid ""
"I<iobase> -- the first I/O port that the SCSI host occupies.  These are "
"specified in hexadecimal notation, and usually lie in the range from 0x200 "
"to 0x3ff."
msgstr ""
"I<iobase> -- SCSI ホストアダプターが占有する I/O ポートの先頭アドレス。 16 進"
"表記で指定し、通常 0x200 から 0x3ff の範囲に位置する。"

#. type: Plain text
#: build/C/man7/bootparam.7:409
msgid ""
"I<irq> -- the hardware interrupt that the card is configured to use.  Valid "
"values will be dependent on the card in question, but will usually be 5, 7, "
"9, 10, 11, 12, and 15.  The other values are usually used for common "
"peripherals like IDE hard disks, floppies, serial ports, and so on."
msgstr ""
"I<irq> -- カードが利用するハードウェア割り込み。有効な値はカードに よって異な"
"るが、通常は 5, 7, 9, 10, 11, 12, 15 である。 これ以外の値は通常、IDE ハード"
"ディスク、フロッピー、 シリアルポートといった一般的な周辺機器によって使用され"
"る。"

#. type: Plain text
#: build/C/man7/bootparam.7:417
msgid ""
"I<scsi-id> -- the ID that the host adapter uses to identify itself on the "
"SCSI bus.  Only some host adapters allow you to change this value, as most "
"have it permanently specified internally.  The usual default value is 7, but "
"the Seagate and Future Domain TMC-950 boards use 6."
msgstr ""
"I<scsi-id> -- SCSI バス上のホストアダプターが自分自身を識別するために使用す"
"る ID 番号。 この値を変更できるホストアダプターもごく希に存在するが、 ほとん"
"どはアダプター内部で固定されている。 よく使われるデフォルト値は 7 であるが、"
"Seagate もしくは Future Domain 製の TMC-950 ボードでは 6 が使われる。"

#. type: Plain text
#: build/C/man7/bootparam.7:425
msgid ""
"I<parity> -- whether the SCSI host adapter expects the attached devices to "
"supply a parity value with all information exchanges.  Specifying a one "
"indicates parity checking is enabled, and a zero disables parity checking.  "
"Again, not all adapters will support selection of parity behavior as a boot "
"argument."
msgstr ""
"I<parity> -- SCSI ホストアダプターが取り付けられたデバイスとの通信に際して パ"
"リティ値を必要とするかどうか。 1 を指定するとパリティチェックが有効になり、 "
"0 でパリティチェックが無効になる。 しかし、すべてのデバイスがこの起動時引数に"
"よるパリティの選択を サポートするわけではない。"

#. type: TP
#: build/C/man7/bootparam.7:425
#, no-wrap
msgid "B<'max_scsi_luns=...'>"
msgstr "B<'max_scsi_luns=...'>"

#. type: Plain text
#: build/C/man7/bootparam.7:436
msgid ""
"A SCSI device can have a number of 'subdevices' contained within itself.  "
"The most common example is one of the new SCSI CD-ROMs that handle more than "
"one disk at a time.  Each CD is addressed as a \\&'Logical Unit "
"Number' (LUN) of that particular device.  But most devices, such as hard "
"disks, tape drives and such are only one device, and will be assigned to LUN "
"zero."
msgstr ""
"SCSI デバイスは複数の「サブデバイス」を自分自身の内部に持つことができる。 最"
"もよくある例として、一時に 1 枚以上のディスクを扱うことができる (チェンジャー"
"機能付の) SCSI CD-ROM がある。 それぞれの CD はそのデバイスの 「論理ユニット"
"番号 (LUN)」によって特定される。 しかしほとんどのデバイス (例えばハードディス"
"クやテープドライブ) は、 LUN 番号 0 が割り当てられた、ただひとつのデバイスか"
"らなる。"

#. type: Plain text
#: build/C/man7/bootparam.7:442
msgid ""
"Some poorly designed SCSI devices cannot handle being probed for LUNs not "
"equal to zero.  Therefore, if the compile-time flag B<CONFIG_SCSI_MULTI_LUN> "
"is not set, newer kernels will by default probe only LUN zero."
msgstr ""
"設計が不十分な SCSI デバイスでは 0 以外の LUN 番号への自動検出を 扱えないこと"
"がある。 したがって、コンパイル時に B<CONFIG_SCSI_MULTI_LUN> オプションが指定"
"されていないと、 最近のカーネルではデフォルトでは LUN 番号 0 のみを検出する。"

#. type: Plain text
#: build/C/man7/bootparam.7:448
msgid ""
"To specify the number of probed LUNs at boot, one enters "
"\\&'max_scsi_luns=n' as a boot arg, where n is a number between one and "
"eight.  To avoid problems as described above, one would use n=1 to avoid "
"upsetting such broken devices."
msgstr ""
"起動時に調べる LUN 番号を指定する場合、起動時引数として \\&'max_scsi_luns=n' "
"を指定する。n は 1 から 8 の間で指定する。 n=1 以上の値を使用しないようにすれ"
"ば、 このようないかれた機械にひどい目にあわされずにすむだろう。"

#. type: TP
#: build/C/man7/bootparam.7:448
#, no-wrap
msgid "B<SCSI tape configuration>"
msgstr "B<SCSI テープドライブの設定>"

#. type: Plain text
#: build/C/man7/bootparam.7:452
msgid ""
"Some boot time configuration of the SCSI tape driver can be achieved by "
"using the following:"
msgstr ""
"SCSI テープドライバの起動時設定の一部は以下のようにして行なうことができる。"

#. type: Plain text
#: build/C/man7/bootparam.7:456
#, no-wrap
msgid "B<st=>I<buf_size[,write_threshold[,max_bufs]]>\n"
msgstr "B<st=>I<buf_size[,write_threshold[,max_bufs]]>\n"

#. type: Plain text
#: build/C/man7/bootparam.7:471
#, fuzzy
#| msgid ""
#| "The first two numbers are specified in units of kB.  The default "
#| "I<buf_size> is 32kB, and the maximum size that can be specified is a "
#| "ridiculous 16384kB.  The I<write_threshold> is the value at which the "
#| "buffer is committed to tape, with a default value of 30kB.  The maximum "
#| "number of buffers varies with the number of drives detected, and has a "
#| "default of two.  An example usage would be:"
msgid ""
"The first two numbers are specified in units of kB.  The default I<buf_size> "
"is 32k\\ B, and the maximum size that can be specified is a ridiculous "
"16384\\ kB.  The I<write_threshold> is the value at which the buffer is "
"committed to tape, with a default value of 30\\ kB.  The maximum number of "
"buffers varies with the number of drives detected, and has a default of "
"two.  An example usage would be:"
msgstr ""
"最初の 2 つの数字は kB 単位で指定する。 I<buf_size> のデフォルトは 32kB であ"
"る。上限は 16384kB まで指定できる。 I<write_threshold> はデータ書き出しの閾値"
"で、 バッファーのデータのサイズがこの値を越えるとデータはテープに書き出され"
"る。 デフォルト値は 30kB である。 バッファー数の最大値 (I<max_bufs>)  は検出"
"されたドライブの数によって変化するが、デフォルトは 2 である。 使用例を以下に"
"示す。"

#. type: Plain text
#: build/C/man7/bootparam.7:475
#, no-wrap
msgid "st=32,30,2\n"
msgstr "st=32,30,2\n"

#. type: Plain text
#: build/C/man7/bootparam.7:483
msgid ""
"Full details can be found in the file I<Documentation/scsi/st.txt> (or "
"I<drivers/scsi/README.st> for older kernels) in the Linux kernel source."
msgstr ""
"詳細は Linux カーネルソース内の I<Documentation/scsi/st.txt> (古いカーネルの"
"場合は I<drivers/scsi/README.st>) に書かれている。"

#. type: SS
#: build/C/man7/bootparam.7:483
#, no-wrap
msgid "Hard disks"
msgstr "ハードディスク"

#. type: TP
#: build/C/man7/bootparam.7:484
#, no-wrap
msgid "B<IDE Disk/CD-ROM Driver Parameters>"
msgstr "B<IDE Disk/CD-ROM ドライバのパラメーター>"

#. type: Plain text
#: build/C/man7/bootparam.7:489
#, fuzzy
#| msgid ""
#| "The IDE driver accepts a number of parameters, which range from disk "
#| "geometry specifications, to support for broken controller chips.  Drive-"
#| "specific options are specified by using 'hdX=' with X in 'a'-'h'."
msgid ""
"The IDE driver accepts a number of parameters, which range from disk "
"geometry specifications, to support for broken controller chips.  Drive-"
"specific options are specified by using 'hdX=' with X in 'a'\\(en'h'."
msgstr ""
"IDE ドライバは、 ディスクのジオメトリ指定からバグのあるコントローラーチップの"
"サポートまで、 数多くのパラメーターを受け付ける。 ドライブを特定するには "
"'hdX=' を使う。 ここで X には 'a' から 'h' の文字を指定する。"

#. type: Plain text
#: build/C/man7/bootparam.7:493
msgid ""
"Non-drive-specific options are specified with the prefix 'hd='.  Note that "
"using a drive-specific prefix for a non-drive-specific option will still "
"work, and the option will just be applied as expected."
msgstr ""
"あるドライブに特有なものではないオプションは、hd= を前に付けて指定する。 ドラ"
"イブ特有でないオプションに対してドライブ指定 ('hdX=') を前置しても問題はな"
"い。 そのオプションは期待通りそのドライブに適用される。"

#.  Linux 2.0, 2.2, 2.4
#. type: Plain text
#: build/C/man7/bootparam.7:506
#, fuzzy
#| msgid ""
#| "Also note that 'hd=' can be used to refer to the next unspecified drive "
#| "in the (a, ..., h) sequence.  For the following discussions, the 'hd=' "
#| "option will be cited for brevity.  See the file I<Documentation/ide.txt> "
#| "(or I<drivers/block/README.ide> for older kernels) in the Linux kernel "
#| "source for more details."
msgid ""
"Also note that 'hd=' can be used to refer to the next unspecified drive in "
"the (a, ..., h) sequence.  For the following discussions, the 'hd=' option "
"will be cited for brevity.  See the file I<Documentation/ide/ide.txt> (or "
"I<Documentation/ide.txt> in older kernels, or I<drivers/block/README.ide> in "
"ancient kernels) in the Linux kernel source for more details."
msgstr ""
"\\&'hd=' は、(a, ..., h) のシーケンスにおいて、 まだ指定されていない次のドラ"
"イブを指すためにも使える。 これ以降では簡単のために 'hd=' を使って説明する。 "
"さらに詳しい情報を得るには、Linux カーネルソース内の I<Documentation/ide."
"txt> (古いカーネルの場合は I<drivers/block/README.ide>) を参照のこと。"

#. type: TP
#: build/C/man7/bootparam.7:506
#, no-wrap
msgid "B<The 'hd=cyls,heads,sects[,wpcom[,irq]]' options>"
msgstr "B<'hd=cyls,heads,sects[,wpcom[,irq]]' オプション>"

#. type: Plain text
#: build/C/man7/bootparam.7:517
msgid ""
"These options are used to specify the physical geometry of the disk.  Only "
"the first three values are required.  The cylinder/head/sectors values will "
"be those used by fdisk.  The write precompensation value is ignored for IDE "
"disks.  The IRQ value specified will be the IRQ used for the interface that "
"the drive resides on, and is not really a drive-specific parameter."
msgstr ""
"これらのオプションはディスクの物理的なジオメトリを指定するために使う。 最初"
"の 3 つの値以降は省略できる。 シリンダ (cyls)、ヘッド (heads)、セクタ "
"(sects) の各値は fdisk で用いられるものと同じである。 書き込み補正 (wpcom) 値"
"は IDE ディスクでは無視される。 IRQ 値には、そのドライブが接続されているイン"
"ターフェースが用いる IRQ を指定する (本来の意味では「ドライブに特有」のパラ"
"メーターではない)。"

#. type: TP
#: build/C/man7/bootparam.7:517
#, no-wrap
msgid "B<The 'hd=serialize' option>"
msgstr "B<'hd=serialize' オプション>"

#. type: Plain text
#: build/C/man7/bootparam.7:525
msgid ""
"The dual IDE interface CMD-640 chip is broken as designed such that when "
"drives on the secondary interface are used at the same time as drives on the "
"primary interface, it will corrupt your data.  Using this option tells the "
"driver to make sure that both interfaces are never used at the same time."
msgstr ""
"デュアル IDE インターフェースである CMD-640 チップには設計上の問題があって、 "
"セカンダリインターフェース上のドライブと プライマリインターフェース上のドライ"
"ブを 同時に使用するとデータが破壊されることがある。 このオプションを使用する"
"と、 ドライバは両方のインターフェースが 同時に使用されることが絶対にないよう"
"にする。"

#. type: TP
#: build/C/man7/bootparam.7:525
#, no-wrap
msgid "B<The 'hd=noprobe' option>"
msgstr "B<'hd=noprobe' オプション>"

#. type: Plain text
#: build/C/man7/bootparam.7:529
msgid "Do not probe for this drive.  For example,"
msgstr "このドライブの自動検出をしない。 例えば"

#. type: Plain text
#: build/C/man7/bootparam.7:533
#, no-wrap
msgid "hdb=noprobe hdb=1166,7,17\n"
msgstr "hdb=noprobe hdb=1166,7,17\n"

#. type: Plain text
#: build/C/man7/bootparam.7:539
msgid ""
"would disable the probe, but still specify the drive geometry so that it "
"would be registered as a valid block device, and hence usable."
msgstr ""
"とすると自動検出が無効になる。 しかしドライブのジオメトリを指定しているの"
"で、 このドライブは正しいブロックデバイスとして登録され、使用可能になる。"

#. type: TP
#: build/C/man7/bootparam.7:539
#, no-wrap
msgid "B<The 'hd=nowerr' option>"
msgstr "B<'hd=nowerr' オプション>"

#. type: Plain text
#: build/C/man7/bootparam.7:545
msgid ""
"Some drives apparently have the B<WRERR_STAT> bit stuck on permanently.  "
"This enables a work-around for these broken devices."
msgstr ""
"ドライブによっては、書き込みエラー (B<WRERR_STAT>)  ビットがクリアできなくな"
"ることがある。 このオプションを指定すると、 このような壊れたデバイスに対する"
"回避機能が有効になる。"

#. type: TP
#: build/C/man7/bootparam.7:545
#, no-wrap
msgid "B<The 'hd=cdrom' option>"
msgstr "B<'hd=cdrom' オプション>"

#. type: Plain text
#: build/C/man7/bootparam.7:551
msgid ""
"This tells the IDE driver that there is an ATAPI compatible CD-ROM attached "
"in place of a normal IDE hard disk.  In most cases the CD-ROM is identified "
"automatically, but if it isn't then this may help."
msgstr ""
"このオプションは、通常の IDE ハードディスクの代わりに、 ATAPI 互換の CDROM が"
"続されていることを IDE ドライバに伝える。 CD-ROM はたいてい自動的に認識される"
"が、 うまく行かない場合に試してみると良い。"

#. type: TP
#: build/C/man7/bootparam.7:551
#, no-wrap
msgid "B<Standard ST-506 Disk Driver Options ('hd=')>"
msgstr "B<スタンダード ST-506 ディスクドライバのオプション ('hd=')>"

#. type: Plain text
#: build/C/man7/bootparam.7:560
msgid ""
"The standard disk driver can accept geometry arguments for the disks similar "
"to the IDE driver.  Note however that it expects only three values (C/H/S); "
"any more or any less and it will silently ignore you.  Also, it accepts only "
"'hd=' as an argument, that is, 'hda=' and so on are not valid here.  The "
"format is as follows:"
msgstr ""
"スタンダードディスクドライバは IDE ドライバと同様のジオメトリ指定を引数にとる"
"ことができる。 ただし受け付ける値はちょうど 3 つ (C/H/S) に限られる。 それ以"
"上の値やそれ以下の値を指定すると、ドライバは黙ってその指定を無視する。 また引"
"数として受け入れられるのは 'hd=' の形式だけである。 つまり 'hda=' のような指"
"定はここでは正しくない。 書式は次の通り。"

#. type: Plain text
#: build/C/man7/bootparam.7:564
#, no-wrap
msgid "hd=cyls,heads,sects\n"
msgstr "hd=cyls,heads,sects\n"

#. type: Plain text
#: build/C/man7/bootparam.7:569
msgid ""
"If there are two disks installed, the above is repeated with the geometry "
"parameters of the second disk."
msgstr ""
"2 台のディスクが接続されてい場合は、 2 番目のディスクに対しても上記のジオメト"
"リが設定される。"

#. type: SS
#: build/C/man7/bootparam.7:569
#, no-wrap
msgid "Ethernet devices"
msgstr "イーサネットデバイス"

#. type: Plain text
#: build/C/man7/bootparam.7:573
msgid ""
"Different drivers make use of different parameters, but they all at least "
"share having an IRQ, an I/O port base value, and a name.  In its most "
"generic form, it looks something like this:"
msgstr ""
"ドライバが異なると用いるパラメーターも異なるが、 すべてのドライバは、少なくと"
"も割り込み番号 (irq)、 I/O ポートのベースアドレス (iobase)、名前 (name) を持"
"つ。 最も一般的な形式は以下の通り。"

#. type: Plain text
#: build/C/man7/bootparam.7:577
#, no-wrap
msgid "ether=irq,iobase[,param_1[,...param_8]],name\n"
msgstr "ether=irq,iobase[,param_1[,...param_8]],name\n"

#. type: Plain text
#: build/C/man7/bootparam.7:586
msgid ""
"The first nonnumeric argument is taken as the name.  The param_n values (if "
"applicable) usually have different meanings for each different card/driver.  "
"Typical param_n values are used to specify things like shared memory "
"address, interface selection, DMA channel and the like."
msgstr ""
"最初の数字でない値は名前として使用される。 param_n の値はカード (ドライバ) ご"
"とに異なる意味を持つ。 よくある目的は、共有メモリーアドレスの指定、インター"
"フェースの選択、 DMA チャネルなどである。"

#. type: Plain text
#: build/C/man7/bootparam.7:590
msgid ""
"The most common use of this parameter is to force probing for a second "
"ethercard, as the default is to probe only for one.  This can be "
"accomplished with a simple:"
msgstr ""
"このパラメーターの最もよくある利用法は、 2 番目の Ethernet カードを強制的に検"
"出させる場合である (デフォルトでは 1 枚しか検出しない)。 これは簡単で、次のよ"
"うにすればよい。"

#. type: Plain text
#: build/C/man7/bootparam.7:594
#, no-wrap
msgid "ether=0,0,eth1\n"
msgstr "ether=0,0,eth1\n"

#. type: Plain text
#: build/C/man7/bootparam.7:599
msgid ""
"Note that the values of zero for the IRQ and I/O base in the above example "
"tell the driver(s) to autoprobe."
msgstr ""
"この例で IRQ と I/O ベースアドレスに 0 を指定しているのは、 ドライバに自動検"
"出をするよう伝えているのである。"

#. type: Plain text
#: build/C/man7/bootparam.7:605
msgid ""
"The Ethernet-HowTo has extensive documentation on using multiple cards and "
"on the card/driver-specific implementation of the param_n values where "
"used.  Interested readers should refer to the section in that document on "
"their particular card."
msgstr ""
"Ethernet-HOWTO では、複数のカードを使うやり方や、 カードやドライバに特有の "
"param_n 値の意味について、 ずっと詳細に解説されている。 興味を持った読者は、"
"この文書にあたり、 自分のカードに関して書かれているセクションを参照すると良"
"い。"

#. type: SS
#: build/C/man7/bootparam.7:605
#, no-wrap
msgid "The floppy disk driver"
msgstr "フロッピーディスクドライバ"

#. type: Plain text
#: build/C/man7/bootparam.7:614
#, fuzzy
#| msgid ""
#| "There are many floppy driver options, and they are all listed in "
#| "I<Documentation/floppy.txt> (or I<drivers/block/README.fd> for older "
#| "kernels) in the Linux kernel source.  This information is taken directly "
#| "from that file."
msgid ""
"There are many floppy driver options, and they are all listed in "
"I<Documentation/blockdev/floppy.txt> (or I<Documentation/floppy.txt> in "
"older kernels, or I<drivers/block/README.fd> for ancient kernels) in the "
"Linux kernel source.  See that file for the details."
msgstr ""
"フロッピードライバのオプションは多数あり、 Linux カーネルソース内の "
"I<Documentation/floppy.txt> (古いカーネルの場合は I<drivers/block/README."
"fd>)  にすべて記載されている。 以下の情報はこのファイルからとったものである。"

#. type: SS
#: build/C/man7/bootparam.7:614
#, no-wrap
msgid "The sound driver"
msgstr "サウンドドライバ"

#. type: Plain text
#: build/C/man7/bootparam.7:624
#, fuzzy
#| msgid ""
#| "The sound driver can also accept boot arguments to override the compiled "
#| "in values.  This is not recommended, as it is rather complex.  It is "
#| "described in the Linux kernel source file I<Documentation/sound/oss/"
#| "README.OSS> (I<drivers/sound/Readme.linux> in older kernel versions).  It "
#| "accepts a boot argument of the form:"
msgid ""
"The sound driver can also accept boot arguments to override the compiled-in "
"values.  This is not recommended, as it is rather complex.  It is described "
"in the Linux kernel source file I<Documentation/sound/oss/README.OSS> "
"(I<drivers/sound/Readme.linux> in older kernel versions).  It accepts a boot "
"argument of the form:"
msgstr ""
"サウンドドライバも起動時引数を受け付け、 コンパイル時に指定された値を変更でき"
"る。 これはやや面倒なため、あまりお薦めできない。 詳細は、Linux カーネルソー"
"ス内の I<Documentation/sound/oss/README.OSS> (古いカーネルの場合は I<drivers/"
"sound/Readme.linux>)  に記載されている。 引数の形式は以下の通り。"

#. type: Plain text
#: build/C/man7/bootparam.7:628
#, no-wrap
msgid "sound=device1[,device2[,device3...[,device10]]]\n"
msgstr "sound=device1[,device2[,device3...[,device10]]]\n"

#. type: Plain text
#: build/C/man7/bootparam.7:633
msgid ""
"where each deviceN value is of the following format 0xTaaaId and the bytes "
"are used as follows:"
msgstr ""
"各 deviceN はそれぞれ 0xTaaaId という形式で指定する。 各バイトの意味は以下の"
"通り。"

#. type: Plain text
#: build/C/man7/bootparam.7:636
msgid ""
"T - device type: 1=FM, 2=SB, 3=PAS, 4=GUS, 5=MPU401, 6=SB16, 7=SB16-MPU401"
msgstr ""
"T - デバイスのタイプ: 1=FM, 2=SB, 3=PAS, 4=GUS, 5=MPU401, 6=SB16, 7=SB16-"
"MPU401"

#. type: Plain text
#: build/C/man7/bootparam.7:638
msgid "aaa - I/O address in hex."
msgstr "aaa - I/O ポートアドレス (16進値)"

#. type: Plain text
#: build/C/man7/bootparam.7:640
#, fuzzy
#| msgid "I - interrupt line in hex (i.e 10=a, 11=b, ...)"
msgid "I - interrupt line in hex (i.e., 10=a, 11=b, ...)"
msgstr "I - 割り込み番号 (16 進値。例: 10=a, 11=b, ...)"

#. type: Plain text
#: build/C/man7/bootparam.7:642
msgid "d - DMA channel."
msgstr "d - DMA チャネル"

#. type: Plain text
#: build/C/man7/bootparam.7:647
#, fuzzy
#| msgid ""
#| "As you can see it gets pretty messy, and you are better off to compile in "
#| "your own personal values as recommended.  Using a boot argument of "
#| "\\&'sound=0' will disable the sound driver entirely."
msgid ""
"As you can see, it gets pretty messy, and you are better off to compile in "
"your own personal values as recommended.  Using a boot argument of "
"\\&'sound=0' will disable the sound driver entirely."
msgstr ""
"上記の通り、かなり扱いにくい形式となっており、 コンパイル時に自分にあった値を"
"指定する方が良いだろう。 なお起動時引数として 'sound=0' を指定すると、 サウン"
"ドドライバを完全に無効にする。"

#. type: SS
#: build/C/man7/bootparam.7:647
#, no-wrap
msgid "The line printer driver"
msgstr "ラインプリンタドライバ"

#. type: TP
#: build/C/man7/bootparam.7:648
#, no-wrap
msgid "B<'lp='>"
msgstr "B<'lp='>"

#. type: Plain text
#: build/C/man7/bootparam.7:652
msgid "Syntax:"
msgstr "構文は以下の通り。"

#. type: Plain text
#: build/C/man7/bootparam.7:659
#, no-wrap
msgid ""
"lp=0\n"
"lp=auto\n"
"lp=reset\n"
"lp=port[,port...]\n"
msgstr ""
"lp=0\n"
"lp=auto\n"
"lp=reset\n"
"lp=port[,port...]\n"

#. type: Plain text
#: build/C/man7/bootparam.7:667
msgid ""
"You can tell the printer driver what ports to use and what ports not to "
"use.  The latter comes in handy if you don't want the printer driver to "
"claim all available parallel ports, so that other drivers (e.g., PLIP, PPA) "
"can use them instead."
msgstr ""
"プリンタドライバには、どのポートを使うか、 どのポートを使ってはいけないかを伝"
"えることができる。 後者は、 利用可能なあらゆるパラレルポートをプリンタドライ"
"バが要求しないようにして、 他のドライバ (PLIP や PPA など) から それらを使え"
"るようにしたい場合に便利である。"

#.  .SH AUTHORS
#.  Linus Torvalds (and many others)
#. type: Plain text
#: build/C/man7/bootparam.7:676
msgid ""
"The format of the argument is multiple port names.  For example, lp=none,"
"parport0 would use the first parallel port for lp1, and disable lp0.  To "
"disable the printer driver entirely, one can use lp=0."
msgstr ""
"引数の書式は、複数のポート名である。 例えば lp=none,parport0 とすると、 最初"
"のパラレルポートを lp1 として使い、 lp0 は無効にする。プリンタードライバを完"
"全に無効にするには lp=0 とすればよい。"

#. type: Plain text
#: build/C/man7/bootparam.7:679
msgid "B<klogd>(8), B<mount>(8)"
msgstr "B<klogd>(8), B<mount>(8)"

#. type: Plain text
#: build/C/man7/bootparam.7:682
#, fuzzy
#| msgid ""
#| "For a detailed description of the initrd feature, see the kernel source "
#| "file I<Documentation/initrd.txt>."
msgid ""
"For up-to-date information, see the kernel source file I<Documentation/admin-"
"guide/kernel-parameters.txt>."
msgstr ""
"initrd に関する詳細な解説はカーネルソースファイル I<Documentation/initrd."
"txt> を参照。"

#. type: TH
#: build/C/man2/reboot.2:28
#, no-wrap
msgid "REBOOT"
msgstr "REBOOT"

#. type: TH
#: build/C/man2/reboot.2:28
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: build/C/man2/reboot.2:31
msgid "reboot - reboot or enable/disable Ctrl-Alt-Del"
msgstr "reboot - 再起動する。または Ctrl-Alt-Delを有効・無効にする"

#. type: Plain text
#: build/C/man2/reboot.2:34
#, no-wrap
msgid ""
"/* Since kernel version 2.1.30 there are symbolic names LINUX_REBOOT_*\n"
"   for the constants and a fourth argument to the call: */\n"
msgstr ""
"/* カーネル 2.1.30 以降では、定数としてシンボリックな名前\n"
"   LINUX_REBOOT_* が定義されており、呼び出しの第 4 引数として\n"
"   指定することができる。*/\n"

#. type: Plain text
#: build/C/man2/reboot.2:36 build/C/man2/reboot.2:47 build/C/man2/sync.2:41
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/reboot.2:38
msgid "B<#include E<lt>linux/reboot.hE<gt>>"
msgstr "B<#include E<lt>linux/reboot.hE<gt>>"

#. type: Plain text
#: build/C/man2/reboot.2:40
msgid ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"
msgstr ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"

#. type: Plain text
#: build/C/man2/reboot.2:45
#, fuzzy, no-wrap
#| msgid ""
#| "/* Under glibc some of the constants involved have gotten\n"
#| "   symbolic names RB_*, and the library call is a 1-argument\n"
#| "   wrapper around the 3-argument system call: */\n"
msgid ""
"/* Under glibc and most alternative libc's (including uclibc, dietlibc,\n"
"   musl and a few others), some of the constants involved have gotten\n"
"   symbolic names RB_*, and the library call is a 1-argument\n"
"   wrapper around the system call: */\n"
msgstr ""
"/* glibc では、関連する定数に RB_* というシンボリックな名前が付け\n"
"   られている。ライブラリ関数の引数は 1 つで、3 引数のシステムコールの\n"
"   ラッパ (wrapper) となっている。 */\n"

#. type: Plain text
#: build/C/man2/reboot.2:49
msgid "B<#include E<lt>sys/reboot.hE<gt>>"
msgstr "B<#include E<lt>sys/reboot.hE<gt>>"

#. type: Plain text
#: build/C/man2/reboot.2:51
msgid "B<int reboot(int >I<cmd>B<);>"
msgstr "B<int reboot(int >I<cmd>B<);>"

#. type: Plain text
#: build/C/man2/reboot.2:58
msgid ""
"The B<reboot>()  call reboots the system, or enables/disables the reboot "
"keystroke (abbreviated CAD, since the default is Ctrl-Alt-Delete; it can be "
"changed using B<loadkeys>(1))."
msgstr ""
"B<reboot>()  はシステムを再起動する。または再起動のキーストロークである Ctrl-"
"Alt-Delete (CAD) を有効/無効にする。 このキーストロークは B<loadkeys>(1)  に"
"よって変更できる。"

#. type: Plain text
#: build/C/man2/reboot.2:82
msgid ""
"This system call fails (with the error B<EINVAL>)  unless I<magic> equals "
"B<LINUX_REBOOT_MAGIC1> (that is, 0xfee1dead) and I<magic2> equals "
"B<LINUX_REBOOT_MAGIC2> (that is, 672274793).  However, since 2.1.17 also "
"B<LINUX_REBOOT_MAGIC2A> (that is, 85072278)  and since 2.1.97 also "
"B<LINUX_REBOOT_MAGIC2B> (that is, 369367448)  and since 2.5.71 also "
"B<LINUX_REBOOT_MAGIC2C> (that is, 537993216)  are permitted as values for "
"I<magic2>.  (The hexadecimal values of these constants are meaningful.)"
msgstr "I<magic> が B<LINUX_REBOOT_MAGIC1> (値は 0xfee1dead) であり、かつ I<magic2> が B<LINUX_REBOOT_MAGIC2> (672274793) でなければ、このシステムコールは (エラー B<EINVAL> で) 失敗する。 しかし 2.1.17 からは B<LINUX_REBOOT_MAGIC2A> (85072278) が、 また 2.1.97 からは B<LINUX_REBOOT_MAGIC2B> (369367448) が、 2.5.71 からは B<LINUX_REBOOT_MAGIC2C> (537993216) が I<magic2> の値として指定できるようになった (これらの定数の 16 進での 表記にはちょっとした意味がある)。"

#. type: Plain text
#: build/C/man2/reboot.2:86
msgid "The I<cmd> argument can have the following values:"
msgstr "I<cmd> 引数には以下の値を指定できる。"

#. type: TP
#: build/C/man2/reboot.2:86
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_OFF>"
msgstr "B<LINUX_REBOOT_CMD_CAD_OFF>"

#. type: Plain text
#: build/C/man2/reboot.2:96
msgid ""
"(B<RB_DISABLE_CAD>, 0).  CAD is disabled.  This means that the CAD keystroke "
"will cause a B<SIGINT> signal to be sent to init (process 1), whereupon this "
"process may decide upon a proper action (maybe: kill all processes, sync, "
"reboot)."
msgstr ""
"(B<RB_DISABLE_CAD>, 0)  CAD を無効にする。 これ以降に CAD キーストロークが入"
"力されると、 B<SIGINT> シグナルが init (プロセス 1) に送られる。 このシグナル"
"を受けると、おそらく init プロセスは 前もって定められた動作を行うことになる "
"(多分すべてのプロセスの kill, sync, 再起動)。"

#. type: TP
#: build/C/man2/reboot.2:96
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_ON>"
msgstr "B<LINUX_REBOOT_CMD_CAD_ON>"

#. type: Plain text
#: build/C/man2/reboot.2:104
msgid ""
"(B<RB_ENABLE_CAD>, 0x89abcdef).  CAD is enabled.  This means that the CAD "
"keystroke will immediately cause the action associated with "
"B<LINUX_REBOOT_CMD_RESTART>."
msgstr ""
"(B<RB_ENABLE_CAD>, 0x89abcdef)  CAD を有効にする。 これ以降に CAD キースト"
"ロークが入力されると、 ただちに B<LINUX_REBOOT_CMD_RESTART> に関連付けられた"
"動作が行われるようになる。"

#. type: TP
#: build/C/man2/reboot.2:104
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_HALT>"
msgstr "B<LINUX_REBOOT_CMD_HALT>"

#. type: Plain text
#: build/C/man2/reboot.2:113
msgid ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; since Linux 1.1.76).  The message \"System "
"halted.\" is printed, and the system is halted.  Control is given to the ROM "
"monitor, if there is one.  If not preceded by a B<sync>(2), data will be "
"lost."
msgstr ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; Linux 1.1.76 以降)  \"System halted.\" という"
"メッセージが表示され、システムは停止 (halt) する。 制御は ROM モニタに移る "
"(ROM モニタがある場合)。 先に B<sync>(2)  を行なわないと、データが失われる。"

#. type: TP
#: build/C/man2/reboot.2:113
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_KEXEC>"
msgstr "B<LINUX_REBOOT_CMD_KEXEC>"

#. type: Plain text
#: build/C/man2/reboot.2:121
msgid ""
"(B<RB_KEXEC>, 0x45584543, since Linux 2.6.13).  Execute a kernel that has "
"been loaded earlier with B<kexec_load>(2).  This option is available only if "
"the kernel was configured with B<CONFIG_KEXEC>."
msgstr ""
"(B<RB_KEXEC>, 0x45584543, Linux 2.6.13 以降) B<kexec_load>(2) を使って事前に"
"ロードされたカーネルを実行する。このオプションが利用できるのは、カーネルのコ"
"ンフィグで B<CONFIG_KEXEC> が有効になっている場合にのみである。"

#. type: TP
#: build/C/man2/reboot.2:121
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>"
msgstr "B<LINUX_REBOOT_CMD_POWER_OFF>"

#. type: Plain text
#: build/C/man2/reboot.2:130
msgid ""
"(B<RB_POWER_OFF>, 0x4321fedc; since Linux 2.1.30).  The message \"Power down."
"\" is printed, the system is stopped, and all power is removed from the "
"system, if possible.  If not preceded by a B<sync>(2), data will be lost."
msgstr ""
"(B<RB_POWER_OFF>, 0x4321fedc; Linux 2.1.30 以降)  \"Power down\" というメッ"
"セージが表示され、システムは停止 (stop) する。 可能な場合はシステムの電源が落"
"とされる。 先に B<sync>(2)  を行なわないと、データが失われる。"

#. type: TP
#: build/C/man2/reboot.2:130
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>"
msgstr "B<LINUX_REBOOT_CMD_RESTART>"

#. type: Plain text
#: build/C/man2/reboot.2:139
msgid ""
"(B<RB_AUTOBOOT>, 0x1234567).  The message \"Restarting system.\" is printed, "
"and a default restart is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""
"(B<RB_AUTOBOOT>, 0x1234567)  \"Restarting system.\" というメッセージが表示さ"
"れ、 デフォルトの再起動処理がただちに実行される。 先に B<sync>(2)  を行なわな"
"いと、データが失われる。"

#. type: TP
#: build/C/man2/reboot.2:139
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART2>"
msgstr "B<LINUX_REBOOT_CMD_RESTART2>"

#. type: Plain text
#: build/C/man2/reboot.2:149
msgid ""
"(0xa1b2c3d4; since Linux 2.1.30).  The message \"Restarting system with "
"command \\(aq%s\\(aq\" is printed, and a restart (using the command string "
"given in I<arg>)  is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""
"(0xa1b2c3d4; Linux 2.1.30 以降)  \"Restarting system with command \\(aq%s"
"\\(aq\" というメッセージが表示され、 ただちに ( I<arg> に指定されたコマンドを"
"用いて) 再起動 (restart) が行われる。 先に B<sync>(2)  を行なわないと、データ"
"が失われる。"

#. type: TP
#: build/C/man2/reboot.2:149
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_SW_SUSPEND>"
msgstr "B<LINUX_REBOOT_CMD_SW_SUSPEND>"

#. type: Plain text
#: build/C/man2/reboot.2:156
msgid ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; since Linux 2.5.18).  The system is suspended "
"(hibernated) to disk.  This option is available only if the kernel was "
"configured with B<CONFIG_HIBERNATION>."
msgstr ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; Linux 2.5.18 以降). システムがディスクにサスペ"
"ンド (ハイバネーション) される。このオプションはカーネルで "
"B<CONFIG_HIBERNATION> が有効になっている場合にのみ利用できる。"

#. type: Plain text
#: build/C/man2/reboot.2:159
msgid "Only the superuser may call B<reboot>()."
msgstr "スーパーユーザーだけが B<reboot>()  を呼び出すことができる。"

#. type: Plain text
#: build/C/man2/reboot.2:166
msgid ""
"The precise effect of the above actions depends on the architecture.  For "
"the i386 architecture, the additional argument does not do anything at "
"present (2.1.122), but the type of reboot can be determined by kernel "
"command-line arguments (\"reboot=...\") to be either warm or cold, and "
"either hard or through the BIOS."
msgstr ""
"上述のアクションの実際の効果はアーキテクチャーに依存する。 i386 アーキテク"
"チャーでは、現在のところ (2.1.122) 付加引数は 何も行わないが、再起動のタイプ"
"をカーネルのコマンドライン引数 (\"reboot=...\") によって定めることができる。 "
"これには warm または cold と、 hard または BIOS 経由の再起動を 設定できる。"

#. type: SS
#: build/C/man2/reboot.2:166
#, no-wrap
msgid "Behavior inside PID namespaces"
msgstr "PID 名前空間内での動作"

#.  commit cf3f89214ef6a33fad60856bc5ffd7bb2fc4709b
#.  see also commit 923c7538236564c46ee80c253a416705321f13e3
#. type: Plain text
#: build/C/man2/reboot.2:181
msgid ""
"Since Linux 3.4, if B<reboot>()  is called from a PID namespace other than "
"the initial PID namespace with one of the I<cmd> values listed below, it "
"performs a \"reboot\" of that namespace: the \"init\" process of the PID "
"namespace is immediately terminated, with the effects described in "
"B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/reboot.2:187
msgid ""
"The values that can be supplied in I<cmd> when calling B<reboot>()  in this "
"case are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/reboot.2:187
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>, B<LINUX_REBOOT_CMD_RESTART2>"
msgstr "B<LINUX_REBOOT_CMD_RESTART>, B<LINUX_REBOOT_CMD_RESTART2>"

#. type: Plain text
#: build/C/man2/reboot.2:195
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGHUP> signal."
msgstr ""

#. type: TP
#: build/C/man2/reboot.2:195
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>, B<LINUX_REBOOT_CMD_HALT>"
msgstr "B<LINUX_REBOOT_CMD_POWER_OFF>, B<LINUX_REBOOT_CMD_HALT>"

#. type: Plain text
#: build/C/man2/reboot.2:203
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGINT> signal."
msgstr ""

#. type: Plain text
#: build/C/man2/reboot.2:212
msgid ""
"For the other I<cmd> values, B<reboot>()  returns -1 and I<errno> is set to "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/reboot.2:225
msgid ""
"For the values of I<cmd> that stop or restart the system, a successful call "
"to B<reboot>()  does not return.  For the other I<cmd> values, zero is "
"returned on success.  In all cases, -1 is returned on failure, and I<errno> "
"is set appropriately."
msgstr ""
"I<cmd> がシステムの停止や再起動を表す値の場合、呼び出しが成功すると "
"B<reboot>()  は返らない。 I<cmd> が他の値の場合には、成功すると 0 が返る。 "
"I<cmd> の値に関わらず、失敗の場合には -1 が返り、 I<errno> が適切に設定され"
"る。"

#. type: Plain text
#: build/C/man2/reboot.2:230
msgid ""
"Problem with getting user-space data under B<LINUX_REBOOT_CMD_RESTART2>."
msgstr ""
"B<LINUX_REBOOT_CMD_RESTART2> の時にユーザースペースのデータの取得に問題があっ"
"た。"

#. type: Plain text
#: build/C/man2/reboot.2:233
msgid "Bad magic numbers or I<cmd>."
msgstr "magic の数字か I<cmd> が間違っている。"

#. type: Plain text
#: build/C/man2/reboot.2:240
#, fuzzy
#| msgid ""
#| "The calling process has insufficient privilege to call B<reboot>(); the "
#| "B<CAP_SYS_BOOT> capability is required."
msgid ""
"The calling process has insufficient privilege to call B<reboot>(); the "
"caller must have the B<CAP_SYS_BOOT> inside its user namespace."
msgstr ""
"呼び出し元プロセスに B<reboot>()  を呼び出すのに十分な権限がなかった。 "
"B<CAP_SYS_BOOT> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/reboot.2:244
msgid ""
"B<reboot>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"B<reboot>()  は Linux に特有であり、移植を考慮したプログラムでは用いるべきで"
"はない。"

#. type: Plain text
#: build/C/man2/reboot.2:254
msgid ""
"B<systemctl>(1), B<systemd>(1), B<kexec_load>(2), B<sync>(2), "
"B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>(8), "
"B<shutdown>(8)"
msgstr "B<systemctl>(1), B<systemd>(1), B<kexec_load>(2), B<sync>(2), B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>(8), B<shutdown>(8)"

#. type: TH
#: build/C/man2/sync.2:36
#, no-wrap
msgid "SYNC"
msgstr "SYNC"

#. type: TH
#: build/C/man2/sync.2:36
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man2/sync.2:39
msgid "sync, syncfs - commit filesystem caches to disk"
msgstr "sync, syncfs - ファイルシステムキャッシュをディスクに書き込む"

#. type: Plain text
#: build/C/man2/sync.2:43
msgid "B<void sync(void);>"
msgstr "B<void sync(void);>"

#. type: Plain text
#: build/C/man2/sync.2:45
msgid "B<int syncfs(int >I<fd>B<);>"
msgstr "B<int syncfs(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/sync.2:49
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/sync.2:52
msgid "B<sync>():"
msgstr "B<sync>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/sync.2:58
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/sync.2:62
msgid "B<syncfs>():"
msgstr "B<syncfs>():"

#. type: Plain text
#: build/C/man2/sync.2:65
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man2/sync.2:71
#, fuzzy
#| msgid ""
#| "B<sync>()  causes all buffered modifications to file metadata and data to "
#| "be written to the underlying filesystems."
msgid ""
"B<sync>()  causes all pending modifications to filesystem metadata and "
"cached file data to be written to the underlying filesystems."
msgstr ""
"B<sync>() を呼び出すと、バッファーされたファイルのメタデータとデータ本体に\n"
"対して行われた全ての変更が、対応するファイルシステムに書き込まれる。"

#. type: Plain text
#: build/C/man2/sync.2:78
msgid ""
"B<syncfs>()  is like B<sync>(), but synchronizes just the filesystem "
"containing file referred to by the open file descriptor I<fd>."
msgstr ""
"B<syncfs>() は B<sync>() と同様だが、オープンされたファイルディスクリプター "
"I<fd>\n"
"が参照するファイルを含むファイルシステムだけを同期する点が異なる。"

#. type: Plain text
#: build/C/man2/sync.2:84
msgid ""
"B<syncfs>()  returns 0 on success; on error, it returns -1 and sets I<errno> "
"to indicate the error."
msgstr ""
"B<syncfs>() は成功すると 0 を返す。エラーが発生した場合は -1 を返し、\n"
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/sync.2:87
msgid "B<sync>()  is always successful."
msgstr "B<sync>() は常に成功する。"

#. type: Plain text
#: build/C/man2/sync.2:90
msgid "B<syncfs>()  can fail for at least the following reasons:"
msgstr "B<syncfs>() は少なくとも以下の理由で失敗する可能性がある:"

#. type: TP
#: build/C/man2/sync.2:90
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/sync.2:94
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターでない。。"

#. type: TP
#: build/C/man2/sync.2:94
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/sync.2:99
msgid ""
"An error occurred during synchronization.  This error may relate to data "
"written to any file on the filesystem, or on metadata related to the "
"filesystem itself."
msgstr ""

#. type: TP
#: build/C/man2/sync.2:99
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/sync.2:102
msgid "Disk space was exhausted while synchronizing."
msgstr ""

#. type: TP
#: build/C/man2/sync.2:102
#, no-wrap
msgid "B<ENOSPC>, B<EDQUOT>"
msgstr "B<ENOSPC>, B<EDQUOT>"

#. type: Plain text
#: build/C/man2/sync.2:109
msgid ""
"Data was written to a files on NFS or another filesystem which does not "
"allocate space at the time of a B<write>(2)  system call, and some previous "
"write failed due to insufficient storage space."
msgstr ""

#. type: Plain text
#: build/C/man2/sync.2:113
msgid ""
"B<syncfs>()  first appeared in Linux 2.6.39; library support was added to "
"glibc in version 2.14."
msgstr ""
"B<syncfs>() は Linux 2.6.39 で初めて登場した。\n"
"ライブラリによるサポートは glibc バージョン 2.14 で追加された。"

#. type: Plain text
#: build/C/man2/sync.2:116
msgid "B<sync>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "B<sync>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man2/sync.2:119
msgid "B<syncfs>()  is Linux-specific."
msgstr "B<syncfs>() is Linux 固有である。"

#. type: SH
#: build/C/man2/sync.2:119
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/sync.2:128
msgid ""
"Since glibc 2.2.2, the Linux prototype for B<sync>()  is as listed above, "
"following the various standards.  In glibc 2.2.1 and earlier, it was \"int "
"sync(void)\", and B<sync>()  always returned 0."
msgstr ""
"Linux での B<sync>() のプロトタイプは、さまざまな標準規格での規定に準拠し、\n"
"glibc 2.2.2 から上述のようになった。\n"
"glibc 2.2.1 以前ではプロトタイプは \"int sync(void)\" で、\n"
"B<sync>()  は常に 0 を返していた。"

#. type: Plain text
#: build/C/man2/sync.2:142
#, fuzzy
#| msgid ""
#| "According to the standard specification (e.g., POSIX.1-2001), B<sync>()  "
#| "schedules the writes, but may return before the actual writing is done.  "
#| "However, since version 1.3.20 Linux does actually wait.  (This still does "
#| "not guarantee data integrity: modern disks have large caches.)"
msgid ""
"According to the standard specification (e.g., POSIX.1-2001), B<sync>()  "
"schedules the writes, but may return before the actual writing is done.  "
"However Linux waits for I/O completions, and thus B<sync>()  or B<syncfs>()  "
"provide the same guarantees as B<fsync>()  called on every file in the "
"system or filesystem respectively."
msgstr ""
"標準規格 (例えば POSIX.1-2001) によると、\n"
"B<sync>()\n"
"は書き込むことを予定に\n"
"組み込むのみで実際に書き込みが終了する前に戻ってもよいことになっている。\n"
"一方で Linux はバージョン 1.3.20 からは書き込みが終了するまで待つ。\n"
"(最近のディスクは大きなキャッシュを持っているため、\n"
" これはデータの完全性 (data integrity) までは保証していない。)"

#.  commit 735e4ae5ba28c886d249ad04d3c8cc097dad6336
#. type: Plain text
#: build/C/man2/sync.2:154
msgid ""
"In mainline kernel versions prior to 5.8, B<syncfs>()  will fail only when "
"passed a bad file descriptor (B<EBADF>).  Since Linux 5.8, B<syncfs>()  will "
"also report an error if one or more inodes failed to be written back since "
"the last B<syncfs>()  call."
msgstr ""

#. type: SH
#: build/C/man2/sync.2:154
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/sync.2:157
msgid ""
"Before version 1.3.20 Linux did not wait for I/O to complete before "
"returning."
msgstr ""

#. type: Plain text
#: build/C/man2/sync.2:161
msgid "B<sync>(1), B<fdatasync>(2), B<fsync>(2)"
msgstr "B<sync>(1), B<fdatasync>(2), B<fsync>(2)"

#~ msgid "boot-scripts - general description of boot sequence"
#~ msgstr "boot-scripts - ブートシーケンスの一般的な解説"

#~ msgid ""
#~ "The boot sequence varies in details among systems but can be roughly "
#~ "divided to the following steps: (i) hardware boot, (ii) operating system "
#~ "(OS) loader, (iii) kernel startup, (iv) init and inittab, (v) boot "
#~ "scripts.  We will describe each of these in more detail below."
#~ msgstr ""
#~ "細かいところはシステムによって異なるが、大まかに言うと、 ブートシーケンス"
#~ "は以下の段階に分けられる: (1) ハードウェアのブート (2) オペレーティングシ"
#~ "ステム (OS) ローダー (3) カーネルの起動 (4) init と inittab (5) ブートスク"
#~ "リプト"

#~ msgid ""
#~ "The parameters stored in the nvram vary between systems, but as a "
#~ "minimum, the hardware boot program should know what is the boot device, "
#~ "or which devices to probe as possible boot devices."
#~ msgstr ""
#~ "nvram に保存されているパラメーターはシステムによって異なる。 しかし、ハー"
#~ "ドウェアブートプログラムは、少なくとも、 ブートデバイスがどれであるか、も"
#~ "しくは ブートデバイスとして探索するデバイスがどれであるかを 知っていなけれ"
#~ "ばならない。"

#~ msgid ""
#~ "Then the hardware boot stage accesses the boot device, loads the OS "
#~ "loader, which is located on a fixed position on the boot device, and "
#~ "transfers control to it."
#~ msgstr ""
#~ "ハードウェアブートのシーケンスは、次にブートデバイスにアクセスし、 ブート"
#~ "デバイスのあらかじめ決まった場所に置かれている OS ローダーをロードし、制御"
#~ "を渡す。"

#~ msgid ""
#~ "We do not cover here booting from network.  Those who want to investigate "
#~ "this subject may want to research: DHCP, TFTP, PXE, Etherboot."
#~ msgstr ""
#~ "ここではネットワークブートについては触れない。 この話題について調査したい"
#~ "読者は、 DHCP, TFTP, PXE, Etherboot 等について調べてみるとよい。"

#~ msgid ""
#~ "In Linux the OS loader is normally B<lilo>(8)  or B<grub>(8).  Both of "
#~ "them may install either as secondary loaders (where the DOS installed MBR "
#~ "points to them), or as a two part loader where they provide special MBR "
#~ "containing the bootstrap code to load the second part of the loader from "
#~ "the root partition."
#~ msgstr ""
#~ "Linux における OS ローダーは、ふつう B<lilo>(8)  か B<grub>(8)  である。両"
#~ "者とも第二ローダーとしてインストールすることもでき (この場合 DOS がインス"
#~ "トールした MBR がこれらを指すようにする)、 また第一・第二ローダーの両方と"
#~ "してインストールすることもできる。 後者の場合向けに、両者は特別な MBR イ"
#~ "メージを提供している。 これには第二ローダーをルートパーティションからロー"
#~ "ドするような ブートストラップコードが含まれている。"

#~ msgid "init and inittab"
#~ msgstr "init と inittab"

#~ msgid ""
#~ "When init starts it reads I</etc/inittab> for further instructions.  This "
#~ "file defines what should be run in different I<run-levels>."
#~ msgstr ""
#~ "init は、起動するとまず I</etc/inittab> を読み、その後の行動に関する情報を"
#~ "得る。 このファイルは I<ランレベル> によってどのような動作を行うべきである"
#~ "かを定義する。"

#~ msgid ""
#~ "This gives the system administrator an easy management scheme, where each "
#~ "run-level is associated with a set of services (e.g, B<S> is I<single-"
#~ "user>, on B<2> most network services start).  The administrator may "
#~ "change the current run-level via B<init>(1)  and query the current run-"
#~ "level via B<runlevel>(8)."
#~ msgstr ""
#~ "これによってシステム管理者の管理が楽になる。各I<ランレベル>は提供する\n"
#~ "サービスの集合に対応する (例えば、 B<S> は I<シングルユーザー>、 B<2> で\n"
#~ "は大抵のネットワークサービスを起動する)。\n"
#~ "システム管理者は、 B<init>(1) を用いて現在のランレベルを変更でき、\n"
#~ "B<runlevel>(8) によって現在のランレベルを確認できる。"

#~ msgid "2014-06-13"
#~ msgstr "2014-06-13"

#~ msgid "B<'no387'>"
#~ msgstr "B<'no387'>"

#~ msgid ""
#~ "(Only when B<CONFIG_BUGi386> is defined.)  Some i387 coprocessor chips "
#~ "have bugs that show up when used in 32 bit protected mode.  For example, "
#~ "some of the early ULSI-387 chips would cause solid lockups while "
#~ "performing floating-point calculations.  Using the 'no387' boot argument "
#~ "causes Linux to ignore the maths coprocessor even if you have one.  Of "
#~ "course you must then have your kernel compiled with math emulation "
#~ "support!"
#~ msgstr ""
#~ "(カーネルのコンパイル時に B<CONFIG_BUGi386> が指定されたときのみ有効。)  "
#~ "一部の i387 コプロセッサチップには、 32 ビットプロテクトモードでの使用時に"
#~ "生じるバグがある。 例えば初期の ULSI-387 チップは、 浮動小数点演算を行なう"
#~ "と確実にロックアップしてしまう。 この起動時引数 'no387' を指定すると、 "
#~ "Linux はコプロセッサがあってもそれを無視するようになる。 なおもちろん、"
#~ "カーネルコンパイル時に浮動小数点演算をエミュレートする (kernel math "
#~ "emulation) 指定をしなければならない!"

#~ msgid "B<'no-hlt'>"
#~ msgstr "B<'no-hlt'>"

#~ msgid ""
#~ "(Only when B<CONFIG_BUGi386> is defined.)  Some of the early i486DX-100 "
#~ "chips have a problem with the 'hlt' instruction, in that they can't "
#~ "reliably return to operating mode after this instruction is used.  Using "
#~ "the 'no-hlt' instruction tells Linux to just run an infinite loop when "
#~ "there is nothing else to do, and to not halt the CPU.  This allows people "
#~ "with these broken chips to use Linux."
#~ msgstr ""
#~ "(カーネルのコンパイル時に B<CONFIG_BUGi386> が指定されたときのみ有効。)  "
#~ "初期の i486DX-100 チップの一部では 'hlt' 命令に問題があって、 この命令を使"
#~ "うとオペレーティングモードに正しく戻って来ない。 \\&'no-hlt' を指定すれ"
#~ "ば、Linux はアイドリング時に CPU を停止 (halt) するかわりに無限ループを実"
#~ "行するようになる。 これによって、そのようなバグのあるチップでも Linux を使"
#~ "用できる。"

#~ msgid ""
#~ "The root device can be specified symbolically or numerically.  A symbolic "
#~ "specification has the form I</dev/XXYN>, where XX designates the device "
#~ "type ('hd' for ST-506 compatible hard disk, with Y in \\&'a'-'d'; 'sd' "
#~ "for SCSI compatible disk, with Y in 'a'-'e'; \\&'ad' for Atari ACSI disk, "
#~ "with Y in 'a'-'e', \\&'ez' for a Syquest EZ135 parallel port removable "
#~ "drive, with Y='a', \\&'xd' for XT compatible disk, with Y either 'a' or "
#~ "'b'; 'fd' for floppy disk, with Y the floppy drive number\\(emfd0 would "
#~ "be the DOS 'A:' drive, and fd1 would be 'B:'), Y the driver letter or "
#~ "number, and N the number (in decimal) of the partition on this device "
#~ "(absent in the case of floppies).  Recent kernels allow many other types, "
#~ "mostly for CD-ROMs: nfs, ram, scd, mcd, cdu535, aztcd, cm206cd, gscd, "
#~ "sbpcd, sonycd, bpcd.  (The type nfs specifies a net boot; ram refers to a "
#~ "ram disk.)"
#~ msgstr ""
#~ "ルートデバイスの指定にはシンボル形式と数値形式を用いることができる。 シン"
#~ "ボル形式の場合は I</dev/XXYN> という書式で指定する。 XX にはデバイスタイプ"
#~ "を指定する。 Y にはドライブレターもしくはドライブ番号、 N には (フロッピー"
#~ "ディスクを除く) ディスクの パーティション番号を 10 進数の数値で指定する。 "
#~ "(ST-506 互換ハードディスクではデバイスタイプが 'hd' で Y の範囲は 'a' か"
#~ "ら 'd'、 SCSI ディスクは 'sd' で Y は 'a' から 'e'、 Atari ACSI ディスク"
#~ "は 'ad' で Y は 'a' から 'e'、 Syquest EZ135 パラレルポートリムーバブル"
#~ "ディスクは 'ez' で Y は 'a' のみ、 XT ディスクは 'xt' で Y は 'a' か "
#~ "'b'、 フロッピーディスクは 'fd' で Y にはドライブ番号を指定する。 fd0 は "
#~ "DOS の 'A:'、fd1 は 'B:' に対応している。 パーティションは存在しないので "
#~ "N は指定しない。)  最新のカーネルでは、他にも次のような多くのデバイスタイ"
#~ "プを指定できる (ほとんどは CD-ROM だが): nfs, ram, scd, mcd, cdu535, "
#~ "aztcd, cm206cd, gscd, sbpcd, sonycd, bpcd。 (nfs はネットワークブートに、"
#~ "ram は RAM ディスクを使用する場合に用いる。)"

#~ msgid "B<'mem=...'>"
#~ msgstr "B<'mem=...'>"

#~ msgid ""
#~ "The BIOS call defined in the PC specification that returns the amount of "
#~ "installed memory was designed only to be able to report up to 64MB.  "
#~ "Linux uses this BIOS call at boot to determine how much memory is "
#~ "installed.  If you have more than 64MB of RAM installed, you can use this "
#~ "boot argument to tell Linux how much memory you have.  The value is in "
#~ "decimal or hexadecimal (prefix 0x), and the suffixes 'k' (times 1024) or "
#~ "'M' (times 1048576) can be used.  Here is a quote from Linus on usage of "
#~ "the 'mem=' parameter."
#~ msgstr ""
#~ "搭載されているメモリーの量を返す BIOS コールは PC の仕様で定義されている"
#~ "が、これは最大 64MB までしか返すことができない。 Linux は搭載メモリーの量"
#~ "を調べるために、 起動時にこの BIOS コールを使用する。 もし 64MB 以上の "
#~ "RAM を搭載している場合は、 この起動時引数を用いて 実際のメモリー容量を "
#~ "Linux に知らせることができる。 値は 10 進数または 16 進数 (先頭に 0x を付"
#~ "加) の数値で指定し、 1024 倍を表す 'k' または 1048576 倍を表す 'M' を末尾"
#~ "に付加できる。 以下は Linus による 'mem=' パラメーターの解説である。"

#~ msgid ""
#~ "The kernel will accept any 'mem=xx' parameter you give it, and if it "
#~ "turns out that you lied to it, it will crash horribly sooner or later.  "
#~ "The parameter indicates the highest addressable RAM address, so "
#~ "\\&'mem=0x1000000' means you have 16MB of memory, for example.  For a "
#~ "96MB machine this would be 'mem=0x6000000'."
#~ msgstr ""
#~ "カーネルは 'mem=xx' パラメーターとして どんな値を指定してもそれをそのまま"
#~ "受け入れる。 だからそれが嘘だとわかったら、 遅かれ早かれひどいクラッシュを"
#~ "するだろう。 パラメーターはアクセスしうる最も高位の RAM アドレスを指示す"
#~ "る。 だから例えば 'mem=0x1000000' っていうのは 16MB のメモリーがある、とい"
#~ "う意味になる。 96MB のマシンなら 'mem=0x6000000' だ。"

#~ msgid ""
#~ "B<NOTE>: some machines might use the top of memory for BIOS caching or "
#~ "whatever, so you might not actually have up to the full 96MB "
#~ "addressable.  The reverse is also true: some chipsets will map the "
#~ "physical memory that is covered by the BIOS area into the area just past "
#~ "the top of memory, so the top-of-mem might actually be 96MB + 384kB for "
#~ "example.  If you tell linux that it has more memory than it actually does "
#~ "have, bad things will happen: maybe not at once, but surely eventually."
#~ msgstr ""
#~ "B<注意>: マシンによってはメモリーの最上位の領域を BIOS のキャッシュやら何"
#~ "やらの ために使っていることがあるから、 実際には 96MB をフルにアドレスする"
#~ "ことはできないかもしれない。 逆の場合もある。 いくつかのチップセットで"
#~ "は、 BIOS 領域に入っている物理メモリーを最上位のメモリーのさらに上にマップ"
#~ "する。 よって最上位のメモリーはたとえば 96MB + 384kB なんて値になるかもし"
#~ "れない。 linux に実際より多いメモリーを教えてしまったとしたら、 まずいこと"
#~ "が起きるだろう。 すぐにではないかもしれないけど、ゆくゆくは確実にね。"

#~ msgid ""
#~ "You can also use the boot argument 'mem=nopentium' to turn off 4 MB page "
#~ "tables on kernels configured for IA32 systems with a pentium or newer CPU."
#~ msgstr ""
#~ "また、起動時引数に 'mem=nopentium' を指定すると、 pentium とそれ以降の "
#~ "CPU を使った IA32 システム用に設定されたカーネルで 4MB のページテーブルを"
#~ "無効にすることができる。"

#~ msgid "B<'swap=N1,N2,N3,N4,N5,N6,N7,N8'>"
#~ msgstr "B<'swap=N1,N2,N3,N4,N5,N6,N7,N8'>"

#~ msgid ""
#~ "Set the eight parameters max_page_age, page_advance, page_decline, "
#~ "page_initial_age, age_cluster_fract, age_cluster_min, pageout_weight, "
#~ "bufferout_weight that control the kernel swap algorithm.  For kernel "
#~ "tuners only."
#~ msgstr ""
#~ "カーネルのスワップアルゴリズムをコントロールする 次の 8 つのパラメーターを"
#~ "セットする。 max_page_age, page_advance, page_decline, page_initial_age, "
#~ "age_cluster_fract, age_cluster_min, pageout_weight, bufferout_weight.  こ"
#~ "れはカーネルをチューンする人のためのオプションである。"

#~ msgid "B<'buff=N1,N2,N3,N4,N5,N6'>"
#~ msgstr "B<'buff=N1,N2,N3,N4,N5,N6'>"

#~ msgid ""
#~ "Set the six parameters max_buff_age, buff_advance, buff_decline, "
#~ "buff_initial_age, bufferout_weight, buffermem_grace that control kernel "
#~ "buffer memory management.  For kernel tuners only."
#~ msgstr ""
#~ "カーネルのバッファーメモリー管理をコントロールする 次の 6 つのパラメーター"
#~ "をセットする。 max_buff_age, buff_advance, buff_decline, "
#~ "buff_initial_age, bufferout_weight, buffermem_grace.  これはカーネルを"
#~ "チューンする人のためのオプションである。"

#~ msgid "B<Adaptec aha151x, aha152x, aic6260, aic6360, SB16-SCSI configuration>"
#~ msgstr "B<Adaptec aha151x, aha152x, aic6260, aic6360, SB16-SCSI の設定>"

#~ msgid ""
#~ "The aha numbers refer to cards and the aic numbers refer to the actual "
#~ "SCSI chip on these type of cards, including the Soundblaster-16 SCSI."
#~ msgstr ""
#~ "aha に続く番号はカードを表し、 aic に続く番号はカードに搭載されている実際"
#~ "のチップを表す (Soundblaster-16 SCSI も後者に含まれる)。"

#~ msgid ""
#~ "The probe code for these SCSI hosts looks for an installed BIOS, and if "
#~ "none is present, the probe will not find your card.  Then you will have "
#~ "to use a boot argument of the form:"
#~ msgstr ""
#~ "SCSI ホストの検出コードは、 インストールされている BIOS を探す。 見つから"
#~ "ないと、カードは検出できない。 この場合は以下のように起動時引数を指定する"
#~ "ことになる。"

#~ msgid "B<aha152x=>I<iobase[,irq[,scsi-id[,reconnect[,parity]]]]>\n"
#~ msgstr "B<aha152x=>I<iobase[,irq[,scsi-id[,reconnect[,parity]]]]>\n"

#~ msgid ""
#~ "If the driver was compiled with debugging enabled, a sixth value can be "
#~ "specified to set the debug level."
#~ msgstr ""
#~ "もしドライバのコンパイル時にデバッグオプションを指定していた場合は、 6 番"
#~ "目の値でデバッグレベルを指定できる。"

#~ msgid ""
#~ "All the parameters are as described at the top of this section, and the "
#~ "I<reconnect> value will allow device disconnect/reconnect if a nonzero "
#~ "value is used.  An example usage is as follows:"
#~ msgstr ""
#~ "すべてのパラメーターは、このセクションの最初で説明した通りである。 "
#~ "I<reconnect> に 0 以外の値を指定すると、デバイスを切断したり接続したりでき"
#~ "る。 以下に例を示す。"

#~ msgid "aha152x=0x340,11,7,1\n"
#~ msgstr "aha152x=0x340,11,7,1\n"

#~ msgid ""
#~ "Note that the parameters must be specified in order, meaning that if you "
#~ "want to specify a parity setting, then you will have to specify an "
#~ "iobase, irq, scsi-id and reconnect value as well."
#~ msgstr ""
#~ "パラメーターは必ず上記の順番どおりに指定されなければならない。 例えば、パ"
#~ "リティ (parity) を設定したい場合には、 iobase, irq, scsi-id, reconnect も"
#~ "同時に指定する必要がある。"

#~ msgid "B<Adaptec aha154x configuration>"
#~ msgstr "B<Adaptec aha154x の設定>"

#~ msgid ""
#~ "The aha1542 series cards have an i82077 floppy controller onboard, while "
#~ "the aha1540 series cards do not.  These are busmastering cards, and have "
#~ "parameters to set the \"fairness\" that is used to share the bus with "
#~ "other devices.  The boot argument looks like the following."
#~ msgstr ""
#~ "aha1542 シリーズのカードは i82077 フロッピーディスクコントローラーをボード"
#~ "に搭載している。 一方 aha1540 シリーズのカードは搭載していない。 これらは"
#~ "共にバスマスタカードであり、 他のデバイスとバスを共有する際に、 どのくらい"
#~ "「フェアに」振る舞うかを指定するパラメーターがある。 起動時引数は以下のよ"
#~ "うにして指定する。"

#~ msgid "B<aha1542=>I<iobase[,buson,busoff[,dmaspeed]]>\n"
#~ msgstr "B<aha1542=>I<iobase[,buson,busoff[,dmaspeed]]>\n"

#~ msgid ""
#~ "Valid iobase values are usually one of: 0x130, 0x134, 0x230, 0x234, "
#~ "0x330, 0x334.  Clone cards may permit other values."
#~ msgstr ""
#~ "有効な iobase の値は次の通り。 0x130, 0x134, 0x230, 0x234, 0x330, "
#~ "0x334。\n"
#~ "クローンカードの中には他の値を指定できるものもある。"

#~ msgid ""
#~ "The I<buson>, I<busoff> values refer to the number of microseconds that "
#~ "the card dominates the ISA bus.  The defaults are 11us on, and 4us off, "
#~ "so that other cards (such as an ISA LANCE Ethernet card) have a chance to "
#~ "get access to the ISA bus."
#~ msgstr ""
#~ "I<buson>, I<busoff> 値はカードがISA バスを占有する時間をマイクロ秒単位で指"
#~ "定する。 省略時はそれぞれ 11us on と 4us off になっているので、 他のカー"
#~ "ド (例えば ISA LANCE イーサネットカード) も ISA バスにアクセスできる。"

#~ msgid ""
#~ "The I<dmaspeed> value refers to the rate (in MB/s) at which the DMA "
#~ "(Direct Memory Access) transfers proceed.  The default is 5MB/s.  Newer "
#~ "revision cards allow you to select this value as part of the soft-"
#~ "configuration, older cards use jumpers.  You can use values up to 10MB/s "
#~ "assuming that your motherboard is capable of handling it.  Experiment "
#~ "with caution if using values over 5MB/s."
#~ msgstr ""
#~ "I<dmaspeed> 値は DMA (Direct Memory Access) 転送速度を MB/s 単位で設定す"
#~ "る。 省略時は 5MB/s である。新しいリビジョンのカードでは、 この値を使った"
#~ "ソフトウェアによる設定ができる。 古いカードはジャンパ設定を必要とする。 マ"
#~ "ザーボードが対応していれば最大 10MB/s まで指定可能である。 5MB/s 以上の値"
#~ "を使う場合は注意して実験してからにすること。"

#~ msgid "B<Adaptec aha274x, aha284x, aic7xxx configuration>"
#~ msgstr "B<Adaptec aha274x, aha284x, aic7xxx の設定>"

#~ msgid "These boards can accept an argument of the form:"
#~ msgstr "これらのボードは以下の形式で指定する。"

#~ msgid "B<aic7xxx=>I<extended,no_reset>\n"
#~ msgstr "B<aic7xxx=>I<extended,no_reset>\n"

#~ msgid ""
#~ "The I<extended> value, if nonzero, indicates that extended translation "
#~ "for large disks is enabled.  The I<no_reset> value, if nonzero, tells the "
#~ "driver not to reset the SCSI bus when setting up the host adapter at boot."
#~ msgstr ""
#~ "I<extended> 値が 0 以外の時は、大容量ディスク用の拡張変換が有効になる。 "
#~ "I<no_reset> 値を 0 以外の値にすると、ホストアダプターの検出時に、 ドライバ"
#~ "による SCSI バスの初期化を行わない。"

#~ msgid "B<AdvanSys SCSI Hosts configuration ('advansys=')>"
#~ msgstr "B<AdvanSys SCSI ホストアダプターの設定 ('advansys=')>"

#~ msgid ""
#~ "The AdvanSys driver can accept up to four I/O addresses that will be "
#~ "probed for an AdvanSys SCSI card.  Note that these values (if used) do "
#~ "not effect EISA or PCI probing in any way.  They are used only for "
#~ "probing ISA and VLB cards.  In addition, if the driver has been compiled "
#~ "with debugging enabled, the level of debugging output can be set by "
#~ "adding an 0xdeb[0-f] parameter.  The 0-f allows setting the level of the "
#~ "debugging messages to any of 16 levels of verbosity."
#~ msgstr ""
#~ "AdvanSys ドライバはカードの検出先として 4 つの I/O アドレスを受け付ける。 "
#~ "EISA や PCI カードではこれらを指定しても全く効果が無い。 ISA 及び VLB カー"
#~ "ドの検出に対してのみ用いられる。 さらに、デバッグオプション付きでドライバ"
#~ "がコンパイルされている場合、 デバッグ情報の出力レベルとして 0xdeb[0-f] パ"
#~ "ラメーターを追加できる。 0-f によりデバッグメッセージの情報のレベルを 16 "
#~ "段階で指定する。"

#~ msgid "B<AM53C974>"
#~ msgstr "B<AM53C974>"

#~ msgid "B<AM53C974=>I<host-scsi-id,target-scsi-id,max-rate,max-offset>\n"
#~ msgstr "B<AM53C974=>I<host-scsi-id,target-scsi-id,max-rate,max-offset>\n"

#~ msgid "B<BusLogic SCSI Hosts configuration ('BusLogic=')>"
#~ msgstr "B<BusLogic SCSI ホストアダプターの設定 ('BusLogic=')>"

#~ msgid "B<BusLogic=>I<N1,N2,N3,N4,N5,S1,S2,...>\n"
#~ msgstr "B<BusLogic=>I<N1,N2,N3,N4,N5,S1,S2,...>\n"

#~ msgid ""
#~ "For an extensive discussion of the BusLogic command line parameters, see "
#~ "the kernel source file I<drivers/scsi/BusLogic.c>.  The text below is a "
#~ "very much abbreviated extract."
#~ msgstr ""
#~ "Buslogic のコマンドラインパラメーターに関する詳細な議論はカーネルソース"
#~ "ファイル I<drivers/scsi/BusLogic.c> を参照すること。 以下はこれを非常にお"
#~ "おざっぱに要約したものである。"

#~ msgid ""
#~ "The parameters N1-N5 are integers.  The parameters S1,... are strings.  "
#~ "N1 is the I/O Address at which the Host Adapter is located.  N2 is the "
#~ "Tagged Queue Depth to use for Target Devices that support Tagged "
#~ "Queuing.  N3 is the Bus Settle Time in seconds.  This is the amount of "
#~ "time to wait between a Host Adapter Hard Reset which initiates a SCSI Bus "
#~ "Reset and issuing any SCSI Commands.  N4 is the Local Options (for one "
#~ "Host Adapter).  N5 is the Global Options (for all Host Adapters)."
#~ msgstr ""
#~ "パラメーター N1 から N5 までは整数である。 パラメーター S1 以降は文字列で"
#~ "ある。 N1 はホストアダプターが存在する I/O アドレス。 N2 はタグキューイン"
#~ "グをサポートするデバイスに対して使用するキューの深さ。 N3 はバス安定時間 "
#~ "(BST) を秒単位で指定する。 これはホストアダプターのハードリセットにより "
#~ "SCSI バスをリセットしてから SCSI コマンドの発行を開始するまでの待ち時間で"
#~ "ある。 N4 はローカルオプション (ひとつのホストアダプター用)。 N5 はグロー"
#~ "バルオプション (すべてのホストアダプター用)。"

#~ msgid ""
#~ "The string options are used to provide control over Tagged Queuing (TQ:"
#~ "Default, TQ:Enable, TQ:Disable, TQ:E<lt>Per-Target-SpecE<gt>), over Error "
#~ "Recovery (ER:Default, ER:HardReset, ER:BusDeviceReset, ER:None, ER:"
#~ "E<lt>Per-Target-SpecE<gt>), and over Host Adapter Probing (NoProbe, "
#~ "NoProbeISA, NoSortPCI)."
#~ msgstr ""
#~ "文字列オプションは以下の動作を制御する: タグキューイング (TQ:Default, TQ:"
#~ "Enable, TQ:Disable, TQ:E<lt>Per-Target-SpecE<gt>)、 エラー復帰 (ER:"
#~ "Default, ER:HardReset, ER:BusDeviceReset, ER:None, ER:E<lt>Per-Target-"
#~ "SpecE<gt>)、 ホストアダプターの検出 (NoProbe, NoProbeISA, NoSortPCI)。"

#~ msgid "B<EATA/DMA configuration>"
#~ msgstr "B<EATA/DMA の設定>"

#~ msgid "The default list of I/O ports to be probed can be changed by"
#~ msgstr ""
#~ "検出対象にする I/O ポートのデフォルトのリストは以下のようにして変更でき"
#~ "る。"

#~ msgid "B<eata=>I<iobase,iobase,...>B<.>\n"
#~ msgstr "B<eata=>I<iobase,iobase,...>B<.>\n"

#~ msgid "B<Future Domain TMC-16x0 configuration>"
#~ msgstr "B<Future Domain TMC-16x0 の設定>"

#~ msgid "B<fdomain=>I<iobase,irq[,adapter_id]>\n"
#~ msgstr "B<fdomain=>I<iobase,irq[,adapter_id]>\n"

#~ msgid "B<Great Valley Products (GVP) SCSI controller configuration>"
#~ msgstr "B<Great Valley Products (GVP) SCSI コントローラーの設定>"

#~ msgid "B<gvp11=>I<dma_transfer_bitmask>\n"
#~ msgstr "B<gvp11=>I<dma_transfer_bitmask>\n"

#~ msgid "B<Future Domain TMC-8xx, TMC-950 configuration>"
#~ msgstr "B<Future Domain 製 TMC-8xx, TMC-950 の設定>"

#~ msgid "B<tmc8xx=>I<mem_base,irq>\n"
#~ msgstr "B<tmc8xx=>I<mem_base,irq>\n"

#~ msgid ""
#~ "The I<mem_base> value is the value of the memory-mapped I/O region that "
#~ "the card uses.  This will usually be one of the following values: "
#~ "0xc8000, 0xca000, 0xcc000, 0xce000, 0xdc000, 0xde000."
#~ msgstr ""
#~ "I<mem_base> にはカードが使用するメモリーマップ I/O の領域を指定する。\n"
#~ "通常は次の値のどれかである: 0xc8000, 0xca000, 0xcc000, 0xce000, 0xdc000, "
#~ "0xde000。"

#~ msgid "B<IN2000 configuration>"
#~ msgstr "B<IN2000 の設定>"

#~ msgid "B<in2000=>I<S>\n"
#~ msgstr "B<in2000=>I<S>\n"

#~ msgid ""
#~ "where S is a comma-separated string of items keyword[:value].  Recognized "
#~ "keywords (possibly with value) are: ioport:addr, noreset, nosync:x, "
#~ "period:ns, disconnect:x, debug:x, proc:x.  For the function of these "
#~ "parameters, see the kernel source file I<drivers/scsi/in2000.c>."
#~ msgstr ""
#~ "S はコンマ区切りの文字列で、各項目は keyword[:value] 形式で指定する。 指定"
#~ "できるキーワードは以下の通り。 ioport:addr, noreset, nosync:x, period:ns, "
#~ "disconnect:x, debug:x, proc:x。 これらのパラメーターの機能についてはカーネ"
#~ "ルソースファイル I<drivers/scsi/in2000.c> を参照。"

#~ msgid "B<NCR5380 and NCR53C400 configuration>"
#~ msgstr "B<NCR5380 および NCR53C400 の設定>"

#~ msgid "The boot argument is of the form"
#~ msgstr "この起動時引数は以下の書式で指定する。"

#~ msgid "B<ncr5380=>I<iobase,irq,dma>\n"
#~ msgstr "B<ncr5380=>I<iobase,irq,dma>\n"

#~ msgid "or"
#~ msgstr "または"

#~ msgid "B<ncr53c400=>I<iobase,irq>\n"
#~ msgstr "B<ncr53c400=>I<iobase,irq>\n"

#~ msgid ""
#~ "If the card doesn't use interrupts, then an IRQ value of 255 (0xff) will "
#~ "disable interrupts.  An IRQ value of 254 means to autoprobe.  More "
#~ "details can be found in the file I<Documentation/scsi/g_NCR5380.txt> (or "
#~ "I<drivers/scsi/README.g_NCR5380> for older kernels) in the Linux kernel "
#~ "source."
#~ msgstr ""
#~ "カードが IRQ を使用しない場合は、 255 (0xff) を指定すれば無効にできる。 "
#~ "IRQ に 254 を指定すると自動検出する。 詳細は Linux カーネルソース内の "
#~ "I<Documentation/scsi/g_NCR5380.txt> (古いカーネルの場合は I<drivers/scsi/"
#~ "README.g_NCR5380>)  に書かれている。"

#~ msgid "B<NCR53C8xx configuration>"
#~ msgstr "B<NCR53C8xx の設定>"

#~ msgid "B<ncr53c8xx=>I<S>\n"
#~ msgstr "B<ncr53c8xx=>I<S>\n"

#~ msgid ""
#~ "where S is a comma-separated string of items keyword:value.  Recognized "
#~ "keywords are: mpar (master_parity), spar (scsi_parity), disc "
#~ "(disconnection), specf (special_features), ultra (ultra_scsi), fsn "
#~ "(force_sync_nego), tags (default_tags), sync (default_sync), verb "
#~ "(verbose), debug (debug), burst (burst_max).  For the function of the "
#~ "assigned values, see the kernel source file I<drivers/scsi/ncr53c8xx.c>."
#~ msgstr ""
#~ "S はコンマ区切りの文字列で、各項目は keyword[:value] 形式で指定する。 指定"
#~ "できるキーワードは以下の通り。 mpar (master_parity), spar (scsi_parity), "
#~ "disc (disconnection), specf (special_features), ultra (ultra_scsi), fsn "
#~ "(force_sync_nego), tags (default_tags), sync (default_sync), verb "
#~ "(verbose), debug (debug), burst (burst_max)。 これらのオプションの機能につ"
#~ "いてはカーネルソースファイル I<drivers/scsi/ncr53c8xx.c> を参照すること。"

#~ msgid "B<NCR53c406a configuration>"
#~ msgstr "B<NCR53c406a の設定>"

#~ msgid "B<ncr53c406a=>I<iobase[,irq[,fastpio]]>\n"
#~ msgstr "B<ncr53c406a=>I<iobase[,irq[,fastpio]]>\n"

#~ msgid ""
#~ "Specify irq = 0 for noninterrupt driven mode.  Set fastpio = 1 for fast "
#~ "pio mode, 0 for slow mode."
#~ msgstr ""
#~ "割り込み無しで動作するモードには irq に 0 を指定する。 高速 PIO モードは "
#~ "fastpio に 1 を指定し、低速モードは 0 を指定する。"

#~ msgid "B<Pro Audio Spectrum configuration>"
#~ msgstr "B<Pro Audio Spectrum の設定>"

#~ msgid ""
#~ "The PAS16 uses a NC5380 SCSI chip, and newer models support jumperless "
#~ "configuration.  The boot argument is of the form:"
#~ msgstr ""
#~ "PAS16 は NC5380 SCSI チップを使用しており、 最近のモデルはジャンパレスの設"
#~ "定をサポートしている。 起動時引数の書式は以下の通り。"

#~ msgid "B<pas16=>I<iobase,irq>\n"
#~ msgstr "B<pas16=>I<iobase,irq>\n"

#~ msgid ""
#~ "The only difference is that you can specify an IRQ value of 255, which "
#~ "will tell the driver to work without using interrupts, albeit at a "
#~ "performance loss.  The iobase is usually 0x388."
#~ msgstr ""
#~ "唯一の違いとして、 IRQ に 255 を指定すれば割り込みを使用しないようドライバ"
#~ "に指示できる (パフォーマンスは低下する)。 通常 iobase は 0x388 である。"

#~ msgid "B<Seagate ST-0x configuration>"
#~ msgstr "B<Seagate 製 ST-0x の設定>"

#~ msgid ""
#~ "If your card is not detected at boot time, you will then have to use a "
#~ "boot argument of the form:"
#~ msgstr ""
#~ "カードが起動時に認識されない場合は以下のような指定が必要になるだろう。"

#~ msgid "B<st0x=>I<mem_base,irq>\n"
#~ msgstr "B<st0x=>I<mem_base,irq>\n"

#~ msgid "B<Trantor T128 configuration>"
#~ msgstr "B<Trantor 製 T128 の設定>"

#~ msgid ""
#~ "These cards are also based on the NCR5380 chip, and accept the following "
#~ "options:"
#~ msgstr ""
#~ "このカードも NCR5380 チップを利用しており、 以下のオプションを受け付ける。"

#~ msgid "B<t128=>I<mem_base,irq>\n"
#~ msgstr "B<t128=>I<mem_base,irq>\n"

#~ msgid ""
#~ "The valid values for I<mem_base> are as follows: 0xcc000, 0xc8000, "
#~ "0xdc000, 0xd8000."
#~ msgstr ""
#~ "有効な I<mem_base> の値は次の通りである: 0xcc000, 0xc8000, 0xdc000, "
#~ "0xd8000。"

#~ msgid "B<UltraStor 14F/34F configuration>"
#~ msgstr "B<UltraStor 製 14F/34F の設定>"

#~ msgid "B<WD7000 configuration>"
#~ msgstr "B<WD7000 の設定>"

#~ msgid "B<wd7000=>I<irq,dma,iobase>\n"
#~ msgstr "B<wd7000=>I<irq,dma,iobase>\n"

#~ msgid "B<Commodore Amiga A2091/590 SCSI controller configuration>"
#~ msgstr "B<Commodore Amiga 製 A2091/590 SCSI コントローラーの設定>"

#~ msgid "B<wd33c93=>I<S>\n"
#~ msgstr "B<wd33c93=>I<S>\n"

#~ msgid ""
#~ "where S is a comma-separated string of options.  Recognized options are "
#~ "nosync:bitmask, nodma:x, period:ns, disconnect:x, debug:x, clock:x, "
#~ "next.  For details, see the kernel source file I<drivers/scsi/wd33c93.c>."
#~ msgstr ""
#~ "S はコンマ区切りの文字列で、各項目は keyword[:value] 形式で指定する。 認識"
#~ "されるオプションは以下の通り。 nosync:bitmask, nodma:x, period:ns, "
#~ "disconnect:x, debug:x, clock:x, next。 詳細はカーネルソースファイル "
#~ "I<drivers/scsi/wd33c93.c> を参照。"

#~ msgid "B<The 'hd=dtc2278' option>"
#~ msgstr "B<'hd=dtc2278' オプション>"

#~ msgid ""
#~ "This option tells the driver that you have a DTC-2278D IDE interface.  "
#~ "The driver then tries to do DTC-specific operations to enable the second "
#~ "interface and to enable faster transfer modes."
#~ msgstr ""
#~ "このオプションは、DTC-2278D IDE インターフェースが使われている ことをドラ"
#~ "イバに伝える。 するとドライバは、DTC 特有の機能 (2 番目のインターフェース"
#~ "と高速転送モード)  を使用可能にするよう試みる。"

#~ msgid "B<XT Disk Driver Options ('xd=')>"
#~ msgstr "B<XT ディスクドライバのオプション ('xd=')>"

#~ msgid ""
#~ "If you are unfortunate enough to be using one of these old 8-bit cards "
#~ "that move data at a whopping 125kB/s, then here is the scoop.  If the "
#~ "card is not recognized, you will have to use a boot argument of the form:"
#~ msgstr ""
#~ "これらの古い 8 bit カード (125kB/s の転送速度しかない!)  を使わなければな"
#~ "らない不幸な人のためのオプションである。 カードが認識されない場合は以下の"
#~ "書式で起動時引数を指定する必要があるだろう。"

#~ msgid "xd=type,irq,iobase,dma_chan\n"
#~ msgstr "xd=type,irq,iobase,dma_chan\n"

#~ msgid ""
#~ "The type value specifies the particular manufacturer of the card, "
#~ "overriding autodetection.  For the types to use, consult the I<drivers/"
#~ "block/xd.c> source file of the kernel you are using.  The type is an "
#~ "index in the list I<xd_sigs> and in the course of time types have been "
#~ "added to or deleted from the middle of the list, changing all type "
#~ "numbers.  Today (Linux 2.5.0) the types are 0=generic; 1=DTC 5150cx; "
#~ "2,3=DTC 5150x; 4,5=Western Digital; 6,7,8=Seagate; 9=Omti; 10=XEBEC, and "
#~ "where here several types are given with the same designation, they are "
#~ "equivalent."
#~ msgstr ""
#~ "type 値にはカードのメーカーを指定し、これは自動検知より優先される。 指定す"
#~ "べき type の値については、使っているカーネルのソースファイル I<drivers/"
#~ "block/xd.c> を調べてほしい。type はリスト I<xd_sigs> のインデックスで、歴"
#~ "史と共に追加されたり削除されたりしてきた。 リストの途中での追加・削除も行"
#~ "われたので、 その場合はすべての type 番号が変更された。 今日 (Linux "
#~ "2.5.0) における type は、 0=generic; 1=DTC 5150cx; 2,3=DTC 5150x; "
#~ "4,5=Western Digital; 6,7,8=Seagate; 9=Omti; 10=XEBEC である。 ここではいく"
#~ "つかの type に同じ指定が与えられているが、 それらは等価である。"

#~ msgid ""
#~ "The xd_setup() function does no checking on the values, and assumes that "
#~ "you entered all four values.  Don't disappoint it.  Here is an example "
#~ "usage for a WD1002 controller with the BIOS disabled/removed, using the "
#~ "'default' XT controller parameters:"
#~ msgstr ""
#~ "xd_setup() 関数は引数をチェックせず、 4 つの値がすべて指定されることを想定"
#~ "している。 引数を省略してはならない。 例として、BIOS が無効にされた (ある"
#~ "いは削除された)  WD1002 コントローラーの場合を示す (パラメーターには XT コ"
#~ "ントローラーの「デフォルト」の値を使っている)。"

#~ msgid "xd=2,5,0x320,3\n"
#~ msgstr "xd=2,5,0x320,3\n"

#~ msgid "B<Syquest's EZ* removable disks>"
#~ msgstr "B<Syquest 製 EZ* リムーバブルディスク>"

#~ msgid "B<ez=>I<iobase[,irq[,rep[,nybble]]]>\n"
#~ msgstr "B<ez=>I<iobase[,irq[,rep[,nybble]]]>\n"

#~ msgid "IBM MCA bus devices"
#~ msgstr "IBM MCA バス上のデバイス"

#~ msgid "See also the kernel source file I<Documentation/mca.txt>."
#~ msgstr "カーネルソースファイル I<Documentation/mca.txt> も参照。"

#~ msgid "B<PS/2 ESDI hard disks>"
#~ msgstr "B<PS/2 ESDI ハードディスク>"

#~ msgid "It is possible to specify the desired geometry at boot time:"
#~ msgstr "起動時に所望のジオメトリを指定できる。"

#~ msgid "B<ed=>I<cyls,heads,sectors.>\n"
#~ msgstr "B<ed=>I<cyls,heads,sectors.>\n"

#~ msgid "For a ThinkPad-720, add the option"
#~ msgstr "ThinkPad-720 を使用する場合は以下のオプションを追加すること。"

#~ msgid "B<tp720=1>.\n"
#~ msgstr "B<tp720=1>.\n"

#~ msgid "B<IBM Microchannel SCSI Subsystem configuration>"
#~ msgstr "B<IBM Microchannel SCSI サブシステムの設定>"

#~ msgid "B<ibmmcascsi=>I<N>\n"
#~ msgstr "B<ibmmcascsi=>I<N>\n"

#~ msgid "where N is the I<pun> (SCSI ID) of the subsystem."
#~ msgstr "N はサブシステムの I<pun> (SCSI ID) を表す。"

#~ msgid "B<The Aztech Interface>"
#~ msgstr "B<Aztech インターフェース>"

#~ msgid "The syntax for this type of card is:"
#~ msgstr "このタイプのカードの構文は以下の通り。"

#~ msgid "aztcd=iobase[,magic_number]\n"
#~ msgstr "aztcd=iobase[,magic_number]\n"

#~ msgid ""
#~ "If you set the magic_number to 0x79, then the driver will try and run "
#~ "anyway in the event of an unknown firmware version.  All other values are "
#~ "ignored."
#~ msgstr ""
#~ "magic_number に 0x79 をセットすると、 ドライバはファームウェアのバージョン"
#~ "が分からない場合でも、 とにかく実行を試みる。 その他の値はすべて無視され"
#~ "る。"

#~ msgid "B<Parallel port CD-ROM drives>"
#~ msgstr "B<パラレルポート CD-ROM ドライブ>"

#~ msgid ""
#~ "pcd.driveN=prt,pro,uni,mod,slv,dly\n"
#~ "pcd.nice=nice\n"
#~ msgstr ""
#~ "pcd.driveN=prt,pro,uni,mod,slv,dly\n"
#~ "pcd.nice=nice\n"

#~ msgid ""
#~ "where 'port' is the base address, 'pro' is the protocol number, 'uni' is "
#~ "the unit selector (for chained devices), 'mod' is the mode (or -1 to "
#~ "choose the best automatically), 'slv' is 1 if it should be a slave, and "
#~ "'dly' is a small integer for slowing down port accesses.  The 'nice' "
#~ "parameter controls the driver's use of idle CPU time, at the expense of "
#~ "some speed."
#~ msgstr ""
#~ "ここで 'port' はベースアドレス、'pro' はプロトコル番号、'uni' はユニットセ"
#~ "レクタ (チェインデバイス用)、'mod' はモード (あるいは自動的に最適のものを"
#~ "選ばせるには -1)、'slv' はスレーブにしたい場合に 1、'dly' はポートアクセス"
#~ "を遅くしたい場合に小さな整数を与える。'nice' パラメーターは、 ドライバのア"
#~ "イドル CPU 時間の使い方を制御する。 ただし速度はある程度低下する。"

#~ msgid "B<The CDU-31A and CDU-33A Sony Interface>"
#~ msgstr "B<Sony 製 CDU-31A と CDU-33A のインターフェース>"

#~ msgid ""
#~ "This CD-ROM interface is found on some of the Pro Audio Spectrum sound "
#~ "cards, and other Sony supplied interface cards.  The syntax is as follows:"
#~ msgstr ""
#~ "この CD-ROM インターフェースは、 Pro Audio Spectrum サウンドカードの一部"
#~ "や ソニーが供給するインターフェースカードで使われている。 構文は以下の通"
#~ "り。"

#~ msgid "cdu31a=iobase,[irq[,is_pas_card]]\n"
#~ msgstr "cdu31a=iobase,[irq[,is_pas_card]]\n"

#~ msgid ""
#~ "Specifying an IRQ value of zero tells the driver that hardware interrupts "
#~ "aren't supported (as on some PAS cards).  If your card supports "
#~ "interrupts, you should use them as it cuts down on the CPU usage of the "
#~ "driver."
#~ msgstr ""
#~ "IRQ に 0 を指定すると、 ハードウェア割り込みがサポートされていないことをド"
#~ "ライバに伝える (PAS カードにはそのようなものがある)。 使用するカードが割り"
#~ "込みをサポートしているなら、 ドライバによる CPU の負荷を減らすためにも割り"
#~ "込みを使用すべきである。"

#~ msgid ""
#~ "The I<is_pas_card> should be entered as 'PAS' if using a Pro Audio "
#~ "Spectrum card, and otherwise it should not be specified at all."
#~ msgstr ""
#~ "I<is_pas_card> には、Pro Audio Spectrum カードを使用しているときには "
#~ "'PAS' を指定し、 そうでないときにはなにも指定しない。"

#~ msgid "B<The CDU-535 Sony Interface>"
#~ msgstr "B<Sony 製 CDU-535 インターフェース>"

#~ msgid "The syntax for this CD-ROM interface is:"
#~ msgstr "この CD-ROM インターフェースの構文は以下の通り。"

#~ msgid "sonycd535=iobase[,irq]\n"
#~ msgstr "sonycd535=iobase[,irq]\n"

#~ msgid ""
#~ "A zero can be used for the I/O base as a 'placeholder' if one wishes to "
#~ "specify an IRQ value."
#~ msgstr ""
#~ "IRQ の値だけを指定したい場合には、 iobase 値を 0 とすれば単なる穴埋めと解"
#~ "釈される。"

#~ msgid "B<The GoldStar Interface>"
#~ msgstr "B<GoldStar インターフェース>"

#~ msgid "gscd=iobase\n"
#~ msgstr "gscd=iobase\n"

#~ msgid "B<The ISP16 CD-ROM Interface>"
#~ msgstr "B<ISP16 CD-ROM インターフェース>"

#~ msgid "isp16=[iobase[,irq[,dma[,type]]]]\n"
#~ msgstr "isp16=[iobase[,irq[,dma[,type]]]]\n"

#~ msgid ""
#~ "(Three integers and a string.)  If the type is given as 'noisp16', the "
#~ "interface will not be configured.  Other recognized types are: 'Sanyo\", "
#~ "'Sony', 'Panasonic' and 'Mitsumi'."
#~ msgstr ""
#~ "(整数値 3 つと文字列 1 つの形式) type に 'noisp16' を指定すると、 インター"
#~ "フェースの設定は行なわれない。 type にはこの他にも 'Sanyo', 'Sony', "
#~ "'Panasonic', 'Mitsumi' が指定できる。"

#~ msgid "B<The Mitsumi Standard Interface>"
#~ msgstr "B<Mitsumi 標準インターフェース>"

#~ msgid "mcd=iobase,[irq[,wait_value]]\n"
#~ msgstr "mcd=iobase,[irq[,wait_value]]\n"

#~ msgid ""
#~ "The I<wait_value> is used as an internal timeout value for people who are "
#~ "having problems with their drive, and may or may not be implemented "
#~ "depending on a compile-time #define.  The Mitsumi FX400 is an IDE/ATAPI "
#~ "CD-ROM player and does not use the mcd driver."
#~ msgstr ""
#~ "I<wait_value> はドライブに問題がある場合に、 ドライバ内部のタイムアウトの"
#~ "指定に用いる。 コンパイル時の #define によって実装されるかされないかが決ま"
#~ "る。 Mitsumi FX400 は IDE/ATAPI CD-ROM プレイヤーであり、 この mcd ドライ"
#~ "バは使用しない。"

#~ msgid "B<The Mitsumi XA/MultiSession Interface>"
#~ msgstr "B<Mitsumi XA/マルチセッションインターフェース>"

#~ msgid ""
#~ "This is for the same hardware as above, but the driver has extended "
#~ "features.  Syntax:"
#~ msgstr ""
#~ "これは上記と同じハードウェアだが、拡張機能がある。 構文は以下の通り。"

#~ msgid "mcdx=iobase[,irq]\n"
#~ msgstr "mcdx=iobase[,irq]\n"

#~ msgid "B<The Optics Storage Interface>"
#~ msgstr "B<Optics ストレージインターフェース>"

#~ msgid "optcd=iobase\n"
#~ msgstr "optcd=iobase\n"

#~ msgid "B<The Phillips CM206 Interface>"
#~ msgstr "B<Phillips CM206 インターフェース>"

#~ msgid "cm206=[iobase][,irq]\n"
#~ msgstr "cm206=[iobase][,irq]\n"

#~ msgid ""
#~ "The driver assumes numbers between 3 and 11 are IRQ values, and numbers "
#~ "between 0x300 and 0x370 are I/O ports, so you can specify one, or both "
#~ "numbers, in any order.  It also accepts 'cm206=auto' to enable "
#~ "autoprobing."
#~ msgstr ""
#~ "ドライバは IRQ 値として 3 から 11 まで、 I/O ポートアドレスの値として "
#~ "0x300 から 0x370 を想定している。 いずれか一方、あるいは両方を指定できる。"
#~ "順番も問わない。 \\&'cm206=auto' とすることにより自動検出もできる。"

#~ msgid "B<The Sanyo Interface>"
#~ msgstr "B<Sanyo インターフェース>"

#~ msgid "sjcd=iobase[,irq[,dma_channel]]\n"
#~ msgstr "sjcd=iobase[,irq[,dma_channel]]\n"

#~ msgid "B<The SoundBlaster Pro Interface>"
#~ msgstr "B<SoundBlaster Pro インターフェース>"

#~ msgid "sbpcd=iobase,type\n"
#~ msgstr "sbpcd=iobase,type\n"

#~ msgid ""
#~ "where type is one of the following (case sensitive) strings: "
#~ "\\&'SoundBlaster', 'LaserMate', or 'SPEA'.  The I/O base is that of the "
#~ "CD-ROM interface, and not that of the sound portion of the card."
#~ msgstr ""
#~ "type 値には 'SoundBlaster', 'LaserMate', 'SPEA' のうちひとつを指定できる "
#~ "(大文字小文字が区別される)。 iobase は CD-ROM インターフェースの値であ"
#~ "る。 カードのサウンド部の値と間違えないこと。"

#~ msgid "B<floppy=mask,allowed_drive_mask>"
#~ msgstr "B<floppy=mask,allowed_drive_mask>"

#~ msgid ""
#~ "Sets the bit mask of allowed drives to mask.  By default, only units 0 "
#~ "and 1 of each floppy controller are allowed.  This is done because "
#~ "certain nonstandard hardware (ASUS PCI motherboards) mess up the keyboard "
#~ "when accessing units 2 or 3.  This option is somewhat obsoleted by the "
#~ "cmos option."
#~ msgstr ""
#~ "使ってよいドライブにかけるビットマスクを設定する。 デフォルトでは、 ユニッ"
#~ "ト 0 と 1 のフロッピーコントローラーだけが許可されている。 これは、標準で"
#~ "ないハードウェア (例えば ASUS の PCIマザーボードなど)  でユニット 2 や 3 "
#~ "にアクセスすると、 キーボードがおかしくなってしまうからである。 cmos オプ"
#~ "ション (後述) の導入によって、 このオプションはあまり使われなくなった。"

#~ msgid "B<floppy=all_drives>"
#~ msgstr "B<floppy=all_drives>"

#~ msgid ""
#~ "Sets the bit mask of allowed drives to all drives.  Use this if you have "
#~ "more than two drives connected to a floppy controller."
#~ msgstr ""
#~ "許可するドライブを示すビットマスクを、「すべてのドライブ」にする。 1 つの"
#~ "フロッピーコントローラーに 2 台以上のドライブを接続する場合に用いる。"

#~ msgid "B<floppy=asus_pci>"
#~ msgstr "B<floppy=asus_pci>"

#~ msgid "Sets the bit mask to allow only units 0 and 1.  (The default)"
#~ msgstr ""
#~ "ユニット 0 と 1 のみを許可するようビットマスクを設定する。 (デフォルト)。"

#~ msgid "B<floppy=daring>"
#~ msgstr "B<floppy=daring>"

#~ msgid ""
#~ "Tells the floppy driver that you have a well behaved floppy controller.  "
#~ "This allows more efficient and smoother operation, but may fail on "
#~ "certain controllers.  This may speed up certain operations."
#~ msgstr ""
#~ "正しく振る舞うフロッピーコントローラーを使っていることをドライバに伝え"
#~ "る。 このオプションを使うと動作はより効率的かつスムースになるが、 コント"
#~ "ローラーによっては動作に失敗することがある。 これを指定するとある種の動作"
#~ "が高速になる。"

#~ msgid "B<floppy=0,daring>"
#~ msgstr "B<floppy=0,daring>"

#~ msgid ""
#~ "Tells the floppy driver that your floppy controller should be used with "
#~ "caution."
#~ msgstr ""
#~ "注意して扱わなければならない フロッピーコントローラーであることをドライバ"
#~ "に伝える。"

#~ msgid "B<floppy=one_fdc>"
#~ msgstr "B<floppy=one_fdc>"

#~ msgid ""
#~ "Tells the floppy driver that you have only floppy controller (default)"
#~ msgstr ""
#~ "フロッピーコントローラーがひとつしかないことをドライバに伝える (デフォル"
#~ "ト)。"

#~ msgid "B<floppy=two_fdc> or B<floppy=address,two_fdc>"
#~ msgstr "B<floppy=two_fdc> または B<floppy=address,two_fdc>"

#~ msgid ""
#~ "Tells the floppy driver that you have two floppy controllers.  The second "
#~ "floppy controller is assumed to be at address.  If address is not given, "
#~ "0x370 is assumed."
#~ msgstr ""
#~ "フロッピーコントローラーがふたつあることをドライバに伝える。 2 番目のコン"
#~ "トローラーの I/O アドレスは address で指定する。 address が指定されない場"
#~ "合は 0x370 が使われる。"

#~ msgid "B<floppy=thinkpad>"
#~ msgstr "B<floppy=thinkpad>"

#~ msgid ""
#~ "Tells the floppy driver that you have a Thinkpad.  Thinkpads use an "
#~ "inverted convention for the disk change line."
#~ msgstr ""
#~ "Thinkpad を使っていることをフロッピードライバに伝える。\n"
#~ "Thinkpad はディスク取出の検出信号を反転して使っている。"

#~ msgid "B<floppy=0,thinkpad>"
#~ msgstr "B<floppy=0,thinkpad>"

#~ msgid "Tells the floppy driver that you don't have a Thinkpad."
#~ msgstr "Thinkpad を使っていないことをドライバに伝える。"

#~ msgid "B<floppy=drive,type,cmos>"
#~ msgstr "B<floppy=drive,type,cmos>"

#~ msgid ""
#~ "Sets the cmos type of drive to type.  Additionally, this drive is allowed "
#~ "in the bit mask.  This is useful if you have more than two floppy drives "
#~ "(only two can be described in the physical cmos), or if your BIOS uses "
#~ "nonstandard CMOS types.  Setting the CMOS to 0 for the first two drives "
#~ "(default) makes the floppy driver read the physical cmos for those drives."
#~ msgstr ""
#~ "ドライブの cmos タイプを type に設定する。 さらにビットマスクを変更し、こ"
#~ "のドライブの使用を許可する。 この指定が便利なのは、フロッピードライブが 2 "
#~ "台以上ある場合 (物理 cmos に記述できるのは 2 台まで) や、 BIOS が標準的で"
#~ "ない CMOS タイプを使っている場合である。 最初の 2 台のドライブの CMOS に "
#~ "0 を指定する (デフォルト) と、 フロッピードライバはこれらのドライブの物理 "
#~ "cmos を参照する。"

#~ msgid "B<floppy=unexpected_interrupts>"
#~ msgstr "B<floppy=unexpected_interrupts>"

#~ msgid ""
#~ "Print a warning message when an unexpected interrupt is received (default "
#~ "behavior)"
#~ msgstr ""
#~ "予期しない割り込みを受けた時に警告メッセージを表示する (デフォルト)。"

#~ msgid "B<floppy=no_unexpected_interrupts> or B<floppy=L40SX>"
#~ msgstr "B<floppy=no_unexpected_interrupts> または B<floppy=L40SX>"

#~ msgid ""
#~ "Don't print a message when an unexpected interrupt is received.  This is "
#~ "needed on IBM L40SX laptops in certain video modes.  (There seems to be "
#~ "an interaction between video and floppy.  The unexpected interrupts only "
#~ "affect performance, and can safely be ignored.)"
#~ msgstr ""
#~ "予期しない割り込みを受けた時でも警告メッセージを表示しない。 これは IBM "
#~ "L40SX ラップトップコンピュータを 特定のビデオモードで使用する時に必要とな"
#~ "る。 (ビデオとフロッピーとの間で何らかの相互作用があるようだ。 予期しない"
#~ "割り込みは性能だけに影響し、無視しても安全である。)"

#~ msgid "ISDN drivers"
#~ msgstr "ISDN ドライバ"

#~ msgid "B<The ICN ISDN driver>"
#~ msgstr "B<ICN ISDN ドライバ>"

#~ msgid "icn=iobase,membase,icn_id1,icn_id2\n"
#~ msgstr "icn=iobase,membase,icn_id1,icn_id2\n"

#~ msgid ""
#~ "where icn_id1,icn_id2 are two strings used to identify the card in kernel "
#~ "messages."
#~ msgstr ""
#~ "icn_id1,icn_id2 はカードを識別するための 2 つの文字列である。 カーネルメッ"
#~ "セージで用いられる。"

#~ msgid "B<The PCBIT ISDN driver>"
#~ msgstr "B<PCBIT ISDN ドライバ>"

#~ msgid "pcbit=membase1,irq1[,membase2,irq2]\n"
#~ msgstr "pcbit=membase1,irq1[,membase2,irq2]\n"

#~ msgid ""
#~ "where membaseN is the shared memory base of the N'th card, and irqN is "
#~ "the interrupt setting of the N'th card.  The default is IRQ 5 and membase "
#~ "0xD0000."
#~ msgstr ""
#~ "membaseN は N 番目のカードの共有メモリーのベースアドレスであり、 irqN は "
#~ "N 番目のカードの割り込み設定である。 無指定時には IRQ = 5, membase = "
#~ "0xD0000 となる。"

#~ msgid "B<The Teles ISDN driver>"
#~ msgstr "B<Teles ISDN ドライバ>"

#~ msgid "teles=iobase,irq,membase,protocol,teles_id\n"
#~ msgstr "teles=iobase,irq,membase,protocol,teles_id\n"

#~ msgid ""
#~ "where iobase is the I/O port address of the card, membase is the shared "
#~ "memory base address of the card, irq is the interrupt channel the card "
#~ "uses, and teles_id is the unique ASCII string identifier."
#~ msgstr ""
#~ "iobase はカードの I/O ポートアドレス、 membase はカードの共有メモリーの"
#~ "ベースアドレス、 そして irq はカードが使用する割り込みチャネルである。 "
#~ "teles_id はアスキー文字列による識別文字列である (他と重ならないようにす"
#~ "る)。"

#~ msgid "Serial port drivers"
#~ msgstr "シリアルポートドライバ"

#~ msgid "B<The RISCom/8 Multiport Serial Driver ('riscom8=')>"
#~ msgstr "B<RISCom/8 マルチポートシリアルドライバ ('riscom8=')>"

#~ msgid ""
#~ "More details can be found in the kernel source file I<Documentation/"
#~ "riscom8.txt>."
#~ msgstr ""
#~ "詳細はカーネルソースファイル I<Documentation/riscom8.txt> を参照のこと。"

#~ msgid "B<The DigiBoard Driver ('digi=')>"
#~ msgstr "B<DigiBoard ドライバ ('digi=')>"

#~ msgid ""
#~ "If this option is used, it should have precisely six parameters.  Syntax:"
#~ msgstr ""
#~ "このオプションを使う場合は、6 個のパラメーターをきっちり指定しなければなら"
#~ "ない。\n"
#~ "構文は以下の通り。"

#~ msgid ""
#~ "The parameters maybe given as integers, or as strings.  If strings are "
#~ "used, then iobase and membase should be given in hexadecimal.  The "
#~ "integer arguments (fewer may be given) are in order: status (Enable(1) or "
#~ "Disable(0) this card), type (PC/Xi(0), PC/Xe(1), PC/Xeve(2), PC/Xem(3)), "
#~ "altpin (Enable(1) or Disable(0) alternate pin arrangement), numports "
#~ "(number of ports on this card), iobase (I/O Port where card is configured "
#~ "(in HEX)), membase (base of memory window (in HEX)).  Thus, the following "
#~ "two boot prompt arguments are equivalent:"
#~ msgstr ""
#~ "パラメーターは整数値か文字列で与える。 文字列で指定する場合は、 iobase と "
#~ "membase は 16 進値でなければならない。 整数値で指定する場合はパラメーター"
#~ "の個数は少なくても良く、順に: status このカードの動作を指定する "
#~ "(Enable(1) または Disable(0)), type カードのタイプ (PC/Xi(0), PC/Xe(1), "
#~ "PC/Xeve(2), PC/Xem(3)), altpin ピン配置を反転させる (Enable(1) or "
#~ "Disable(0)), numports カードのポート番号, iobase このカードの I/O ポート "
#~ "(文字列指定の場合は 16 進表記), membase メモリーウィンドウのベースアドレ"
#~ "ス (文字列指定の場合は 16 進表記)。 したがって以下のふたつの起動時引数は同"
#~ "じ意味を持つ。"

#~ msgid ""
#~ "More details can be found in the kernel source file I<Documentation/"
#~ "digiboard.txt>."
#~ msgstr ""
#~ "詳細はカーネルソースファイル I<Documentation/digiboard.txt> を参照。"

#~ msgid "B<The Baycom Serial/Parallel Radio Modem>"
#~ msgstr "B<Baycom シリアル・パラレル ラジオモデム>"

#~ msgid ""
#~ "There are precisely 3 parameters; for several cards, give several "
#~ "'baycom=' commands.  The modem parameter is a string that can take one of "
#~ "the values ser12, ser12*, par96, par96*.  Here the * denotes that "
#~ "software DCD is to be used, and ser12/par96 chooses between the supported "
#~ "modem types.  For more details, see the file I<Documentation/networking/"
#~ "baycom.txt> (or I<drivers/net/README.baycom> for older kernels) in the "
#~ "Linux kernel source."
#~ msgstr ""
#~ "ちょうど 3 つのパラメーターを与える。 複数のカードがある場合は、'baycom=' "
#~ "コマンドも複数記述する。 modem パラメーターは文字列で、 ser12, ser12*, "
#~ "par96, par96* の中からひとつを選ぶ。 * をつけるとソフトウェア DCD を使用す"
#~ "る。 モデムの種類に応じて ser12 か par96 かを選択する。 詳細は Linux カー"
#~ "ネルソース内の I<Documentation/networking/baycom.txt> (古いカーネルの場合"
#~ "は I<drivers/net/README.baycom>)  を参照。"

#~ msgid "B<Soundcard radio modem driver>"
#~ msgstr "B<サウンドカードラジオモデムドライバ>"

#~ msgid ""
#~ "All parameters except the last are integers; the dummy 0 is required "
#~ "because of a bug in the setup code.  The mode parameter is a string with "
#~ "syntax hw:modem, where hw is one of sbc, wss, or wssfdx, and modem is one "
#~ "of afsk1200 or fsk9600."
#~ msgstr ""
#~ "最後のパラメーターを除くすべてのパラメーターは整数である。 ダミーの 0 があ"
#~ "るのは、設定プログラムのバグのせいである。 mode パラメーターは文字列で、"
#~ "hw:modem という書式で指定する。 hw は sbc, wss, wssfdx のうちひとつ、 "
#~ "modem は afsk1200, fsk9600 のどちらかを選択して記述する。"

#~ msgid "Mouse drivers"
#~ msgstr "マウスドライバ"

#~ msgid ""
#~ "The busmouse driver accepts only one parameter, that being the hardware "
#~ "IRQ value to be used."
#~ msgstr ""
#~ "バスマウスドライバはパラメーターをひとつだけとり、 ハードウェア IRQ を指定"
#~ "できる。"

#~ msgid "And precisely the same is true for the msmouse driver."
#~ msgstr "msmouse ドライバでもこの事情はまったく同じである。"

#~ msgid "B<ATARI mouse setup>"
#~ msgstr "B<ATARI マウスの設定>"

#~ msgid ""
#~ "If only one argument is given, it is used for both x-threshold and y-"
#~ "threshold.  Otherwise, the first argument is the x-threshold, and the "
#~ "second the y-threshold.  These values must lie between 1 and 20 "
#~ "(inclusive); the default is 2."
#~ msgstr ""
#~ "パラメーターがひとつだけ与えられた場合には、 x-threshold と y-threshold を"
#~ "両方に用いられる。 ふたつ与えられた場合は、最初の値が x-threshold として用"
#~ "いられ、 2 番目の値が y-threshold として用いられる。 値は 1 から 20 までの"
#~ "数値で指定する。 デフォルトは 2。"

#~ msgid ""
#~ "This option tells the console driver not to use hardware scroll (where a "
#~ "scroll is effected by moving the screen origin in video memory, instead "
#~ "of moving the data).  It is required by certain Braille machines."
#~ msgstr ""
#~ "このオプションは、コンソールドライバに、 ハードウェアスクロールを用いない"
#~ "よう伝える (ここで言うハードウェアスクロールとは、 ビデオメモリー上のデー"
#~ "タを移動させることによって スクリーン表示領域をスクロールさせることを指"
#~ "す)。 特定の点字マシンではこの指定が必要となる。"

#~ msgid ""
#~ "Large parts of this man page have been derived from the Boot Parameter "
#~ "HOWTO (version 1.0.1) written by Paul Gortmaker.  More information may be "
#~ "found in this (or a more recent) HOWTO.  An up-to-date source of "
#~ "information is the kernel source file I<Documentation/kernel-parameters."
#~ "txt>."
#~ msgstr ""
#~ "このマニュアルページの大部分は Paul Gortmaker による Boot Parameter HOWTO "
#~ "(version 1.0.1) を基にしている。 この (あるいは最新の) HOWTO をあたれば、 "
#~ "さらに多くの情報が入手できるだろう。 最新の情報源はカーネルソースファイル "
#~ "I<Documentation/kernel-parameters.txt> である。"

#~ msgid ""
#~ "Since Linux 3.4, when B<reboot>()  is called from a PID namespace (see "
#~ "B<pid_namespaces>(7))  other than the initial PID namespace, the effect "
#~ "of the call is to send a signal to the namespace \"init\" process.  "
#~ "B<LINUX_REBOOT_CMD_RESTART> and B<LINUX_REBOOT_CMD_RESTART2> cause a "
#~ "B<SIGHUP> signal to be sent.  B<LINUX_REBOOT_CMD_POWER_OFF> and "
#~ "B<LINUX_REBOOT_CMD_HALT> cause a B<SIGINT> signal to be sent."
#~ msgstr ""
#~ "Linux 3.4 以降では、 B<reboot>() が最初の PID 名前空間以外の PID 名前空間 "
#~ "(B<pid_namespaces>(7) 参照) から呼び出された場合、 呼び出しの効果として、 "
#~ "名前空間の \"init\" プロセスへシグナルが送信される。 "
#~ "B<LINUX_REBOOT_CMD_RESTART> とB<LINUX_REBOOT_CMD_RESTART2> の場合、 "
#~ "B<SIGHUP> シグナルが送信される。 B<LINUX_REBOOT_CMD_POWER_OFF> と "
#~ "B<LINUX_REBOOT_CMD_HALT> の場合、 B<SIGINT> シグナルが送信される。"
