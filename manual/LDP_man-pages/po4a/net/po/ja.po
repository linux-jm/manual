# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-09-28 04:05+0900\n"
"PO-Revision-Date: 2013-09-28 04:27+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/arp.7:13
#, no-wrap
msgid "ARP"
msgstr "ARP"

#. type: TH
#: build/C/man7/arp.7:13
#, no-wrap
msgid "2008-11-25"
msgstr "2008-11-25"

#. type: TH
#: build/C/man7/arp.7:13 build/C/man3/cmsg.3:11 build/C/man7/ddp.7:12
#: build/C/man5/gai.conf.5:19 build/C/man1/getent.1:24
#: build/C/man3/getipnodebyname.3:26 build/C/man2/getpeername.2:42
#: build/C/man5/host.conf.5:26 build/C/man7/hostname.7:39
#: build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6 build/C/man7/icmp.7:12
#: build/C/man3/inet_ntop.3:26 build/C/man3/inet_pton.3:27
#: build/C/man7/ip.7:36 build/C/man7/ipv6.7:86 build/C/man7/netdevice.7:18
#: build/C/man5/nss.5:19 build/C/man5/nsswitch.conf.5:25
#: build/C/man7/packet.7:12 build/C/man5/protocols.5:29 build/C/man7/raw.7:13
#: build/C/man3/rcmd.3:43 build/C/man3/rexec.3:41 build/C/man5/services.5:34
#: build/C/man2/shutdown.2:40 build/C/man7/tcp.7:65 build/C/man7/udp.7:12
#: build/C/man7/udplite.7:27 build/C/man7/unix.7:18 build/C/man7/x25.7:12
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/arp.7:13 build/C/man3/byteorder.3:32 build/C/man3/cmsg.3:11
#: build/C/man7/ddp.7:12 build/C/man3/endian.3:28 build/C/man3/ether_aton.3:31
#: build/C/man5/gai.conf.5:19 build/C/man3/getaddrinfo.3:43
#: build/C/man3/getaddrinfo_a.3:29 build/C/man3/gethostbyname.3:38
#: build/C/man3/getipnodebyname.3:26 build/C/man3/getnameinfo.3:10
#: build/C/man3/getnetent.3:30 build/C/man3/getnetent_r.3:26
#: build/C/man2/getpeername.2:42 build/C/man3/getprotoent.3:30
#: build/C/man3/getprotoent_r.3:26 build/C/man3/getservent.3:34
#: build/C/man3/getservent_r.3:26 build/C/man7/hostname.7:39
#: build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6 build/C/man7/icmp.7:12
#: build/C/man3/inet.3:42 build/C/man3/inet_ntop.3:26
#: build/C/man3/inet_pton.3:27 build/C/man7/ip.7:36 build/C/man7/ipv6.7:86
#: build/C/man7/netdevice.7:18 build/C/man8/nscd.8:23
#: build/C/man5/nscd.conf.5:20 build/C/man5/nss.5:19
#: build/C/man5/nsswitch.conf.5:25 build/C/man7/packet.7:12
#: build/C/man5/protocols.5:29 build/C/man7/raw.7:13 build/C/man3/rcmd.3:43
#: build/C/man5/resolv.conf.5:23 build/C/man3/resolver.3:32
#: build/C/man3/rexec.3:41 build/C/man5/services.5:34
#: build/C/man3/setnetgrent.3:10 build/C/man2/shutdown.2:40
#: build/C/man7/tcp.7:65 build/C/man7/udp.7:12 build/C/man7/udplite.7:27
#: build/C/man7/unix.7:18 build/C/man7/x25.7:12
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/arp.7:14 build/C/man3/byteorder.3:33 build/C/man3/cmsg.3:12
#: build/C/man7/ddp.7:13 build/C/man3/endian.3:29 build/C/man3/ether_aton.3:32
#: build/C/man5/gai.conf.5:20 build/C/man3/getaddrinfo.3:44
#: build/C/man3/getaddrinfo_a.3:30 build/C/man1/getent.1:25
#: build/C/man3/gethostbyname.3:39 build/C/man3/getipnodebyname.3:27
#: build/C/man3/getnameinfo.3:11 build/C/man3/getnetent.3:31
#: build/C/man3/getnetent_r.3:27 build/C/man2/getpeername.2:43
#: build/C/man3/getprotoent.3:31 build/C/man3/getprotoent_r.3:27
#: build/C/man3/getservent.3:35 build/C/man3/getservent_r.3:27
#: build/C/man5/host.conf.5:27 build/C/man7/hostname.7:40
#: build/C/man5/hosts.5:28 build/C/man5/hosts.equiv.5:7 build/C/man7/icmp.7:13
#: build/C/man3/inet.3:43 build/C/man3/inet_ntop.3:27
#: build/C/man3/inet_pton.3:28 build/C/man7/ip.7:37 build/C/man7/ipv6.7:87
#: build/C/man7/netdevice.7:19 build/C/man5/networks.5:27
#: build/C/man8/nscd.8:24 build/C/man5/nscd.conf.5:21 build/C/man5/nss.5:20
#: build/C/man5/nsswitch.conf.5:26 build/C/man7/packet.7:13
#: build/C/man5/protocols.5:30 build/C/man7/raw.7:14 build/C/man3/rcmd.3:44
#: build/C/man5/resolv.conf.5:25 build/C/man3/resolver.3:33
#: build/C/man3/rexec.3:42 build/C/man5/services.5:35
#: build/C/man3/setnetgrent.3:11 build/C/man2/shutdown.2:41
#: build/C/man7/tcp.7:66 build/C/man7/udp.7:13 build/C/man7/udplite.7:28
#: build/C/man7/unix.7:19 build/C/man7/x25.7:13
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/arp.7:16
msgid "arp - Linux ARP kernel module."
msgstr "arp - Linux ARP カーネルモジュール"

#. type: SH
#: build/C/man7/arp.7:16 build/C/man3/byteorder.3:48 build/C/man3/cmsg.3:37
#: build/C/man7/ddp.7:23 build/C/man3/endian.3:53 build/C/man3/ether_aton.3:57
#: build/C/man5/gai.conf.5:22 build/C/man3/getaddrinfo.3:75
#: build/C/man3/getaddrinfo_a.3:50 build/C/man1/getent.1:30
#: build/C/man3/gethostbyname.3:132 build/C/man3/getipnodebyname.3:44
#: build/C/man3/getnameinfo.3:32 build/C/man3/getnetent.3:48
#: build/C/man3/getnetent_r.3:62 build/C/man2/getpeername.2:50
#: build/C/man3/getprotoent.3:48 build/C/man3/getprotoent_r.3:59
#: build/C/man3/getservent.3:52 build/C/man3/getservent_r.3:59
#: build/C/man5/host.conf.5:29 build/C/man7/hostname.7:42
#: build/C/man5/hosts.5:32 build/C/man5/hosts.equiv.5:11
#: build/C/man7/icmp.7:15 build/C/man3/inet.3:75 build/C/man3/inet_ntop.3:36
#: build/C/man3/inet_pton.3:36 build/C/man7/ip.7:53 build/C/man7/ipv6.7:99
#: build/C/man7/netdevice.7:25 build/C/man5/networks.5:29
#: build/C/man8/nscd.8:26 build/C/man5/nscd.conf.5:23 build/C/man5/nss.5:22
#: build/C/man5/nsswitch.conf.5:28 build/C/man7/packet.7:25
#: build/C/man5/protocols.5:32 build/C/man7/raw.7:22 build/C/man3/rcmd.3:92
#: build/C/man5/resolv.conf.5:29 build/C/man3/resolver.3:85
#: build/C/man3/rexec.3:56 build/C/man5/services.5:37
#: build/C/man3/setnetgrent.3:44 build/C/man2/shutdown.2:47
#: build/C/man7/tcp.7:76 build/C/man7/udp.7:23 build/C/man7/udplite.7:38
#: build/C/man7/unix.7:29 build/C/man7/x25.7:21
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/arp.7:24
msgid ""
"This kernel protocol module implements the Address Resolution Protocol "
"defined in RFC\\ 826.  It is used to convert between Layer2 hardware "
"addresses and IPv4 protocol addresses on directly connected networks.  The "
"user normally doesn't interact directly with this module except to configure "
"it; instead it provides a service for other protocols in the kernel."
msgstr ""
"このカーネルプロトコルモジュールは、 RFC\\ 826 で定義されている Address "
"Resolution Protocol を 実装したものである。 ARP は、ダイレクトに接続された"
"ネットワーク上で、 第 2 層のハードウェアアドレスをIPv4 プロトコルアドレスに "
"変換するために用いられる。ユーザーは設定の場合を除いて 通常直接このモジュール"
"に関ることはない。 これはカーネル内部の他のプロトコルにサービスを提供するもの"
"である。"

#. type: Plain text
#: build/C/man7/arp.7:37
msgid ""
"A user process can receive ARP packets by using B<packet>(7)  sockets.  "
"There is also a mechanism for managing the ARP cache in user-space by using "
"B<netlink>(7)  sockets.  The ARP table can also be controlled via B<ioctl>"
"(2)  on any B<AF_INET> socket."
msgstr ""
"ユーザープロセスは、 B<packet>(7)  ソケットを用いれば ARP パケットを受信する"
"ことができる。 ARP キャッシュをユーザー空間で管理することもできる。 これには "
"B<netlink>(7)  を用いる。 ARP テーブルも制御可能で、これには任意の "
"B<AF_INET> ソケットに B<ioctl>(2)  を用いる。"

#. type: Plain text
#: build/C/man7/arp.7:49
msgid ""
"The ARP module maintains a cache of mappings between hardware addresses and "
"protocol addresses.  The cache has a limited size so old and less frequently "
"used entries are garbage-collected.  Entries which are marked as permanent "
"are never deleted by the garbage-collector.  The cache can be directly "
"manipulated by the use of ioctls and its behavior can be tuned by the I</"
"proc> interfaces described below."
msgstr ""
"ARP モジュールはハードウェアアドレスからプロトコルアドレスへの マッピングの"
"キャッシュを管理する。キャッシュの大きさには制限が あるので、古いエントリや利"
"用されないエントリはガベージコレクト される。 permanent (保存) マークがつけら"
"れたエントリは、 決してガベージコレクタによって消去されない。 ioctl を用いれ"
"ばキャッシュを直接操作することもできる。 また後述の I</proc> インタフェースに"
"よりキャッシュの振る舞いを調整できる。"

#. type: Plain text
#: build/C/man7/arp.7:72
msgid ""
"When there is no positive feedback for an existing mapping after some time "
"(see the I</proc> interfaces below), a neighbor cache entry is considered "
"stale.  Positive feedback can be gotten from a higher layer; for example "
"from a successful TCP ACK.  Other protocols can signal forward progress "
"using the B<MSG_CONFIRM> flag to B<sendmsg>(2).  When there is no forward "
"progress, ARP tries to reprobe.  It first tries to ask a local arp daemon "
"B<app_solicit> times for an updated MAC address.  If that fails and an old "
"MAC address is known, a unicast probe is sent B<ucast_solicit> times.  If "
"that fails too, it will broadcast a new ARP request to the network.  "
"Requests are sent only when there is data queued for sending."
msgstr ""
"存在しているマッピングに対して、 正のフィードバックが一定時間ない (後述の I</"
"proc> インタフェースを見よ) と、 近傍キャッシュエントリ (neighbor cache "
"entry) は 古くなった (stale) とみなされる。 正のフィードバックは高位のレイ"
"ヤーからも取得できる (例えば TCP ACK が成功した場合など)。 他のプロトコル"
"は、 B<sendmsg>(2)  に B<MSG_CONFIRM> フラグを用いることによって、 フォワード"
"プログレス (forward progress) をシグナルできる。 フォワードプログレスがなけれ"
"ば、 ARP は再びプローブを試みる。 まずローカルな arp デーモンに問合わせを行"
"い、 更新された MAC アドレスを取得しようとする。 このリクエストに "
"B<app_solicit> 回失敗すると、古い MAC アドレスがわかっている場合は、 unicast "
"のプローブが B<ucaset_solicit> 回送られる。これにも失敗すると、新しい ARP リ"
"クエスト をネットワークにブロードキャストする。 リクエストは、データが送信"
"キューにある場合のみ送られる。"

#. type: Plain text
#: build/C/man7/arp.7:77
msgid ""
"Linux will automatically add a nonpermanent proxy arp entry when it receives "
"a request for an address it forwards to and proxy arp is enabled on the "
"receiving interface.  When there is a reject route for the target, no proxy "
"arp entry is added."
msgstr ""
"Linux は、あるアドレスへのリクエストを受信・フォワードし、 受信したインター"
"フェースで代理 arp が有効になっている場合には、 自動的にそのアドレスを "
"nonpermanent な代理 arp エントリに追加する。 そのターゲットに reject route が"
"あった場合には、 代理 arp エントリは一切追加されない。"

#. type: SS
#: build/C/man7/arp.7:77 build/C/man7/ddp.7:144 build/C/man7/ip.7:1047
#: build/C/man7/netdevice.7:72 build/C/man7/packet.7:230
#: build/C/man7/tcp.7:1032 build/C/man7/udp.7:202 build/C/man7/unix.7:284
#, no-wrap
msgid "Ioctls"
msgstr "ioctl"

#. type: Plain text
#: build/C/man7/arp.7:84
msgid ""
"Three ioctls are available on all B<AF_INET> sockets.  They take a pointer "
"to a I<struct arpreq> as their argument."
msgstr ""
"すべての B<AF_INET> ソケットでは、 3 つの ioctl が使用できる。 これらは "
"I<struct arpreq> へのポインタを引数に取る。"

#. type: Plain text
#: build/C/man7/arp.7:94
#, no-wrap
msgid ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"
msgstr ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"

#. type: Plain text
#: build/C/man7/arp.7:103
msgid ""
"B<SIOCSARP>, B<SIOCDARP> and B<SIOCGARP> respectively set, delete and get an "
"ARP mapping.  Setting and deleting ARP maps are privileged operations and "
"may be performed only by a process with the B<CAP_NET_ADMIN> capability or "
"an effective UID of 0."
msgstr ""
"B<SIOCSARP>, B<SIOCDARP>, B<SIOCGARP> は、それぞれ ARP マッピングを設定・削"
"除・取得する。 ARP マップの設定と削除は特権が必要な操作であり、 "
"B<CAP_NET_ADMIN> 権限を持つプロセスか、実行ユーザー ID が 0 のプロセス でなけ"
"れば実行できない。"

#. type: Plain text
#: build/C/man7/arp.7:113
msgid ""
"I<arp_pa> must be an B<AF_INET> address and I<arp_ha> must have the same "
"type as the device which is specified in I<arp_dev>.  I<arp_dev> is a zero-"
"terminated string which names a device."
msgstr ""
"I<arp_pa> は B<AF_INET> アドレスでなければならず、 I<arp_ha> は I<arp_dev> で"
"設定されたデバイスと同じタイプでなければならない。 I<arp_dev> はデバイスの名"
"前を示す、ゼロで終端された文字列である。"

#. type: tbl table
#: build/C/man7/arp.7:118
#, no-wrap
msgid "I<arp_flags>\n"
msgstr "I<arp_flags>\n"

#. type: tbl table
#: build/C/man7/arp.7:119
#, no-wrap
msgid "flag:meaning\n"
msgstr "フラグ:意味\n"

#. type: tbl table
#: build/C/man7/arp.7:120
#, no-wrap
msgid "ATF_COM:Lookup complete\n"
msgstr "ATF_COM:参照完了\n"

#. type: tbl table
#: build/C/man7/arp.7:121
#, no-wrap
msgid "ATF_PERM:Permanent entry\n"
msgstr "ATF_PERM:エントリを peramanent にする\n"

#. type: tbl table
#: build/C/man7/arp.7:122
#, no-wrap
msgid "ATF_PUBL:Publish entry\n"
msgstr "ATF_PUBL:エントリを publish する\n"

#. type: tbl table
#: build/C/man7/arp.7:123
#, no-wrap
msgid "ATF_USETRAILERS:Trailers requested\n"
msgstr "ATF_USETRAILERS:trailer が必要\n"

#. type: tbl table
#: build/C/man7/arp.7:124
#, no-wrap
msgid "ATF_NETMASK:Use a netmask\n"
msgstr "ATF_NETMASK:netmask を用いる\n"

#. type: tbl table
#: build/C/man7/arp.7:125
#, no-wrap
msgid "ATF_DONTPUB:Don't answer\n"
msgstr "ATF_DONTPUB:回答しない\n"

#. type: Plain text
#: build/C/man7/arp.7:138
msgid ""
"If the B<ATF_NETMASK> flag is set, then I<arp_netmask> should be valid.  "
"Linux 2.2 does not support proxy network ARP entries, so this should be set "
"to 0xffffffff, or 0 to remove an existing proxy arp entry.  "
"B<ATF_USETRAILERS> is obsolete and should not be used."
msgstr ""
"B<ATF_NETMASK> フラグがセットされているときには、 I<arp_netmask> が有効でなけ"
"ればならない。 Linux 2.2 は代理ネットワーク ARP エントリをサポートしていない"
"ので、 これは 0xffffffff にセットしておくか、あるいは 現存の代理 arp エントリ"
"を削除したい場合には 0 にしておく必要がある。 B<ATF_USETRAILERS> は obsolete "
"なので、用いるべきでない。"

#. type: SS
#: build/C/man7/arp.7:138 build/C/man7/ddp.7:122 build/C/man7/icmp.7:41
#: build/C/man7/ip.7:923 build/C/man7/tcp.7:208 build/C/man7/udp.7:137
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インタフェース"

#. type: Plain text
#: build/C/man7/arp.7:151
msgid ""
"ARP supports a range of I</proc> interfaces to configure parameters on a "
"global or per-interface basis.  The interfaces can be accessed by reading or "
"writing the I</proc/sys/net/ipv4/neigh/*/*> files.  Each interface in the "
"system has its own directory in I</proc/sys/net/ipv4/neigh/>.  The setting "
"in the \"default\" directory is used for all newly created devices.  Unless "
"otherwise specified, time-related interfaces are specified in seconds."
msgstr ""
"ARP では、グローバルなパラメータやインターフェースごとのパラメータを I</"
"proc> インタフェースを通して設定することができる。 これらのインタフェースに"
"は、 I<proc/sys/net/ipv4/neigh/*/*> ファイルの読み書きによりアクセスできる。 "
"システムにあるそれぞれのインターフェースには、 それぞれ対応するディレクトリ"
"が I</proc/sys/net/ipv4/neigh/> 以下にある。 \"default\" ディレクトリに対して"
"設定をすると、 それ以降生成されるデバイス全てに対してその設定が用いられる。 "
"特に指定がなければ、時間に関る sysctl の単位は秒である。"

#. type: TP
#: build/C/man7/arp.7:151
#, no-wrap
msgid "I<anycast_delay> (since Linux 2.2)"
msgstr "I<anycast_delay> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:158
msgid ""
"The maximum number of jiffies to delay before replying to a IPv6 neighbor "
"solicitation message.  Anycast support is not yet implemented.  Defaults to "
"1 second."
msgstr ""
"IPv6 の近傍要請メッセージ (neighbor soliciation message)  に応答するまでの最"
"大遅延時間 (jiffy 単位)。 anycast のサポートはまだ実装されていない。 デフォル"
"トは 1 秒。"

#. type: TP
#: build/C/man7/arp.7:158
#, no-wrap
msgid "I<app_solicit> (since Linux 2.2)"
msgstr "I<app_solicit> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:165
msgid ""
"The maximum number of probes to send to the user space ARP daemon via "
"netlink before dropping back to multicast probes (see I<mcast_solicit>).  "
"Defaults to 0."
msgstr ""
"ユーザー空間の ARP デーモンに netlink を用いて探索させる最大回数。 これを越え"
"るとマルチキャストによる探索に移行する (I<mcast_solicit> を見よ)。"

#. type: TP
#: build/C/man7/arp.7:165
#, no-wrap
msgid "I<base_reachable_time> (since Linux 2.2)"
msgstr "I<base_reachable_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:176
msgid ""
"Once a neighbor has been found, the entry is considered to be valid for at "
"least a random value between I<base_reachable_time>/2 and "
"3*I<base_reachable_time>/2.  An entry's validity will be extended if it "
"receives positive feedback from higher level protocols.  Defaults to 30 "
"seconds.  This file is now obsolete in favor of I<base_reachable_time_ms>."
msgstr ""
"近傍のホストがみつかると、そのエントリは I<base_reachable_time>/2 から "
"3*I<base_reachable_time>/2 の間のランダムな値の時間、有効であるとみなされ"
"る。 エントリの有効性は、高位のプロトコルからポジティブなフィードバックを 受"
"け取ると延長される。デフォルトは 30 秒。 このファイルは現在は非推奨であり、代"
"わりに I<base_reachable_time_ms> を使うこと。"

#. type: TP
#: build/C/man7/arp.7:176
#, no-wrap
msgid "I<base_reachable_time_ms> (since Linux 2.6.12)"
msgstr "I<base_reachable_time_ms> (Linux 2.6.12 以降)"

#. type: Plain text
#: build/C/man7/arp.7:182
msgid ""
"As for I<base_reachable_time>, but measures time in milliseconds.  Defaults "
"to 30000 milliseconds."
msgstr ""
"I<base_reachable_time> と同じだが、時間をミリ秒単位で測る。 デフォルトは "
"30000 ミリ秒である。"

#. type: TP
#: build/C/man7/arp.7:182
#, no-wrap
msgid "I<delay_first_probe_time> (since Linux 2.2)"
msgstr "I<delay_first_probe_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:188
msgid ""
"Delay before first probe after it has been decided that a neighbor is "
"stale.  Defaults to 5 seconds."
msgstr ""
"近傍ホストのエントリが古くなったと判断された後に 最初に探索を行うまでの遅延時"
"間。デフォルトは 5 秒。"

#. type: TP
#: build/C/man7/arp.7:188
#, no-wrap
msgid "I<gc_interval> (since Linux 2.2)"
msgstr "I<gc_interval> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:194
msgid ""
"How frequently the garbage collector for neighbor entries should attempt to "
"run.  Defaults to 30 seconds."
msgstr ""
"ガベージ・コレクタを近傍ホストエントリに対して実行させる頻度。 デフォルトは "
"30 秒。"

#. type: TP
#: build/C/man7/arp.7:194
#, no-wrap
msgid "I<gc_stale_time> (since Linux 2.2)"
msgstr "I<gc_stale_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:201
msgid ""
"Determines how often to check for stale neighbor entries.  When a neighbor "
"entry is considered stale, it is resolved again before sending data to it.  "
"Defaults to 60 seconds."
msgstr ""
"古くなった近傍ホストエントリに対してチェックを行う頻度。 近傍ホストエントリが"
"古くなったとみなされると、そのエントリに データを送る前には再度解決が行われ"
"る。 デフォルトは 60 秒。"

#. type: TP
#: build/C/man7/arp.7:201
#, no-wrap
msgid "I<gc_thresh1> (since Linux 2.2)"
msgstr "I<gc_thresh1> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:208
msgid ""
"The minimum number of entries to keep in the ARP cache.  The garbage "
"collector will not run if there are fewer than this number of entries in the "
"cache.  Defaults to 128."
msgstr ""
"ARP キャッシュに保存するエントリ数の最小値。 この数より少ないエントリしか"
"キャッシュになければ、 ガベージ・コレクタは実行されない。 デフォルトは 128。"

#. type: TP
#: build/C/man7/arp.7:208
#, no-wrap
msgid "I<gc_thresh2> (since Linux 2.2)"
msgstr "I<gc_thresh2> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:215
msgid ""
"The soft maximum number of entries to keep in the ARP cache.  The garbage "
"collector will allow the number of entries to exceed this for 5 seconds "
"before collection will be performed.  Defaults to 512."
msgstr ""
"ARP キャッシュに保存されるエントリ数のソフトな最大値。 キャッシュのエントリが"
"この数を 5 秒間越えつづけると、 ガベージ・コレクタが実行される。 デフォルト"
"は 512。"

#. type: TP
#: build/C/man7/arp.7:215
#, no-wrap
msgid "I<gc_thresh3> (since Linux 2.2)"
msgstr "I<gc_thresh3> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:222
msgid ""
"The hard maximum number of entries to keep in the ARP cache.  The garbage "
"collector will always run if there are more than this number of entries in "
"the cache.  Defaults to 1024."
msgstr ""
"ARP キャッシュに保存されるエントリ数のハードな最大値。 キャッシュのエントリが"
"この数を越えると、 ガベージ・コレクタはただちに実行される。 デフォルトは "
"1024。"

#. type: TP
#: build/C/man7/arp.7:222
#, no-wrap
msgid "I<locktime> (since Linux 2.2)"
msgstr "I<locktime> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:229
msgid ""
"The minimum number of jiffies to keep an ARP entry in the cache.  This "
"prevents ARP cache thrashing if there is more than one potential mapping "
"(generally due to network misconfiguration).  Defaults to 1 second."
msgstr ""
"ARP エントリをキャッシュに保存する時間の最小値 (jiffy 単位)。 可能性のある"
"マッピングが一つ以上ある (たいていはネットワーク設定のミス)  場合に、 ARP "
"キャッシュのスラッシングが起きることを防ぐ。 デフォルトは 1 秒。"

#. type: TP
#: build/C/man7/arp.7:229
#, no-wrap
msgid "I<mcast_solicit> (since Linux 2.2)"
msgstr "I<mcast_solicit> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:235
msgid ""
"The maximum number of attempts to resolve an address by multicast/broadcast "
"before marking the entry as unreachable.  Defaults to 3."
msgstr ""
"エントリを unreachable マークする前に、 アドレスをマルチキャスト/ブロードキャ"
"ストで解決しようとする 試行回数の最大値。 デフォルトは 3。"

#. type: TP
#: build/C/man7/arp.7:235
#, no-wrap
msgid "I<proxy_delay> (since Linux 2.2)"
msgstr "I<proxy_delay> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:243
msgid ""
"When an ARP request for a known proxy-ARP address is received, delay up to "
"I<proxy_delay> jiffies before replying.  This is used to prevent network "
"flooding in some cases.  Defaults to 0.8 seconds."
msgstr ""
"既知の代理 ARP アドレスに対して ARP リクエストを受信した場合に、 応答前に最"
"大 I<proxy_delay> jiffy まで遅延する。これは場合によって生じる ネットワーク・"
"フラッディング (network flooding) を避けるために用いる。 デフォルトは 0.8 "
"秒。"

#. type: TP
#: build/C/man7/arp.7:243
#, no-wrap
msgid "I<proxy_qlen> (since Linux 2.2)"
msgstr "I<proxy_qlen> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:248
msgid ""
"The maximum number of packets which may be queued to proxy-ARP addresses.  "
"Defaults to 64."
msgstr ""
"代理 ARP アドレスに対してキューイングできる最大のパケット数。 デフォルトは "
"64。"

#. type: TP
#: build/C/man7/arp.7:248
#, no-wrap
msgid "I<retrans_time> (since Linux 2.2)"
msgstr "I<retrans_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:255
msgid ""
"The number of jiffies to delay before retransmitting a request.  Defaults to "
"1 second.  This file is now obsolete in favor of I<retrans_time_ms>."
msgstr ""
"リクエストを再度送るまでの遅延時間 (jiffy 単位)。 デフォルトは 1 秒。 この"
"ファイルは現在は非推奨であり、代わりに I<retrans_time_ms> を使うこと。"

#. type: TP
#: build/C/man7/arp.7:255
#, no-wrap
msgid "I<retrans_time_ms> (since Linux 2.6.12)"
msgstr "I<retrans_time_ms> (Linux 2.6.12 以降)"

#. type: Plain text
#: build/C/man7/arp.7:259
msgid ""
"The number of milliseconds to delay before retransmitting a request.  "
"Defaults to 1000 milliseconds."
msgstr ""
"リクエストを再度送るまでの遅延時間 (ミリ秒単位)。 デフォルトは 1000 ミリ秒。"

#. type: TP
#: build/C/man7/arp.7:259
#, no-wrap
msgid "I<ucast_solicit> (since Linux 2.2)"
msgstr "I<ucast_solicit> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:266
msgid ""
"The maximum number of attempts to send unicast probes before asking the ARP "
"daemon (see I<app_solicit>).  Defaults to 3."
msgstr ""
"ARP デーモンへの問い合わせを行う前に行う unicast 探索の最大試行数 "
"(I<app_solicit> を見よ)。デフォルトは 3。"

#. type: TP
#: build/C/man7/arp.7:266
#, no-wrap
msgid "I<unres_qlen> (since Linux 2.2)"
msgstr "I<unres_qlen> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:272
msgid ""
"The maximum number of packets which may be queued for each unresolved "
"address by other network layers.  Defaults to 3."
msgstr ""
"解決されていないアドレスに対して、 他のネットワーク層からキューイングできる最"
"大パケット数。 デフォルトは 3。"

#. type: SH
#: build/C/man7/arp.7:272 build/C/man7/ddp.7:221 build/C/man3/endian.3:74
#: build/C/man3/getnameinfo.3:203 build/C/man7/icmp.7:161
#: build/C/man7/ipv6.7:361 build/C/man7/packet.7:282 build/C/man7/raw.7:175
#: build/C/man3/rcmd.3:262 build/C/man3/rexec.3:138 build/C/man7/tcp.7:1149
#: build/C/man7/udp.7:251 build/C/man7/udplite.7:132 build/C/man7/unix.7:401
#: build/C/man7/x25.7:100
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/arp.7:279
msgid ""
"The I<struct arpreq> changed in Linux 2.0 to include the I<arp_dev> member "
"and the ioctl numbers changed at the same time.  Support for the old ioctls "
"was dropped in Linux 2.2."
msgstr ""
"Linux 2.0 で、 I<struct arpreq> に I<arp_dev> メンバーが含まれるように変更が"
"あった。また同時に ioctl 番号も変更された。古い ioctl は Linux 2.2 で用いるこ"
"とができなくなった。"

#. type: Plain text
#: build/C/man7/arp.7:285
msgid ""
"Support for proxy arp entries for networks (netmask not equal 0xffffffff)  "
"was dropped in Linux 2.2.  It is replaced by automatic proxy arp setup by "
"the kernel for all reachable hosts on other interfaces (when forwarding and "
"proxy arp is enabled for the interface)."
msgstr ""
"ネットワークに対する代理 arp エントリ (netmask が 0xffffffff でない)  は、 "
"Linux 2.2 で用いることができなくなった。 これはカーネルによって設定される、別"
"のインターフェースにおける 到達可能なすべてのホストに対する自動代理 arp に"
"よって置き換えられた (そのインターフェースでフォワーディングと代理 arp が有効"
"になっている場合)。"

#. type: Plain text
#: build/C/man7/arp.7:289
msgid "The I<neigh/*> interfaces did not exist before Linux 2.2."
msgstr "I<neigh/*> の各インタフェースは Linux 2.2 以前には存在しない。"

#. type: SH
#: build/C/man7/arp.7:289 build/C/man7/ddp.7:244 build/C/man3/ether_aton.3:145
#: build/C/man3/gethostbyname.3:441 build/C/man3/inet_ntop.3:112
#: build/C/man3/inet_pton.3:150 build/C/man7/ip.7:1217 build/C/man7/ipv6.7:400
#: build/C/man7/netdevice.7:328 build/C/man7/packet.7:363
#: build/C/man7/raw.7:252 build/C/man3/rcmd.3:278 build/C/man3/rexec.3:158
#: build/C/man2/shutdown.2:104 build/C/man7/tcp.7:1156
#: build/C/man7/udplite.7:134 build/C/man7/x25.7:102
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man7/arp.7:293
msgid ""
"Some timer settings are specified in jiffies, which is architecture- and "
"kernel version-dependent; see B<time>(7)."
msgstr ""
"いくつかのタイマー設定は jiffy で指定されるが、 jiffy はアーキテクチャやカー"
"ネルのバージョンに依存する。 B<time>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/arp.7:299
msgid ""
"There is no way to signal positive feedback from user space.  This means "
"connection-oriented protocols implemented in user space will generate "
"excessive ARP traffic, because ndisc will regularly reprobe the MAC "
"address.  The same problem applies for some kernel protocols (e.g., NFS over "
"UDP)."
msgstr ""
"ユーザー空間からポジティブなフィードバックを送る方法が存在しない。 つまり接続"
"指向 (connection-oriented) のプロトコルをユーザー空間で 実装すると、余計な "
"ARP トラフィックの原因となる。 なぜなら ndisc は定期的に MAC アドレスを再探索"
"するからである。 同様の問題はいくつかのカーネルプロトコル (NFS over UDP な"
"ど) にも存在する。"

#. type: Plain text
#: build/C/man7/arp.7:302
msgid ""
"This man page mashes IPv4 specific and shared between IPv4 and IPv6 "
"functionality together."
msgstr ""
"この man ページでは IPv4 特有の機能と IPv4・IPv6 で共有される機能とがごっちゃ"
"になっている。"

#. type: SH
#: build/C/man7/arp.7:302 build/C/man3/byteorder.3:83 build/C/man3/cmsg.3:217
#: build/C/man7/ddp.7:249 build/C/man3/endian.3:151
#: build/C/man3/ether_aton.3:149 build/C/man5/gai.conf.5:93
#: build/C/man3/getaddrinfo.3:817 build/C/man3/getaddrinfo_a.3:600
#: build/C/man1/getent.1:368 build/C/man3/gethostbyname.3:446
#: build/C/man3/getipnodebyname.3:266 build/C/man3/getnameinfo.3:275
#: build/C/man3/getnetent.3:154 build/C/man3/getnetent_r.3:145
#: build/C/man2/getpeername.2:143 build/C/man3/getprotoent.3:142
#: build/C/man3/getprotoent_r.3:237 build/C/man3/getservent.3:159
#: build/C/man3/getservent_r.3:241 build/C/man5/host.conf.5:199
#: build/C/man7/hostname.7:85 build/C/man5/hosts.5:115
#: build/C/man5/hosts.equiv.5:84 build/C/man7/icmp.7:191
#: build/C/man3/inet.3:297 build/C/man3/inet_ntop.3:118
#: build/C/man3/inet_pton.3:215 build/C/man7/ip.7:1236 build/C/man7/ipv6.7:411
#: build/C/man7/netdevice.7:342 build/C/man5/networks.5:74
#: build/C/man8/nscd.8:85 build/C/man5/nscd.conf.5:232 build/C/man5/nss.5:110
#: build/C/man5/nsswitch.conf.5:352 build/C/man7/packet.7:394
#: build/C/man5/protocols.5:81 build/C/man7/raw.7:269 build/C/man3/rcmd.3:285
#: build/C/man5/resolv.conf.5:287 build/C/man3/resolver.3:274
#: build/C/man3/rexec.3:167 build/C/man5/services.5:210
#: build/C/man3/setnetgrent.3:107 build/C/man2/shutdown.2:113
#: build/C/man7/tcp.7:1168 build/C/man7/udp.7:256 build/C/man7/udplite.7:146
#: build/C/man7/unix.7:445 build/C/man7/x25.7:118
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/arp.7:305
msgid "B<capabilities>(7), B<ip>(7)"
msgstr "B<capabilities>(7), B<ip>(7)"

#. type: Plain text
#: build/C/man7/arp.7:310
msgid ""
"RFC\\ 826 for a description of ARP.  RFC\\ 2461 for a description of IPv6 "
"neighbor discovery and the base algorithms used.  Linux 2.2+ IPv4 ARP uses "
"the IPv6 algorithms when applicable."
msgstr ""
"RFC \\ 826: ARP の説明。 RFC\\ 2461: IPv6 neighbor discovery の説明と利用され"
"ている基礎アルゴリズム。 Linux 2.2 以降では IPv4 ARP は可能な場合は IPv6 アル"
"ゴリズムを使っている。"

#. type: SH
#: build/C/man7/arp.7:310 build/C/man3/byteorder.3:87 build/C/man3/cmsg.3:222
#: build/C/man7/ddp.7:254 build/C/man3/endian.3:153
#: build/C/man3/ether_aton.3:151 build/C/man5/gai.conf.5:96
#: build/C/man3/getaddrinfo.3:827 build/C/man3/getaddrinfo_a.3:607
#: build/C/man1/getent.1:370 build/C/man3/gethostbyname.3:460
#: build/C/man3/getipnodebyname.3:271 build/C/man3/getnameinfo.3:308
#: build/C/man3/getnetent.3:161 build/C/man3/getnetent_r.3:148
#: build/C/man2/getpeername.2:150 build/C/man3/getprotoent.3:147
#: build/C/man3/getprotoent_r.3:240 build/C/man3/getservent.3:164
#: build/C/man3/getservent_r.3:244 build/C/man5/host.conf.5:204
#: build/C/man7/hostname.7:93 build/C/man5/hosts.5:126
#: build/C/man5/hosts.equiv.5:88 build/C/man7/icmp.7:195
#: build/C/man3/inet.3:307 build/C/man3/inet_ntop.3:122
#: build/C/man3/inet_pton.3:219 build/C/man7/ip.7:1254 build/C/man7/ipv6.7:418
#: build/C/man7/netdevice.7:347 build/C/man5/networks.5:80
#: build/C/man8/nscd.8:91 build/C/man5/nscd.conf.5:237 build/C/man5/nss.5:112
#: build/C/man5/nsswitch.conf.5:355 build/C/man7/packet.7:408
#: build/C/man5/protocols.5:86 build/C/man7/raw.7:282 build/C/man3/rcmd.3:293
#: build/C/man5/resolv.conf.5:294 build/C/man3/resolver.3:280
#: build/C/man3/rexec.3:170 build/C/man5/services.5:222
#: build/C/man3/setnetgrent.3:111 build/C/man2/shutdown.2:117
#: build/C/man7/tcp.7:1194 build/C/man7/udp.7:267 build/C/man7/udplite.7:156
#: build/C/man7/unix.7:454 build/C/man7/x25.7:127
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/arp.7:317 build/C/man3/byteorder.3:94 build/C/man3/cmsg.3:229
#: build/C/man7/ddp.7:261 build/C/man3/endian.3:160
#: build/C/man3/ether_aton.3:158 build/C/man5/gai.conf.5:103
#: build/C/man3/getaddrinfo.3:834 build/C/man3/getaddrinfo_a.3:614
#: build/C/man1/getent.1:377 build/C/man3/gethostbyname.3:467
#: build/C/man3/getipnodebyname.3:278 build/C/man3/getnameinfo.3:315
#: build/C/man3/getnetent.3:168 build/C/man3/getnetent_r.3:155
#: build/C/man2/getpeername.2:157 build/C/man3/getprotoent.3:154
#: build/C/man3/getprotoent_r.3:247 build/C/man3/getservent.3:171
#: build/C/man3/getservent_r.3:251 build/C/man5/host.conf.5:211
#: build/C/man7/hostname.7:100 build/C/man5/hosts.5:133
#: build/C/man5/hosts.equiv.5:95 build/C/man7/icmp.7:202
#: build/C/man3/inet.3:314 build/C/man3/inet_ntop.3:129
#: build/C/man3/inet_pton.3:226 build/C/man7/ip.7:1261 build/C/man7/ipv6.7:425
#: build/C/man7/netdevice.7:354 build/C/man5/networks.5:87
#: build/C/man8/nscd.8:98 build/C/man5/nscd.conf.5:244 build/C/man5/nss.5:119
#: build/C/man5/nsswitch.conf.5:362 build/C/man7/packet.7:415
#: build/C/man5/protocols.5:93 build/C/man7/raw.7:289 build/C/man3/rcmd.3:300
#: build/C/man5/resolv.conf.5:301 build/C/man3/resolver.3:287
#: build/C/man3/rexec.3:177 build/C/man5/services.5:229
#: build/C/man3/setnetgrent.3:118 build/C/man2/shutdown.2:124
#: build/C/man7/tcp.7:1201 build/C/man7/udp.7:274 build/C/man7/udplite.7:163
#: build/C/man7/unix.7:461 build/C/man7/x25.7:134
msgid ""
"This page is part of release 3.54 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.54 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/byteorder.3:32
#, no-wrap
msgid "BYTEORDER"
msgstr "BYTEORDER"

#. type: TH
#: build/C/man3/byteorder.3:32
#, no-wrap
msgid "2009-01-15"
msgstr "2009-01-15"

#. type: TH
#: build/C/man3/byteorder.3:32 build/C/man3/endian.3:28
#: build/C/man3/ether_aton.3:31 build/C/man3/getaddrinfo.3:43
#: build/C/man3/getaddrinfo_a.3:29 build/C/man3/getnameinfo.3:10
#: build/C/man3/getnetent.3:30 build/C/man3/getnetent_r.3:26
#: build/C/man3/getprotoent.3:30 build/C/man3/getprotoent_r.3:26
#: build/C/man3/getservent.3:34 build/C/man3/getservent_r.3:26
#: build/C/man3/inet.3:42 build/C/man8/nscd.8:23 build/C/man5/nscd.conf.5:20
#: build/C/man3/resolver.3:32 build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/byteorder.3:36
msgid ""
"htonl, htons, ntohl, ntohs - convert values between host and network byte "
"order"
msgstr ""
"htonl, htons, ntohl, ntohs - ホストバイトオーダーとネットワークバイトオーダー"
"の間で値を変換する"

#. type: SH
#: build/C/man3/byteorder.3:36 build/C/man3/cmsg.3:14 build/C/man7/ddp.7:15
#: build/C/man3/endian.3:33 build/C/man3/ether_aton.3:35
#: build/C/man3/getaddrinfo.3:47 build/C/man3/getaddrinfo_a.3:33
#: build/C/man1/getent.1:27 build/C/man3/gethostbyname.3:46
#: build/C/man3/getipnodebyname.3:30 build/C/man3/getnameinfo.3:13
#: build/C/man3/getnetent.3:34 build/C/man3/getnetent_r.3:30
#: build/C/man2/getpeername.2:45 build/C/man3/getprotoent.3:34
#: build/C/man3/getprotoent_r.3:30 build/C/man3/getservent.3:38
#: build/C/man3/getservent_r.3:30 build/C/man5/hosts.5:30
#: build/C/man3/inet.3:46 build/C/man3/inet_ntop.3:29
#: build/C/man3/inet_pton.3:30 build/C/man7/ip.7:39 build/C/man7/ipv6.7:89
#: build/C/man7/netdevice.7:21 build/C/man7/packet.7:15 build/C/man7/raw.7:16
#: build/C/man3/rcmd.3:48 build/C/man5/resolv.conf.5:27
#: build/C/man3/resolver.3:36 build/C/man3/rexec.3:44
#: build/C/man3/setnetgrent.3:14 build/C/man2/shutdown.2:43
#: build/C/man7/tcp.7:68 build/C/man7/udp.7:15 build/C/man7/udplite.7:30
#: build/C/man7/unix.7:21 build/C/man7/x25.7:15
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/byteorder.3:39 build/C/man3/inet_ntop.3:32
#: build/C/man3/inet_pton.3:33
#, no-wrap
msgid "B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr "B<#include E<lt>arpa/inet.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:41
#, no-wrap
msgid "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"
msgstr "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:43
#, no-wrap
msgid "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"
msgstr "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:45
#, no-wrap
msgid "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"
msgstr "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:47
#, no-wrap
msgid "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"
msgstr "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:54
msgid ""
"The B<htonl>()  function converts the unsigned integer I<hostlong> from host "
"byte order to network byte order."
msgstr ""
"B<htonl>()  関数は unsigned integer I<hostlong> を ホストバイトオーダーから"
"ネットワークバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:60
msgid ""
"The B<htons>()  function converts the unsigned short integer I<hostshort> "
"from host byte order to network byte order."
msgstr ""
"B<htons>()  関数は unsigned short integer I<hostshort> を ホストバイトオー"
"ダーからネットワークバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:66
msgid ""
"The B<ntohl>()  function converts the unsigned integer I<netlong> from "
"network byte order to host byte order."
msgstr ""
"B<ntohl>()  関数は unsigned integer I<netlong> を ネットワークバイトオーダー"
"からホストバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:72
msgid ""
"The B<ntohs>()  function converts the unsigned short integer I<netshort> "
"from network byte order to host byte order."
msgstr ""
"B<ntohs>()  関数は unsigned short integer I<netshort> を ネットワークバイト"
"オーダーからホストバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:76
msgid ""
"On the i386 the host byte order is Least Significant Byte first, whereas the "
"network byte order, as used on the Internet, is Most Significant Byte first."
msgstr ""
"i80x86 のホストバイトオーダーでは最下位バイトが若いアドレスに配置されるが、 "
"インターネットで用いられるネットワークバイトオーダーでは最上位バイト が先に配"
"置される。"

#. type: SH
#: build/C/man3/byteorder.3:76 build/C/man3/cmsg.3:141
#: build/C/man3/endian.3:76 build/C/man3/ether_aton.3:143
#: build/C/man3/getaddrinfo.3:584 build/C/man3/getaddrinfo_a.3:305
#: build/C/man3/gethostbyname.3:320 build/C/man3/getipnodebyname.3:258
#: build/C/man3/getnameinfo.3:206 build/C/man3/getnetent.3:145
#: build/C/man3/getnetent_r.3:141 build/C/man2/getpeername.2:101
#: build/C/man3/getprotoent.3:140 build/C/man3/getprotoent_r.3:131
#: build/C/man3/getservent.3:157 build/C/man3/getservent_r.3:130
#: build/C/man3/inet.3:210 build/C/man3/inet_ntop.3:100
#: build/C/man3/inet_pton.3:129 build/C/man3/rcmd.3:270
#: build/C/man3/resolver.3:272 build/C/man3/rexec.3:149
#: build/C/man3/setnetgrent.3:92 build/C/man2/shutdown.2:91
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/byteorder.3:78 build/C/man3/inet_pton.3:131
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/byteorder.3:83
msgid ""
"Some systems require the inclusion of I<E<lt>netinet/in.hE<gt>> instead of "
"I<E<lt>arpa/inet.hE<gt>>."
msgstr ""
"いくつかのシステムでは、 I<E<lt>arpa/inet.hE<gt>> の代わりに I<E<lt>netinet/"
"in.hE<gt>> をインクルードする必要がある。"

#. type: Plain text
#: build/C/man3/byteorder.3:87
msgid "B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"
msgstr "B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"

#. type: TH
#: build/C/man3/cmsg.3:11
#, no-wrap
msgid "CMSG"
msgstr "CMSG"

#. type: TH
#: build/C/man3/cmsg.3:11 build/C/man7/ddp.7:12
#, no-wrap
msgid "2008-11-20"
msgstr "2008-11-20"

#. type: Plain text
#: build/C/man3/cmsg.3:14
msgid ""
"CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - access ancillary data"
msgstr ""
"CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - 補助データにアクセスす"
"る。"

#. type: Plain text
#: build/C/man3/cmsg.3:16 build/C/man7/ddp.7:17 build/C/man2/getpeername.2:47
#: build/C/man7/ip.7:41 build/C/man7/ipv6.7:91 build/C/man7/raw.7:18
#: build/C/man2/shutdown.2:45 build/C/man7/tcp.7:70 build/C/man7/udp.7:17
#: build/C/man7/udplite.7:32 build/C/man7/unix.7:23 build/C/man7/x25.7:17
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: build/C/man3/cmsg.3:18
msgid "B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>"
msgstr "B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>"

#. type: Plain text
#: build/C/man3/cmsg.3:20
msgid ""
"B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<, struct cmsghdr "
"*>I<cmsg>B<);>"
msgstr ""
"B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<, struct cmsghdr "
"*>I<cmsg>B<);>"

#. type: Plain text
#: build/C/man3/cmsg.3:22
msgid "B<size_t CMSG_ALIGN(size_t >I<length>B<);>"
msgstr "B<size_t CMSG_ALIGN(size_t >I<length>B<);>"

#. type: Plain text
#: build/C/man3/cmsg.3:24
msgid "B<size_t CMSG_SPACE(size_t >I<length>B<);>"
msgstr "B<size_t CMSG_SPACE(size_t >I<length>B<);>"

#. type: Plain text
#: build/C/man3/cmsg.3:26
msgid "B<size_t CMSG_LEN(size_t >I<length>B<);>"
msgstr "B<size_t CMSG_LEN(size_t >I<length>B<);>"

#. type: Plain text
#: build/C/man3/cmsg.3:28
msgid "B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>"
msgstr "B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>"

#. type: Plain text
#: build/C/man3/cmsg.3:36
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    socklen_t cmsg_len;    /* data byte count, including header */\n"
"    int       cmsg_level;  /* originating protocol */\n"
"    int       cmsg_type;   /* protocol-specific type */\n"
"    /* followed by unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""
"struct cmsghdr {\n"
"    socklen_t cmsg_len;    /* data byte count, including header */\n"
"    int       cmsg_level;  /* originating protocol */\n"
"    int       cmsg_type;   /* protocol-specific type */\n"
"    /* followed by unsigned char cmsg_data[]; */\n"
"};\n"

#. type: Plain text
#: build/C/man3/cmsg.3:51
msgid ""
"These macros are used to create and access control messages (also called "
"ancillary data) that are not a part of the socket payload.  This control "
"information may include the interface the packet was received on, various "
"rarely used header fields, an extended error description, a set of file "
"descriptors or UNIX credentials.  For instance, control messages can be used "
"to send additional header fields such as IP options.  Ancillary data is sent "
"by calling B<sendmsg>(2)  and received by calling B<recvmsg>(2).  See their "
"manual pages for more information."
msgstr ""
"これらのマクロは制御メッセージ (補助データ (ancillary data) とも呼ばれる) を"
"作り、 それにアクセスするために使われる。 制御メッセージはソケットにのるデー"
"タではない。 この制御情報は、到着したパケットへのインターフェイス、様々なあま"
"り 使われないヘッダーフィールド、エラー記述の拡張、ファイルデスクリ プタの集"
"合や、UNIXにおける信頼情報 (credential) を含んでいる。 制御メッセージは、例え"
"ば IP オプションのような追加ヘッダーフィールドを 送るのに使う事ができる。 補"
"助データは、 B<sendmsg>(2)  を呼び出して送り、 B<recvmsg>(2)  を呼び出して受"
"け取る。 詳細はそれらのマニュアルページを参照。"

#. type: Plain text
#: build/C/man3/cmsg.3:62
msgid ""
"Ancillary data is a sequence of I<struct cmsghdr> structures with appended "
"data.  This sequence should be accessed using only the macros described in "
"this manual page and never directly.  See the specific protocol man pages "
"for the available control message types.  The maximum ancillary buffer size "
"allowed per socket can be set using I</proc/sys/net/core/optmem_max>; see "
"B<socket>(7)."
msgstr ""
"補助データは I<struct cmsghdr> 構造体のシーケンスに追加データが付加されたもの"
"である。 このシーケンスにはこのマニュアルページに書かれている マクロを使って"
"アクセスすべきで、直接アクセスすべきではない。 使用可能な制御メッセージのタイ"
"プについては、 それぞれのプロトコルのマニュアルページを参照のこと。 接続毎の"
"最大補助用バッファサイズは I</proc/sys/net/core/optmem_max> を使って設定でき"
"る。 B<socket>(7)  を参照。"

#. type: Plain text
#: build/C/man3/cmsg.3:69
msgid ""
"B<CMSG_FIRSTHDR>()  returns a pointer to the first I<cmsghdr> in the "
"ancillary data buffer associated with the passed I<msghdr>."
msgstr ""
"B<CMSG_FIRSTHDR>()  は、渡した I<msghdr> に関連した補助データバッファ中の、最"
"初の I<cmsghdr> へのポインタを返す。"

#. type: Plain text
#: build/C/man3/cmsg.3:76
msgid ""
"B<CMSG_NXTHDR>()  returns the next valid I<cmsghdr> after the passed "
"I<cmsghdr>.  It returns NULL when there isn't enough space left in the "
"buffer."
msgstr ""
"B<CMSG_NXTHDR>()  は、渡した I<cmsghdr> の次にくる (有効な)  I<cmsghdr> を返"
"す。 バッファに十分な空きが無い場合、NULL を返す。"

#. type: Plain text
#: build/C/man3/cmsg.3:81
msgid ""
"B<CMSG_ALIGN>(), given a length, returns it including the required "
"alignment.  This is a constant expression."
msgstr ""
"B<CMSG_ALIGN>()  に長さを与えると、必要なアラインメントを加味した長さを返して"
"くる。 これは定数式である。"

#. type: Plain text
#: build/C/man3/cmsg.3:86
msgid ""
"B<CMSG_SPACE>()  returns the number of bytes an ancillary element with "
"payload of the passed data length occupies.  This is a constant expression."
msgstr ""
"B<CMSG_SPACE>()  は、与えたデータ長が占めるのに必要な補助要素 (ancillary "
"element) の バイト数を返す。これは定数式である。"

#. type: Plain text
#: build/C/man3/cmsg.3:90
msgid "B<CMSG_DATA>()  returns a pointer to the data portion of a I<cmsghdr>."
msgstr "B<CMSG_DATA>()  は、 I<cmsghdr> のデータ部分へのポインタを返す。"

#. type: Plain text
#: build/C/man3/cmsg.3:101
msgid ""
"B<CMSG_LEN>()  returns the value to store in the I<cmsg_len> member of the "
"I<cmsghdr> structure, taking into account any necessary alignment.  It takes "
"the data length as an argument.  This is a constant expression."
msgstr ""
"B<CMSG_LEN>()  は、 I<cmsghdr> 構造体の I<cmsg_len> メンバにデータを格納する"
"際に必要な値を返す。アラインメントも考慮に入れ られる。 引数としてデータ長を"
"とる。これは定数式である。"

#. type: Plain text
#: build/C/man3/cmsg.3:134
msgid ""
"To create ancillary data, first initialize the I<msg_controllen> member of "
"the I<msghdr> with the length of the control message buffer.  Use "
"B<CMSG_FIRSTHDR>()  on the I<msghdr> to get the first control message and "
"B<CMSG_NXTHDR>()  to get all subsequent ones.  In each control message, "
"initialize I<cmsg_len> (with B<CMSG_LEN>()), the other I<cmsghdr> header "
"fields, and the data portion using B<CMSG_DATA>().  Finally, the "
"I<msg_controllen> field of the I<msghdr> should be set to the sum of the "
"B<CMSG_SPACE>()  of the length of all control messages in the buffer.  For "
"more information on the I<msghdr>, see B<recvmsg>(2)."
msgstr ""
"補助データを作るためには最初に I<msghdr> のメンバー I<msg_controllen> を、制"
"御メッセージバッファの長さで初期化する。 B<CMSG_FIRSTHDR>()  を I<msghdr> に"
"用いると最初の制御メッセージが得られ、 B<CMSG_NXTHDR>()  を使うと次の制御メッ"
"セージが得られる。 それぞれの制御メッセージでは、 I<cmsg_len> を初期化する "
"(B<CMSG_LEN>()  を使う)。 その他の I<cmsghdr> ヘッダーフィールド、そしてデー"
"タ部分に対しても B<CMSG_DATA>()  を使って初期化をする。 最後に I<msghdr> の "
"I<msg_controllen> フィールドに、バッファ中の制御メッセージの長さの "
"B<CMSG_SPACE>()  の合計がセットされる。 I<msghdr> についての詳細は B<recvmsg>"
"(2)  を参照。"

#. type: Plain text
#: build/C/man3/cmsg.3:141
msgid ""
"When the control message buffer is too short to store all messages, the "
"B<MSG_CTRUNC> flag is set in the I<msg_flags> member of the I<msghdr>."
msgstr ""
"制御メッセージバッファが全てのメッセージを納めるのには短すぎる場合、 "
"I<msghdr> の I<msg_flags> メンバーに B<MSG_CTRUNC> フラグがセットされる。"

#. type: Plain text
#: build/C/man3/cmsg.3:146
msgid ""
"This ancillary data model conforms to the POSIX.1g draft, 4.4BSD-Lite, the "
"IPv6 advanced API described in RFC\\ 2292 and the SUSv2.  B<CMSG_ALIGN>()  "
"is a Linux extension."
msgstr ""
"この補助データモデルは、POSIX.1g draft, 4.4BSD-Lite, RFC\\ 2292 に 記述されて"
"いる IPv6 advanced API, そして SUSv2 に準拠している。 B<CMSG_ALIGN>()  は "
"Linux の拡張である。"

#. type: SH
#: build/C/man3/cmsg.3:146 build/C/man7/ddp.7:226 build/C/man3/endian.3:91
#: build/C/man3/getaddrinfo.3:589 build/C/man3/getaddrinfo_a.3:308
#: build/C/man3/gethostbyname.3:344 build/C/man3/getipnodebyname.3:261
#: build/C/man3/getnameinfo.3:208 build/C/man3/getnetent.3:147
#: build/C/man2/getpeername.2:105 build/C/man5/host.conf.5:190
#: build/C/man5/hosts.5:88 build/C/man5/hosts.equiv.5:71
#: build/C/man7/icmp.7:169 build/C/man3/inet.3:218
#: build/C/man3/inet_pton.3:131 build/C/man7/ip.7:1155 build/C/man7/ipv6.7:390
#: build/C/man7/netdevice.7:310 build/C/man8/nscd.8:60
#: build/C/man5/nsswitch.conf.5:333 build/C/man7/packet.7:300
#: build/C/man7/raw.7:187 build/C/man3/setnetgrent.3:103
#: build/C/man2/shutdown.2:95 build/C/man7/unix.7:407
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/cmsg.3:151
msgid ""
"For portability, ancillary data should be accessed using only the macros "
"described here.  B<CMSG_ALIGN>()  is a Linux extension and should be not "
"used in portable programs."
msgstr ""
"移植性のために、補助データへのアクセスには、 ここで述べられているマクロだけを"
"使うべきである。 B<CMSG_ALIGN>()  は Linux での拡張であり、移植性を考えたプロ"
"グラムでは使うべきではない。"

#. type: Plain text
#: build/C/man3/cmsg.3:161
msgid ""
"In Linux, B<CMSG_LEN>(), B<CMSG_DATA>(), and B<CMSG_ALIGN>()  are constant "
"expressions (assuming their argument is constant); this could be used to "
"declare the size of global variables.  This may be not portable, however."
msgstr ""
"Linux では B<CMSG_LEN>(), B<CMSG_DATA>(), B<CMSG_ALIGN>()  は定数式である (そ"
"れらの引数が定数とみなされる)。 このことは、大域変数のサイズを宣言するのに使"
"える。 しかし移植性はなくなるだろう。"

#. type: SH
#: build/C/man3/cmsg.3:161 build/C/man3/endian.3:107
#: build/C/man5/gai.conf.5:74 build/C/man3/getaddrinfo.3:612
#: build/C/man3/getaddrinfo_a.3:314 build/C/man3/getnameinfo.3:236
#: build/C/man3/getprotoent_r.3:135 build/C/man3/getservent_r.3:134
#: build/C/man5/hosts.5:107 build/C/man3/inet.3:254
#: build/C/man3/inet_ntop.3:115 build/C/man3/inet_pton.3:156
#: build/C/man5/nss.5:100 build/C/man7/unix.7:437
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/cmsg.3:165
msgid ""
"This code looks for the B<IP_TTL> option in a received ancillary buffer:"
msgstr ""
"次のコードは、受け取った補助バッファから B<IP_TTL> オプションを探すものであ"
"る。"

#. type: Plain text
#: build/C/man3/cmsg.3:172
#, no-wrap
msgid ""
"struct msghdr msgh;\n"
"struct cmsghdr *cmsg;\n"
"int *ttlptr;\n"
"int received_ttl;\n"
msgstr ""
"struct msghdr msgh;\n"
"struct cmsghdr *cmsg;\n"
"int *ttlptr;\n"
"int received_ttl;\n"

#. type: Plain text
#: build/C/man3/cmsg.3:189
#, no-wrap
msgid ""
"/* Receive auxiliary data in msgh */\n"
"for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL;\n"
"        cmsg = CMSG_NXTHDR(&msgh,cmsg)) {\n"
"    if (cmsg-E<gt>cmsg_level == IPPROTO_IP\n"
"            && cmsg-E<gt>cmsg_type == IP_TTL) {\n"
"        ttlptr = (int *) CMSG_DATA(cmsg);\n"
"        received_ttl = *ttlptr;\n"
"        break;\n"
"    }\n"
"}\n"
"if (cmsg == NULL) {\n"
"    /*\n"
"     * Error: IP_TTL not enabled or small buffer\n"
"     * or I/O error.\n"
"     */\n"
"}\n"
msgstr ""
"/* Receive auxiliary data in msgh */\n"
"for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL;\n"
"        cmsg = CMSG_NXTHDR(&msgh,cmsg)) {\n"
"    if (cmsg-E<gt>cmsg_level == IPPROTO_IP\n"
"            && cmsg-E<gt>cmsg_type == IP_TTL) {\n"
"        ttlptr = (int *) CMSG_DATA(cmsg);\n"
"        received_ttl = *ttlptr;\n"
"        break;\n"
"    }\n"
"}\n"
"if (cmsg == NULL) {\n"
"    /*\n"
"     * Error: IP_TTL not enabled or small buffer\n"
"     * or I/O error.\n"
"     */\n"
"}\n"

#. type: Plain text
#: build/C/man3/cmsg.3:195
msgid ""
"The code below passes an array of file descriptors over a UNIX domain socket "
"using B<SCM_RIGHTS>:"
msgstr ""
"以下のコードは、 B<SCM_RIGHTS> を使い、ファイルデスクリプタの配列を UNIX ドメ"
"インソケットを通して送るものである。"

#. type: Plain text
#: build/C/man3/cmsg.3:203
#, no-wrap
msgid ""
"struct msghdr msg = {0};\n"
"struct cmsghdr *cmsg;\n"
"int myfds[NUM_FD]; /* Contains the file descriptors to pass. */\n"
"char buf[CMSG_SPACE(sizeof myfds)];  /* ancillary data buffer */\n"
"int *fdptr;\n"
msgstr ""
"struct msghdr msg = {0};\n"
"struct cmsghdr *cmsg;\n"
"int myfds[NUM_FD]; /* Contains the file descriptors to pass. */\n"
"char buf[CMSG_SPACE(sizeof myfds)];  /* ancillary data buffer */\n"
"int *fdptr;\n"

#. type: Plain text
#: build/C/man3/cmsg.3:215
#, no-wrap
msgid ""
"msg.msg_control = buf;\n"
"msg.msg_controllen = sizeof buf;\n"
"cmsg = CMSG_FIRSTHDR(&msg);\n"
"cmsg-E<gt>cmsg_level = SOL_SOCKET;\n"
"cmsg-E<gt>cmsg_type = SCM_RIGHTS;\n"
"cmsg-E<gt>cmsg_len = CMSG_LEN(sizeof(int) * NUM_FD);\n"
"/* Initialize the payload: */\n"
"fdptr = (int *) CMSG_DATA(cmsg);\n"
"memcpy(fdptr, myfds, NUM_FD * sizeof(int));\n"
"/* Sum of the length of all control messages in the buffer: */\n"
"msg.msg_controllen = cmsg-E<gt>cmsg_len;\n"
msgstr ""
"msg.msg_control = buf;\n"
"msg.msg_controllen = sizeof buf;\n"
"cmsg = CMSG_FIRSTHDR(&msg);\n"
"cmsg-E<gt>cmsg_level = SOL_SOCKET;\n"
"cmsg-E<gt>cmsg_type = SCM_RIGHTS;\n"
"cmsg-E<gt>cmsg_len = CMSG_LEN(sizeof(int) * NUM_FD);\n"
"/* Initialize the payload: */\n"
"fdptr = (int *) CMSG_DATA(cmsg);\n"
"memcpy(fdptr, myfds, NUM_FD * sizeof(int));\n"
"/* Sum of the length of all control messages in the buffer: */\n"
"msg.msg_controllen = cmsg-E<gt>cmsg_len;\n"

#. type: Plain text
#: build/C/man3/cmsg.3:220
msgid "B<recvmsg>(2), B<sendmsg>(2)"
msgstr "B<recvmsg>(2), B<sendmsg>(2)"

#. type: Plain text
#: build/C/man3/cmsg.3:222
msgid "RFC\\ 2292"
msgstr "RFC\\ 2292"

#. type: TH
#: build/C/man7/ddp.7:12
#, no-wrap
msgid "DDP"
msgstr "DDP"

#. type: Plain text
#: build/C/man7/ddp.7:15
msgid "ddp - Linux AppleTalk protocol implementation"
msgstr "ddp - Linux での AppleTalk プロトコルの実装"

#. type: Plain text
#: build/C/man7/ddp.7:19
msgid "B<#include E<lt>netatalk/at.hE<gt>>"
msgstr "B<#include E<lt>netatalk/at.hE<gt>>"

#. type: Plain text
#: build/C/man7/ddp.7:21
msgid "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"
msgstr "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/ddp.7:23
msgid "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ddp.7:34
msgid ""
"Linux implements the Appletalk protocols described in I<Inside Appletalk>.  "
"Only the DDP layer and AARP are present in the kernel.  They are designed to "
"be used via the B<netatalk> protocol libraries.  This page documents the "
"interface for those who wish or need to use the DDP layer directly."
msgstr ""
"Linux は I<Inside Appletalk> に記述されている Appletalk プロトコルを実装して"
"いる。 カーネルにあるのは DDP 層と AARP だけである。これらは B<netatalk> プロ"
"トコルライブラリを通して利用されるように設計されている。 このページは DDP 層"
"を直接利用したいユーザーのために、 インターフェースを記述したものである。"

#. type: Plain text
#: build/C/man7/ddp.7:39
msgid ""
"The communication between Appletalk and the user program works using a BSD-"
"compatible socket interface.  For more information on sockets, see B<socket>"
"(7)."
msgstr ""
"Appletalk とユーザープログラムとの通信には、 BSD 互換のソケットインターフェー"
"スを利用する。 ソケットに関するより詳しい情報は B<socket>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/ddp.7:60
msgid ""
"An AppleTalk socket is created by calling the B<socket>(2)  function with a "
"B<AF_APPLETALK> socket family argument.  Valid socket types are "
"B<SOCK_DGRAM> to open a B<ddp> socket or B<SOCK_RAW> to open a B<raw> "
"socket.  I<protocol> is the Appletalk protocol to be received or sent.  For "
"B<SOCK_RAW> you must specify B<ATPROTO_DDP>."
msgstr ""
"Appletalk ソケットは、 ソケットファミリーの引数に B<AF_APPLETALK> を指定して "
"B<socket>(2)  関数を呼び出すことによって生成される。指定できるソケットタイプ"
"は、 B<ddp> ソケットをオープンする場合には B<SOCK_DGRAM>、 B<raw> ソケットを"
"オープンする場合には B<SOCK_RAW> である。 I<protocol> は送受信される "
"Appletalk プロトコルである。 ソケットタイプに B<SOCK_RAW> を指定した場合は、"
"プロトコルに B<ATPROTO_DDP> を指定しなければならない。"

#. type: Plain text
#: build/C/man7/ddp.7:65
msgid ""
"Raw sockets may be opened only by a process with effective user ID 0 or when "
"the process has the B<CAP_NET_RAW> capability."
msgstr ""
"raw ソケットは実効ユーザー ID が 0 のプロセスか、 B<CAT_NEW_RAW> 権限を持った"
"プロセスでないとオープンできない。"

#. type: SS
#: build/C/man7/ddp.7:65 build/C/man7/ip.7:123 build/C/man7/ipv6.7:142
#: build/C/man7/raw.7:93 build/C/man7/udp.7:98 build/C/man7/udplite.7:58
#: build/C/man7/unix.7:55
#, no-wrap
msgid "Address format"
msgstr "アドレスのフォーマット"

#. type: Plain text
#: build/C/man7/ddp.7:68
msgid ""
"An Appletalk socket address is defined as a combination of a network number, "
"a node number, and a port number."
msgstr ""
"Appletalk ソケットアドレスはネットワーク番号・ノード番号・ポート番号の 組み合"
"わせで定義される。"

#. type: Plain text
#: build/C/man7/ddp.7:75
#, no-wrap
msgid ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"
msgstr ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"

#. type: Plain text
#: build/C/man7/ddp.7:81
#, no-wrap
msgid ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"
msgstr ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"

#.  FIXME this doesn't make sense [johnl]
#. type: Plain text
#: build/C/man7/ddp.7:120
msgid ""
"I<sat_family> is always set to B<AF_APPLETALK>.  I<sat_port> contains the "
"port.  The port numbers below 129 are known as I<reserved ports>.  Only "
"processes with the effective user ID 0 or the B<CAP_NET_BIND_SERVICE> "
"capability may B<bind>(2)  to these sockets.  I<sat_addr> is the host "
"address.  The I<net> member of I<struct at_addr> contains the host network "
"in network byte order.  The value of B<AT_ANYNET> is a wildcard and also "
"implies \\(lqthis network.\\(rq The I<node> member of I<struct at_addr> "
"contains the host node number.  The value of B<AT_ANYNODE> is a wildcard and "
"also implies \\(lqthis node.\\(rq The value of B<ATADDR_BCAST> is a link "
"local broadcast address."
msgstr ""
"I<sat_family> は常に B<AF_APPLETALK> に設定する。 I<sat_port> はポートを与え"
"る。ポート番号が 129 以下のポートは 「予約ポート (reserved port)」 と呼ばれ"
"る。実効ユーザー ID が 0 のプロセスか、 B<CAP_NET_BIND_SERVICE> 権限を持つプ"
"ロセスだけが、このようなソケットを B<bind>(2)  できる。 I<sat_addr> はホスト"
"アドレスである。 I<struct at_addr> のメンバー I<s_net> にはホストのネットワー"
"クをネットワークバイトオーダーで与える。値 B<AT_ANYNET> はワイルドカードで、"
"「このネットワーク」も暗黙のうちに含まれる。 I<struct at_addr> のメンバー "
"I<s_node> にはホストのノード番号を与える。値 B<AT_ANYNODE> はワイルドカード"
"で、「このノード」も暗黙のうちに含まれる。値 B<ATADDR_BCAST> はローカルなブ"
"ロードキャストアドレスである。"

#. type: SS
#: build/C/man7/ddp.7:120 build/C/man7/ip.7:224 build/C/man7/ipv6.7:192
#: build/C/man7/packet.7:179 build/C/man7/raw.7:109 build/C/man7/tcp.7:858
#: build/C/man7/udp.7:178 build/C/man7/udplite.7:67 build/C/man7/unix.7:137
#: build/C/man7/x25.7:72
#, no-wrap
msgid "Socket options"
msgstr "ソケットオプション"

#. type: Plain text
#: build/C/man7/ddp.7:122
msgid "No protocol-specific socket options are supported."
msgstr "プロトコル固有のソケットオプションはない。"

#. type: Plain text
#: build/C/man7/ddp.7:128
msgid ""
"IP supports a set of I</proc> interfaces to configure some global AppleTalk "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/atalk/>."
msgstr ""
"Appletalk のグローバルパラメータのいくつかは、 I</proc> インタフェースを通し"
"て設定することができる。 これらのパラメータには、 I</proc/sys/net/atalk/> "
"ディレクトリ内のファイルの読み書きでアクセスできる。"

#. type: TP
#: build/C/man7/ddp.7:128
#, no-wrap
msgid "I<aarp-expiry-time>"
msgstr "I<aarp-expiry-time>"

#. type: Plain text
#: build/C/man7/ddp.7:131
msgid "The time interval (in seconds) before an AARP cache entry expires."
msgstr "AARP キャッシュエントリを破棄するまでのタイムインターバル (秒単位)。"

#. type: TP
#: build/C/man7/ddp.7:131
#, no-wrap
msgid "I<aarp-resolve-time>"
msgstr "I<aarp-resolve-time>"

#. type: Plain text
#: build/C/man7/ddp.7:134
msgid "The time interval (in seconds) before an AARP cache entry is resolved."
msgstr "AARP キャッシュエントリが解決されるまでのタイムインターバル (秒単位)。"

#. type: TP
#: build/C/man7/ddp.7:134
#, no-wrap
msgid "I<aarp-retransmit-limit>"
msgstr "I<aarp-retransmit-limit>"

#. type: Plain text
#: build/C/man7/ddp.7:138
msgid ""
"The number of retransmissions of an AARP query before the node is declared "
"dead."
msgstr ""
"AARP クエリーの最大再送信回数。この回数を越えると、 そのノードは dead である"
"とみなされる。"

#. type: TP
#: build/C/man7/ddp.7:138
#, no-wrap
msgid "I<aarp-tick-time>"
msgstr "I<aarp-tick-time>"

#. type: Plain text
#: build/C/man7/ddp.7:141
msgid "The timer rate (in seconds) for the timer driving AARP."
msgstr "タイマー動作する AARP のタイマーレート (秒単位)"

#. type: Plain text
#: build/C/man7/ddp.7:144
msgid ""
"The default values match the specification and should never need to be "
"changed."
msgstr ""
"デフォルトの値で仕様にマッチしているので、 変更する必要は全くないはずである。"

#.  FIXME Add a section about multicasting
#. type: Plain text
#: build/C/man7/ddp.7:149
msgid "All ioctls described in B<socket>(7)  apply to DDP."
msgstr "B<socket>(7)  に記述されているすべての ioctl が DDP にも適用される。"

#. type: SH
#: build/C/man7/ddp.7:149 build/C/man3/gethostbyname.3:295
#: build/C/man3/getnetent_r.3:129 build/C/man2/getpeername.2:73
#: build/C/man3/getprotoent_r.3:119 build/C/man3/getservent_r.3:118
#: build/C/man3/inet_ntop.3:91 build/C/man7/ip.7:1064 build/C/man7/ipv6.7:349
#: build/C/man7/packet.7:246 build/C/man7/raw.7:144 build/C/man2/shutdown.2:74
#: build/C/man7/tcp.7:1131 build/C/man7/udp.7:241 build/C/man7/udplite.7:121
#: build/C/man7/unix.7:322
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man7/ddp.7:153 build/C/man7/ip.7:1068 build/C/man7/raw.7:145
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man7/ddp.7:160
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include sending to a broadcast address without having the broadcast "
"flag set, and trying to bind to a reserved port without effective user ID 0 "
"or B<CAP_NET_BIND_SERVICE>."
msgstr ""
"ユーザが行おうとした操作に必要な権限を持っていない。 broadcast フラグをセット"
"せずにブロードキャストアドレスへ送信を行おうとした、 実効ユーザー ID が 0 で"
"なく、 B<CAP_NET_BIND_SERVICE> 権限のないプロセスで特権ポートをバインドしよう"
"とした、などが考えられる。"

#. type: TP
#: build/C/man7/ddp.7:160 build/C/man7/ip.7:1084 build/C/man7/unix.7:323
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: build/C/man7/ddp.7:163 build/C/man7/ip.7:1087
msgid "Tried to bind to an address already in use."
msgstr "既に使用されているアドレスにバインドしようとした。"

#. type: TP
#: build/C/man7/ddp.7:163 build/C/man7/ip.7:1087 build/C/man7/packet.7:247
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: build/C/man7/ddp.7:167 build/C/man7/ip.7:1091
msgid ""
"A nonexistent interface was requested or the requested source address was "
"not local."
msgstr ""
"存在しないインターフェースが要求された。または 要求されたソースアドレスがロー"
"カルでない。"

#. type: TP
#: build/C/man7/ddp.7:167 build/C/man7/ip.7:1091
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man7/ddp.7:170 build/C/man7/ip.7:1094
msgid "Operation on a nonblocking socket would block."
msgstr "非ブロッキングソケットに対してブロックする操作を行った。"

#. type: TP
#: build/C/man7/ddp.7:170 build/C/man7/ip.7:1094
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: build/C/man7/ddp.7:173
msgid "A connection operation on a nonblocking socket is already in progress."
msgstr "非ブロッキングソケットに対する接続操作が既に実行中である。"

#. type: TP
#: build/C/man7/ddp.7:173 build/C/man7/ip.7:1097
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: build/C/man7/ddp.7:177 build/C/man7/ip.7:1101
msgid "A connection was closed during an B<accept>(2)."
msgstr "B<accept>(2)  の途中で接続がクローズされた。"

#. type: TP
#: build/C/man7/ddp.7:177 build/C/man7/ip.7:1101
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr "B<EHOSTUNREACH>"

#. type: Plain text
#: build/C/man7/ddp.7:180
msgid "No routing table entry matches the destination address."
msgstr "行き先アドレスにマッチするエントリがルーティングテーブルにない。"

#. type: TP
#: build/C/man7/ddp.7:180 build/C/man2/getpeername.2:85 build/C/man7/ip.7:1106
#: build/C/man7/packet.7:253 build/C/man7/raw.7:152 build/C/man2/shutdown.2:79
#: build/C/man7/unix.7:339
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man7/ddp.7:183
msgid "Invalid argument passed."
msgstr "渡した引数が不正。"

#. type: TP
#: build/C/man7/ddp.7:183 build/C/man7/ip.7:1112 build/C/man7/unix.7:348
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: build/C/man7/ddp.7:187 build/C/man7/ip.7:1116
msgid "B<connect>(2)  was called on an already connected socket."
msgstr "接続済みのソケットに対して B<connect>(2)  が呼ばれた。"

#. type: TP
#: build/C/man7/ddp.7:187 build/C/man7/ip.7:1116 build/C/man7/packet.7:256
#: build/C/man7/raw.7:155
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: build/C/man7/ddp.7:190
msgid "Datagram is bigger than the DDP MTU."
msgstr "データグラムが DDP MTU より大きい。"

#. type: TP
#: build/C/man7/ddp.7:190 build/C/man7/ipv6.7:351 build/C/man7/packet.7:265
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man7/ddp.7:193
msgid "Network device not available or not capable of sending IP."
msgstr "ネットワークデバイスがない。あるいは IP を送ることができない。"

#. type: TP
#: build/C/man7/ddp.7:193 build/C/man3/getnetent_r.3:130
#: build/C/man3/getprotoent_r.3:120 build/C/man3/getservent_r.3:119
#: build/C/man7/ip.7:1124 build/C/man7/packet.7:268 build/C/man7/unix.7:353
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man7/ddp.7:197 build/C/man7/ip.7:1128
msgid "B<SIOCGSTAMP> was called on a socket where no packet arrived."
msgstr "パケットが到着していないソケットに対して B<SIOCGSTAMP> が呼ばれた。"

#. type: TP
#: build/C/man7/ddp.7:197
#, no-wrap
msgid "B<ENOMEM> and B<ENOBUFS>"
msgstr "B<ENOMEM> と B<ENOBUFS>"

#. type: Plain text
#: build/C/man7/ddp.7:200
msgid "Not enough memory available."
msgstr "メモリが足りない。"

#. type: TP
#: build/C/man7/ddp.7:200 build/C/man7/ip.7:1128
#, no-wrap
msgid "B<ENOPKG>"
msgstr "B<ENOPKG>"

#. type: Plain text
#: build/C/man7/ddp.7:203 build/C/man7/ip.7:1131
msgid "A kernel subsystem was not configured."
msgstr "カーネルサブシステムが設定されていない。"

#. type: TP
#: build/C/man7/ddp.7:203 build/C/man7/ip.7:1131
#, no-wrap
msgid "B<ENOPROTOOPT> and B<EOPNOTSUPP>"
msgstr "B<ENOPROTOOPT> と B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man7/ddp.7:206 build/C/man7/ip.7:1134
msgid "Invalid socket option passed."
msgstr "無効なソケットオプションが渡された。"

#. type: TP
#: build/C/man7/ddp.7:206 build/C/man2/getpeername.2:93 build/C/man7/ip.7:1134
#: build/C/man7/packet.7:271 build/C/man2/shutdown.2:84
#: build/C/man7/unix.7:361
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: build/C/man7/ddp.7:210 build/C/man7/ip.7:1138
msgid ""
"The operation is defined only on a connected socket, but the socket wasn't "
"connected."
msgstr ""
"接続されていないソケットに対して、 接続状態でしか定義されていない操作を行おう"
"とした。"

#. type: TP
#: build/C/man7/ddp.7:210 build/C/man7/ip.7:1138 build/C/man7/packet.7:277
#: build/C/man7/raw.7:166 build/C/man7/unix.7:368
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man7/ddp.7:215
msgid ""
"User doesn't have permission to set high priority, make a configuration "
"change, or send signals to the requested process or group."
msgstr ""
"高い優先度に設定したり、設定を変更したり、 指定したプロセスやグループにシグナ"
"ルを送るのに必要な権限を ユーザが持っていない。"

#. type: TP
#: build/C/man7/ddp.7:215 build/C/man7/ip.7:1142 build/C/man7/tcp.7:1138
#: build/C/man7/unix.7:372
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: build/C/man7/ddp.7:218 build/C/man7/ip.7:1145
msgid "The connection was unexpectedly closed or shut down by the other end."
msgstr ""
"接続が接続相手によって、予期しないやり方でクローズまたはシャットダウンされ"
"た。"

#. type: TP
#: build/C/man7/ddp.7:218 build/C/man7/ip.7:1145 build/C/man7/unix.7:394
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: build/C/man7/ddp.7:221
msgid "The socket was unconfigured, or an unknown socket type was requested."
msgstr "ソケットが設定されていない。または未知のソケットタイプが要求された。"

#. type: Plain text
#: build/C/man7/ddp.7:226
msgid ""
"Appletalk is supported by Linux 2.0 or higher.  The I</proc> interfaces "
"exist since Linux 2.2."
msgstr ""
"Appletalk は Linux 2.0 以降でサポートされている。 I</proc> インタフェースは "
"Linux 2.2 以降に存在する。"

#. type: Plain text
#: build/C/man7/ddp.7:232
msgid ""
"Be very careful with the B<SO_BROADCAST> option - it is not privileged in "
"Linux.  It is easy to overload the network with careless sending to "
"broadcast addresses."
msgstr ""
"B<SO_BROADCAST> オプションを用いる時には慎重の上にも慎重になってほしい。 "
"Linux ではこれに特権を必要としない。 不注意にブロードキャストアドレスに送信を"
"行うと、 ネットワークの状態が簡単に変更されてしまう。"

#. type: SS
#: build/C/man7/ddp.7:232 build/C/man7/ip.7:1204 build/C/man7/packet.7:331
#, no-wrap
msgid "Compatibility"
msgstr "移植性"

#. type: Plain text
#: build/C/man7/ddp.7:239
msgid ""
"The basic AppleTalk socket interface is compatible with B<netatalk> on BSD-"
"derived systems.  Many BSD systems fail to check B<SO_BROADCAST> when "
"sending broadcast frames; this can lead to compatibility problems."
msgstr ""
"基本的な Appletalk ソケットインターフェースは BSD 由来のシステムにおける "
"B<netatalk> と互換性がある。多くの BSD システムでは、 ブロードキャストフレー"
"ムを送信しようとしたときの B<SO_BROADCAST> のチェックに失敗する。これは互換性"
"の問題となるかもしれない。"

#. type: Plain text
#: build/C/man7/ddp.7:244
msgid ""
"The raw socket mode is unique to Linux and exists to support the alternative "
"CAP package and AppleTalk monitoring tools more easily."
msgstr ""
"raw ソケットモードは Linux 独特のもので、もう一方の実装である CAP パッケージ"
"や、 Appletalk モニタツールをより簡単に実装できるようになる。"

#. type: Plain text
#: build/C/man7/ddp.7:246 build/C/man7/ip.7:1219
msgid "There are too many inconsistent error values."
msgstr "エラーの値がまったく首尾一貫していない。"

#. type: Plain text
#: build/C/man7/ddp.7:249
msgid ""
"The ioctls used to configure routing tables, devices, AARP tables and other "
"devices are not yet described."
msgstr ""
"ルーティングテーブル・デバイス・ AARP テーブル・その他のデバイスを 設定するた"
"めに用いられる ioctl がまだ記述されていない。"

#. type: Plain text
#: build/C/man7/ddp.7:254
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"
msgstr "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"

#. type: TH
#: build/C/man3/endian.3:28
#, no-wrap
msgid "ENDIAN"
msgstr "ENDIAN"

#. type: TH
#: build/C/man3/endian.3:28 build/C/man3/getnetent_r.3:26
#: build/C/man3/getprotoent_r.3:26 build/C/man3/getservent_r.3:26
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/endian.3:33
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and big-/"
"little-endian byte order"
msgstr ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh,\n"
"le32toh, htobe64, htole64, be64toh, le64toh - ホストバイトオーダーと\n"
"ビッグ/リトルエンディアンバイトオーダーの間で値の変換を行う"

#. type: Plain text
#: build/C/man3/endian.3:37
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>endian.hE<gt>>\n"
msgstr ""
"B<#define _BSD_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>endian.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/endian.3:42
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"

#. type: Plain text
#: build/C/man3/endian.3:47
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"

#. type: Plain text
#: build/C/man3/endian.3:52
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"

#. type: Plain text
#: build/C/man3/endian.3:57
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""
"これらの関数は、整数値のバイトエンコーディングを、\n"
"使用中の CPU (\"ホスト\") のバイトオーダーから\n"
"リトルエンディアンやビッグエンディアンバイトオーダーへの変換や\n"
"その逆の変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:62
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""
"各関数の名前に付いている数字 I<nn> は、その関数が扱う整数のサイズ\n"
"(16, 32, 64 ビットのどれか) を示している。"

#. type: Plain text
#: build/C/man3/endian.3:65
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""
"名前が \"htobeI<nn>\" という形の関数は、ホストバイトオーダーから\n"
"ビッグエンディアンバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:68
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""
"名前が \"htoleI<nn>\" という形の関数は、ホストバイトオーダーから\n"
"リトルエンディアンバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:71
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""
"名前が \"beI<nn>toh\" という形の関数は、ビッグエンディアンバイトオーダー\n"
"からホストバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:74
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from little-"
"endian order to host byte order."
msgstr ""
"名前が \"leI<nn>toh\" という形の関数は、リトルエンディアンバイトオーダー\n"
"からホストバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:76
msgid "These functions were added to glibc in version 2.9."
msgstr "これらの関数は glibc バージョン 2.9 で追加された。"

#. type: Plain text
#: build/C/man3/endian.3:91
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs, "
"where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby "
"the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""
"これらの関数は非標準である。\n"
"BSD には同様の関数が存在するが、 BSD では\n"
"必要なヘッダファイルは I<E<lt>endian.hE<gt>> ではなく\n"
"I<E<lt>sys/endian.hE<gt>> である。\n"
"不幸なことに、 NetBSD, FreeBSD, glibc では、\n"
"これらの関数の元々の OpenBSD での、 I<nn> は常に関数名の末尾に置く\n"
"という名前付けルールが踏襲されていない\n"
"(そのため、例を挙げると、 OpenBSD の \"betoh32\" と等価な関数は\n"
"NetBSD, FreeBSD, glibc では \"be32toh\" となる)。"

#. type: Plain text
#: build/C/man3/endian.3:99
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()B<.>"
msgstr ""
"これらの関数は、前からある B<byteorder>(3) 系の関数と同じである。\n"
"例えば、 B<be32toh>() は B<ntohl>() と等価である。"

#. type: Plain text
#: build/C/man3/endian.3:107
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the "
"64-bit and little-endian variants described in this page."
msgstr ""
"B<byteorder>(3) 系の関数のメリットは、これらが\n"
"全ての UNIX システムで利用可能な標準関数である点である。\n"
"一方で、これらの関数は TCP/IP 処理で使用されることを想定して\n"
"設計されたため、このページで説明している 64 ビット版や\n"
"リトルエンディアン版などが存在しない。"

#. type: Plain text
#: build/C/man3/endian.3:114
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte "
"order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""
"以下のプログラムは、整数をホストバイトオーダーからリトルエンディアンと\n"
"ビットエンディアンの両方のバイトオーダーに変換し、その結果を表示する。\n"
"ホストバイトオーダーはリトルエンディアンかビットエンディアンのいずれか\n"
"なので、変換に意味があるのはどちらか一方だけである。\n"
"このプログラムを x86-32 などのリトルエンディアンのシステムで実行した\n"
"場合の実行結果は下記のようになる。"

#. type: Plain text
#: build/C/man3/endian.3:121
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"

#. type: SS
#: build/C/man3/endian.3:123 build/C/man3/getprotoent_r.3:162
#: build/C/man3/getservent_r.3:160 build/C/man3/inet.3:270
#: build/C/man3/inet_pton.3:173
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/endian.3:130
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/endian.3:138
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"\tuint32_t u32;\n"
"\tuint8_t arr[4];\n"
"    } x;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"\tuint32_t u32;\n"
"\tuint8_t arr[4];\n"
"    } x;\n"

#. type: Plain text
#: build/C/man3/endian.3:143
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"

#. type: Plain text
#: build/C/man3/endian.3:147
#, no-wrap
msgid ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"
msgstr ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"

#. type: Plain text
#: build/C/man3/endian.3:150 build/C/man3/getaddrinfo.3:816
#: build/C/man3/getprotoent_r.3:236 build/C/man3/getservent_r.3:240
#: build/C/man3/inet_pton.3:214
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/endian.3:153
msgid "B<byteorder>(3)"
msgstr "B<byteorder>(3)"

#. type: TH
#: build/C/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr "ETHER_ATON"

#. type: TH
#: build/C/man3/ether_aton.3:31 build/C/man3/rexec.3:41
#, no-wrap
msgid "2013-07-04"
msgstr "2013-07-04"

#. type: Plain text
#: build/C/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet アドレスの操作用関数"

#. type: Plain text
#: build/C/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr "B<#include E<lt>netinet/ether.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:44
#, no-wrap
msgid "B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:46
#, no-wrap
msgid "B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<);>\n"
msgstr "B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:51 build/C/man3/gethostbyname.3:70
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr "/* GNU 拡張 */\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:53
#, no-wrap
msgid "B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"
msgstr "B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:67
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""
"関数 B<ether_aton>()  は、標準的な 16進数とコロンの形式で書かれた 48ビットの "
"Ethernet ホストアドレス I<asc> を、ネットワークでのバイト順 (byte order)  の"
"バイナリデータに変換し、静的に割り当てられたバッファに格納されたデータ へのポ"
"インタを返す。このバッファは、これ以降の関数呼び出しで上書きされる。 アドレス"
"が不正な場合、 B<ether_aton>()  は NULL を返す。"

#. type: Plain text
#: build/C/man3/ether_aton.3:76
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""
"関数 B<ether_ntoa>()  は、ネットワークのバイト順で表された Ethernet ホストア"
"ドレス I<addr> を、標準的な 16進数とコロンの形式の文字列に変換する。 但し、先"
"頭の 0 は省略される。変換後の文字列は静的に割り当てられたバッファ に格納され"
"て返される。このバッファは、これ以降の関数呼び出しで上書きされる。"

#. type: Plain text
#: build/C/man3/ether_aton.3:83
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""
"関数 B<ether_ntohost>()  は、Ethernet アドレスに対応するホスト名を I</etc/"
"ethers> を検索して割り当てる。対応するホスト名が見つからなかった場合は、 非 "
"0 を返す。"

#. type: Plain text
#: build/C/man3/ether_aton.3:90
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be found."
msgstr ""
"関数 B<ether_hostton>()  は、ホスト名に対応する Ethernet アドレスを I</etc/"
"ethers> を検索して割り当てる。対応するホスト名が見つからなかった場合は、 非 "
"0 を返す。"

#. type: Plain text
#: build/C/man3/ether_aton.3:102
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""
"関数 B<ether_line>()  は、 I</etc/ethers> 形式になった行を解析し、 アドレスと"
"ホスト名の組を返す (I</etc/ethers> 形式は、Ethernet アドレス、ホスト名が空白"
"文字 (whitespace)  で区切られた書式で、\\(aq#\\(aq 以降はコメントとみなされ"
"る)。 解析できなかった場合は、非 0 を返す。 I<hostname> で指定されたバッファ"
"は十分な長さが必要である。つまり、 I<line> と同じ長さでなければならない。"

#. type: Plain text
#: build/C/man3/ether_aton.3:113
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant thread-"
"safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, and do "
"not use static buffers."
msgstr ""
"関数 B<ether_ntoa_r>()  と B<ether_aton_r>()  は、 それぞれ B<ether_ntoa>()  "
"と B<ether_aton>()  の リエントラントでスレッドセーフなバージョンであり、 静"
"的なバッファを使用しない。"

#. type: Plain text
#: build/C/man3/ether_aton.3:119
msgid ""
"The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr ""
"I<ether_addr> 構造体は I<E<lt>net/ethernet.hE<gt>> で次のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man3/ether_aton.3:125
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"

#. type: SH
#: build/C/man3/ether_aton.3:127 build/C/man3/rexec.3:142
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: SS
#: build/C/man3/ether_aton.3:128 build/C/man3/rexec.3:143
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "マルチスレッディング (pthreads(7) 参照)"

#. type: Plain text
#: build/C/man3/ether_aton.3:134
msgid ""
"The B<ether_aton>()  and B<ether_ntoa>()  functions are not thread-safe."
msgstr "関数 B<ether_aton>() と B<ether_ntoa>() はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/ether_aton.3:143
msgid ""
"The B<ether_ntohost>(), B<ether_hostton>(), B<ether_line>(), B<ether_ntoa_r>"
"()  and B<ether_aton_r>()  functions are thread-safe."
msgstr ""
"関数 B<ether_ntohost>(), B<ether_hostton>(), B<ether_line>(), B<ether_ntoa_r>"
"(), B<ether_aton_r>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/ether_aton.3:145
msgid "4.3BSD, SunOS."
msgstr "4.3BSD, SunOS."

#. type: Plain text
#: build/C/man3/ether_aton.3:149
msgid "The glibc 2.2.5 implementation of B<ether_line>()  is broken."
msgstr "glibc 2.2.5 での B<ether_line>()  の実装はおかしい。"

#. type: Plain text
#: build/C/man3/ether_aton.3:151
msgid "B<ethers>(5)"
msgstr "B<ethers>(5)"

#. type: TH
#: build/C/man5/gai.conf.5:19
#, no-wrap
msgid "GAI.CONF"
msgstr "GAI.CONF"

#. type: TH
#: build/C/man5/gai.conf.5:19 build/C/man5/nss.5:19
#, no-wrap
msgid "2013-02-13"
msgstr "2013-02-13"

#. type: Plain text
#: build/C/man5/gai.conf.5:22
msgid "gai.conf - getaddrinfo(3) configuration file"
msgstr "gai.conf - getaddrinfo(3) 設定ファイル"

#. type: Plain text
#: build/C/man5/gai.conf.5:36
msgid ""
"A call to B<getaddrinfo>(3)  might return multiple answers.  According to RFC"
"\\ 3484 these answers must be sorted so that the answer with the highest "
"success rate is first in the list.  The RFC provides an algorithm for the "
"sorting.  The static rules are not always adequate, though.  For this "
"reason, the RFC also requires that system administrators should have the "
"possibility to dynamically change the sorting.  For the glibc "
"implementation, this can be achieved with the I</etc/gai.conf> file."
msgstr ""
"B<getaddrinfo>(3) の呼び出しでは、複数の答えが返る場合がある。 RFC\\ 3484 に"
"よれば、 これらの答えは、 最も成功の可能性が高い答えがリストの先頭になるよう"
"な順番に並び替えなければならない。 RFC には、 並び替えのアルゴリズムが書かれ"
"ている。 しかしながら、 静的なルールが常に適切という訳ではない。 この理由か"
"ら、 RFC では、 並び替え方法をシステム管理者が動的に変更できるようにすること"
"も要求している。 glibc の実装では、 I</etc/gai.conf> ファイルでこれが実現でき"
"るようになっている。"

#. type: Plain text
#: build/C/man5/gai.conf.5:40
msgid ""
"Each line in the configuration file consists of a keyword and its "
"parameters.  White spaces in any place are ignored.  Lines starting with "
"\\(aq#\\(aq are comments and are ignored."
msgstr ""
"設定ファイルの各行は、キーワードとそのパラメータで構成される。 ホワイトスペー"
"スはどこにあっても全て無視される。 \\(aq#\\(aq で始まる行はコメントで、 無視"
"される。"

#. type: Plain text
#: build/C/man5/gai.conf.5:42
msgid "The keywords currently recognized are:"
msgstr "現在のところ、認識されるキーワードは以下の通りである。"

#. type: TP
#: build/C/man5/gai.conf.5:42
#, no-wrap
msgid "B<label> I<netmask> I<precedence>"
msgstr "B<label> I<netmask> I<precedence>"

#. type: Plain text
#: build/C/man5/gai.conf.5:51
msgid ""
"The value is added to the label table used in the RFC\\ 3484 sorting.  If "
"any B<label> definition is present in the configuration file is present, the "
"default table is not used.  All the label definitions of the default table "
"which are to be maintained have to be duplicated.  Following the keyword, "
"the line has to contain a network mask and a label value."
msgstr ""
"指定した値は RFC\\ 3484 の並び替えで使用されるラベルテーブルに追加される。 設"
"定ファイルに B<label> 定義が一つでもあれば、デフォルトテーブルは使用されな"
"い。 デフォルトテーブルのすべてのラベル定義はきちんと管理されていれば、 重複"
"が発生するはずだからである。 ラベル行では、 キーワードの後に、 ネットワークマ"
"スクとラベル値が含まれていなければならない。"

#. type: TP
#: build/C/man5/gai.conf.5:51
#, no-wrap
msgid "B<precedence> I<netmask> I<precedence>"
msgstr "B<precedence> I<netmask> I<precedence>"

#. type: Plain text
#: build/C/man5/gai.conf.5:58
msgid ""
"This keyword is similar to B<label>, but instead the value is added to the "
"precedence table as specified in RFC\\ 3484.  Once again, the presence of a "
"single B<precedence> line in the configuration file causes the default table "
"to not be used."
msgstr ""
"このキーワードは B<label> に似ているが、 指定された値を RFC\\ 3484 で規定され"
"た優先度テーブルに追加する点が異なる。 繰り返しになるが、 設定ファイルに "
"B<precedence> が一つでもあれば、デフォルトテーブルは使用されない。"

#. type: TP
#: build/C/man5/gai.conf.5:58
#, no-wrap
msgid "B<reload> E<lt>B<yes>|B<no>E<gt>"
msgstr "B<reload> E<lt>B<yes>|B<no>E<gt>"

#. type: Plain text
#: build/C/man5/gai.conf.5:67
msgid ""
"This keyword controls whether a process checks whether the configuration "
"file has been changed since the last time it was read.  If the value is "
"\"B<yes>\" the file is re-read.  This might cause problems in multithreaded "
"applications and is generally a bad idea.  The default is \"B<no>\"."
msgstr ""
"このキーワードは、 設定ファイルが前回の読み出し以降に変更されているかをプロセ"
"スが確認するかを制御する。 値が \"B<yes>\" であれば、 ファイルが再読み込みさ"
"れる。 再読み込みはマルチスレッドアプリケーションで問題を起こす可能性があ"
"り、 一般にはよい考えとは言えない。 デフォルトは \"B<no>\" である。"

#. type: TP
#: build/C/man5/gai.conf.5:67
#, no-wrap
msgid "B<scopev4> I<mask> I<value>"
msgstr "B<scopev4> I<mask> I<value>"

#. type: Plain text
#: build/C/man5/gai.conf.5:72
msgid ""
"Add another rule to the RFC\\ 3484 scope table for IPv4 address.  By "
"default, the scope IDs described in section 3.2 in RFC\\ 3438 are used.  "
"Changing these defaults should hardly ever be necessary."
msgstr ""
"IPv4 アドレス用の RFC\\ 3484 スコープテーブルに別のルールを追加する。 デフォ"
"ルトでは、 RFC\\ 3438 のセクション 3.2 で説明されているスコープ ID が使用され"
"る。 これらのデフォルト値の変更が必要になることはまずないだろう。"

#. type: SH
#: build/C/man5/gai.conf.5:72 build/C/man3/getaddrinfo.3:582
#: build/C/man3/gethostbyname.3:310 build/C/man3/getnameinfo.3:197
#: build/C/man3/getnetent.3:141 build/C/man3/getprotoent.3:134
#: build/C/man3/getservent.3:153 build/C/man5/host.conf.5:180
#: build/C/man5/hosts.5:86 build/C/man5/hosts.equiv.5:69
#: build/C/man5/networks.5:70 build/C/man5/nss.5:98
#: build/C/man5/nsswitch.conf.5:298 build/C/man5/protocols.5:77
#: build/C/man5/resolv.conf.5:284 build/C/man3/resolver.3:267
#: build/C/man5/services.5:185 build/C/man3/setnetgrent.3:88
#: build/C/man7/udplite.7:126
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man5/gai.conf.5:74 build/C/man3/getaddrinfo.3:584
msgid "I</etc/gai.conf>"
msgstr "I</etc/gai.conf>"

#. type: Plain text
#: build/C/man5/gai.conf.5:77
msgid ""
"The default table according to RFC\\ 3484 would be specified with the "
"following configuration file:"
msgstr ""
"RFC\\ 3484 で規定されているデフォルトテーブルは、 以下の設定ファイルを指定す"
"るのと同じである。"

#. type: Plain text
#: build/C/man5/gai.conf.5:89
#, no-wrap
msgid ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"
msgstr ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"

#. type: Plain text
#: build/C/man5/gai.conf.5:96
msgid "B<getaddrinfo(3),> RFC\\ 3484"
msgstr "B<getaddrinfo(3),> RFC\\ 3484"

#. type: TH
#: build/C/man3/getaddrinfo.3:43
#, no-wrap
msgid "GETADDRINFO"
msgstr "GETADDRINFO"

#. type: TH
#: build/C/man3/getaddrinfo.3:43 build/C/man3/getnameinfo.3:10
#, no-wrap
msgid "2013-01-15"
msgstr "2013-01-15"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:47
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr ""
"getaddrinfo, freeaddrinfo, gai_strerror - ネットワークのアドレスとサービスを"
"変換する"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:52 build/C/man3/getipnodebyname.3:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:56
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:58
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:60
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr "B<const char *gai_strerror(int >I<errcode>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:65 build/C/man3/gethostbyname.3:93
#: build/C/man3/getnameinfo.3:26 build/C/man3/getnetent_r.3:52
#: build/C/man3/getprotoent_r.3:49 build/C/man3/getservent_r.3:49
#: build/C/man3/inet.3:70 build/C/man3/rcmd.3:81 build/C/man3/setnetgrent.3:34
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:71
msgid "B<getaddrinfo>(), B<freeaddrinfo>(), B<gai_strerror>():"
msgstr "B<getaddrinfo>(), B<freeaddrinfo>(), B<gai_strerror>():"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:73
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:100
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service, "
"B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which "
"contains an Internet address that can be specified in a call to B<bind>(2)  "
"or B<connect>(2).  The B<getaddrinfo>()  function combines the functionality "
"provided by the B<gethostbyname>(3)  and B<getservbyname>(3)  functions into "
"a single interface, but unlike the latter functions, B<getaddrinfo>()  is "
"reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies."
msgstr ""
"B<getaddrinfo>()  は、(インターネットのホストとサービスを識別する)  I<node> "
"と I<service> を渡すと、一つ以上の I<addrinfo> 構造体を返す。それぞれの "
"I<addrinfo> 構造体には、 B<bind>(2)  や B<connect>(2)  を呼び出す際に指定でき"
"るインターネットアドレスが格納されている。 B<getaddrinfo>()  関数は、 "
"B<gethostbyname>(3) と B<getservbyname>(3) の機能をまとめて一つのインター"
"フェースにしたものであるが、 これらの関数と違い、 B<getaddrinfo>() はリエント"
"ラントであり、 B<getaddrinfo>() を使うことでプログラムは IPv4 と IPv6 の違い"
"に関する依存関係を なくすことができる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:106
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr ""
"B<getaddrinfo>()  が用いる I<addrinfo> 構造体は以下のフィールドを含む。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:119
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:141
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by B<getaddrinfo>"
"(), as follows:"
msgstr ""
"I<hints> 引き数は I<addrinfo> 構造体を指し示し、この構造体を用いて I<res> が"
"指すリストに入れて返すソケットアドレス構造体を選択するための基準を指定する。 "
"I<hints> が NULL でない場合、 I<hints> は I<addrinfo> 構造体を指し示し、その"
"構造体のフィールド I<ai_family>, I<ai_socktype>, I<ai_protocol> で "
"B<getaddrinfo>()  が返すソケットアドレス集合に対する基準を指定する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:141
#, no-wrap
msgid "I<ai_family>"
msgstr "I<ai_family>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:157
msgid ""
"This field specifies the desired address family for the returned addresses.  "
"Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value "
"B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket addresses "
"for any address family (either IPv4 or IPv6, for example) that can be used "
"with I<node> and I<service>."
msgstr ""
"このフィールドは返されるアドレスの希望のアドレスファミリーを指定する。 この"
"フィールドに指定できる有効な値としては B<AF_INET> と B<AF_INET6> がある。 ま"
"た、値 B<AF_UNSPEC> を指定すると、 B<getaddrinfo>()  は I<node> と "
"I<service> で使用できるいずれかのアドレスファミリー (例えば IPv4 か IPv6) の "
"ソケットアドレスを返すことを求められる。"

#. type: TP
#: build/C/man3/getaddrinfo.3:157
#, no-wrap
msgid "I<ai_socktype>"
msgstr "I<ai_socktype>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:166
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr ""
"このフィールドは推奨のソケット型 (例えば B<SOCK_STREAM> や B<SOCK_DGRAM>)  を"
"指定する。 このフィールドに 0 を指定すると、任意のソケット型のソケットアドレ"
"スを B<getaddrinfo>()  が返してよいことを意味する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:166
#, no-wrap
msgid "I<ai_protocol>"
msgstr "I<ai_protocol>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:172
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol "
"can be returned by B<getaddrinfo>()."
msgstr ""
"このフィールドは返されるソケットアドレスのプロトコルを指定する。 このフィール"
"ドに 0 を指定すると、任意のプロトコルののソケットアドレスを B<getaddrinfo>"
"()  が返してよいことを意味する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:172
#, no-wrap
msgid "I<ai_flags>"
msgstr "I<ai_flags>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:176
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr ""
"このフィールドは、追加のオプション (下記) を指定する。 複数のフラグを指定する"
"際には、それらのビット単位の OR をとって指定する。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:194
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a NULL pointer, as appropriate.  Specifying I<hints> as NULL is "
"equivalent to setting I<ai_socktype> and I<ai_protocol> to 0; I<ai_family> "
"to B<AF_UNSPEC>; and I<ai_flags> to B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>."
msgstr ""
"I<hints> が指し示す構造体の他のすべてのフィールドには 0 か NULL ポインタを適"
"切に入れなければならない。 I<hints> に NULL を指定するのは、 I<ai_socktype> "
"と I<ai_protocol> に 0 を、 I<ai_family> に B<AF_UNSPEC> を、 I<ai_flags> に "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> を設定するのと等価である。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:212
msgid ""
"I<node> specifies either a numerical network address (for IPv4, numbers-and-"
"dots notation as supported by B<inet_aton>(3); for IPv6, hexadecimal string "
"format as supported by B<inet_pton>(3)), or a network hostname, whose "
"network addresses are looked up and resolved.  If I<hints.ai_flags> contains "
"the B<AI_NUMERICHOST> flag then I<node> must be a numerical network "
"address.  The B<AI_NUMERICHOST> flag suppresses any potentially lengthy "
"network host address lookups."
msgstr ""
"I<node> には、数値形式のネットワークアドレス (IPv4 の場合は B<inet_aton>(3)  "
"でサポートされているドット区切りの数字による表記、 IPv6 の場合は B<inet_pton>"
"(3)  でサポートされている 16 進数の文字列形式) もしくは ネットワークホスト名"
"を指定する。 ネットワークホスト名を指定した場合には、そのネットワークアドレス"
"が検索され、 名前解決が行なわれる。 I<hints.ai_flags> に B<AI_NUMERICHOST> フ"
"ラグが含まれている場合は、 I<node> は数値形式のネットワークアドレスでなければ"
"ならない。 B<AI_NUMERICHOST> フラグを使うと、時間の掛かる可能性のあるネット"
"ワークホストアドレスの検索は すべて抑制される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:237
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the hosts's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr ""
"I<hints.ai_flags> に B<AI_PASSIVE> フラグが指定され、かつ I<node> が NULL の"
"場合、 返されるソケットアドレスは コネクションを B<accept>(2)  するためのソ"
"ケットを B<bind>(2)  するのに適したものとなる。 返されるソケットアドレスには"
"「ワイルドカード・アドレス」 (IPv4 アドレスの場合は B<INADDR_ANY>、 IPv6 アド"
"レスの場合は B<IN6ADDR_ANY_INIT>)  が入る。 ワイルドカード・アドレスは、任意"
"のホストのネットワークアドレスで接続を 受け付けようとするアプリケーション (通"
"常はサーバー) で用いられる。 I<node> が NULL でない場合、 B<AI_PASSIVE> フラ"
"グは無視される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:257
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned "
"socket addresses will be suitable for use with B<connect>(2), B<sendto>(2), "
"or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set "
"to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr ""
"I<hints.ai_flags> に B<AI_PASSIVE> フラグがセットされていない場合、 返される"
"ソケットアドレスは B<connect>(2), B<sendto>(2), B<sendmsg>(2)  での使用に適し"
"たものとなる。 I<node> が NULL の場合、ネットワークアドレスにはループバック・"
"インターフェイスの アドレス (IPv4 アドレスの場合は B<INADDR_LOOPBACK> IPv6 ア"
"ドレスの場合は B<IN6ADDR_LOOPBACK_INIT>)B<が設定される。> これは同じホスト上"
"で動作している接続相手と通信するような アプリケーションで用いられる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:280
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal "
"number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left "
"uninitialized.  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and "
"I<service> is not NULL, then I<service> must point to a string containing a "
"numeric port number.  This flag is used to inhibit the invocation of a name "
"resolution service in cases where it is known not to be required."
msgstr ""
"I<service> により、返される各アドレス構造体のポート番号が決まる。 この引き数"
"がサービス名 (B<services>(5)  参照) の場合、対応するポート番号に翻訳される。 "
"この引き数には 10 進数も指定することができ、 この場合にはバイナリへの変換だけ"
"が行われる。 I<service> が NULL の場合、返されるソケットアドレスのポート番号"
"は 初期化されないままとなる。 I<hints.ai_flags> に B<AI_NUMERICSERV> が指定さ"
"れ、かつ I<service> が NULL でない場合、 I<service> は数値のポート番号を含む"
"文字列を指し示さなければならない。 このフラグは、名前解決サービスが不要である"
"ことが分かっている場合に、 サービスの起動を抑制するために用いられる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:286
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr ""
"I<node> と I<service> のどちらかは NULL にしてよいが、両方同時に NULL にして"
"はならない。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:302
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns "
"a pointer to the start of the list in I<res>.  The items in the linked list "
"are linked by the I<ai_next> field."
msgstr ""
"B<getaddrinfo>()  関数は、 I<addrinfo> 構造体のメモリ確保を行い、 "
"I<addrinfo> 構造体のリンクリストを初期化し、 I<res> にリストの先頭へのポイン"
"タを入れて返す。 このとき、各構造体のネットワークアドレスは I<node> と "
"I<service> に一致し、 I<hints> で課されたすべての制限を満たすものとなる。 リ"
"ンクリストの要素は I<ai_next> フィールドにより連結される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:324
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible "
"over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the same "
"service is available from multiple socket types (one B<SOCK_STREAM> address "
"and another B<SOCK_DGRAM> address, for example).  Normally, the application "
"should try using the addresses in the order in which they are returned.  The "
"sorting function used within B<getaddrinfo>()  is defined in RFC\\ 3484; the "
"order can be tweaked for a particular system by editing I</etc/gai.conf> "
"(available since glibc 2.5)."
msgstr ""
"リンクリストの I<addrinfo> 構造体は複数個になることもあり、その理由はいくつか"
"ある。 ネットワークホストがマルチホームである、 複数のプロトコルでアクセスで"
"きる (例えば B<AF_INET> と B<AF_INET6> の両方) 、 複数のソケット種別で同じ"
"サービスが利用できる (例えば、ひとつが B<SOCK_STREM> アドレスで、もうひとつ"
"が B<SOCK_DGRAM> アドレスである)、がある。 通常は、アプリケーションは返された"
"順序でアドレスを試すべきである。 B<getaddrinfo>()  の中で使用される並べ替え関"
"数は RFC\\ 3484 で定義されている。 特殊なシステムでは、 I</etc/gai.conf> を編"
"集することで、この順序を微調整することができる (I</etc/gai.conf> は glibc "
"2.5 以降で利用できる)。"

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: build/C/man3/getaddrinfo.3:339
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr ""
"I<hints.ai_flags> に B<AI_CANONNAME> フラグが含まれている場合、返されるリスト"
"の最初の I<addrinfo> 構造体の I<ai_canonname> フィールドはホストの公式な名前"
"を指すように設定される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:343
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr ""
"返される各々の I<addrinfo> 構造体の残りのフィールドは以下のように初期化され"
"る。"

#. type: IP
#: build/C/man3/getaddrinfo.3:343 build/C/man3/getaddrinfo.3:366
#: build/C/man3/getaddrinfo_a.3:191 build/C/man3/getaddrinfo_a.3:195
#: build/C/man3/getaddrinfo_a.3:197 build/C/man5/nsswitch.conf.5:144
#: build/C/man5/nsswitch.conf.5:148 build/C/man7/unix.7:74
#: build/C/man7/unix.7:91 build/C/man7/unix.7:111
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:366
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr ""
"I<ai_family>, I<ai_socktype>, I<ai_protocol> フィールドはソケット生成パラメー"
"タを返す (これらのフィールドの意味は B<socket>(2)  の同じ名前の引き数と同じで"
"ある)。 例えば、 I<ai_family> は B<AF_INET> や B<AF_INET6> を返し、 "
"I<ai_socktype> は B<SOCK_DGRAM> や B<SOCK_STREAM> を返し、 I<ai_protocol> は"
"そのソケットのプロトコルを返す。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:373
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> field."
msgstr ""
"I<ai_addr> フィールドにはソケットアドレスへのポインタが書き込まれ、 "
"I<ai_addrlen> フィールドにはソケットアドレスの長さがバイト単位で書き込まれ"
"る。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:385
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses "
"are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are returned only "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address."
msgstr ""
"I<hints.ai_flags> が B<AI_ADDRCONFIG> を含む場合、 I<res> が指すリスト\n"
"には、ローカルシステムに最低一つの IPv4 アドレスが設定されている場合のみ\n"
"IPv4 アドレスが返され、 ローカルシステムに最低一つの IPv6 アドレスが\n"
"設定されている場合にのみ IPv6 アドレスが返される。なお、この場合には、\n"
"ループバックアドレスは有効に設定されたアドレスとはみなされない。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:410
msgid ""
"If I<hints.ai_flags> specifies the B<AI_V4MAPPED> flag, and I<hints."
"ai_family> was specified as B<AF_INET6>, and no matching IPv6 addresses "
"could be found, then return IPv4-mapped IPv6 addresses in the list pointed "
"to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified in I<hints."
"ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses in the list "
"pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is not also "
"specified."
msgstr ""
"I<hints.ai_flags> に B<AI_V4MAPPED> が指定されていて、 I<hints.ai_family> に "
"B<AF_INET6> が指定され、 マッチする IPv6 アドレスが見つからなかった場合、 "
"I<res> が指すリストには IPv4-mapped IPv6 アドレスが返される。 I<hints."
"ai_flags> に B<AI_V4MAPPED> と B<AI_ALL> の両方が指定されている場合、 I<res> "
"が指すリストには IPv6 アドレスと IPv4-mapped IPv6 アドレスの 両方が返され"
"る。 B<AI_V4MAPPED> が指定されていない場合、 B<AI_ALL> は無視される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:416
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr ""
"B<freeaddrinfo>()  関数は、 リンクリスト I<res> に対して動的に割り当てられた"
"メモリを解放する。"

#. type: SS
#: build/C/man3/getaddrinfo.3:416
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr "国際化ドメイン名のための getaddrinfo() の拡張"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:425
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr ""
"glibc 2.3.4 から、 B<getaddrinfo>()  は入出力するホスト名を透過的に国際化ドメ"
"イン名 (IDN) 形式 (RFC 3490 の I<Internationalizing Domain Names in "
"Applications (IDNA)> を参照のこと) と変換することを選択的に認めるように拡張さ"
"れている。 4 つの新しいフラグが定義されている:"

#. type: TP
#: build/C/man3/getaddrinfo.3:425
#, no-wrap
msgid "B<AI_IDN>"
msgstr "B<AI_IDN>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:431
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr ""
"このフラグが指定されると、 I<node> で与えられたノード名は必要があれば IDN 形"
"式に変換される。 ソース符号化形式は現在のロケールのものである。"

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:443
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain non-"
"ASCII characters are encoded using ASCII Compatible Encoding (ACE)  before "
"being passed to the name resolution functions."
msgstr ""
"入力名に非 ASCII 文字が含まれている場合、 IDN 符号化形式が使われる。 非 "
"ASCII 文字が含まれている(ピリオドで区切られる)部分ノード名は、 名前解決機能に"
"渡される前に ASCII 互換符号化形式 (ACE) を使って 符号化される。"

#. type: TP
#: build/C/man3/getaddrinfo.3:443
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr "B<AI_CANONIDN>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:455
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution function."
msgstr ""
"B<AI_CANONNAME> が指定されている場合、 B<getaddrinfo>()  は名前の検索に成功し"
"た後、 返された I<addrinfo> 構造体に対応するノードの正規名を返す。 返り値は名"
"前解決機能から返された値の正確なコピーである。"

#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:468
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's "
"encoding."
msgstr ""
"B<AI_CANONIDN> 名前が ACE で符号化されている場合、一つまたは複数の名前の構成"
"要素の先頭に I<xn--> を含んでいる。 これらの構成要素を読み込み可能な形に変換"
"するために、 B<AI_CANONNAME> と共に B<AI_CANONIDN> フラグを渡すことも出来"
"る。 返される文字列は現在のロケールの符号化形式で符号化されている。"

#. type: TP
#: build/C/man3/getaddrinfo.3:468
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:475 build/C/man3/getnameinfo.3:139
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the "
"IDNA handling."
msgstr ""
"これらのフラグをセットすると、IDNA 処理で使用されるフラグ "
"IDNA_ALLOW_UNASSIGNED (未割り当ての Unicode のコードポイントを許容) と "
"IDNA_USE_STD3_ASCII_RULES (出力が STD3 準拠のホスト名かをチェックする)  がそ"
"れぞれ有効になる。"

#. type: SH
#: build/C/man3/getaddrinfo.3:475 build/C/man3/getaddrinfo_a.3:242
#: build/C/man3/gethostbyname.3:283 build/C/man3/getipnodebyname.3:186
#: build/C/man3/getnameinfo.3:139 build/C/man3/getnetent.3:130
#: build/C/man3/getnetent_r.3:118 build/C/man2/getpeername.2:68
#: build/C/man3/getprotoent.3:123 build/C/man3/getprotoent_r.3:108
#: build/C/man3/getservent.3:142 build/C/man3/getservent_r.3:107
#: build/C/man3/inet_ntop.3:83 build/C/man3/inet_pton.3:116
#: build/C/man3/rcmd.3:239 build/C/man3/resolver.3:245
#: build/C/man3/setnetgrent.3:86 build/C/man2/shutdown.2:69
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.  #ifdef __USE_GNU
#.  #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.  #define EAI_CANCELED    -101  /* Request canceled.  */
#.  #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.  #define EAI_ALLDONE     -103  /* All requests done.  */
#.  #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.  #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.  #endif
#. type: Plain text
#: build/C/man3/getaddrinfo.3:489
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr ""
"B<getaddrinfo>()  は成功すると 0 を返し、失敗すると以下の非 0 のエラーコード"
"のいずれかを返す。"

#. type: TP
#: build/C/man3/getaddrinfo.3:489
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr "B<EAI_ADDRFAMILY>"

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:494
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr ""
"指定されたネットワークホストには、 要求されたアドレスファミリーのネットワーク"
"アドレスがない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:494 build/C/man3/getaddrinfo_a.3:247
#: build/C/man3/getaddrinfo_a.3:264 build/C/man3/getnameinfo.3:155
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr "B<EAI_AGAIN>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:498
msgid ""
"The name server returned a temporary failure indication.  Try again later."
msgstr ""
"ネームサーバーから一時的な失敗 (temporary failure)  を意味する返事が返され"
"た。後でもう一度試してみよ。"

#. type: TP
#: build/C/man3/getaddrinfo.3:498 build/C/man3/getnameinfo.3:159
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr "B<EAI_BADFLAGS>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:508
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr ""
"I<hints.ai_flags> のフラグに不正なフラグが含まれている。または、 I<hints."
"ai_flags> に B<AI_CANONNAME> が含まれていて、かつ I<name> が NULL であった。"

#. type: TP
#: build/C/man3/getaddrinfo.3:508 build/C/man3/getnameinfo.3:164
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr "B<EAI_FAIL>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:511
msgid "The name server returned a permanent failure indication."
msgstr ""
"ネームサーバーから恒久的な失敗 (permanent failure)  を意味する返事が返され"
"た。"

#. type: TP
#: build/C/man3/getaddrinfo.3:511 build/C/man3/getnameinfo.3:167
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr "B<EAI_FAMILY>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:514
msgid "The requested address family is not supported."
msgstr "要求されたアドレスファミリーがサポートされていない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:514 build/C/man3/getaddrinfo_a.3:252
#: build/C/man3/getnameinfo.3:171
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr "B<EAI_MEMORY>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:517 build/C/man3/getaddrinfo_a.3:255
#: build/C/man3/getnameinfo.3:174 build/C/man7/unix.7:361
msgid "Out of memory."
msgstr "メモリが足りない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:517
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr "B<EAI_NODATA>"

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:522
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr ""
"指定されたネットワークホストは存在するが、 ネットワークアドレスがひとつも定義"
"されていない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:522 build/C/man3/getnameinfo.3:174
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr "B<EAI_NONAME>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:539
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service> "
"was not a numeric port-number string."
msgstr ""
"I<node> と I<service> のどちらかが不明、または I<node> と I<service> の両方"
"が NULL だった場合、または B<AI_NUMERICSERV> が I<hints.ai_flags> に指定され"
"ていて、 I<hints.ai_flags> と I<service> が数値のポート番号の文字列でない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:539
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr "B<EAI_SERVICE>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:560
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could "
"occur if I<service> was \"shell\" (a service available only on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or I<hints."
"ai_socktype> was B<SOCK_DGRAM>; or the error could occur if I<service> was "
"not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket type that does "
"not support the concept of services)."
msgstr ""
"要求されたサービスは、要求されたソケットタイプでは利用できない。 他のソケット"
"タイプでなら利用可能かもしれない。 このエラーが発生する例としては、 "
"I<service> が \"shell\" (ストリーム・ソケットでのみ利用できるサービス) で、 "
"I<hints.ai_protocol> に B<IPPROTO_UDP> が指定されたり、 I<hints.ai_socktype> "
"に B<SOCK_DGRAM> が指定されたりした場合がある。 また、 I<service> が NULL 以"
"外で、 I<hints.ai_socktype> に B<SOCK_RAW> (サービスの考え方をサポートしてい"
"ないソケット種別)  が指定された場合にも、このエラーが発生する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:560
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr "B<EAI_SOCKTYPE>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:572
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr ""
"要求されたソケットタイプがサポートされていない。 このエラーが発生する例として"
"は、 I<hints.ai_socktype> と I<hints.ai_protocol> が矛盾している場合 (例えば "
"I<hints.ai_socktype> が B<SOCK_DGRAM> で I<hints.ai_protocol> が "
"B<IPPROTO_TCP>)  がある。"

#. type: TP
#: build/C/man3/getaddrinfo.3:572 build/C/man3/getaddrinfo_a.3:255
#: build/C/man3/getnameinfo.3:187
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr "B<EAI_SYSTEM>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:577
msgid "Other system error, check I<errno> for details."
msgstr "その他のシステムエラー。詳しくは I<errno> を調べること。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:582
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""
"B<gai_strerror>()  関数を用いると、これらのエラーコードを人間に可読な文字列に"
"変換できるので、 エラー報告に適するだろう。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:589
msgid ""
"POSIX.1-2001.  The B<getaddrinfo>()  function is documented in RFC\\ 2553."
msgstr "POSIX.1-2001.  B<getaddrinfo>()  関数は RFC 2553 に記載されている。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:594
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr ""
"B<getaddrinfo>()  は、IPv6 scope-ID を指定するために I<address>B<%>I<scope-"
"id> 記法をサポートしている。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:602
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, B<AI_V4MAPPED> は glibc 2.3.3 以降で利用可能であ"
"る。 B<AI_NUMERICSERV> は glibc 2.3.4 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:612
msgid ""
"According to POSIX.1-2001, specifying I<hints> as NULL should cause "
"I<ai_flags> to be assumed as 0.  The GNU C library instead assumes a value "
"of B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr ""
"POSIX.1-2001 によると、 I<hints> に NULL が指定された場合、 I<ai_flags> を 0 "
"とみなすべきとされている。 GNU C ライブラリでは、この場合に、代わりに "
"I<ai_flags> を B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> とみなすようになってい"
"る。 この値の方が標準規格の改善になると考えられているからである。"

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: build/C/man3/getaddrinfo.3:626
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr ""
"以下のプログラムは、 B<getaddrinfo>(), B<gai_strerror>(), B<freeaddrinfo>(), "
"B<getnameinfo>(3)  の使い方を示したものである。 プログラムは UDP データグラム"
"の echo サーバとクライアントである。"

#. type: SS
#: build/C/man3/getaddrinfo.3:626
#, no-wrap
msgid "Server program"
msgstr "サーバのプログラム"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:636
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>  \n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:638 build/C/man3/getaddrinfo.3:733
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr "#define BUF_SIZE 500\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:649
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:654
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:663
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:669
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:674
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:680
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype, \n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:683
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:686 build/C/man3/getaddrinfo.3:779
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr ""
"        close(sfd);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:691
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:693 build/C/man3/getaddrinfo.3:786
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr "    freeaddrinfo(result);           /* No longer needed */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:695
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr "    /* Read datagrams and echo them back to sender */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:702
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(struct sockaddr_storage);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(struct sockaddr_storage);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:704
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:713
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"       if (s == 0)\n"
"            printf(\"Received %ld bytes from %s:%s\\en\",\n"
"                    (long) nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"       if (s == 0)\n"
"            printf(\"Received %ld bytes from %s:%s\\en\",\n"
"                    (long) nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:720
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"

#. type: SS
#: build/C/man3/getaddrinfo.3:721
#, no-wrap
msgid "Client program"
msgstr "クライアントのプログラム"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:731
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:743
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s, j;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s, j;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:748
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:750
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr "    /* Obtain address(es) matching host/port */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:756
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:762
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:767
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:773
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:776
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:784
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:789
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr ""
"    /* Send remaining command-line arguments as separate \n"
"       datagrams, and read responses from server */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:793
#, no-wrap
msgid ""
"    for (j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr ""
"    for (j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:799
#, no-wrap
msgid ""
"        if (len + 1 E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr ""
"        if (len + 1 E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:804
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:810
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:813
#, no-wrap
msgid ""
"        printf(\"Received %ld bytes: %s\\en\", (long) nread, buf);\n"
"    }\n"
msgstr ""
"        printf(\"Received %ld bytes: %s\\en\", (long) nread, buf);\n"
"    }\n"

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:827
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"
msgstr ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"

#. type: TH
#: build/C/man3/getaddrinfo_a.3:29
#, no-wrap
msgid "GETADDRINFO_A"
msgstr "GETADDRINFO_A"

#. type: TH
#: build/C/man3/getaddrinfo_a.3:29
#, no-wrap
msgid "2010-09-27"
msgstr "2010-09-27"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:33
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:40
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:43
#, no-wrap
msgid ""
"B<int gai_suspend(struct gaicb *>I<list[]>B<, int >I<nitems>B<,>\n"
"B<                struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int gai_suspend(struct gaicb *>I<list[]>B<, int >I<nitems>B<,>\n"
"B<                struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:45
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_error(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:47
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:49
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr "I<-lanl> でリンクする。\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:57
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as B<getaddrinfo>"
"(3), but allows multiple name look-ups to be performed asynchronously, with "
"optional notification on completion of look-up operations."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:61
msgid "The I<mode> argument has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:61
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr "B<GAI_WAIT>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:65
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have "
"completed."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:65
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr "B<GAI_NOWAIT>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:73
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:88
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up "
"operations are started in parallel.  NULL elements in I<list> are ignored.  "
"Each request is described by a I<gaicb> structure, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:97
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:128
msgid ""
"The elements of this structure correspond to the arguments of B<getaddrinfo>"
"(3).  Thus, I<ar_name> corresponds to the I<node> argument and I<ar_service> "
"to the I<service> argument, identifying an Internet host and a service.  The "
"I<ar_request> element corresponds to the I<hints> argument, specifying the "
"criteria for selecting the returned socket address structures.  Finally, "
"I<ar_result> corresponds to the I<res> argument; you do not need to "
"initialize this element, it will be automatically set when the request is "
"resolved.  The I<addrinfo> structure referenced by the last two elements is "
"described in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:144
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:144
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:147
msgid "Don't provide any notification."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:147
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:163
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:163
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:171
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:180
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point I<sevp-"
"E<gt>sigev_value.sival_ptr> to I<list>."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:191
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:195
msgid "One or more of the operations in I<list> completes."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:197
msgid "The call is interrupted by a signal that is caught."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:210
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:215
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:225
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:242
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELLED> and normal asynchronous notification will be performed.  "
"The request cannot be canceled if it is currently being processed; in that "
"case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:247
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:252
msgid ""
"The resources necessary to enqueue the look-up requests were not available.  "
"The application may check the error status of each request to determine "
"which ones failed."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:259
msgid "I<mode> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:264
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:267
msgid ""
"The given timeout expired before any of the requests could be completed."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:267 build/C/man3/getaddrinfo_a.3:297
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr "B<EAI_ALLDONE>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:270
msgid "There were no actual requests given to the function."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:270
#, no-wrap
msgid "B<EAI_INTR>"
msgstr "B<EAI_INTR>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:275
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:287
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELLED> if the request has been canceled "
"explicitly before it could be finished."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:291
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:291
#, no-wrap
msgid "B<EAI_CANCELLED>"
msgstr "B<EAI_CANCELLED>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:294
msgid "The request has been canceled successfully."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:294
#, no-wrap
msgid "B<EAI_NOTCANCELLED>"
msgstr "B<EAI_NOTCANCELLED>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:297
msgid "The request has not been canceled."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:300
msgid "The request has already completed."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:305 build/C/man3/getnameinfo.3:197
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""
"B<gai_strerror>(3) 関数を使うと、これらのエラー・コードを、エラー・レポートに"
"適した 人間が読みやすい文字列に翻訳してくれる。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:308
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:314
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)  "
"interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:318
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo_a.3:318
#, no-wrap
msgid "Synchronous example"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:323
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:330
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:334
msgid "Here is the program source code"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:341 build/C/man3/getaddrinfo_a.3:430
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:349
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:354
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:364
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:371
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:377
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:387
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:394
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SS
#: build/C/man3/getaddrinfo_a.3:395
#, no-wrap
msgid "Asynchronous example"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:400
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:402
msgid "An example session might look like this:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:419
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:423
msgid "The program source is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:433
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:438
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:442
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:445
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:448
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr ""
"    return buf;\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:456
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:460
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"
msgstr ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:464
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:466
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr "    /* Queue nreqs_base..nreqs requests. */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:475
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:484
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int i, ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int i, ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:487 build/C/man3/getaddrinfo_a.3:524
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:492 build/C/man3/getaddrinfo_a.3:529
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:495
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:505
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:509
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:514
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:521
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:535
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:543
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int i, ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int i, ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:547
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:550
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:565
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:571
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:574
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:599
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:607
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"

#. type: TH
#: build/C/man1/getent.1:24
#, no-wrap
msgid "GETENT"
msgstr "GETENT"

#. type: TH
#: build/C/man1/getent.1:24
#, no-wrap
msgid "2013-03-15"
msgstr "2013-03-15"

#. type: TH
#: build/C/man1/getent.1:24
#, no-wrap
msgid "User Commands"
msgstr "User Commands"

#. type: Plain text
#: build/C/man1/getent.1:27
msgid "getent - get entries from Name Service Switch libraries"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:30
msgid "B<getent> I<database> [I<key> ...]"
msgstr "B<getent> I<database> [I<key> ...]"

#. type: Plain text
#: build/C/man1/getent.1:45
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If "
"one or more I<key> arguments are provided, then only the entries that match "
"the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:49
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:50
#, no-wrap
msgid "B<ahosts>"
msgstr "B<ahosts>"

#. type: Plain text
#: build/C/man1/getent.1:71
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:71
#, no-wrap
msgid "B<ahostsv4>"
msgstr "B<ahostsv4>"

#. type: Plain text
#: build/C/man1/getent.1:77
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:77
#, no-wrap
msgid "B<ahostsv6>"
msgstr "B<ahostsv6>"

#. type: Plain text
#: build/C/man1/getent.1:88
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:88 build/C/man5/nsswitch.conf.5:44
#, no-wrap
msgid "B<aliases>"
msgstr "B<aliases>"

#. type: Plain text
#: build/C/man1/getent.1:105
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:105 build/C/man5/nsswitch.conf.5:49
#, no-wrap
msgid "B<ethers>"
msgstr "B<ethers>"

#. type: Plain text
#: build/C/man1/getent.1:121
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:121 build/C/man5/nsswitch.conf.5:52
#, no-wrap
msgid "B<group>"
msgstr "B<group>"

#. type: Plain text
#: build/C/man1/getent.1:142
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each "
"nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:142
#, no-wrap
msgid "B<gshadow>"
msgstr "B<gshadow>"

#. type: Plain text
#: build/C/man1/getent.1:159
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:159 build/C/man5/nsswitch.conf.5:57
#, no-wrap
msgid "B<hosts>"
msgstr "B<hosts>"

#. type: Plain text
#: build/C/man1/getent.1:182
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the "
"result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:182 build/C/man5/nsswitch.conf.5:62
#, no-wrap
msgid "B<initgroups>"
msgstr "B<initgroups>"

#. type: Plain text
#: build/C/man1/getent.1:196
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:196 build/C/man5/nsswitch.conf.5:67
#, no-wrap
msgid "B<netgroup>"
msgstr "B<netgroup>"

#. type: Plain text
#: build/C/man1/getent.1:222
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username> and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on "
"B<netgroup>, so either one or three I<keys> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:222 build/C/man5/nsswitch.conf.5:71
#, no-wrap
msgid "B<networks>"
msgstr "B<networks>"

#. type: Plain text
#: build/C/man1/getent.1:243
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to B<getnetbyaddr>"
"(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and display the "
"result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:243 build/C/man5/nsswitch.conf.5:76
#, no-wrap
msgid "B<passwd>"
msgstr "B<passwd>"

#. type: Plain text
#: build/C/man1/getent.1:264
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each "
"nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:264 build/C/man5/nsswitch.conf.5:81
#, no-wrap
msgid "B<protocols>"
msgstr "B<protocols>"

#. type: Plain text
#: build/C/man1/getent.1:285
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:285 build/C/man5/nsswitch.conf.5:89
#, no-wrap
msgid "B<rpc>"
msgstr "B<rpc>"

#. type: Plain text
#: build/C/man1/getent.1:306
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:306 build/C/man5/nsswitch.conf.5:94
#, no-wrap
msgid "B<services>"
msgstr "B<services>"

#. type: Plain text
#: build/C/man1/getent.1:327
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to B<getservbynumber>"
"(3)  and each nonnumeric I<key> to B<getservbyname>(3)  and display the "
"result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:327 build/C/man5/nsswitch.conf.5:99
#, no-wrap
msgid "B<shadow>"
msgstr "B<shadow>"

#. type: Plain text
#: build/C/man1/getent.1:344
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr ""

#. type: SH
#: build/C/man1/getent.1:345
#, no-wrap
msgid "EXIT STATUS"
msgstr "終了ステータス"

#. type: Plain text
#: build/C/man1/getent.1:348
msgid "One of the following exit values can be returned by B<getent>:"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:349
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: build/C/man1/getent.1:352
msgid "Command completed successfully."
msgstr "コマンドが正常に完了した。"

#. type: TP
#: build/C/man1/getent.1:352
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: build/C/man1/getent.1:357
msgid "Missing arguments, or I<database> unknown."
msgstr "引き数が不足しているか、 知らない I<database> が指定された。"

#. type: TP
#: build/C/man1/getent.1:357
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: build/C/man1/getent.1:363
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr "指定された I<key> が I<database> で見つからなかった。"

#. type: TP
#: build/C/man1/getent.1:363
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man1/getent.1:367
msgid "Enumeration not supported on this I<database>."
msgstr "この I<database> では列挙はサポートされていない。"

#. type: Plain text
#: build/C/man1/getent.1:370
msgid "B<nsswitch.conf>(5)"
msgstr "B<nsswitch.conf>(5)"

#. type: TH
#: build/C/man3/gethostbyname.3:38
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr "GETHOSTBYNAME"

#. type: TH
#: build/C/man3/gethostbyname.3:38
#, fuzzy, no-wrap
#| msgid "2013-07-04"
msgid "2013-09-04"
msgstr "2013-07-04"

#. type: Plain text
#: build/C/man3/gethostbyname.3:46
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - ネットワーク上のホストのエントリを取得する"

#. type: Plain text
#: build/C/man3/gethostbyname.3:50
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:52
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:56
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>       /* AF_INET を使う場合 */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr "B<void sethostent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr "B<void endhostent(void);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:62
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr "B<void herror(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:64
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr "B<const char *hstrerror(int >I<err>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:66
#, no-wrap
msgid "/* System V/POSIX extension */\n"
msgstr "/* System V/POSIX 拡張 */\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:68
#, no-wrap
msgid "B<struct hostent *gethostent(void);>\n"
msgstr "B<struct hostent *gethostent(void);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:72
#, no-wrap
msgid "B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr "B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:76
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:80
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:84
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:88
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:102
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"

#. type: Plain text
#: build/C/man3/gethostbyname.3:104 build/C/man3/gethostbyname.3:112
#: build/C/man3/getnetent_r.3:60 build/C/man3/getprotoent_r.3:57
#: build/C/man3/getservent_r.3:57
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/gethostbyname.3:108
msgid "B<herror>(), B<hstrerror>():"
msgstr "B<herror>(), B<hstrerror>():"

#. type: TP
#: build/C/man3/gethostbyname.3:109 build/C/man3/gethostbyname.3:122
#, fuzzy, no-wrap
#| msgid "Since glibc 2.8:"
msgid "Since glibc 2.12:"
msgstr "glibc 2.8 以降:"

#. type: TP
#: build/C/man3/gethostbyname.3:112
#, no-wrap
msgid "From glibc 2.8 to glibc 2.11:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:115
msgid "_BSD_SOURCE || _SVID_SOURCE || _GNU_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _GNU_SOURCE"

#. type: TP
#: build/C/man3/gethostbyname.3:115
#, no-wrap
msgid "Before glibc 2.8:"
msgstr "glibc 2.8 より前:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:118 build/C/man3/gethostbyname.3:129
msgid "none"
msgstr "なし"

#. type: Plain text
#: build/C/man3/gethostbyname.3:121
msgid "B<h_errno>:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:126
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_POSIX_C_SOURCE E<lt> 200809L && _XOPEN_SOURCE E<lt> 700)\n"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:126
#, fuzzy, no-wrap
#| msgid "Before glibc 2.8:"
msgid "Before glibc 2.12:"
msgstr "glibc 2.8 より前:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:146
#, fuzzy
#| msgid ""
#| "The B<gethostbyname*>()  and B<gethostbyaddr*>()  functions are "
#| "obsolete.  Applications should use B<getaddrinfo>(3)  and B<getnameinfo>"
#| "(3)  instead."
msgid ""
"The B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), and B<hstrerror>"
"()  functions are obsolete.  Applications should use B<getaddrinfo>(3), "
"B<getnameinfo>(3), and B<gai_strerror>(3)  instead."
msgstr ""
"B<gethostbyname*>()  と B<gethostbyaddr*>()  は過去のものである。 アプリケー"
"ションでは、代わりに B<getaddrinfo>(3)  と B<getnameinfo>(3)  を使用するこ"
"と。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:187
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname, or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)), or an IPv6 "
"address in colon (and possibly dot) notation.  (See RFC\\ 1884 for the "
"description of IPv6 addresses.)  If I<name> is an IPv4 or IPv6 address, no "
"lookup is performed and B<gethostbyname>()  simply copies I<name> into the "
"I<h_name> field and its I<struct in_addr> equivalent into the I<h_addr_list"
"[0]> field of the returned I<hostent> structure.  If I<name> doesn't end in "
"a dot and the environment variable B<HOSTALIASES> is set, the alias file "
"pointed to by B<HOSTALIASES> will first be searched for I<name> (see "
"B<hostname>(7)  for the file format).  The current domain and its parents "
"are searched unless I<name> ends in a dot."
msgstr ""
"B<gethostbyname>()  関数は与えられたホスト名 I<name> に対応する構造体 "
"I<hostent> を返す。 I<name> にはホスト名、ドット区切りの IPv4 アドレス "
"(B<inet_addr>(3)  参照)、コロン区切りの IPv6 アドレス (おそらくドット区切りで"
"も大丈夫)  のいずれかを指定する (IPv6 アドレスの記述方法については RFC\\ "
"1884 を参考にしてほしい)。 I<name> が IPv4 か IPv6 のアドレスだった場合、 名"
"前解決 (lookup) は行われない。その場合には、 B<gethostbyname>()  は I<name> "
"をそのまま I<hostent> 構造体の I<h_name> フィールドにコピーし、 さらに "
"I<name> を I<struct in_addr> 形式で表したデータを I<hostent> 構造体の "
"I<h_addr_list[0]> フィールドに入れて、その I<hostent> 構造体を返す。 I<name> "
"がドットで終了していて、かつ環境変数 B<HOSTALIASES> が設定されている場合、ま"
"ず B<HOSTALIASES> で指定されているエイリアスファイルから I<name> のエントリが"
"検索される (ファイルのフォーマットについては B<hostname>(7)  を参照のこと)。 "
"I<name> がドットで終了していなければ、現在のドメインとその親ドメインが検索さ"
"れる。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:203
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr ""
"B<gethostbyaddr>()  関数は与えられたホストアドレス I<addr> (長さ I<len>、 タ"
"イプ I<type>) に対応する構造体 I<hostent> を返す。 用いることのできるタイプ"
"は B<AF_INET> と B<AF_INET6> である。 ホストアドレス引き数はアドレスタイプに"
"依存した 構造体へのポインタである。 例えば、アドレスタイプ B<AF_INET> に対し"
"ては (B<inet_addr>(3)  の呼び出しで得られる)  I<struct in_addr *> である。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:210
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the "
"connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr ""
"B<sethostent>()  関数は、ネームサーバへの接続形態を指定する。 I<stayopen> が"
"真 (1) ならば、ネームサーバへの問い合わせには、 接続された TCP ソケットを用"
"い、連続した問い合わせの間に接続を維持する。 偽ならばネームサーバへの問い合わ"
"せに UDP データグラムを用いる。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:215
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr ""
"B<endhostent>()  関数はネームサーバへの問い合わせに用いた TCP 接続の利用を終"
"了する。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:220
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr ""
"(廃止予定の)  B<herror>()  関数は現在の I<h_errno> に対応するエラーメッセージ"
"を標準エラー I<stderr> に出力する。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:225
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr ""
"(廃止予定の)  B<hstrerror>()  関数はエラー番号 (通常は I<h_errno>) を引き数に"
"取り、 対応するエラーメッセージ文字列を返す。"

#.  (See
#.  .BR resolv+ (8)).
#. type: Plain text
#: build/C/man3/gethostbyname.3:242
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  use a combination of any or all of the name server "
"B<named>(8), a broken out line from I</etc/hosts>, and the Network "
"Information Service (NIS or YP), depending upon the contents of the I<order> "
"line in I</etc/host.conf>.  The default action is to query B<named>(8), "
"followed by I</etc/hosts>."
msgstr ""
"B<gethostbyname>()  と B<gethostbyaddr>()  によって実行されるドメイン名の問い"
"合わせでは、ネームサーバ B<named>(8)、 I</etc/hosts> のデータ行、および "
"Network Information Service (NIS または YP)  が組み合わせて使用される。何が使"
"用されるかは、 I</etc/host.conf> の I<order> 行の内容により決まる。 デフォル"
"トでは、まず B<named>(8)  に問い合わせを行い、次いで I</etc/hosts> を参照す"
"る。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:244
msgid "The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "I<hostent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:256
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* 過去との互換性のため */\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:260
msgid "The members of the I<hostent> structure are:"
msgstr "I<hostent> 構造体のメンバは以下の通り。"

#. type: TP
#: build/C/man3/gethostbyname.3:260 build/C/man3/getipnodebyname.3:210
#, no-wrap
msgid "I<h_name>"
msgstr "I<h_name>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:263
msgid "The official name of the host."
msgstr "ホストの正式名 (official name)。"

#. type: TP
#: build/C/man3/gethostbyname.3:263 build/C/man3/getipnodebyname.3:213
#, no-wrap
msgid "I<h_aliases>"
msgstr "I<h_aliases>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:266
msgid ""
"An array of alternative names for the host, terminated by a NULL pointer."
msgstr "ホストの別名の配列。配列は NULL ポインタで終端される。"

#. type: TP
#: build/C/man3/gethostbyname.3:266 build/C/man3/getipnodebyname.3:217
#, no-wrap
msgid "I<h_addrtype>"
msgstr "I<h_addrtype>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:273
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr "アドレスのタイプ。現在はすべて B<AF_INET> または B<AF_INET6> である。"

#. type: TP
#: build/C/man3/gethostbyname.3:273 build/C/man3/getipnodebyname.3:239
#, no-wrap
msgid "I<h_length>"
msgstr "I<h_length>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:276
msgid "The length of the address in bytes."
msgstr "バイト単位で表したアドレスの長さ。"

#. type: TP
#: build/C/man3/gethostbyname.3:276 build/C/man3/getipnodebyname.3:253
#, no-wrap
msgid "I<h_addr_list>"
msgstr "I<h_addr_list>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:280
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a NULL pointer."
msgstr ""
"ホストのネットワークアドレスへのポインタの配列。 配列は NULL ポインタで終端さ"
"れる。 ネットワークアドレスはネットワークバイトオーダ形式である。"

#. type: TP
#: build/C/man3/gethostbyname.3:280
#, no-wrap
msgid "I<h_addr>"
msgstr "I<h_addr>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:283
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr ""
"I<h_addr_list> の最初のアドレス。過去との互換性を保つためのものである。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:295
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a NULL pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr ""
"B<gethostbyname>()  および B<gethostbyaddr>()  関数は I<hostent> 構造体を返"
"す。エラーが起こったら NULL ポインタを返す。エラーの際には I<h_errno> 変数が"
"エラーの番号を保持する。 返り値が NULL でない場合、静的データをポインタで指し"
"ていることもある。 以下の「注意」を参照すること。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:297
msgid "The variable I<h_errno> can have the following values:"
msgstr "I<h_errno> 変数は以下の値を取りうる。"

#. type: TP
#: build/C/man3/gethostbyname.3:297 build/C/man3/getipnodebyname.3:190
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr "B<HOST_NOT_FOUND>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:300
msgid "The specified host is unknown."
msgstr "指定したホストが見つからない。"

#. type: TP
#: build/C/man3/gethostbyname.3:300
#, no-wrap
msgid "B<NO_ADDRESS> or B<NO_DATA>"
msgstr "B<NO_ADDRESS  または  NO_DATA>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:303
msgid "The requested name is valid but does not have an IP address."
msgstr "指定した名前は有効だが IP アドレスを持っていない。"

#. type: TP
#: build/C/man3/gethostbyname.3:303 build/C/man3/getipnodebyname.3:199
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr "B<NO_RECOVERY>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:306
msgid "A nonrecoverable name server error occurred."
msgstr "ネームサーバの復旧不能なエラーが起こった。"

#. type: TP
#: build/C/man3/gethostbyname.3:306 build/C/man3/getipnodebyname.3:202
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr "B<TRY_AGAIN>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:310
msgid ""
"A temporary error occurred on an authoritative name server.  Try again later."
msgstr ""
"authoritative なネームサーバで一時的なエラーが起こった。 時間をおいてもう一度"
"試すこと。"

#. type: TP
#: build/C/man3/gethostbyname.3:311 build/C/man5/host.conf.5:181
#, no-wrap
msgid "I</etc/host.conf>"
msgstr "I</etc/host.conf>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:314
msgid "resolver configuration file"
msgstr "名前解決の設定ファイル"

#. type: Plain text
#: build/C/man3/gethostbyname.3:314 build/C/man5/host.conf.5:187
#: build/C/man5/hosts.5:88
#, no-wrap
msgid "I</etc/hosts>"
msgstr "I</etc/hosts>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:317
msgid "host database file"
msgstr "ホストのデータベースファイル"

#. type: Plain text
#: build/C/man3/gethostbyname.3:317 build/C/man5/nsswitch.conf.5:306
#: build/C/man3/setnetgrent.3:92
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr "I</etc/nsswitch.conf>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:320
msgid "name service switch configuration"
msgstr "ネームサービス切替設定"

#. type: Plain text
#: build/C/man3/gethostbyname.3:344
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), B<sethostent>"
"(), B<endhostent>(), B<gethostent>(), and I<h_errno>; B<gethostbyname>(), "
"B<gethostbyaddr>(), and I<h_errno> are marked obsolescent in that standard.  "
"POSIX.1-2008 removes the specifications of B<gethostbyname>(), "
"B<gethostbyaddr>(), and I<h_errno>, recommending the use of B<getaddrinfo>"
"(3)  and B<getnameinfo>(3)  instead."
msgstr ""
"POSIX.1-2001 では、 B<gethostbyname>(), B<gethostbyaddr>(), B<sethostent>(), "
"B<endhostent>(), B<gethostent>(), I<h_errno> が規定されており、 "
"B<gethostbyaddr>()  と B<gethostbyname>()  は廃止予定であるとされている。 "
"POSIX.1-2008 では B<gethostbyname>(), B<gethostbyaddr>(), I<h_errno> の仕様が"
"削除されている。 代わりに、 B<getaddrinfo>(3)  と B<getnameinfo>(3)  の使用が"
"推奨されている。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:354
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr ""
"B<gethostbyname>()  および B<gethostbyaddr>()  関数は静的データへのポインタを"
"返す。 このポインタは、その後の呼び出しで上書きされるかもしれない。 "
"I<hostent> 構造体はポインタを含んでいるので、構造体のコピーだけでは不十分であ"
"る; より深いコピーが必要である。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:378
msgid ""
"In the original BSD implementation the I<len> argument of B<gethostbyname>"
"()  was an I<int>.  The SUSv2 standard is buggy and declares the I<len> "
"argument of B<gethostbyaddr>()  to be of type I<size_t>.  (That is wrong, "
"because it has to be I<int>, and I<size_t> is not.  POSIX.1-2001 makes it "
"I<socklen_t>, which is OK.)  See also B<accept>(2)."
msgstr ""
"オリジナルの BSD の実装では、 B<gethostbyname>()  の I<len> 引き数は I<int> "
"であった。 SUSv2 標準はバグが多く、 B<gethostbyaddr>()  の I<len> パラメータ"
"を I<size_t> 型として宣言している。 (これは誤りで、 I<size_t> 型ではなく "
"I<int> 型でなければならない。 POSIX.1-2001 ではこれを I<socklen_t> としている"
"が、これは OK。)  B<accept>(2)  も参照。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:384
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char\\ *> for the "
"first argument."
msgstr ""
"B<gethostbyaddr>()  の BSD のプロトタイプは、最初の引き数として I<const char"
"\\ *> を使う。"

#. type: SS
#: build/C/man3/gethostbyname.3:384
#, no-wrap
msgid "System V/POSIX extension"
msgstr "System V/POSIX 拡張"

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: build/C/man3/gethostbyname.3:401
msgid ""
"POSIX requires the B<gethostent>()  call, that should return the next entry "
"in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems a routine of this name reads from the file I</"
"etc/hosts>.  It may be available only when the library was built without DNS "
"support.  The glibc version will ignore ipv6 entries.  This function is not "
"reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr ""
"POSIX では、 B<gethostent>()  が必須とされている。 この関数はホストデータベー"
"スの次のエントリを返す。 DNS/BIND を使う場合はあまり意味を持たないが、 ホスト"
"データベースが 1 行ずつ読み込まれるファイルである場合は意味がある。 多くのシ"
"ステムでは、この名前のルーチンはファイル I</etc/hosts> を読み込む。 DNS サ"
"ポートなしでライブラリがビルドされた場合にのみ利用可能である。 glibc 版は "
"ipv6 エントリを無視する。 この関数はリエントラント (reentrant) ではなく、 "
"glibc にはリエントラント版の B<gethostent_r>()  が追加された。"

#. type: SS
#: build/C/man3/gethostbyname.3:401
#, no-wrap
msgid "GNU extensions"
msgstr "GNU 拡張"

#. type: Plain text
#: build/C/man3/gethostbyname.3:407
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr ""
"glibc2 には B<gethostbyname2>()  もあり、 B<gethostbyname>()  と同じように動"
"作するが、 こちらはアドレスが属するアドレスファミリーを指定することができる。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:441
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr ""
"glibc2 にはリエントラントな B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  と B<gethostbyname2_r>()  もある。 呼び出し側は、成功時"
"に結果が格納される I<hostent> 構造体 I<ret> と、大きさ I<buflen> の一時的な作"
"業バッファ I<buf> を提供する。 コール終了後、成功した場合 I<result> は結果を"
"指している。 エラーの場合、またはエントリが見つからなかった場合、 I<result> "
"は NULL になる。 これらの関数は、成功した場合 0 を返し、失敗の場合は 0 以外の"
"エラー番号を返す。 これらの関数のリエントラントでないバージョンが返すエラーに"
"加えて、 これらの関数は、 I<buf> が小さすぎた場合に B<ERANGE> を返す。この場"
"合はもっと大きなバッファを用意して 関数呼び出しを再度行うべきである。 大域変"
"数 I<h_errno> は変更されないが、エラー番号を格納する変数のアドレスが "
"I<h_errnop> に渡される。"

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: build/C/man3/gethostbyname.3:446
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr ""
"B<gethostbyname>()  は、16進数表現のドット区切りの IPv4 アドレス文字列の要素"
"を認識しない。"

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#.  .BR resolv+ (8)
#. type: Plain text
#: build/C/man3/gethostbyname.3:460
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"

#. type: TH
#: build/C/man3/getipnodebyname.3:26
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr "GETIPNODEBYNAME"

#. type: TH
#: build/C/man3/getipnodebyname.3:26
#, no-wrap
msgid "2010-09-04"
msgstr "2010-09-04"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:30
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr ""
"getipnodebyname, getipnodebyaddr, freehostent - ネットワークホストの名前とア"
"ドレスの取得"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:38
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:41
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:43
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr "B<void freehostent(struct hostent *>I<ip>B<);>\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:51
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""
"これらの関数は非推奨である (glibc では利用できない)。 代わりに B<getaddrinfo>"
"(3)  と B<getnameinfo>(3)  を使うこと。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:59
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr ""
"B<getipnodebyname>()  と B<getipnodebyaddr>()  は、ネットワークホストの名前と"
"アドレスを返す。 これらの関数は、以下の構造体へのポインタを返す。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:69
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:82
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could access only the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr ""
"これらの関数は、 IPv4 ネットワークアドレスファミリにしかアクセスできない "
"B<gethostbyname>(3)  や B<gethostbyaddr>(3)  を置き換えるものである。 "
"B<getipnodebyname>()  関数と B<getipnodebyaddr>()  関数は複数のネットワークア"
"ドレスファミリーにアクセス可能になっている。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:93
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr ""
"これらの関数は、 B<gethostby> の関数群と異なり、動的に割り当てられたメモリへ"
"のポインタを返す。 呼び出し元がこれらの I<hostent> 構造体を必要としなくなった"
"後は、 B<freehostent>()  関数を用いれば動的な割り当てメモリを解放できる。"

#. type: SS
#: build/C/man3/getipnodebyname.3:93
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr "getipnodebyname() の引き数"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:104
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr ""
"B<getipnodebyname>()  関数は I<name> 引き数で指定されたホストのネットワークア"
"ドレスを引く。 I<af> 引き数には以下の値のいずれかを指定する。"

#. type: TP
#: build/C/man3/getipnodebyname.3:104 build/C/man3/getipnodebyname.3:166
#: build/C/man3/inet_ntop.3:57 build/C/man3/inet_pton.3:53
#, no-wrap
msgid "B<AF_INET>"
msgstr "B<AF_INET>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:110
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr ""
"I<name> 引き数は、ドットで 4 つに区切られた IPv4 アドレスか、 IPv4 ネットワー"
"クホストの名前へのポインタである。"

#. type: TP
#: build/C/man3/getipnodebyname.3:110 build/C/man3/getipnodebyname.3:176
#: build/C/man3/inet_ntop.3:70 build/C/man3/inet_pton.3:67
#, no-wrap
msgid "B<AF_INET6>"
msgstr "B<AF_INET6>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:116
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr ""
"I<name> 引き数は、16 進の IPv6 アドレスか、 IPv6 ネットワークホストの名前への"
"ポインタである。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:125
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to "
"0 if no options are desired."
msgstr ""
"I<flags> パラメータには追加のオプションを指定する。 複数のフラグを指定するに"
"は、それらのビット単位の OR をとって指定すればよい。 オプションをひとつも指定"
"したくないときには、 I<flags> に 0 を設定する必要がある。"

#. type: TP
#: build/C/man3/getipnodebyname.3:125
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr "B<AI_V4MAPPED>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:132
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr ""
"このフラグは B<AF_INET6> と共に用いられ、IPv6 アドレスの代わりに IPv4 アドレ"
"スを問い合わせる。 問い合わせる IPv4 アドレスは IPv6 アドレスにマップされる。"

#. type: TP
#: build/C/man3/getipnodebyname.3:132
#, no-wrap
msgid "B<AI_ALL>"
msgstr "B<AI_ALL>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:138
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr ""
"このフラグは B<AI_V4MAPPED> と共に用いられ、IPv4 アドレスと IPv6 アドレスの両"
"方を問い合わせる。 見つかった IPv4 アドレスは、すべて IPv6 アドレスにマップさ"
"れる。"

#. type: TP
#: build/C/man3/getipnodebyname.3:138
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr "B<AI_ADDRCONFIG>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:150
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address "
"assigned to a network interface, and that queries for IPv4 addresses should "
"not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr ""
"このフラグは B<AF_INET6> と共に用いられ、 IPv6 が割り当てられたネットワークイ"
"ンターフェースが システムにひとつもなければ IPv6 アドレスの問い合わせを行わ"
"ず、 IPv4 が割り当てられたネットワークインターフェースが システムにひとつもな"
"ければ IPv4 アドレスの問い合わせを行わないように要求する。 このフラグは単独で"
"も、あるいは B<AI_V4MAPPED> フラグと共にでも用いることができる。"

#. type: TP
#: build/C/man3/getipnodebyname.3:150
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr "B<AI_DEFAULT>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:154
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr "このフラグは B<(AI_ADDRCONFIG>|B<AI_V4MAPPED)> と等価である。"

#. type: SS
#: build/C/man3/getipnodebyname.3:154
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr "getipnodebyaddr() の引き数"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:166
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr ""
"B<getipnodebyaddr>()  関数は、ネットワークアドレスが I<addr> 引き数で指定され"
"たホストの名前を引く。 I<af> 引き数には以下の値のいずれかを指定する。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:176
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to "
"I<sizeof(struct in_addr)>."
msgstr ""
"I<addr> 引き数は I<struct in_addr> へのポインターであり、 I<len> 引き数は "
"I<sizeof(struct in_addr)> に設定しなければならない。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:186
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr ""
"I<addr> 引き数は I<struct in6_addr> へのポインターであり、 I<len> 引き数は "
"I<sizeof(struct in6_addr)> に設定しなければならない。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:190
msgid ""
"A NULL pointer is returned if an error occurred, and I<error_num> will "
"contain an error code from the following list:"
msgstr ""
"エラーが起こるとヌル・ポインターが返され、 I<error_num> に以下にリストされた"
"エラーコードのいずれかが設定される。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:193
msgid "The hostname or network address was not found."
msgstr "ホスト名またはネットワークアドレスが見つからなかった。"

#. type: TP
#: build/C/man3/getipnodebyname.3:193
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr "B<NO_ADDRESS>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:199
msgid ""
"The domain name server recognized the network address or name, but no answer "
"was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr ""
"ドメインネームサーバーは そのネットワークアドレスまたはネットワーク名を認識し"
"たが、 返事が返ってこなかった。原因としては、 例えば IPv4 アドレスしか持たな"
"いネットワークホストに対して IPv6 の情報の問い合わせが行われた (およびその"
"逆) などが考えられる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:202
msgid "The domain name server returned a permanent failure response."
msgstr ""
"ドメインネームサーバーから恒久的な失敗 (permanent failure)  を意味する返事が"
"返された。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:206
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr ""
"ネームサーバーから一時的な失敗 (temporary failure)  を意味する返事が返され"
"た。次にはもうちょっと運が必要かも。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:210
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains "
"the following fields:"
msgstr ""
"問い合わせに成功すると、 I<hostent> 構造体へのポインタが返される。 この構造体"
"は以下のフィールドからなる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:213
msgid "This is the official name of this network host."
msgstr "これはこのネットワークホストのオフィシャルな名前である。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:217
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a NULL pointer."
msgstr ""
"これは、そのホストのオフィシャルでない別名へのポインターの配列である。 配列は"
"ヌル・ポインターで終端する。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:239
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr ""
"これは B<getipnodebyname>()  または B<getipnodebyaddr>()  に与えられた I<af> "
"引き数のコピーである。 I<af> 引き数が B<AF_INET> なら I<h_addrtype> は常に "
"B<AF_INET> になり、 I<af> 引き数が B<AF_INET6> なら I<h_addrtype> も常に "
"B<AF_INET6> になる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:253
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr ""
"このフィールドは、 I<h_addrtype> が B<AF_INET> なら I<sizeof(struct in_addr)"
"> に、 I<h_addrtype> が B<AF_INET6> なら I<sizeof(struct in6_addr)> に設定さ"
"れる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:258
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a NULL pointer."
msgstr ""
"これはひとつ以上のポインターの配列で、 それぞれのポインターは、 そのネット"
"ワークホストに対応するネットワークアドレス構造体を指す。 この配列はヌル・ポイ"
"ンターで終端する。"

#.  Not in POSIX.1-2001.
#. type: Plain text
#: build/C/man3/getipnodebyname.3:261
msgid "RFC\\ 2553."
msgstr "RFC\\ 2553."

#. type: Plain text
#: build/C/man3/getipnodebyname.3:266
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr ""
"これらの関数は glibc 2.1.91-95 に存在したが、再び削除された。 いくつかの "
"UNIX 風システムはこれらの関数に対応しているが、 これらの関数は全て推奨されな"
"い。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:271
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"

#. type: TH
#: build/C/man3/getnameinfo.3:10
#, no-wrap
msgid "GETNAMEINFO"
msgstr "GETNAMEINFO"

#. type: Plain text
#: build/C/man3/getnameinfo.3:13
msgid ""
"getnameinfo - address-to-name translation in protocol-independent manner"
msgstr ""
"getnameinfo - アドレスから名前への変換をプロトコルに依存しないかたちで行う"

#. type: Plain text
#: build/C/man3/getnameinfo.3:17
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:21
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<sa>B<, socklen_t >I<salen>B<,>\n"
"B<                char *>I<host>B<, size_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, size_t >I<servlen>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int getnameinfo(const struct sockaddr *>I<sa>B<, socklen_t >I<salen>B<,>\n"
"B<                char *>I<host>B<, size_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, size_t >I<servlen>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:31
msgid ""
"B<getnameinfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""
"B<getnameinfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/getnameinfo.3:47
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a protocol-"
"independent manner.  It combines the functionality of B<gethostbyaddr>(3)  "
"and B<getservbyport>(3), but unlike those functions, B<getnameinfo>()  is "
"reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies."
msgstr ""
"B<getnameinfo>()  関数は、 B<getaddrinfo>(3)  の逆の動作を行う。つまり、プロ"
"トコルに依存しないかたちで ソケットアドレスから対応するホスト名とサービスへの"
"変換を行う。 この関数は B<gethostbyaddr>(3)  と B<getservbyport>(3)  の機能を"
"一つにしたものだが、 これらの関数と違い、 B<getnameinfo>(3)  はリエントラント"
"であり、IPv4 と IPv6 の差分に依存しないかたちで プログラムを書くことができ"
"る。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:70
msgid ""
"The I<sa> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<salen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr ""
"I<sa> 引き数は、 IP アドレスとポート番号の情報を保持している 汎用的なソケット"
"アドレス構造体 (I<sockaddr_in> 型または I<sockaddr_in6> 型) へのポインタであ"
"る。 I<salen> は I<sa> のサイズである。 I<host> と I<serv> 引き数は、(それぞ"
"れサイズが I<hostlen> と I<servlen> の) 呼び出し側で確保されたバッファへのポ"
"インタであり、 ホスト名とサービス名を含む NULL 終端された文字列が それぞれの"
"バッファに格納される。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:83
msgid ""
"The caller can specify that no hostname (or no service name)  is required by "
"providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr ""
"ホスト名が不要であることをこの関数に伝えるには、 I<host> に NULL を指定する"
"か、 I<hostlen> に 0 を指定する。同様に、サービス名が不要な場合は、 I<serv> "
"に NULL を指定するか、 I<servlen> に 0 を指定する。 しかし、ホスト名とサービ"
"ス名の両方を不要だと指定することはできない (いずれか一方は要求すること)。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:89
msgid ""
"The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr ""
"I<flags> 引き数で B<getnameinfo>()  の動作を変えることができる。指定できる値"
"は以下の通り:"

#. type: TP
#: build/C/man3/getnameinfo.3:89
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr "B<NI_NAMEREQD>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:92
msgid "If set, then an error is returned if the hostname cannot be determined."
msgstr "指定すると、ホスト名が決定できなかった場合にエラーを返す。"

#. type: TP
#: build/C/man3/getnameinfo.3:92
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr "B<NI_DGRAM>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:98
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512-514)  that have different "
"services for UDP and TCP."
msgstr ""
"指定すると、ストリームベース (TCP) でなくデータグラムベース (UDP)  のサービス"
"を対象にする。数は少ないが、 UDP と TCP で違うサービスを提供しているポート "
"(512-514) に対して必要となる。"

#. type: TP
#: build/C/man3/getnameinfo.3:98
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr "B<NI_NOFQDN>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:102
msgid ""
"If set, return only the hostname part of the fully qualified domain name for "
"local hosts."
msgstr ""
"指定すると、ローカルなホストには fully qualified domain name (FQDN) の ホスト"
"名の部分のみを返す。"

#. type: TP
#: build/C/man3/getnameinfo.3:102
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr "B<NI_NUMERICHOST>"

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2003 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: build/C/man3/getnameinfo.3:112
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr ""
"指定すると、数値形式のホスト名が返される。 (指定しなくても、ノードの名前が決"
"定できない場合は数値形式が返ることがある)。"

#. type: TP
#: build/C/man3/getnameinfo.3:112
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr "B<NI_NUMERICSERV>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:117
msgid ""
"If set, then the numeric form of the service address is returned.  (When not "
"set, this will still happen in case the service's name cannot be determined.)"
msgstr ""
"指定すると、数値形式のサービス名 (例えばポート番号) が返される (指定しなくて"
"も、サービス名が決定できない場合は数値形式が返ることがある)。"

#. type: SS
#: build/C/man3/getnameinfo.3:117
#, no-wrap
msgid "Extensions to getnameinfo() for Internationalized Domain Names"
msgstr "国際化ドメイン名のための getnameinfo() の拡張"

#. type: Plain text
#: build/C/man3/getnameinfo.3:126
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags "
"are defined:"
msgstr ""
"glibc 2.3.4 から、 B<getnameinfo>()  に拡張が行われ、ホスト名と 国際化ドメイ"
"ン名 (Internationalized Domain Name; IDN) 形式との間で 透過的な変換ができるよ"
"うになっている (IDN 形式については RFC 3490 の I<Internationalizing Domain "
"Names in Applications (IDNA)> を参照)。3つのフラグが新たに定義されている:"

#. type: TP
#: build/C/man3/getnameinfo.3:126
#, no-wrap
msgid "B<NI_IDN>"
msgstr "B<NI_IDN>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:132
msgid ""
"If this flag is used, then the name found in the lookup process is converted "
"from IDN format to the locale's encoding if necessary.  ASCII-only names are "
"not affected by the conversion, which makes this flag usable in existing "
"programs and environments."
msgstr ""
"このフラグを指定すると、必要であれば、検索処理で見つかった名前は IDN 形式から"
"ロケールに応じた符号化形式に変換される。 ASCII 文字だけの名前はこの変換では影"
"響を受けない。このため、 既存のプログラムや環境でこのフラグを使うことができ"
"る。"

#. type: TP
#: build/C/man3/getnameinfo.3:132
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#.  #ifdef __USE_GNU
#.  #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.  #define EAI_CANCELED    -101  /* Request canceled.  */
#.  #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.  #define EAI_ALLDONE     -103  /* All requests done.  */
#.  #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.  #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.  #endif
#. type: Plain text
#: build/C/man3/getnameinfo.3:155
msgid ""
"On success 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified "
"buffer lengths.  On error one of the following nonzero error codes is "
"returned:"
msgstr ""
"成功すると 0 が返り、(要求されていれば) ノードとサービスの名前が NULL 終端さ"
"れた文字列の形式でそれぞれの指定バッファに返される (バッファの長さにあうよう"
"に縮められるかもしれない)。 エラーの場合は、以下の 0 以外のエラー・コードが返"
"される:"

#. type: Plain text
#: build/C/man3/getnameinfo.3:159
msgid "The name could not be resolved at this time.  Try again later."
msgstr "指定された名前が現時点では解決できなかった。 後で再試行してみること。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:164
msgid "The I<flags> argument has an invalid value."
msgstr "I<flags> 引き数に不正な値が与えられた。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:167
msgid "A nonrecoverable error occurred."
msgstr "回復できないエラーが発生した。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:171
msgid ""
"The address family was not recognized, or the address length was invalid for "
"the specified family."
msgstr ""
"指定したアドレスファミリーが認識できなかった。 あるいはアドレスの長さが指定さ"
"れたファミリーに合うものでなかった。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:180
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set "
"and the host's name cannot be located, or neither hostname nor service name "
"were requested."
msgstr ""
"与えられたパラメータでは名前が解決できない。 B<NI_NAMEREQD> が設定されていた"
"がホスト名が決定できなかったか、 ホスト名もサービス名も要求されなかった。"

#. type: TP
#: build/C/man3/getnameinfo.3:180
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr "B<EAI_OVERFLOW>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:187
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr "I<host> または I<serv> が指しているバッファが小さすぎた。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:192
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr "システムエラーが起った。 エラーコードは I<errno> に設定される。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:199
msgid "/etc/hosts"
msgstr "/etc/hosts"

#. type: Plain text
#: build/C/man3/getnameinfo.3:201
msgid "/etc/nsswitch.conf"
msgstr "/etc/nsswitch.conf"

#. type: Plain text
#: build/C/man3/getnameinfo.3:203
msgid "/etc/resolv.conf"
msgstr "/etc/resolv.conf"

#. type: Plain text
#: build/C/man3/getnameinfo.3:206
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr "B<getnameinfo>()  は、glibc バージョン 2.1 以降で提供されている。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:208
msgid "RFC\\ 2553, POSIX.1-2001."
msgstr "RFC\\ 2553, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/getnameinfo.3:213
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr ""
"適切なバッファサイズを選択できるように、 I<E<lt>netdb.hE<gt>> に以下の定数が"
"定義されている。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:218
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:228
msgid ""
"Since glibc 2.8, these definitions are exposed only if one of the feature "
"test macros B<_BSD_SOURCE>, B<_SVID_SOURCE>, or B<_GNU_SOURCE> is defined."
msgstr ""
"glibc 2.8 以降では、機能検査マクロ B<_BSD_SOURCE>, B<_SVID_SOURCE>, "
"B<_GNU_SOURCE> のいずれかが定義された場合にのみ、これらの定義が公開される。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:236
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the "
"services listed in the current Assigned Numbers RFC."
msgstr ""
"前者は、最近のバージョンの BIND のヘッダファイル I<E<lt>arpa/nameser.hE<gt>> "
"中の定数 B<MAXDNAME> と同じ値である。 後者は、割り当て済の数値について記した"
"現在の RFC に 列挙されてサービスから推量した値である。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:241
msgid ""
"The following code tries to get the numeric hostname and service name, for a "
"given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr ""
"以下のコードは、指定されたソケットアドレスに対する ホストとサービスの数値表式"
"を取得しようと試みる。 特定のアドレスファミリーに対する参照情報は 一切ハード"
"コードされていないことに着目してほしい。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:247
#, no-wrap
msgid ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;          /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:251
#, no-wrap
msgid ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:256
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr ""
"以下ではソケットアドレスに 逆向きのアドレスマッピングが存在するかをチェックし"
"ている。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:262
#, no-wrap
msgid ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;          /* input */\n"
"char hbuf[NI_MAXHOST];\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:268
#, no-wrap
msgid ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:275
msgid ""
"An example program using B<getnameinfo>()  can be found in B<getaddrinfo>(3)."
msgstr ""
"B<getnameinfo>()  を使ったプログラム例が B<getaddrinfo>(3)  に記載されてい"
"る。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:290
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), B<socket>"
"(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), B<socket>"
"(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"

#. type: Plain text
#: build/C/man3/getnameinfo.3:294
msgid ""
"R. Gilligan, S. Thomson, J. Bound and W. Stevens, I<Basic Socket Interface "
"Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr ""
"R. Gilligan, S. Thomson, J. Bound and W. Stevens, I<Basic Socket Interface "
"Extensions for IPv6>, RFC\\ 2553, March 1999."

#. type: Plain text
#: build/C/man3/getnameinfo.3:300
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org\\:/"
"internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"
msgstr ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org\\:/"
"internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:305
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"
msgstr ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"

#. type: Plain text
#: build/C/man3/getnameinfo.3:308
msgid ""
"E<.UR http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/"
"usenix2000\\:/freenix\\:/metzprotocol.html> E<.UE .>"
msgstr ""
"E<.UR http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/"
"usenix2000\\:/freenix\\:/metzprotocol.html> E<.UE .>"

#. type: TH
#: build/C/man3/getnetent.3:30
#, no-wrap
msgid "GETNETENT"
msgstr "GETNETENT"

#. type: TH
#: build/C/man3/getnetent.3:30 build/C/man3/getprotoent.3:30
#: build/C/man3/getservent.3:34
#, no-wrap
msgid "2008-08-19"
msgstr "2008-08-19"

#. type: Plain text
#: build/C/man3/getnetent.3:34
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - ネットワークエ"
"ントリを取得する"

#. type: Plain text
#: build/C/man3/getnetent.3:37 build/C/man3/getnetent_r.3:33
#: build/C/man3/getprotoent.3:37 build/C/man3/getprotoent_r.3:33
#: build/C/man3/getservent.3:41 build/C/man3/getservent_r.3:33
#: build/C/man3/setnetgrent.3:17
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr "B<struct netent *getnetent(void);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:43
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:45
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr "B<void setnetent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:47
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr "B<void endnetent(void);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:57
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database "
"and returns a I<netent> structure containing the broken-out fields from the "
"entry.  A connection is opened to the database if necessary."
msgstr ""
"B<getnetent>()  関数はネットワークデータベースから次のエントリを読み込み、 そ"
"のエントリを I<netent> 構造体の要素別のフィールドに格納し、 その構造体を返"
"す。 必要であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getnetent.3:66
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr ""
"B<getnetbyname>()  関数は、ネットワーク名 I<name> にマッチするエントリを デー"
"タベースから探し、そのエントリを収めた I<netent> 構造体を返す。"

#. type: Plain text
#: build/C/man3/getnetent.3:80
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr ""
"B<getnetbyaddr>()  関数は、I<type> 型のネットワーク番号 I<net> にマッチするエ"
"ントリを データベースから探し、そのエントリを収めた I<netent> 構造体を返す。 "
"I<net> 引き数はホスト・バイトオーダでなければならない。"

#. type: Plain text
#: build/C/man3/getnetent.3:92
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr ""
"B<setnetent>()  関数はデータベースへの接続をオープンし、 次の読み込みエントリ"
"を先頭のエントリに設定する。 I<stayopen> が 0 でない場合、 一つ一つの "
"B<getnet*>()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getnetent.3:96
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr "B<endnetent>()  関数はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getnetent.3:102
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "I<netent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getnetent.3:111
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"

#. type: Plain text
#: build/C/man3/getnetent.3:117
msgid "The members of the I<netent> structure are:"
msgstr "I<netent> 構造体のメンバは以下の通り。"

#. type: TP
#: build/C/man3/getnetent.3:117
#, no-wrap
msgid "I<n_name>"
msgstr "I<n_name>"

#. type: Plain text
#: build/C/man3/getnetent.3:120
msgid "The official name of the network."
msgstr "ネットワークの正式名 (official name)。"

#. type: TP
#: build/C/man3/getnetent.3:120
#, no-wrap
msgid "I<n_aliases>"
msgstr "I<n_aliases>"

#. type: Plain text
#: build/C/man3/getnetent.3:123
msgid "A NULL-terminated list of alternative names for the network."
msgstr "ネットワークの別名からなるリスト。 リストは NULL で終端される。"

#. type: TP
#: build/C/man3/getnetent.3:123
#, no-wrap
msgid "I<n_addrtype>"
msgstr "I<n_addrtype>"

#. type: Plain text
#: build/C/man3/getnetent.3:127
msgid "The type of the network number; always B<AF_INET>."
msgstr "ネットワーク番号の形式。現在は B<AF_INET> のみ。"

#. type: TP
#: build/C/man3/getnetent.3:127
#, no-wrap
msgid "I<n_net>"
msgstr "I<n_net>"

#. type: Plain text
#: build/C/man3/getnetent.3:130
msgid "The network number in host byte order."
msgstr "ホスト・バイトオーダ形式のネットワーク番号。"

#. type: Plain text
#: build/C/man3/getnetent.3:141
msgid ""
"The B<getnetent>(), B<getnetbyname>()  and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a NULL "
"pointer if an error occurs or the end of the file is reached."
msgstr ""
"B<getnetent>(), B<getnetbyname>(), B<getnetbyaddr>()  関数は、静的に割り当て"
"られた I<netent> 構造体へのポインタを返す。 エラーが起こったり、ファイルの末"
"尾に達した場合は NULL ポインタを返す。"

#. type: TP
#: build/C/man3/getnetent.3:142 build/C/man5/networks.5:71
#, no-wrap
msgid "I</etc/networks>"
msgstr "I</etc/networks>"

#. type: Plain text
#: build/C/man3/getnetent.3:145
msgid "networks database file"
msgstr "ネットワークデータベースファイル"

#. type: Plain text
#: build/C/man3/getnetent.3:147 build/C/man3/getprotoent.3:142
#: build/C/man3/getservent.3:159
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/getnetent.3:154
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr ""
"バージョン 2.2 より前の glibc では、 B<getnetbyaddr>()  の引き数 I<net> は "
"I<long> 型だった。"

#.  .BR networks (5)
#. type: Plain text
#: build/C/man3/getnetent.3:159
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"

#. type: Plain text
#: build/C/man3/getnetent.3:161
msgid "RFC\\ 1101"
msgstr "RFC\\ 1101"

#. type: TH
#: build/C/man3/getnetent_r.3:26
#, no-wrap
msgid "GETNETENT_R"
msgstr "GETNETENT_R"

#. type: Plain text
#: build/C/man3/getnetent_r.3:30
msgid ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - ネットワークエントリを\n"
"取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getnetent_r.3:37
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent_r.3:42
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent_r.3:47
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent_r.3:58
msgid "B<getnetent_r>(), B<getnetbyname_r>(), B<getnetbyaddr_r>():"
msgstr "B<getnetent_r>(), B<getnetbyname_r>(), B<getnetbyaddr_r>():"

#. type: Plain text
#: build/C/man3/getnetent_r.3:79
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""
"関数 B<getnetent_r>(), B<getnetbyname_r>(), B<getnetbyaddr_r>() は、\n"
"それぞれ B<getnetent>(3), B<getnetbyname>(3), B<getnetbynumber>(3) の\n"
"リエントラント版である。\n"
"I<netent> 構造体の返し方と、関数呼び出し時の引き数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:85
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure "
"as the function result, these functions copy the structure into the location "
"pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<netent> 構造体\n"
"へのポインタを返すのではなく、 I<netent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getnetent_r.3:102
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<netent> 構造体が指す文字列フィールドを格納\n"
"するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:110
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しでネットワークレコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: build/C/man3/getnetent_r.3:118
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr ""
"I<h_errnop> が指すバッファは、リエントラントでない関数では\n"
"グローバル変数 I<h_errno> に格納されていた値を返すのに使用される。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:121 build/C/man3/getprotoent_r.3:111
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""
"成功すると、これらの関数は 0 を返す。エラーの場合、「エラー」の節の\n"
"リストにある正のエラー番号のいずれかを返す。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:129
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()) やこれ以上レコードがない場合 (B<getnetent_r>())、\n"
"I<result> には NULL が設定される。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:134
msgid "(B<getnetent_r>())  No more records in database."
msgstr "(B<getnetent_r>())  データベースにこれ以上レコードがない。"

#. type: TP
#: build/C/man3/getnetent_r.3:134 build/C/man3/getprotoent_r.3:124
#: build/C/man3/getservent_r.3:123
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/getnetent_r.3:141 build/C/man3/getprotoent_r.3:131
#: build/C/man3/getservent_r.3:130
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""
"I<buf> が小さすぎる。もっと大きなバッファにして \n"
"(または I<buflen> を増やして) 再度呼び出すこと。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:145 build/C/man3/getprotoent_r.3:135
#: build/C/man3/getservent_r.3:134
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""
"これらの関数は GNU による拡張である。\n"
"他のシステムにも同様の名前の関数が存在する場合があるが、\n"
"通常は関数の引き数が異なる。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:148
msgid "B<getnetent>(3), B<networks>(5)"
msgstr "B<getnetent>(3), B<networks>(5)"

#. type: TH
#: build/C/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr "GETPEERNAME"

#. type: TH
#: build/C/man2/getpeername.2:42 build/C/man5/nscd.conf.5:20
#: build/C/man5/nsswitch.conf.5:25
#, no-wrap
msgid "2013-02-12"
msgstr "2013-02-12"

#. type: Plain text
#: build/C/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr "getpeername - 接続している相手ソケットの名前を取得する"

#. type: Plain text
#: build/C/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"

#. type: Plain text
#: build/C/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by "
"I<addr>.  On return it contains the actual size of the name returned (in "
"bytes).  The name is truncated if the buffer provided is too small."
msgstr ""
"B<getpeername>()  は、ソケット(socket)  I<sockfd> に接続している相手のアドレ"
"スを、 I<addr> が指すバッファに格納して返す。 I<addrlen> 引き数は、 I<addr> "
"が指している領域のサイズに初期化しておかなければならない。 関数が返る時に"
"は、 I<addrlen> には実際に返された名前のサイズが (バイト単位で) 格納される。 "
"提供されたバッファが小さすぎた場合には、名前は切り詰められる。"

#. type: Plain text
#: build/C/man2/getpeername.2:68
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""
"渡されたバッファが小さ過ぎた場合は、返されるアドレスの末尾が切り詰められる。 "
"この場合には、 I<addrlen> には、呼び出し時に指定された値よりも大きな値が格納"
"される。"

#. type: Plain text
#: build/C/man2/getpeername.2:73 build/C/man2/shutdown.2:74
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: TP
#: build/C/man2/getpeername.2:74 build/C/man2/shutdown.2:75
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/getpeername.2:79
msgid "The argument I<sockfd> is not a valid descriptor."
msgstr "引き数 I<sockfd> が有効なディスクリプタでない。"

#. type: TP
#: build/C/man2/getpeername.2:79 build/C/man7/packet.7:250
#: build/C/man7/raw.7:149 build/C/man7/unix.7:336
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""
"I<addr> 引き数の指しているメモリが有効なプロセスのアドレス空間の 一部でない。"

#. type: Plain text
#: build/C/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr "I<addrlen> が不正である (例えば、負で場合など)。"

#. type: TP
#: build/C/man2/getpeername.2:89 build/C/man7/packet.7:262
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: build/C/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the operation."
msgstr "この操作を行なうのに十分な資源がシステムに存在しない。"

#. type: Plain text
#: build/C/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr "ソケットが接続していない。"

#. type: TP
#: build/C/man2/getpeername.2:96 build/C/man2/shutdown.2:87
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: build/C/man2/getpeername.2:101
msgid "The argument I<sockfd> is a file, not a socket."
msgstr "引き数 I<sockfd> がソケットでなくてファイルである。"

#. type: Plain text
#: build/C/man2/getpeername.2:105
msgid ""
"SVr4, 4.4BSD (the B<getpeername>()  function call first appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""
"SVr4, 4.4BSD (B<getpeername>()  関数は 4.2BSD で登場した), POSIX.1-2001."

#. type: Plain text
#: build/C/man2/getpeername.2:116
msgid ""
"The third argument of B<getpeername>()  is in reality an I<int\\ *> (and "
"this is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion "
"resulted in the present I<socklen_t>, also used by glibc.  See also B<accept>"
"(2)."
msgstr ""
"B<getpeername>()  の三番目の引き数は実際には I<`int\\ *'> である (4.x BSD, "
"libc4, libc5 では このようになっている)。 POSIX では紆余曲折を経て現在の "
"I<socklen_t> になっており、 glibc でも I<socklen_t> を使っている。 B<accept>"
"(2)  も参照のこと。"

#. type: Plain text
#: build/C/man2/getpeername.2:143
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the "
"other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on "
"a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr ""
"ストリームソケットでは、 いったん B<connect>(2) が実行されると、 どのソケット"
"も B<getpeername>() を使って相手ソケットのアドレスを取得できる。 一方、データ"
"グラムソケットはコネクションレスである (接続がない)。 データグラムソケットに"
"対する B<connect>(2) の呼び出しは、 B<write>(2) や B<recv>(2) で送信される出"
"力データグラムの相手アドレスを設定するだけである。\n"
"B<connect>(2) の呼び出し元は、 B<getpeername>() を使って、それ以前にそのソ"
"ケットに設定された相手アドレスを取得することができる。 しかし、相手ソケットは"
"この情報を知らないので、 相手ソケットで B<getpeername>() を呼び出しても、 役"
"に立つ情報は得られない (相手側でも B<connect>(2) が呼び出されている場合を除"
"く)。 なお、データグラムの受信側では B<recvfrom>(2) を使って送信元アドレスを "
"取得できることも覚えておいてほしい。"

#. type: Plain text
#: build/C/man2/getpeername.2:150
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), B<unix>"
"(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), B<unix>"
"(7)"

#. type: TH
#: build/C/man3/getprotoent.3:30
#, no-wrap
msgid "GETPROTOENT"
msgstr "GETPROTOENT"

#. type: Plain text
#: build/C/man3/getprotoent.3:34
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - プ"
"ロトコルのエントリを取得する"

#. type: Plain text
#: build/C/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr "B<struct protoent *getprotoent(void);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:43
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:45
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr "B<void setprotoent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:47
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr "B<void endprotoent(void);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:58
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr ""
"B<getprotoent>()  関数は、プロトコルのデータベース (B<protocols>(5)  参照) か"
"ら次のエントリを読み込み、 そのエントリを I<protoent> 構造体の要素別のフィー"
"ルドに格納し、 その構造体を返す。 必要であれば、データベースへの接続がオープ"
"ンされる。"

#. type: Plain text
#: build/C/man3/getprotoent.3:68
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr ""
"B<getprotobyname>()  関数は、プロトコル名 I<name> にマッチするエントリを デー"
"タベースから探し、そのエントリを収めた I<protoent> 構造体を返す。 必要であれ"
"ば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getprotoent.3:78
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr ""
"B<getprotobynumber>()  関数は、プロトコル番号 I<number> にマッチするエントリ"
"を データベースから探し、そのエントリを収めた I<protoent> 構造体を返す。 必要"
"であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getprotoent.3:90
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr ""
"B<setprotoent>()  関数はデータベースへの接続をオープンし、 次の読み込みエント"
"リを先頭のエントリに設定する。 I<stayopen> が 0 でない場合、 一つ一つの "
"B<getproto*>()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getprotoent.3:94
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr "B<endprotoent>()  関数はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getprotoent.3:100
msgid ""
"The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""
"I<protoent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getprotoent.3:108
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:114
msgid "The members of the I<protoent> structure are:"
msgstr "I<protoent> 構造体のメンバーは以下の通り。"

#. type: TP
#: build/C/man3/getprotoent.3:114
#, no-wrap
msgid "I<p_name>"
msgstr "I<p_name>"

#. type: Plain text
#: build/C/man3/getprotoent.3:117
msgid "The official name of the protocol."
msgstr "プロトコルの正式名 (official name)。"

#. type: TP
#: build/C/man3/getprotoent.3:117
#, no-wrap
msgid "I<p_aliases>"
msgstr "I<p_aliases>"

#. type: Plain text
#: build/C/man3/getprotoent.3:120
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr "プロトコルの別名のリスト。 リストは NULL で終端される。"

#. type: TP
#: build/C/man3/getprotoent.3:120
#, no-wrap
msgid "I<p_proto>"
msgstr "I<p_proto>"

#. type: Plain text
#: build/C/man3/getprotoent.3:123
msgid "The protocol number."
msgstr "プロトコルの番号"

#. type: Plain text
#: build/C/man3/getprotoent.3:134
msgid ""
"The B<getprotoent>(), B<getprotobyname>()  and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a NULL pointer if an error occurs or the end of the file is reached."
msgstr ""
"B<getprotoent>(), B<getprotobyname>(), B<getprotobynumber>()  関数は、静的に"
"割り当てられた I<protoent> 構造体へのポインタを返す。 エラーが起こったり、"
"ファイルの最後に達した場合は NULL ポインタを返す。"

#. type: TP
#: build/C/man3/getprotoent.3:136 build/C/man5/protocols.5:78
#, no-wrap
msgid "I</etc/protocols>"
msgstr "I</etc/protocols>"

#. type: Plain text
#: build/C/man3/getprotoent.3:139
msgid "protocol database file"
msgstr "プロトコルのデータベースファイル"

#. type: Plain text
#: build/C/man3/getprotoent.3:147
msgid "B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr ""
"B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"

#. type: TH
#: build/C/man3/getprotoent_r.3:26
#, no-wrap
msgid "GETPROTOENT_R"
msgstr "GETPROTOENT_R"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:30
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - プロトコル\n"
"エントリを取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:36
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:40
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:44
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:55
msgid "B<getprotoent_r>(), B<getprotobyname_r>(), B<getprotobynumber_r>():"
msgstr "B<getprotoent_r>(), B<getprotobyname_r>(), B<getprotobynumber_r>():"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:76
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3), "
"B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences "
"from the nonreentrant functions."
msgstr ""
"関数 B<getprotoent_r>(), B<getprotobyname_r>(),\n"
"B<getprotobynumber_r>() は、それぞれ B<getprotoent>(3),\n"
"B<getprotobyname>(3), B<getprotobynumber>(3) のリエントラント版である。\n"
"I<protoent> 構造体の返し方と、関数呼び出し時の引き数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:82
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<protoent> 構造体\n"
"へのポインタを返すのではなく、 I<protoent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: build/C/man3/getprotoent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<protoent> 構造体が指す文字列フィールドを\n"
"格納するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:108
msgid ""
"If the function call successfully obtains a protocol record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しでプロトコルレコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:119
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()), "
"or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getprotobyname_r>(),\n"
"B<getprotobyaddr_r>()) やこれ以上レコードがない場合\n"
"(B<getprotoent_r>())、I<result> には NULL が設定される。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:124
msgid "(B<getprotoent_r>())  No more records in database."
msgstr "(B<getprotoent_r>())  データベースにこれ以上レコードがない。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:149
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""
"以下のプログラムは、 B<getprotobyname_r>() を使って、最初のコマンド\n"
"ライン引き数で指定された名前のプロトコルのレコードを取得する。\n"
"二番目のコマンドライン引き数 (整数値) が指定された場合は、\n"
"その値が I<buflen> の初期値として使用される。\n"
"B<getprotobyname_r>() がエラー B<ERANGE> で失敗すると、プログラムは\n"
"より大きなバッファサイズで再度 B<getprotobyname_r> を呼び出す。\n"
"下記のシェルのセッションは、実行例を示している。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:160
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:172 build/C/man3/getservent_r.3:170
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:174 build/C/man3/getservent_r.3:172
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr "#define MAX_BUF 10000\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:183
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
"    char **p;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
"    char **p;\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:188
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:192
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:197 build/C/man3/getservent_r.3:200
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:206
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:209 build/C/man3/getservent_r.3:212
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:211 build/C/man3/getservent_r.3:214
#, no-wrap
msgid "            buflen++;\n"
msgstr "            buflen++;\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:218 build/C/man3/getservent_r.3:221
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:222
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:227 build/C/man3/getservent_r.3:230
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:233
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:240
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr "B<getprotoent>(3), B<protocols>(5)"

#. type: TH
#: build/C/man3/getservent.3:34
#, no-wrap
msgid "GETSERVENT"
msgstr "GETSERVENT"

#. type: Plain text
#: build/C/man3/getservent.3:38
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr ""
"getservent, getservbyname, getservbyport, setservent, endservent - サービスの"
"エントリを取得する"

#. type: Plain text
#: build/C/man3/getservent.3:43
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr "B<struct servent *getservent(void);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:45
#, no-wrap
msgid "B<struct servent *getservbyname(const char *>I<name>B<, const char *>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyname(const char *>I<name>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:47
#, no-wrap
msgid "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:49
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr "B<void setservent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:51
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr "B<void endservent(void);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:62
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing "
"the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr ""
"B<getservent>()  関数はサービスのデータベース (B<services>(5)  参照) から次の"
"エントリを読み込み、 そのエントリを I<servent> 構造体の要素別のフィールドに格"
"納し、 その構造体を返す。 必要であれば、データベースへの接続がオープンされ"
"る。"

#. type: Plain text
#: build/C/man3/getservent.3:77
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr ""
"B<getservbyname>()  関数は、 プロトコル I<proto> を用いるサービスの名前 "
"I<name> にマッチするエントリをデータベースから探し、 そのエントリを収めた "
"I<servent> 構造体を返す。 I<proto> が NULL の場合は、任意のプロトコルにマッチ"
"する。 必要であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getservent.3:93
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte "
"order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be "
"matched.  A connection is opened to the database if necessary."
msgstr ""
"B<getservbyport>()  関数は、 プロトコル I<proto> を用いるサービスのポート番"
"号 I<port> にマッチするエントリをデータベースから探し、 そのエントリの内容を"
"収めた I<servent> 構造体を返す (ポート番号 I<port> はネットワーク・バイトオー"
"ダで指定する)。 I<proto> が NULL の場合は任意のプロトコルにマッチする。 必要"
"であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getservent.3:105
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr ""
"B<setservent>()  関数はデータベースへの接続をオープンし、 次の読み込みエント"
"リを先頭のエントリに設定する。 I<stayopen> が 0 でない場合、 一つ一つの "
"B<getserv*>()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getservent.3:109
msgid "The B<endservent>()  function closes the connection to the database."
msgstr "B<endservent>()  関数はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getservent.3:115
msgid "The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""
"I<servent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getservent.3:124
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"

#. type: Plain text
#: build/C/man3/getservent.3:130
msgid "The members of the I<servent> structure are:"
msgstr "I<servent> 構造体のメンバーは以下の通り。"

#. type: TP
#: build/C/man3/getservent.3:130
#, no-wrap
msgid "I<s_name>"
msgstr "I<s_name>"

#. type: Plain text
#: build/C/man3/getservent.3:133
msgid "The official name of the service."
msgstr "サービスの正式名 (official name)。"

#. type: TP
#: build/C/man3/getservent.3:133
#, no-wrap
msgid "I<s_aliases>"
msgstr "I<s_aliases>"

#. type: Plain text
#: build/C/man3/getservent.3:136
msgid "A NULL-terminated list of alternative names for the service."
msgstr "サービスの別名のリスト。 リストは NULL で終端される。"

#. type: TP
#: build/C/man3/getservent.3:136
#, no-wrap
msgid "I<s_port>"
msgstr "I<s_port>"

#. type: Plain text
#: build/C/man3/getservent.3:139
msgid "The port number for the service given in network byte order."
msgstr "サービスのポート番号。ネットワークバイトオーダで指定される。"

#. type: TP
#: build/C/man3/getservent.3:139
#, no-wrap
msgid "I<s_proto>"
msgstr "I<s_proto>"

#. type: Plain text
#: build/C/man3/getservent.3:142
msgid "The name of the protocol to use with this service."
msgstr "このサービスと共に用いるプロトコルの名前。"

#. type: Plain text
#: build/C/man3/getservent.3:153
msgid ""
"The B<getservent>(), B<getservbyname>()  and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or a NULL "
"pointer if an error occurs or the end of the file is reached."
msgstr ""
"B<getservent>(), B<getservbyname>(), B<getservbyport>()  関数は、 静的に割り"
"当てられた I<servent> 構造体へのポインタを返す。 エラーが起こったり、ファイル"
"の末尾に達した場合は NULL ポインタを返す。"

#. type: TP
#: build/C/man3/getservent.3:154 build/C/man5/services.5:186
#, no-wrap
msgid "I</etc/services>"
msgstr "I</etc/services>"

#. type: Plain text
#: build/C/man3/getservent.3:157
msgid "services database file"
msgstr "サービスのデータベースファイル"

#. type: Plain text
#: build/C/man3/getservent.3:164
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"

#. type: TH
#: build/C/man3/getservent_r.3:26
#, no-wrap
msgid "GETSERVENT_R"
msgstr "GETSERVENT_R"

#. type: Plain text
#: build/C/man3/getservent_r.3:30
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr ""
"getservent_r, getservbyname_r, getservbyport_r - サービスエントリを\n"
"取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getservent_r.3:36
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:40
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:44
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:55
msgid "B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>():"
msgstr "B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>():"

#. type: Plain text
#: build/C/man3/getservent_r.3:76
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""
"関数 B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>() は、\n"
"それぞれ B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3) の\n"
"リエントラント版である。\n"
"I<servent> 構造体の返し方と、関数呼び出し時の引き数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getservent_r.3:82
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<servent> 構造体\n"
"へのポインタを返すのではなく、 I<servent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getservent_r.3:99
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<servent> 構造体が指す文字列フィールドを\n"
"格納するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getservent_r.3:107
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しでサービスレコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#. type: Plain text
#: build/C/man3/getservent_r.3:110
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr ""
"成功すると、これらの関数は 0 を返す。エラーの場合、「エラー」の節の\n"
"リストにある正のエラー番号のいずれかを返す。"

#. type: Plain text
#: build/C/man3/getservent_r.3:118
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getservbyname_r>(),\n"
"B<getservbyaddr_r>()) やこれ以上レコードがない場合 (B<getservent_r>())、\n"
"I<result> には NULL が設定される。"

#. type: Plain text
#: build/C/man3/getservent_r.3:123
msgid "(B<getservent_r>())  No more records in database."
msgstr "(B<getservent_r>())  データベースにこれ以上レコードがない。"

#. type: Plain text
#: build/C/man3/getservent_r.3:148
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial "
"value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""
"以下のプログラムは、 B<getservbyport_r>() を使って、コマンド\n"
"ライン引き数で指定されたポート番号とプロトコル名を持つ\n"
"サービスレコードを取得する。\n"
"三番目のコマンドライン引き数 (整数値) が指定された場合は、\n"
"その値が I<buflen> の初期値として使用される。\n"
"B<getservbyport_r>() がエラー B<ERANGE> で失敗すると、プログラムは\n"
"より大きなバッファサイズで再度 B<getservbyport_r> を呼び出す。\n"
"下記のシェルのセッションは実行例を示している。"

#. type: Plain text
#: build/C/man3/getservent_r.3:158
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
"    char **p;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
"    char **p;\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:187
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:191
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"\t      strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"\t      strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:195
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:209
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:225
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:237
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:244
msgid "B<getservent>(3), B<services>(5)"
msgstr "B<getservent>(3), B<services>(5)"

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "HOST.CONF"
msgstr "HOST.CONF"

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "2003-08-23"
msgstr "2003-08-23"

#. type: TH
#: build/C/man5/host.conf.5:26 build/C/man5/networks.5:26
#, no-wrap
msgid "Linux System Administration"
msgstr "Linux System Administration"

#. type: Plain text
#: build/C/man5/host.conf.5:29
msgid "host.conf - resolver configuration file"
msgstr "host.conf - レゾルバ設定ファイル"

#. type: Plain text
#: build/C/man5/host.conf.5:38
msgid ""
"The file I</etc/host.conf> contains configuration information specific to "
"the resolver library.  It should contain one configuration keyword per line, "
"followed by appropriate configuration information.  The keywords recognized "
"are I<order>, I<trim>, I<multi>, I<nospoof>, I<spoof>, and I<reorder>.  "
"These keywords are described below."
msgstr ""
"ファイル I</etc/host.conf> には、レゾルバライブラリの詳細な設定情報が含まれて"
"いる。 このファイルには、1 行毎に 1 つの設定キーワードと それに続く適切な設定"
"情報がなければならない。 認識されるキーワードは I<order>, I<trim>, I<multi>, "
"I<nospoof>, I<spoof>, I<reorder> である。 各キーワードを、以下で説明する。"

#. type: TP
#: build/C/man5/host.conf.5:38
#, no-wrap
msgid "I<order>"
msgstr "I<order>"

#. type: Plain text
#: build/C/man5/host.conf.5:44
msgid ""
"This keyword specifies how host lookups are to be performed.  It should be "
"followed by one or more lookup methods, separated by commas.  Valid methods "
"are I<bind>, I<hosts>, and I<nis>."
msgstr ""
"このキーワードは、ホストのルックアップ方式を指定する。 このキーワードの後に"
"は、コンマで分けた 1 つ以上のルックアップ方式が続かなくてはならない。 使用可"
"能な方式は I<bind>, I<hosts>, I<nis> である。"

#. type: TP
#: build/C/man5/host.conf.5:44
#, no-wrap
msgid "I<trim>"
msgstr "I<trim>"

#. type: Plain text
#: build/C/man5/host.conf.5:61
msgid ""
"This keyword may be listed more than once.  Each time it should be followed "
"by a list of domains, separated by colons (\\(aq:\\(aq), semicolons (\\(aq;"
"\\(aq) or commas (\\(aq,\\(aq), with the leading dot.  When set, the resolv+ "
"library will automatically trim the given domain name from the end of any "
"hostname resolved via DNS.  This is intended for use with local hosts and "
"domains.  (Related note: trim will not affect hostnames gathered via NIS or "
"the hosts file.  Care should be taken to ensure that the first hostname for "
"each entry in the hosts file is fully qualified or unqualified, as "
"appropriate for the local installation.)"
msgstr ""
"このキーワードは、2 回以上リストすることができる。 毎回、このキーワードの後に"
"は、 ドットではじまる 1 つ以上のドメイン名のリストを続けなければならない。 ド"
"メイン名はコロン (\\(aq:\\(aq)、セミコロン (\\(aq;\\(aq)、コンマ (\\(aq,"
"\\(aq)  で区切る。 このキーワードが設定されると、resolv+ ライブラリは DNS で"
"レゾルブされた すべてのホスト名の後ろから与えられたドメイン名を自動的に取り去"
"る。 このキーワードはローカルなホストとドメインで使用することを意図してい"
"る。 (関連した注意 : NIS または hosts ファイルで集められたホスト名に trim は"
"影響しない。 hosts ファイルの各エントリの最初のホスト名を、 完全なドメイン名"
"付きのものにするかしないかは、 ホストごとのインストールポリシーにあわせて 適"
"切に選択する必要がある。注意すること。)"

#. type: TP
#: build/C/man5/host.conf.5:61
#, no-wrap
msgid "I<multi>"
msgstr "I<multi>"

#. type: Plain text
#: build/C/man5/host.conf.5:76
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolv+ library "
"will return all valid addresses for a host that appears in the I</etc/hosts> "
"file, instead of only the first.  This is I<off> by default, as it may cause "
"a substantial performance loss at sites with large hosts files."
msgstr ""
"有効な値は I<on> と I<off> である。 I<on> に設定された場合、最初のエントリの"
"みを例外として、 resolv+ ライブラリは I</etc/hosts> ファイルに現れるホストに"
"対して全ての有効なアドレスを返そうとする。 大きな hosts ファイルを持つサイト"
"では、 この設定は非常な性能の低下を招くので、 デフォルトでは I<off> である。"

#. type: TP
#: build/C/man5/host.conf.5:76
#, no-wrap
msgid "I<nospoof>"
msgstr "I<nospoof>"

#. type: Plain text
#: build/C/man5/host.conf.5:91
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolv+ library "
"will attempt to prevent hostname spoofing to enhance the security of "
"B<rlogin> and B<rsh>.  It works as follows: after performing a host address "
"lookup, resolv+ will perform a hostname lookup for that address.  If the two "
"hostnames do not match, the query will fail.  The default value is I<off>."
msgstr ""
"有効な値は I<on> と I<off> である。 I<on> に設定された場合、resolv+ ライブラ"
"リは B<rlogin> と B<rsh> のセキュリティを向上させるためホスト名の偽装を防止し"
"ようとする。 これは、「ホストアドレスのルックアップを行った後、 resolv+ はそ"
"のアドレスに対してホスト名のルックアップを行い、 もし 2 つのホスト名が一致し"
"なかった場合は、クエリーは失敗する。」 というように動作する。 デフォルトの値"
"は I<off> である。"

#. type: TP
#: build/C/man5/host.conf.5:91
#, no-wrap
msgid "I<spoofalert>"
msgstr "I<spoofalert>"

#. type: Plain text
#: build/C/man5/host.conf.5:103
msgid ""
"Valid values are I<on> and I<off>.  If this option is set to I<on> and the "
"I<nospoof> option is also set, resolv+ will log a warning of the error via "
"the syslog facility.  The default value is I<off>."
msgstr ""
"有効な値は I<on> と I<off> である。 このオプションが I<on> に設定されてい"
"て、 I<nospoof> オプションも (on に) 設定されている場合、 resolv+ は syslog "
"機能を通じてエラーに関する警告のログをとる。 デフォルトの値は I<off> である。"

#. type: TP
#: build/C/man5/host.conf.5:103
#, no-wrap
msgid "I<spoof>"
msgstr "I<spoof>"

#. type: Plain text
#: build/C/man5/host.conf.5:122
msgid ""
"Valid values are I<off>, I<nowarn> and I<warn>.  If this option is set to "
"I<off>, spoofed addresses are permitted and no warnings will be emitted via "
"the syslog facility.  If this option is set to I<warn>, resolv+ will attempt "
"to prevent hostname spoofing to enhance the security and log a warning of "
"the error via the syslog facility.  If this option is set to I<nowarn>, the "
"resolv+ library will attempt to prevent hostname spoofing to enhance the "
"security but not emit warnings via the syslog facility.  Setting this option "
"to anything else is equal to setting it to I<nowarn>."
msgstr ""
"有効な値は I<off>, I<nowarn>, I<warn> である。 このオプションを I<off> に設定"
"すると、偽装されたアドレスを許可して、 syslog 機能を通じた警告を発しない。 こ"
"のオプションを I<warn> に設定すると、resolv+ はセキュリティを高めるためにホス"
"ト名の偽装を防止し、 syslog 機能を通じてエラーに関する警告のログをとる。 この"
"オプションを I<nowarn> に設定すると、resolv+ はセキュリティを高めるためにホス"
"ト名の偽装を防止するが、 syslog 機能を通じた警告は発しない。 このオプションを"
"何も設定しない場合は、 I<nowarn> を設定したのと同じになる。"

#. type: TP
#: build/C/man5/host.conf.5:122
#, no-wrap
msgid "I<reorder>"
msgstr "I<reorder>"

#. type: Plain text
#: build/C/man5/host.conf.5:135
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, resolv+ will attempt to "
"reorder host addresses so that local addresses (i.e., on the same subnet) "
"are listed first when a B<gethostbyname>(3)  is performed.  Reordering is "
"done for all lookup methods.  The default value is I<off>."
msgstr ""
"有効な値は I<on> と I<off> である。 I<on> に設定されると、 B<gethostbyname "
"(3)> が実行されるとき、resolv+ ライブラリは、ローカルな (つまり、同じサブネッ"
"トにある) アドレスが最初にリストされるように ホストアドレスを並べ変える。 す"
"べてのルックアップ方式に対して並べ変えが行われる。 デフォルトの値は、 I<off> "
"である。"

#. type: SH
#: build/C/man5/host.conf.5:135
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境変数"

#. type: Plain text
#: build/C/man5/host.conf.5:139
msgid ""
"There are six environment variables that can be used to allow users to "
"override the behavior which is configured in I</etc/host.conf>."
msgstr ""
"I</etc/host.conf> で設定されている動作を、ユーザが上書きできる 6 つの環境変数"
"がある。"

#. type: TP
#: build/C/man5/host.conf.5:139
#, no-wrap
msgid "B<RESOLV_HOST_CONF>"
msgstr "B<RESOLV_HOST_CONF>"

#. type: Plain text
#: build/C/man5/host.conf.5:143
msgid ""
"If set this variable points to a file that should be read instead of I</etc/"
"host.conf>."
msgstr ""
"この変数を設定すると、 I</etc/host.conf> の代りに読み込むファイルを設定でき"
"る。"

#. type: TP
#: build/C/man5/host.conf.5:143
#, no-wrap
msgid "B<RESOLV_SERV_ORDER>"
msgstr "B<RESOLV_SERV_ORDER>"

#. type: Plain text
#: build/C/man5/host.conf.5:148
msgid "Overrides the I<order> command."
msgstr "I<order> コマンドを上書きする。"

#. type: TP
#: build/C/man5/host.conf.5:148
#, no-wrap
msgid "B<RESOLV_SPOOF_CHECK>"
msgstr "B<RESOLV_SPOOF_CHECK>"

#. type: Plain text
#: build/C/man5/host.conf.5:157
msgid ""
"Overrides the I<nospoof>, I<spoofalert> and I<spoof> commands in the same "
"way as the I<spoof> command is parsed.  Valid values are I<off>, I<nowarn> "
"and I<warn>."
msgstr ""
"I<spoof> コマンドを解析するのと同じ方式で、 I<nospoof>, I<spoofalert>, "
"I<spoof> コマンドを上書きできる。 有効な値は I<off>, I<nowarn>, I<warn> であ"
"る。"

#. type: TP
#: build/C/man5/host.conf.5:157
#, no-wrap
msgid "B<RESOLV_MULTI>"
msgstr "B<RESOLV_MULTI>"

#. type: Plain text
#: build/C/man5/host.conf.5:162
msgid "Overrides the I<multi> command."
msgstr "I<multi> コマンドを上書きする。"

#. type: TP
#: build/C/man5/host.conf.5:162
#, no-wrap
msgid "B<RESOLV_REORDER>"
msgstr "B<RESOLV_REORDER>"

#. type: Plain text
#: build/C/man5/host.conf.5:167
msgid "Overrides the I<reorder> command."
msgstr "I<reorder> コマンドを上書きする。"

#. type: TP
#: build/C/man5/host.conf.5:167
#, no-wrap
msgid "B<RESOLV_ADD_TRIM_DOMAINS>"
msgstr "B<RESOLV_ADD_TRIM_DOMAINS>"

#. type: Plain text
#: build/C/man5/host.conf.5:172
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons (\\(aq;"
"\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will be added to "
"the list of domains that should be trimmed."
msgstr ""
"コロン (\\(aq:\\(aq)、セミコロン (\\(aq;\\(aq)、コンマ (\\(aq,\\(aq) で区切っ"
"た ドット (\\(aq.\\(aq) で始まるドメイン名のリスト。 ホスト名から取り去るドメ"
"イン名のリストに追加する。"

#. type: TP
#: build/C/man5/host.conf.5:172
#, no-wrap
msgid "B<RESOLV_OVERRIDE_TRIM_DOMAINS>"
msgstr "B<RESOLV_OVERRIDE_TRIM_DOMAINS>"

#. type: Plain text
#: build/C/man5/host.conf.5:180
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons (\\(aq;"
"\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will replace the "
"list of domains that should be trimmed.  Overrides the I<trim> command."
msgstr ""
"コロン (\\(aq:\\(aq)、セミコロン (\\(aq;\\(aq)、コンマ (\\(aq,\\(aq) で区切っ"
"た ドット (\\(aq.\\(aq) で始まるドメイン名のリスト。 ホスト名から取り去るドメ"
"イン名のリストを上書きする。 I<trim> コマンドを上書きする。"

#. type: Plain text
#: build/C/man5/host.conf.5:184 build/C/man5/host.conf.5:187
msgid "Resolver configuration file"
msgstr "リゾルバ設定ファイル"

#. type: TP
#: build/C/man5/host.conf.5:184
#, no-wrap
msgid "I</etc/resolv.conf>"
msgstr "I</etc/resolv.conf>"

#. type: Plain text
#: build/C/man5/host.conf.5:190
msgid "Local hosts database"
msgstr "ローカルの hosts データベース"

#. type: Plain text
#: build/C/man5/host.conf.5:199
msgid ""
"The following differences exist compared to the original implementation.  A "
"new command I<spoof> and a new environment variable B<RESOLV_SPOOF_CHECK> "
"can take arguments like I<off>, I<nowarn> and I<warn>.  Line comments can "
"appear anywhere and not only at the beginning of a line."
msgstr ""
"元々の実装に比べて以下のような違いがある。 新しいコマンド I<spoof> と新しい環"
"境変数 B<RESOLV_SPOOF_CHECK> は、引き数 I<off>, I<nowarn>, I<warn> をとる。 "
"コメントは行頭だけではなく、どこに書いてもよい。"

#. type: Plain text
#: build/C/man5/host.conf.5:204
msgid "B<gethostbyname>(3), B<hostname>(7), B<named>(8), B<resolv+>(8)"
msgstr "B<gethostbyname>(3), B<hostname>(7), B<named>(8), B<resolv+>(8)"

#. type: TH
#: build/C/man7/hostname.7:39
#, no-wrap
msgid "HOSTNAME"
msgstr "HOSTNAME"

#. type: TH
#: build/C/man7/hostname.7:39
#, no-wrap
msgid "2010-11-07"
msgstr "2010-11-07"

#. type: Plain text
#: build/C/man7/hostname.7:42
msgid "hostname - hostname resolution description"
msgstr "hostname - ホスト名の名前解決の説明"

#. type: Plain text
#: build/C/man7/hostname.7:46
msgid ""
"Hostnames are domains, where a domain is a hierarchical, dot-separated list "
"of subdomains; for example, the machine monet, in the Berkeley subdomain of "
"the EDU domain would be represented as \"monet.Berkeley.EDU\"."
msgstr ""
"ホスト名は、階層構造でドット区切りのサブドメインである。\n"
"例えば、 EDU ドメインの Berkeley サブドメインのマシン monet は、\n"
"\"monet.Berkeley.EDU\" と表現される。"

#. type: Plain text
#: build/C/man7/hostname.7:55
msgid ""
"Hostnames are often used with network client and server programs, which must "
"generally translate the name to an address for use.  (This task is generally "
"performed by either B<getaddrinfo>(3)  or the obsolete B<gethostbyname>"
"(3).)  Hostnames are resolved by the Internet name resolver in the following "
"fashion."
msgstr ""
"ホスト名は、ネットワーククライアントやサーバのプログラムでは一般的に\n"
"使用され、使用する際には名前からアドレスに変換しなければならない (一般\n"
"的にはアドレスへの変換処理は B<getaddrinfo>(3) か (廃止予定の)\n"
"B<gethostbyname>(3) で行われる)。ホスト名の解決は、\n"
"インターネット・ネームリゾルバによって以下の方法で実行される。"

#. type: Plain text
#: build/C/man7/hostname.7:68
msgid ""
"If the name consists of a single component, that is, contains no dot, and if "
"the environment variable B<HOSTALIASES> is set to the name of a file, that "
"file is searched for any string matching the input hostname.  The file "
"should consist of lines made up of two white-space separated strings, the "
"first of which is the hostname alias, and the second of which is the "
"complete hostname to be substituted for that alias.  If a case-insensitive "
"match is found between the hostname to be resolved and the first field of a "
"line in the file, the substituted name is looked up with no further "
"processing."
msgstr ""
"ホスト名がドットを含まない単一要素で構成されていて、環境変数\n"
"B<HOSTALIASES> にファイル名が設定されている場合、入力されたホスト名に\n"
"マッチする文字列を検索するのに指定されたファイルが使用される。\n"
"そのファイルの各行は、ホワイトスペースで区切られた文字列 2 つで\n"
"構成され、各行の最初の文字列がホスト名のエイリアス (別名) で、\n"
"二番目の文字列がそのエイリアスに対応する完全なホスト名である。\n"
"解決するホスト名と一致するホスト名のエイリアス (ファイルの各行の最初の\n"
"フィールド) が見つかれば、完全なホスト名に置き換えられ、\n"
"それ以上の変換処理は行わずに、そのホスト名で検索処理が行われる\n"
"(ホスト名とエイリアスの照合では大文字、小文字の違いは無視される)。"

#. type: Plain text
#: build/C/man7/hostname.7:72
msgid ""
"If the input name ends with a trailing dot, the trailing dot is removed, and "
"the remaining name is looked up with no further processing."
msgstr ""
"入力されたホスト名の末尾がドットの場合、\n"
"末尾のドットは削除され、それ以上の処理は行われず、\n"
"(末尾のドットを削除した) 残りの名前で検索が行われる。"

#. type: Plain text
#: build/C/man7/hostname.7:85
msgid ""
"If the input name does not end with a trailing dot, it is looked up by "
"searching through a list of domains until a match is found.  The default "
"search list includes first the local domain, then its parent domains with at "
"least 2 name components (longest first).  For example, in the domain CS."
"Berkeley.EDU, the name lithium.CChem will be checked first as lithium.CChem."
"CS.Berkeley.EDU and then as lithium.CChem.Berkeley.EDU.  Lithium.CChem.EDU "
"will not be tried, as there is only one component remaining from the local "
"domain.  The search path can be changed from the default by a system-wide "
"configuration file (see B<resolver>(5))."
msgstr ""
"入力された名前の末尾がドットでない場合、\n"
"マッチするものが見つかるまでドメインのリストの検索が行われる。\n"
"デフォルトのドメインの検索リストは、先頭ローカルのドメインで、\n"
"親ドメインが (長いものから順に) 続く (親ドメインはドット区切りで\n"
"少なくとも 2 要素あるものだけが使用される)。\n"
"例えば、 CS.Berkeley.EDU ドメインで、\n"
"lithium.CChem というホスト名の場合には、\n"
"最初に lithium.CChem.CS.Berkeley.EDU が確認され、\n"
"次に lithium.CChem.Berkeley.EDU が確認される。\n"
"Lithium.CChem.EDU はチェックされない。\n"
"なぜなら、ローカルドメイン CS.Berkeley.EDU で残っているドメインは\n"
"EDU で、これは一つしか要素がないからである。\n"
"検索リストはシステム全体で共通の設定ファイルでデフォルト値から\n"
"変更できる (B<resolver>(5) 参照)。"

#.  .SH HISTORY
#.  Hostname appeared in
#.  4.2BSD.
#. type: Plain text
#: build/C/man7/hostname.7:93
msgid "B<gethostbyname>(3), B<resolver>(5), B<mailaddr>(7), B<named>(8)"
msgstr "B<gethostbyname>(3), B<resolver>(5), B<mailaddr>(7), B<named>(8)"

#. type: TH
#: build/C/man5/hosts.5:27
#, no-wrap
msgid "HOSTS"
msgstr "HOSTS"

#. type: TH
#: build/C/man5/hosts.5:27
#, no-wrap
msgid "2002-06-16"
msgstr "2002-06-16"

#. type: Plain text
#: build/C/man5/hosts.5:30
msgid "hosts - static table lookup for hostnames"
msgstr "hosts - ホスト名の静的なルックアップテーブル"

#. type: Plain text
#: build/C/man5/hosts.5:32
msgid "B</etc/hosts>"
msgstr "B</etc/hosts>"

#. type: Plain text
#: build/C/man5/hosts.5:40
msgid ""
"This manual page describes the format of the I</etc/hosts> file.  This file "
"is a simple text file that associates IP addresses with hostnames, one line "
"per IP address.  For each host a single line should be present with the "
"following information:"
msgstr ""
"このマニュアルページは、 I</etc/hosts> ファイルのフォーマットについて記述して"
"いる。 このファイルは簡単なテキストファイルで、1 行に 1 つの IP アドレスがあ"
"り、 IP アドレスとホスト名を関連づけている。 各ホストについて、次のような情報"
"が 1 行で与えられる。"

#. type: Plain text
#: build/C/man5/hosts.5:43
msgid "IP_address canonical_hostname [aliases...]"
msgstr "IPアドレス 正式なホスト名 [エイリアス...]"

#. type: Plain text
#: build/C/man5/hosts.5:56
msgid ""
"Fields of the entry are separated by any number of blanks and/or tab "
"characters.  Text from a \"#\" character until the end of the line is a "
"comment, and is ignored.  Host names may contain only alphanumeric "
"characters, minus signs (\"-\"), and periods (\".\").  They must begin with "
"an alphabetic character and end with an alphanumeric character.  Optional "
"aliases provide for name changes, alternate spellings, shorter hostnames, or "
"generic hostnames (for example, I<localhost>)."
msgstr ""
"エントリのフィールドは、空白またはタブ (複数でも可) で区切られる。 \"#\" 文字"
"から行末までのテキストはコメントとして無視される。 ホスト名は英数字・マイナス"
"記号 (\"-\")・ピリオド (\".\") を含むことができる。 ホスト名は英文字 "
"(alphabetic character) で始まって、 英数字 (alphanumeric characte) で終わらな"
"ければならない。 エイリアスはオプションであり、名前の変更、別のスペル、 短い"
"ホスト名、一般的に使われるホスト名 (例えば I<localhost>)  などのために用意さ"
"れている。"

#. type: Plain text
#: build/C/man5/hosts.5:64
msgid ""
"The Berkeley Internet Name Domain (BIND) Server implements the Internet name "
"server for UNIX systems.  It augments or replaces the I</etc/hosts> file or "
"hostname lookup, and frees a host from relying on I</etc/hosts> being up to "
"date and complete."
msgstr ""
"Berkeley Internet Name Domain (BIND) サーバは、 UNIX システムのためのインター"
"ネットネームサーバを実装している。 これは、 I</etc/hosts> ファイルやホスト名"
"ルックアップを拡張したり置き換えたりするものである。 これにより各ホストは I</"
"etc/hosts> を最新かつ完全に保たなくてもよくなる。"

#. type: Plain text
#: build/C/man5/hosts.5:67
msgid ""
"In modern systems, even though the host table has been superseded by DNS, it "
"is still widely used for:"
msgstr ""
"ホストテーブルは、DNS にとって代わられたにもかかわらず、 現在のシステムにおい"
"て次のような用途で広く使われている。"

#. type: TP
#: build/C/man5/hosts.5:67
#, no-wrap
msgid "B<bootstrapping>"
msgstr "B<ブート時>"

#. type: Plain text
#: build/C/man5/hosts.5:73
msgid ""
"Most systems have a small host table containing the name and address "
"information for important hosts on the local network.  This is useful when "
"DNS is not running, for example during system bootup."
msgstr ""
"大部分のシステムは、ローカルネットワークにおいて重要なホストの 名前とアドレス"
"が含まれた小さなホストテーブルを持っている。 これは、システムのブート時など"
"の DNS が稼働していないときに役立つ。"

#. type: TP
#: build/C/man5/hosts.5:73
#, no-wrap
msgid "B<NIS>"
msgstr "B<NIS>"

#. type: Plain text
#: build/C/man5/hosts.5:79
msgid ""
"Sites that use NIS use the host table as input to the NIS host database.  "
"Even though NIS can be used with DNS, most NIS sites still use the host "
"table with an entry for all local hosts as a backup."
msgstr ""
"NIS を使用しているサイトは、ホストテーブルを NIS ホストデータベースの入力とし"
"て用いる。 NIS を DNS と共に使用できるにもかかわらず、 大部分の NIS サイトは"
"未だに、 全てのローカルホストのエントリをもつホストテーブルを バックアップと"
"して使用している。"

#. type: TP
#: build/C/man5/hosts.5:79
#, no-wrap
msgid "B<isolated nodes>"
msgstr "B<隔絶されたノード>"

#. type: Plain text
#: build/C/man5/hosts.5:86
msgid ""
"Very small sites that are isolated from the network use the host table "
"instead of DNS.  If the local information rarely changes, and the network is "
"not connected to the Internet, DNS offers little advantage."
msgstr ""
"ネットワークから隔絶された非常に小さなサイトは、 DNS の代わりにホストテーブル"
"を使用している。 ローカル情報が稀にしか変更されず、 ネットワークがインター"
"ネットと接続されていない場合、 DNS にそれほどの利点はない。"

#. type: Plain text
#: build/C/man5/hosts.5:91
msgid ""
"Modifications to this file normally take effect immediately, except in cases "
"where the file is cached by applications."
msgstr ""
"このファイルへの変更は通常すぐに反映される。但し、アプリケーション によりファ"
"イルの内容がキャッシュされている場合はこの限りではない。"

#. type: SS
#: build/C/man5/hosts.5:91
#, no-wrap
msgid "Historical notes"
msgstr "歴史的な経緯"

#. type: Plain text
#: build/C/man5/hosts.5:94
msgid ""
"RFC\\ 952 gave the original format for the host table, though it has since "
"changed."
msgstr ""
"ホストテーブルのフォーマットはその後変更されているが、 元々のフォーマットは "
"RFC\\ 952 には記載されている。"

#. type: Plain text
#: build/C/man5/hosts.5:107
msgid ""
"Before the advent of DNS, the host table was the only way of resolving "
"hostnames on the fledgling Internet.  Indeed, this file could be created "
"from the official host data base maintained at the Network Information "
"Control Center (NIC), though local changes were often required to bring it "
"up to date regarding unofficial aliases and/or unknown hosts.  The NIC no "
"longer maintains the hosts.txt files, though looking around at the time of "
"writing (circa 2000), there are historical hosts.txt files on the WWW.  I "
"just found three, from 92, 94, and 95."
msgstr ""
"DNS の登場以前、ホストテーブルは、駆け出したばかりのインターネットにおける ホ"
"スト名解決の唯一の方法であった。 実際、このファイルは Network Information "
"Control Center (NIC) によって 管理される公式ホストデータベースから作成するこ"
"とができた。 しかし、非公式なエイリアスや不明なホストを扱えるように、 最新に"
"保つためのローカルな変更が頻繁に必要とされた。 NIC は既に hosts.txt を管理し"
"ていないが、 これを書いている (2000 年頃の) 時点で調べてみると、 WWW 上に歴史"
"的な hosts.txt が存在する。 92, 94, 95 年のものが見つかった。"

#. type: Plain text
#: build/C/man5/hosts.5:114
#, no-wrap
msgid ""
"127.0.0.1       localhost\n"
"192.168.1.10    foo.mydomain.org       foo\n"
"192.168.1.13    bar.mydomain.org       bar\n"
"146.82.138.7    master.debian.org      master\n"
"209.237.226.90  www.opensource.org\n"
msgstr ""
"127.0.0.1       localhost\n"
"192.168.1.10    foo.mydomain.org       foo\n"
"192.168.1.13    bar.mydomain.org       bar\n"
"146.82.138.7    master.debian.org      master\n"
"209.237.226.90  www.opensource.org\n"

#. type: Plain text
#: build/C/man5/hosts.5:121
msgid ""
"B<hostname>(1), B<resolver>(3), B<resolver>(5), B<hostname>(7), B<named>(8)"
msgstr ""
"B<hostname>(1), B<resolver>(3), B<resolver>(5), B<hostname>(7), B<named>(8)"

#.  .SH AUTHOR
#.  This manual page was written by Manoj Srivastava <srivasta@debian.org>,
#.  for the Debian GNU/Linux system.
#. type: Plain text
#: build/C/man5/hosts.5:126
msgid "Internet RFC\\ 952"
msgstr "Internet RFC\\ 952"

#. type: TH
#: build/C/man5/hosts.equiv.5:6
#, no-wrap
msgid "HOSTS.EQUIV"
msgstr "HOSTS.EQUIV"

#. type: TH
#: build/C/man5/hosts.equiv.5:6
#, no-wrap
msgid "2003-08-24"
msgstr "2003-08-24"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:11
msgid ""
"/etc/hosts.equiv - list of hosts and users that are granted \"trusted\" B<r> "
"command access to your system"
msgstr ""
"/etc/hosts.equiv - 「信頼された」B<r> コマンドによるシステムへの アクセスを許"
"可するホストおよびユーザのリスト"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:22
msgid ""
"The B<hosts.equiv> file allows or denies hosts and users to use the B<r>-"
"commands (e.g., B<rlogin>, B<rsh> or B<rcp>)  without supplying a password."
msgstr ""
"B<hosts.equiv> ファイルは B<r>-コマンド (B<rlogin>, B<rsh>, B<rcp> など) によ"
"るパスワードなしでの利用を 許可/拒否するホスト/ユーザを設定する。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:24
msgid "The file uses the following format:"
msgstr "このファイルでは以下の書式を用いる。"

#. type: TP
#: build/C/man5/hosts.equiv.5:24
#, no-wrap
msgid "I<[ + | - ]> I<[hostname]> I<[username]>"
msgstr "I<[ + | - ]> I<[hostname]> I<[username]>"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:43
msgid ""
"The I<hostname> is the name of a host which is logically equivalent to the "
"local host.  Users logged into that host are allowed to access like-named "
"user accounts on the local host without supplying a password.  The "
"I<hostname> may be (optionally) preceded by a plus (+) sign.  If the plus "
"sign is used alone it allows any host to access your system.  You can "
"explicitly deny access to a host by preceding the I<hostname> by a minus (-) "
"sign.  Users from that host must always supply a password.  For security "
"reasons you should always use the FQDN of the hostname and not the short "
"hostname."
msgstr ""
"I<hostname> は、ローカルホストと論理的に等価なホストの名前である。 そのホスト"
"にログインしているユーザは、パスワードなしで ローカルホストの同じ名前のユーザ"
"アカウントにアカウントできる。 I<hostname> の前にはプラス記号 (+) を置いても"
"よい。プラス記号が単独で置かれた場合は、 このシステムへのアクセスをあらゆるホ"
"ストに対して許可したことになる。 アクセスを明示的に拒否するには、 "
"I<hostname> の前にマイナス記号 (-) を付ける。そのホストからのユーザは 常にパ"
"スワードを要求される。セキュリティ上、ホスト名は 短い名前ではなく常に FQDN を"
"使って指定すべきである。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:61
msgid ""
"The I<username> entry grants a specific user access to all user accounts "
"(except root) without supplying a password.  That means the user is NOT "
"restricted to like-named accounts.  The I<username> may be (optionally) "
"preceded by a plus (+) sign.  You can also explicitly deny access to a "
"specific user by preceding the I<username> with a minus (-) sign.  This says "
"that the user is not trusted no matter what other entries for that host "
"exist."
msgstr ""
"I<username> エントリは、特定のユーザに対して、 (root 以外の) あらゆるユーザア"
"カウント へのアクセスをパスワードなしで許可する。すなわち、そのユーザは同じ名"
"前の アカウント以外にもアクセスできる。 I<username> の前にはプラス記号 (+) を"
"置いてもよい。 特定のユーザからのアクセスを明示的に拒否するには、 "
"I<username> の前にマイナス記号 (-) を付ける。こうすると、 ホストのエントリが"
"なんと言おうとも、そのユーザは信頼されないことになる。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:63
msgid "Netgroups can be specified by preceding the netgroup by an @ sign."
msgstr "netgroup を指定することもでき、その場合は @ 記号を前につける。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:69
msgid ""
"Be extremely careful when using the plus (+) sign.  A simple typographical "
"error could result in a standalone plus sign.  A standalone plus sign is a "
"wildcard character that means \"any host\"!"
msgstr ""
"プラス記号 (+) を利用する際にはくれぐれも注意すること。 単純なミスタイプで、"
"単独のプラス記号を置いてしまうことがある。 単独のプラス記号は「すべてのホス"
"ト」を表すワイルドカードになってしまう!"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:71
msgid "I</etc/hosts.equiv>"
msgstr "I</etc/hosts.equiv>"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:76
msgid ""
"Some systems will honor the contents of this file only when it has owner "
"root and no write permission for anybody else.  Some exceptionally paranoid "
"systems even require that there be no other hard links to the file."
msgstr ""
"システムによっては、このファイルの内容が効力を持つのは、 このファイルの所有者"
"が root で、 かつそれ以外に書き込み権限がない場合に限定されていることもあ"
"る。 また、非常に制限がきついシステムでは、このファイルに対する他の ハードリ"
"ンクがないことが要求される場合もある。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:84
msgid ""
"Modern systems use the Pluggable Authentication Modules library (PAM).  With "
"PAM a standalone plus sign is considered a wildcard character which means "
"\"any host\" only when the word I<promiscuous> is added to the auth "
"component line in your PAM file for the particular service (e.g., B<rlogin>)."
msgstr ""
"最近のシステムでは Pluggable Authentication Modules library (PAM) が 使われて"
"いる。PAM では、単独のプラス記号が「すべてのホスト」を表す ワイルドカードとし"
"て扱われるのは、特定のサービス (例えば B<rlogin>)  用の PAM ファイルで auth "
"行にキーワード I<promiscuous> が追加されている場合のみである。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:88
msgid "B<rhosts>(5), B<rlogind>(8), B<rshd>(8)"
msgstr "B<rhosts>(5), B<rlogind>(8), B<rshd>(8)"

#. type: TH
#: build/C/man7/icmp.7:12
#, no-wrap
msgid "ICMP"
msgstr "ICMP"

#. type: TH
#: build/C/man7/icmp.7:12 build/C/man8/nscd.8:23 build/C/man7/packet.7:12
#: build/C/man7/raw.7:13 build/C/man7/unix.7:18
#, no-wrap
msgid "2012-05-10"
msgstr "2012-05-10"

#. type: Plain text
#: build/C/man7/icmp.7:15
msgid "icmp - Linux IPv4 ICMP kernel module."
msgstr "icmp - Linux IPv4 ICMP カーネルモジュール"

#. type: Plain text
#: build/C/man7/icmp.7:23
msgid ""
"This kernel protocol module implements the Internet Control Message Protocol "
"defined in RFC\\ 792.  It is used to signal error conditions and for "
"diagnosis.  The user doesn't interact directly with this module; instead it "
"communicates with the other protocols in the kernel and these pass the ICMP "
"errors to the application layers.  The kernel ICMP module also answers ICMP "
"requests."
msgstr ""
"このカーネルモジュールは RFC\\ 792 で定義されている Internet Control Message "
"Protocol を実装したものである。 このプロトコルはエラー状況を知らせたり診断を"
"行うために用いられる。 ユーザーはこのモジュールとは直接には通信できない。 こ"
"のモジュールはカーネルの他のプロトコルと通信し、 それらのプロトコルが ICMP エ"
"ラーをアプリケーションレイヤに渡す。 カーネルの ICMP モジュールは ICMP リクエ"
"ストに対する応答も行う。"

#. type: Plain text
#: build/C/man7/icmp.7:35
msgid ""
"A user protocol may receive ICMP packets for all local sockets by opening a "
"raw socket with the protocol B<IPPROTO_ICMP>.  See B<raw>(7)  for more "
"information.  The types of ICMP packets passed to the socket can be filtered "
"using the B<ICMP_FILTER> socket option.  ICMP packets are always processed "
"by the kernel too, even when passed to a user socket."
msgstr ""
"raw ソケットをプロトコル B<IPPROTO_ICMP> でオープンすれば、 ユーザープロトコ"
"ルはローカルなソケット全てに対する ICMP パケットを受信することができる。 詳細"
"は B<raw>(7)  を参照のこと。 ソケットに渡される ICMP パケットのタイプは "
"B<ICMP_FILTER> オプションによってフィルターできる。 ICMP パケットは (たとえ"
"ユーザーソケットに渡される場合でも)、 常にカーネルによって (も) 処理される。"

#. type: Plain text
#: build/C/man7/icmp.7:41
msgid ""
"Linux limits the rate of ICMP error packets to each destination.  "
"B<ICMP_REDIRECT> and B<ICMP_DEST_UNREACH> are also limited by the "
"destination route of the incoming packets."
msgstr ""
"Linux では ICMP エラーパケットのレートをそれぞれの送り先に対して 制限してい"
"る。 B<ICMP_REDIRECT> と B<ICMP_DEST_UNREACH> も到着したパケットの行き先経路 "
"(destination route) を制限する。"

#.  FIXME better description needed
#. type: Plain text
#: build/C/man7/icmp.7:54
msgid ""
"ICMP supports a set of I</proc> interfaces to configure some global IP "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/ipv4/>.  Most of these parameters are rate "
"limitations for specific ICMP types.  Linux 2.2 uses a token bucket filter "
"to limit ICMPs.  The value is the timeout in jiffies until the token bucket "
"filter is cleared after a burst.  A jiffy is a system dependent unit, "
"usually 10ms on i386 and about 1ms on alpha and ia64."
msgstr ""
"ICMP では、いくつかのグローバルパラメータを設定するための I</proc> ファイル群"
"が用意されている。 これらのパラメータには、 I</proc/sys/net/ipv4/> ディレクト"
"リ内のファイルの読み書きでアクセスできる。 これらのパラメータのほとんどは特定"
"の ICMP タイプに対するレート制限 (rate limitation) である。 Linux 2.2 は "
"ICMP の制限にトークン・バケット・フィルタ (token bucket filter) を用いる。 そ"
"れぞれの値は、バーストの後にトークン・バケット・フィルタがクリア されるまでの"
"タイムアウトを秒単位で表したものである。最小単位(jiffy)は システム依存の単位"
"で i386 システムは通常 10ms、alpha や ia64 では 1ms である。"

#. type: TP
#: build/C/man7/icmp.7:54
#, no-wrap
msgid "I<icmp_destunreach_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_destunreach_rate> (Linux 2.2 から 2.4.9 まで)"

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:63
msgid ""
"Maximum rate to send ICMP Destination Unreachable packets.  This limits the "
"rate at which packets are sent to any individual route or destination.  The "
"limit does not affect sending of B<ICMP_FRAG_NEEDED> packets needed for path "
"MTU discovery."
msgstr ""
"ICMP 不達パケット (Destination Unreachable packet) を送る最大レート。 これは"
"特定のルートまたは行き先にパケットを送信するレートを制限する。 この制限は、 "
"path MTU discovery に必要な B<ICMP_FRAG_NEEDED> パケットの送信には影響しな"
"い。"

#. type: TP
#: build/C/man7/icmp.7:63
#, no-wrap
msgid "I<icmp_echo_ignore_all> (since Linux 2.2)"
msgstr "I<icmp_echo_ignore_all> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:69
msgid "If this value is nonzero, Linux will ignore all B<ICMP_ECHO> requests."
msgstr ""
"この値が非ゼロの場合は、 Linux はすべての B<ICMP_ECHO> 要求を無視する。"

#. type: TP
#: build/C/man7/icmp.7:69
#, no-wrap
msgid "I<icmp_echo_ignore_broadcasts> (since Linux 2.2)"
msgstr "I<icmp_echo_ignore_broadcasts> (Linux 2.2 以降)"

#.  Precisely: from 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:75
msgid ""
"If this value is nonzero, Linux will ignore all B<ICMP_ECHO> packets sent to "
"broadcast addresses."
msgstr ""
"この値が非ゼロの場合は、 Linux はブロードキャストアドレスに送られたすべての "
"B<ICMP_ECHO> 要求を無視する。"

#. type: TP
#: build/C/man7/icmp.7:75
#, no-wrap
msgid "I<icmp_echoreply_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_echoreply_rate> (Linux 2.2 から 2.4.9 まで)"

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:83
msgid ""
"Maximum rate for sending B<ICMP_ECHOREPLY> packets in response to "
"B<ICMP_ECHOREQUEST> packets."
msgstr ""
"B<ICMP_ECHOREQUEST> パケットに応答する B<ICMP_ECHOREPLY> パケットの最大送信"
"レート。"

#. type: TP
#: build/C/man7/icmp.7:83
#, no-wrap
msgid "I<icmp_errors_use_inbound_ifaddr> (Boolean; default: disabled; since Linux 2.6.12)"
msgstr "I<icmp_errors_use_inbound_ifaddr> (Boolean; default: disabled; Linux 2.6.12 以降)"

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:88
msgid ""
"If disabled, ICMP error messages are sent with the primary address of the "
"exiting interface."
msgstr ""
"これを無効にすると、ICMP エラーメッセージは、 出力インタフェースのプライマリ"
"アドレスで送信される。"

#. type: Plain text
#: build/C/man7/icmp.7:94
msgid ""
"If enabled, the message will be sent with the primary address of the "
"interface that received the packet that caused the ICMP error.  This is the "
"behavior that many network administrators will expect from a router.  And it "
"can make debugging complicated network layouts much easier."
msgstr ""
"これを有効にすると、エラーメッセージは ICMP エラーの原因となったパケットを 受"
"信したインタフェースのプライマアドレスで送信される。 この動作は、多くのネット"
"ワーク管理者がルータに対して期待しているものであり、 これにより複雑なネット"
"ワークレイアウトのデバッグがより容易になる。"

#. type: Plain text
#: build/C/man7/icmp.7:98
msgid ""
"Note that if no primary address exists for the interface selected, then the "
"primary address of the first non-loopback interface that has one will be "
"used regardless of this setting."
msgstr ""
"選択されたインタフェースでプライマリアドレスが存在しない場合は、 この設定に関"
"わらず、最初のループバック以外のインタフェースで、 プライマリアドレスを持つイ"
"ンタフェースのプライマリアドレスが使用される点に 注意すること。"

#. type: TP
#: build/C/man7/icmp.7:98
#, no-wrap
msgid "I<icmp_ignore_bogus_error_responses> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<icmp_ignore_bogus_error_responses> (Boolean; default: disabled; Linux 2.2 以降)"

#.  precisely: since 2.1.32
#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:106
msgid ""
"Some routers violate RFC1122 by sending bogus responses to broadcast "
"frames.  Such violations are normally logged via a kernel warning.  If this "
"parameter is enabled, the kernel will not give such warnings, which will "
"avoid log file clutter."
msgstr ""
"ルータの中には、RFC1122 に違反し、ブロードキャストフレームに対して 偽の応答を"
"送信するものがある。 このような違反は通常カーネルの警告としてログに記録され"
"る。 このパラメータを有効にすると、カーネルはこのような警告を出さなくなり、 "
"ログファイルに雑音のような情報が記録されるのを避けることができる。"

#. type: TP
#: build/C/man7/icmp.7:106
#, no-wrap
msgid "I<icmp_paramprob_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_paramprob_rate> (Linux 2.2 から 2.4.9 まで)"

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:113
msgid ""
"Maximum rate for sending B<ICMP_PARAMETERPROB> packets.  These packets are "
"sent when a packet arrives with an invalid IP header."
msgstr ""
"B<ICMP_PARAMETERPROB> パケットの最大送信レート。 これらのパケットは不正な IP "
"ヘッダを持つパケットが到着した場合に 送信される。"

#. type: TP
#: build/C/man7/icmp.7:113
#, no-wrap
msgid "I<icmp_ratelimit> (integer; default: 1000; since Linux 2.4.10)"
msgstr "I<icmp_ratelimit> (integer; default: 1000; Linux 2.4.10 以降)"

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:121
msgid ""
"Limit the maximum rates for sending ICMP packets whose type matches "
"I<icmp_ratemask> (see below) to specific targets.  0 to disable any "
"limiting, otherwise the minimum space between responses in milliseconds."
msgstr ""
"種別が I<icmp_ratemask> (下記参照) にマッチした ICMP パケットの、 特定の送信"
"先への送信レートの最大値を制限する。 0 はレート制限を無効にすることを、 0 以"
"外の値は応答間の最小間隔 (ミリ秒単位) を示す。"

#. type: TP
#: build/C/man7/icmp.7:121
#, no-wrap
msgid "I<icmp_ratemask> (integer; default: see below; since Linux 2.4.10)"
msgstr "I<icmp_ratemask> (integer; default: 下記参照; Linux 2.4.10 以降)"

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:125
msgid "Mask made of ICMP types for which rates are being limited."
msgstr "レート制限を行う ICMP タイプを決めるマスク。"

#. type: Plain text
#: build/C/man7/icmp.7:127
msgid "Significant bits: IHGFEDCBA9876543210"
msgstr "有効ビット: IHGFEDCBA9876543210"

#. type: Plain text
#: build/C/man7/icmp.7:129
msgid "Default mask: 0000001100000011000 (0x1818)"
msgstr "デフォルトマスク: 0000001100000011000 (0x1818)"

#. type: Plain text
#: build/C/man7/icmp.7:132
msgid ""
"Bit definitions (see the Linux kernel source file I<include/linux/icmp.h>):"
msgstr ""
"ビット定義 (Linux カーネルソースファイル I<include/linux/icmp.h> を参照):"

#. type: tbl table
#: build/C/man7/icmp.7:136
#, no-wrap
msgid "0 Echo Reply\n"
msgstr "0 Echo Reply\n"

#. type: tbl table
#: build/C/man7/icmp.7:137
#, no-wrap
msgid "3 Destination Unreachable *\n"
msgstr "3 Destination Unreachable *\n"

#. type: tbl table
#: build/C/man7/icmp.7:138
#, no-wrap
msgid "4 Source Quench *\n"
msgstr "4 Source Quench *\n"

#. type: tbl table
#: build/C/man7/icmp.7:139
#, no-wrap
msgid "5 Redirect\n"
msgstr "5 Redirect\n"

#. type: tbl table
#: build/C/man7/icmp.7:140
#, no-wrap
msgid "8 Echo Request\n"
msgstr "8 Echo Request\n"

#. type: tbl table
#: build/C/man7/icmp.7:141
#, no-wrap
msgid "B Time Exceeded *\n"
msgstr "B Time Exceeded *\n"

#. type: tbl table
#: build/C/man7/icmp.7:142
#, no-wrap
msgid "C Parameter Problem *\n"
msgstr "C Parameter Problem *\n"

#. type: tbl table
#: build/C/man7/icmp.7:143
#, no-wrap
msgid "D Timestamp Request\n"
msgstr "D Timestamp Request\n"

#. type: tbl table
#: build/C/man7/icmp.7:144
#, no-wrap
msgid "E Timestamp Reply\n"
msgstr "E Timestamp Reply\n"

#. type: tbl table
#: build/C/man7/icmp.7:145
#, no-wrap
msgid "F Info Request\n"
msgstr "F Info Request\n"

#. type: tbl table
#: build/C/man7/icmp.7:146
#, no-wrap
msgid "G Info Reply\n"
msgstr "G Info Reply\n"

#. type: tbl table
#: build/C/man7/icmp.7:147
#, no-wrap
msgid "H Address Mask Request\n"
msgstr "H Address Mask Request\n"

#. type: tbl table
#: build/C/man7/icmp.7:148
#, no-wrap
msgid "I Address Mask Reply\n"
msgstr "I Address Mask Reply\n"

#. type: Plain text
#: build/C/man7/icmp.7:154
msgid ""
"The bits marked with an asterisk are rate limited by default (see the "
"default mask above)."
msgstr ""
"アスタリスク印 (*) が付いたビットは、 デフォルトでレート制限が有効になってい"
"る (上記のマスクのデフォルトも参照)。"

#. type: TP
#: build/C/man7/icmp.7:154
#, no-wrap
msgid "I<icmp_timeexceed_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_timeexceed_rate> (Linux 2.2 から 2.4.9 まで)"

#. type: Plain text
#: build/C/man7/icmp.7:161
msgid ""
"Maximum rate for sending B<ICMP_TIME_EXCEEDED> packets.  These packets are "
"sent to prevent loops when a packet has crossed too many hops."
msgstr ""
"B<ICMP_TIME_EXCEEDED> パケットの最大送信レート。 これらのパケットはパケットが"
"あまりに多くの hop を通過した場合に、 ループを防ぐために送られる。"

#. type: Plain text
#: build/C/man7/icmp.7:165
msgid "Support for the B<ICMP_ADDRESS> request was removed in 2.2."
msgstr "B<ICMP_ADDRESS> 要求に対するサポートは 2.2 で削除された。"

#. type: Plain text
#: build/C/man7/icmp.7:169
msgid "Support for B<ICMP_SOURCE_QUENCH> was removed in Linux 2.2."
msgstr "B<ICMP_SOURCE_QUENCH> は Linux 2.2 で削除された。"

#.  not really true ATM
#.  .PP
#.  Linux ICMP should be compliant to RFC 1122.
#. type: Plain text
#: build/C/man7/icmp.7:177
msgid ""
"As many other implementations don't support B<IPPROTO_ICMP> raw sockets, "
"this feature should not be relied on in portable programs."
msgstr ""
"他の多くの実装では、 B<IPPROTO_ICMP> raw ソケットがサポートされていない。 こ"
"の機能は移植性が必要なプログラムでは用いるべきでない。"

#. type: Plain text
#: build/C/man7/icmp.7:182
msgid ""
"B<ICMP_REDIRECT> packets are not sent when Linux is not acting as a router.  "
"They are also accepted only from the old gateway defined in the routing "
"table and the redirect routes are expired after some time."
msgstr ""
"Linux がルーターとして動作していないときには、 B<ICMP_REDIRECT> パケットは送"
"信されない。 またこれらが受け取られるのも、発信元がルーティングテーブルに定義"
"されている 古いゲートウェイで、リダイレクト・ルート (redirect route) が 適当"
"な時間の後に期限切れになっている場合に限られる。"

#. type: Plain text
#: build/C/man7/icmp.7:186
msgid ""
"The 64-bit timestamp returned by B<ICMP_TIMESTAMP> is in milliseconds since "
"the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""
"B<ICMP_TIMESTAMP> から返される 64 ビットのタイムスタンプは、 紀元 (Epoch) で"
"ある 1970-01-01 00:00:00 +0000 (UTC)  からの経過時間をミリ秒単位で表したもの"
"である。"

#. type: Plain text
#: build/C/man7/icmp.7:191
msgid ""
"Linux ICMP internally uses a raw socket to send ICMPs.  This raw socket may "
"appear in B<netstat>(8)  output with a zero inode."
msgstr ""
"Linux ICMP は ICMP を送るために内部で raw ソケットを用いる。 raw ソケットは "
"B<netstat>(8)  の出力に 0 inode として出力される。"

#. type: Plain text
#: build/C/man7/icmp.7:193
msgid "B<ip>(7)"
msgstr "B<ip>(7)"

#. type: Plain text
#: build/C/man7/icmp.7:195
msgid "RFC\\ 792 for a description of the ICMP protocol."
msgstr "B<RFC\\ 792>: ICMP プロトコルの説明"

#. type: TH
#: build/C/man3/inet.3:42
#, no-wrap
msgid "INET"
msgstr "INET"

#. type: TH
#: build/C/man3/inet.3:42
#, no-wrap
msgid "2013-02-10"
msgstr "2013-02-10"

#. type: Plain text
#: build/C/man3/inet.3:46
msgid ""
"inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, "
"inet_netof - Internet address manipulation routines"
msgstr ""
"inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, "
"inet_netof - インターネットアドレス操作ルーチン"

#. type: Plain text
#: build/C/man3/inet.3:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/inet.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/inet.3:53
#, no-wrap
msgid "B<int inet_aton(const char *>I<cp>B<, struct in_addr *>I<inp>B<);>\n"
msgstr "B<int inet_aton(const char *>I<cp>B<, struct in_addr *>I<inp>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:55
#, no-wrap
msgid "B<in_addr_t inet_addr(const char *>I<cp>B<);>\n"
msgstr "B<in_addr_t inet_addr(const char *>I<cp>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:57
#, no-wrap
msgid "B<in_addr_t inet_network(const char *>I<cp>B<);>\n"
msgstr "B<in_addr_t inet_network(const char *>I<cp>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:59
#, no-wrap
msgid "B<char *inet_ntoa(struct in_addr >I<in>B<);>\n"
msgstr "B<char *inet_ntoa(struct in_addr >I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:61
#, no-wrap
msgid "B<struct in_addr inet_makeaddr(int >I<net>B<, int >I<host>B<);>\n"
msgstr "B<struct in_addr inet_makeaddr(int >I<net>B<, int >I<host>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:63
#, no-wrap
msgid "B<in_addr_t inet_lnaof(struct in_addr >I<in>B<);>\n"
msgstr "B<in_addr_t inet_lnaof(struct in_addr >I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:65
#, no-wrap
msgid "B<in_addr_t inet_netof(struct in_addr >I<in>B<);>\n"
msgstr "B<in_addr_t inet_netof(struct in_addr >I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:75
msgid "B<inet_aton>(), B<inet_ntoa>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<inet_aton>(), B<inet_ntoa>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/inet.3:85
msgid ""
"B<inet_aton>()  converts the Internet host address I<cp> from the IPv4 "
"numbers-and-dots notation into binary form (in network byte order)  and "
"stores it in the structure that I<inp> points to.  B<inet_aton>()  returns "
"nonzero if the address is valid, zero if not.  The address supplied in I<cp> "
"can have one of the following forms:"
msgstr ""
"B<inet_aton>()  は、インターネットホストのアドレス I<cp> を、 IPv4 の数値と"
"ドットによる表記から (ネットワークバイトオーダの) バイナリ値へ 変換し、変換結"
"果を I<inp> が指している構造体に格納する。 アドレスが有効な場合 0 以外を返"
"し、そうでない場合は 0 を返す。 I<cp> で渡すアドレスとして、以下の形式を用い"
"ることができる。"

#. type: TP
#: build/C/man3/inet.3:85
#, no-wrap
msgid "I<a.b.c.d>"
msgstr "I<a.b.c.d>"

#. type: Plain text
#: build/C/man3/inet.3:89
msgid ""
"Each of the four numeric parts specifies a byte of the address; the bytes "
"are assigned in left-to-right order to produce the binary address."
msgstr ""
"4 つの数字のそれぞれはアドレスの各バイトを示す。 これらのバイトは左から右の順"
"序でバイナリアドレスに割り当てられる。"

#. type: TP
#: build/C/man3/inet.3:89
#, no-wrap
msgid "I<a.b.c>"
msgstr "I<a.b.c>"

#. type: Plain text
#: build/C/man3/inet.3:102
msgid ""
"Parts I<a> and I<b> specify the first two bytes of the binary address.  Part "
"I<c> is interpreted as a 16-bit value that defines the rightmost two bytes "
"of the binary address.  This notation is suitable for specifying (outmoded) "
"Class B network addresses."
msgstr ""
"I<a> と I<b> はバイナリアドレスの最初の 2 バイトを示す。 I<c> は 16 ビット値"
"と解釈され、バイナリアドレスの右側の 2 バイトを表す。 この表記は、(過去のもの"
"となった) クラス B ネットワークアドレスを 指定するのに適している。"

#. type: TP
#: build/C/man3/inet.3:102
#, no-wrap
msgid "I<a.b>"
msgstr "I<a.b>"

#. type: Plain text
#: build/C/man3/inet.3:113
msgid ""
"Part I<a> specifies the first byte of the binary address.  Part I<b> is "
"interpreted as a 24-bit value that defines the rightmost three bytes of the "
"binary address.  This notation is suitable for specifying (outmoded) Class C "
"network addresses."
msgstr ""
"I<a> はバイナリアドレスの最初のバイトを示す。 I<b> は 24 ビット値と解釈され、"
"バイナリアドレスの右側の 3 バイトを表す。 この表記は、(過去のものとなった) ク"
"ラス C ネットワークアドレスを 指定するのに適している。"

#. type: TP
#: build/C/man3/inet.3:113
#, no-wrap
msgid "I<a>"
msgstr "I<a>"

#. type: Plain text
#: build/C/man3/inet.3:119
msgid ""
"The value I<a> is interpreted as a 32-bit value that is stored directly into "
"the binary address without any byte rearrangement."
msgstr ""
"値 I<a> は 32 ビット値と解釈され、バイトの再配置は行われず、 そのままバイナリ"
"アドレスとして格納される。"

#. type: Plain text
#: build/C/man3/inet.3:132
msgid ""
"In all of the above forms, components of the dotted address can be specified "
"in decimal, octal (with a leading I<0>), or hexadecimal, with a leading "
"I<0X>).  Addresses in any of these forms are collectively termed I<IPV4 "
"numbers-and-dots notation>.  The form that uses exactly four decimal numbers "
"is referred to as I<IPv4 dotted-decimal notation> (or sometimes: I<IPv4 "
"dotted-quad notation>)."
msgstr ""
"上記の全ての形式で、ドット区切りのアドレスの各要素は、10 進数、 8 進数 (先頭"
"に I<0> を付ける)、 16 進数 (先頭に I<0X> を付ける) で指定できる。 これらの形"
"式のアドレスをまとめて I<IPv4 の数値とドットによる表記 (IPv4 numbers-and-"
"dots notation)> と呼ぶ。 また、10 進数 4 つだけを使った形式を I<IPv4 のドット"
"区切りの 10 進数表記 (IPv4 dotted-decimal notation)> と呼ぶ (I<IPv4 のドット"
"区切り 4 分割表記 (IPv4 dotted-decimal notation)> と呼ぶこともある)。"

#. type: Plain text
#: build/C/man3/inet.3:149
msgid ""
"The B<inet_addr>()  function converts the Internet host address I<cp> from "
"IPv4 numbers-and-dots notation into binary data in network byte order.  If "
"the input is invalid, B<INADDR_NONE> (usually -1) is returned.  Use of this "
"function is problematic because -1 is a valid address (255.255.255.255).  "
"Avoid its use in favor of B<inet_aton>(), B<inet_pton>(3), or B<getaddrinfo>"
"(3)  which provide a cleaner way to indicate error return."
msgstr ""
"B<inet_addr>()  関数は、インターネットホストのアドレス I<cp> を、 IPv4 の数値"
"とドットによる表記からネットワークバイトオーダでの バイナリ値へ変換して返"
"す。 入力が不正な場合、 B<INADDR_NONE> (普通は -1) を返す。 -1 は有効なアドレ"
"ス (255.255.255.255) なので、この関数を使うと 問題になるかもしれない。 この関"
"数を使うのは避け、代わりに B<inet_aton>(), B<inet_pton>(3), B<getaddrinfo>"
"(3)  を使うのがよい。 これらの関数の方が、エラーの通知がよりきれいな方法で行"
"われる。"

#. type: Plain text
#: build/C/man3/inet.3:159
msgid ""
"The B<inet_network>()  function converts I<cp>, a string in IPv4 numbers-and-"
"dots notation, into a number in host byte order suitable for use as an "
"Internet network address.  On success, the converted address is returned.  "
"If the input is invalid, -1 is returned."
msgstr ""
"B<inet_network>()  関数は、 IPv4 の数値とドットによる表記の文字列 I<cp> を、 "
"インターネットアドレスとしての使用に適した ホストバイトオーダの数値に変換す"
"る。 成功すると、変換されたアドレスを返す。 入力が不正な場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/inet.3:167
msgid ""
"The B<inet_ntoa>()  function converts the Internet host address I<in>, given "
"in network byte order, to a string in IPv4 dotted-decimal notation.  The "
"string is returned in a statically allocated buffer, which subsequent calls "
"will overwrite."
msgstr ""
"B<inet_ntoa>()  関数は、ネットワークバイトオーダで渡されたインターネットホス"
"トアドレス I<in> を、 IPv4 のドット区切りの 10 進数表記の文字列に変換する。 "
"文字列は静的に割当てられたバッファに格納されて返されるので、 この後でこの関数"
"を再度呼び出すと文字列は上書きされる。"

#. type: Plain text
#: build/C/man3/inet.3:173
msgid ""
"The B<inet_lnaof>()  function returns the local network address part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""
"B<inet_lnaof>()  関数は、インターネットアドレス I<in> のローカルネットワーク"
"部分を返す。 この返り値はホストバイトオーダである。"

#. type: Plain text
#: build/C/man3/inet.3:179
msgid ""
"The B<inet_netof>()  function returns the network number part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""
"B<inet_netof>()  関数は、インターネットアドレス I<in> のネットワーク部分を返"
"す。 この返り値はホストバイトオーダである。"

#. type: Plain text
#: build/C/man3/inet.3:190
msgid ""
"The B<inet_makeaddr>()  function is the converse of B<inet_netof>()  and "
"B<inet_lnaof>().  It returns an Internet host address in network byte order, "
"created by combining the network number I<net> with the local address "
"I<host>, both in host byte order."
msgstr ""
"B<inet_makeaddr>()  関数は B<inet_netof>()  と B<inet_lnaof>()  の逆の機能を"
"持つ。 ネットワーク番号 I<net> と、ローカルアドレス I<host> を 組み合わせて生"
"成した、インターネットホストアドレスを ネットワークバイトオーダで返す。 "
"I<host>, I<net> はともにホストバイトオーダである。"

#. type: Plain text
#: build/C/man3/inet.3:200
msgid ""
"The structure I<in_addr> as used in B<inet_ntoa>(), B<inet_makeaddr>(), "
"B<inet_lnaof>()  and B<inet_netof>()  is defined in I<E<lt>netinet/in."
"hE<gt>> as:"
msgstr ""
"B<inet_ntoa>(), B<inet_makeaddr>(), B<inet_lnaof>(), B<inet_netof>()  で使用"
"する構造体 I<in_addr> は I<E<lt>netinet/in.hE<gt>> で次のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man3/inet.3:204
#, no-wrap
msgid "typedef uint32_t in_addr_t;\n"
msgstr "typedef uint32_t in_addr_t;\n"

#. type: Plain text
#: build/C/man3/inet.3:208
#, no-wrap
msgid ""
"struct in_addr {\n"
"    in_addr_t s_addr;\n"
"};\n"
msgstr ""
"struct in_addr {\n"
"    in_addr_t s_addr;\n"
"};\n"

#. type: Plain text
#: build/C/man3/inet.3:218
msgid ""
"4.3BSD.  B<inet_addr>()  and B<inet_ntoa>()  are specified in POSIX.1-2001.  "
"B<inet_aton>()  is not specified in POSIX.1-2001, but is available on most "
"systems."
msgstr ""
"4.3BSD.  B<inet_addr>(), B<inet_ntoa>()  は POSIX.1-2001 で規定されている。 "
"B<inet_aton>()  は POSIX.1-2001 で規定されていないが、ほとんどのシステムで利"
"用可能である。"

#. type: Plain text
#: build/C/man3/inet.3:222
msgid ""
"On the i386 the host byte order is Least Significant Byte first (little "
"endian), whereas the network byte order, as used on the Internet, is Most "
"Significant Byte first (big endian)."
msgstr ""
"i386 ではホストバイトオーダは Least Significant Byte (LSB) first (リトルエン"
"ディアン) だが、 インターネットで使われるネットワークバイトオーダは Most "
"Significant Byte (MSB) first (ビッグエンディアン)  である点に注意すること。"

#. type: Plain text
#: build/C/man3/inet.3:231
msgid ""
"B<inet_lnaof>(), B<inet_netof>(), and B<inet_makeaddr>()  are legacy "
"functions that assume they are dealing with I<classful network addresses>.  "
"Classful networking divides IPv4 network addresses into host and network "
"components at byte boundaries, as follows:"
msgstr ""
"B<inet_lnaof>(), B<inet_netof>(), B<inet_makeaddr>()  は過去の名残であり、渡"
"されたアドレスが I<クラスフル・ネットワークアドレス (classful network "
"addresses)> であると仮定して処理を行う。 クラスフル・ネットワークアドレスで"
"は、以下にあるように、 IPv4 ネットワークアドレスをバイト境界でネットワーク部"
"とホスト部に分割する。"

#. type: TP
#: build/C/man3/inet.3:231
#, no-wrap
msgid "Class A"
msgstr "Class A"

#. type: Plain text
#: build/C/man3/inet.3:237
msgid ""
"This address type is indicated by the value 0 in the most significant bit of "
"the (network byte ordered) address.  The network address is contained in the "
"most significant byte, and the host address occupies the remaining three "
"bytes."
msgstr ""
"(ネットワークバイトオーダの) アドレスの最上位ビットが 0 の場合、 このアドレス"
"種別となる。このアドレス種別では、 最上位バイトがネットワークアドレスを表"
"し、 残りの 3 バイトがホストアドレスを表す。"

#. type: TP
#: build/C/man3/inet.3:237
#, no-wrap
msgid "Class B"
msgstr "Class B"

#. type: Plain text
#: build/C/man3/inet.3:243
msgid ""
"This address type is indicated by the binary value 10 in the most "
"significant two bits of the address.  The network address is contained in "
"the two most significant bytes, and the host address occupies the remaining "
"two bytes."
msgstr ""
"(ネットワークバイトオーダの) アドレスの上位側 2 ビットがバイナリ値で 10 の場"
"合、このアドレス種別となる。このアドレス種別では、 上位 2 バイトがネットワー"
"クアドレスを表し、 残りの 2 バイトがホストアドレスを表す。"

#. type: TP
#: build/C/man3/inet.3:243
#, no-wrap
msgid "Class C"
msgstr "Class C"

#. type: Plain text
#: build/C/man3/inet.3:249
msgid ""
"This address type is indicated by the binary value 110 in the most "
"significant three bits of the address.  The network address is contained in "
"the three most significant bytes, and the host address occupies the "
"remaining byte."
msgstr ""
"(ネットワークバイトオーダの) アドレスの上位側 3 ビットがバイナリ値で 110 の場"
"合、このアドレス種別となる。このアドレス種別では、 上位 3 バイトがネットワー"
"クアドレスを表し、 残りの 1 バイトがホストアドレスを表す。"

#. type: Plain text
#: build/C/man3/inet.3:254
msgid ""
"Classful network addresses are now obsolete, having been superseded by "
"Classless Inter-Domain Routing (CIDR), which divides addresses into network "
"and host components at arbitrary bit (rather than byte) boundaries."
msgstr ""
"クラスフル・ネットワークアドレスは現在では廃止され、 クラスレス・ドメイン間"
"ルーチン (CIDR) に取って代わられた。 CIDR では、アドレスを任意のビット境界 "
"(バイト境界ではない) で ネットワーク部とホスト部に分割する。"

#. type: Plain text
#: build/C/man3/inet.3:261
msgid ""
"An example of the use of B<inet_aton>()  and B<inet_ntoa>()  is shown "
"below.  Here are some example runs:"
msgstr ""
"以下は B<inet_aton>()  と B<inet_ntoa>()  の使用例である。このように実行す"
"る。"

#. type: Plain text
#: build/C/man3/inet.3:268
#, no-wrap
msgid ""
"$B< ./a.out 226.000.000.037>      # Last byte is in octal\n"
"226.0.0.31\n"
"$B< ./a.out 0x7f.1         >      # First byte is in hex\n"
"127.0.0.1\n"
msgstr ""
"$B< ./a.out 226.000.000.037>      # Last byte is in octal\n"
"226.0.0.31\n"
"$B< ./a.out 0x7f.1         >      # First byte is in hex\n"
"127.0.0.1\n"

#. type: Plain text
#: build/C/man3/inet.3:277
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _BSD_SOURCE\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/inet.3:282
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct in_addr addr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct in_addr addr;\n"

#. type: Plain text
#: build/C/man3/inet.3:287
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s E<lt>dotted-addressE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s E<lt>dotted-addressE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet.3:292
#, no-wrap
msgid ""
"    if (inet_aton(argv[1], &addr) == 0) {\n"
"        fprintf(stderr, \"Invalid address\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (inet_aton(argv[1], &addr) == 0) {\n"
"        fprintf(stderr, \"Invalid address\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet.3:296
#, no-wrap
msgid ""
"    printf(\"%s\\en\", inet_ntoa(addr));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%s\\en\", inet_ntoa(addr));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/inet.3:307
msgid ""
"B<byteorder>(3), B<getaddrinfo>(3), B<gethostbyname>(3), B<getnameinfo>(3), "
"B<getnetent>(3), B<inet_ntop>(3), B<inet_pton>(3), B<hosts>(5), B<networks>"
"(5)"
msgstr ""
"B<byteorder>(3), B<getaddrinfo>(3), B<gethostbyname>(3), B<getnameinfo>(3), "
"B<getnetent>(3), B<inet_ntop>(3), B<inet_pton>(3), B<hosts>(5), B<networks>"
"(5)"

#. type: TH
#: build/C/man3/inet_ntop.3:26
#, no-wrap
msgid "INET_NTOP"
msgstr "INET_NTOP"

#. type: TH
#: build/C/man3/inet_ntop.3:26
#, no-wrap
msgid "2008-11-11"
msgstr "2008-11-11"

#. type: Plain text
#: build/C/man3/inet_ntop.3:29
msgid "inet_ntop - convert IPv4 and IPv6 addresses from binary to text form"
msgstr "inet_ntop - IPv4/IPv6 アドレスをバイナリ形式からテキスト形式に変換する"

#. type: Plain text
#: build/C/man3/inet_ntop.3:35
#, no-wrap
msgid ""
"B<const char *inet_ntop(int >I<af>B<, const void *>I<src>B<,>\n"
"B<                      char *>I<dst>B<, socklen_t >I<size>B<);>\n"
msgstr ""
"B<const char *inet_ntop(int >I<af>B<, const void *>I<src>B<,>\n"
"B<                      char *>I<dst>B<, socklen_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/inet_ntop.3:48
msgid ""
"This function converts the network address structure I<src> in the I<af> "
"address family into a character string.  The resulting string is copied to "
"the buffer pointed to by I<dst>, which must be a non-NULL pointer.  The "
"caller specifies the number of bytes available in this buffer in the "
"argument I<size>."
msgstr ""
"この関数は、 I<af> アドレスファミリーのネットワークアドレス構造体 I<src> を文"
"字列に変換する。 変換結果の文字列は、 I<dst> が指すバッファにコピーされる。 "
"I<dst> は NULL でないポインタでなければならない。 呼び出し時に、このバッファ"
"で利用できるバイト数を 引き数 I<size> に指定する。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:57
msgid ""
"B<inet_ntop>()  extends the B<inet_ntoa>(3)  function to support multiple "
"address families, B<inet_ntoa>(3)  is now considered to be deprecated in "
"favor of B<inet_ntop>().  The following address families are currently "
"supported:"
msgstr ""
"B<inet_ntop>()  は B<inet_ntoa>(3)  関数を拡張して複数のアドレスファミリーを"
"扱えるようにしたものである。 今後は B<inet_ntoa>(3)  は使わず、 B<inet_ntop>"
"()  を使うようにすると良いだろう。 現在サポートされているアドレスファミリーは"
"以下の通り:"

#. type: Plain text
#: build/C/man3/inet_ntop.3:70
msgid ""
"I<src> points to a I<struct in_addr> (in network byte order)  which is "
"converted to an IPv4 network address in the dotted-decimal format, \"I<ddd."
"ddd.ddd.ddd>\".  The buffer I<dst> must be at least B<INET_ADDRSTRLEN> bytes "
"long."
msgstr ""
"この場合 I<src> は (ネットワークバイトオーダーの)  I<struct in_addr> へのポイ"
"ンタとみなされ、この構造体の内容が ドット区切りの 10 進数形式 \"I<ddd.ddd."
"ddd.ddd>\" の IPv4 ネットワークアドレスに変換される。 バッファ I<dst> は少な"
"くとも B<INET_ADDRSTRLEN> バイトの長さを持たなければならない。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:83
msgid ""
"I<src> points to a I<struct in6_addr> (in network byte order)  which is "
"converted to a representation of this address in the most appropriate IPv6 "
"network address format for this address.  The buffer I<dst> must be at least "
"B<INET6_ADDRSTRLEN> bytes long."
msgstr ""
"この場合 I<src> は (ネットワークバイトオーダーの)  I<struct in6_addr> へのポ"
"インタとみなされ、この構造体の内容が、 (このアドレスに対してもっとも適切な)  "
"IPv6 ネットワークアドレスの表示形式に変換される。 バッファ I<dst> は少なくと"
"も B<INET6_ADDRSTRLEN> バイトの長さを持たなければならない。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:91
msgid ""
"On success, B<inet_ntop>()  returns a non-NULL pointer to I<dst>.  NULL is "
"returned if there was an error, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<inet_ntop>()  は I<dst> への (NULL でない) ポインタを返す。 エ"
"ラーがあった場合は NULL を返し、 I<errno> をエラーを示す値に適切に設定する。"

#. type: TP
#: build/C/man3/inet_ntop.3:92
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: build/C/man3/inet_ntop.3:96
msgid "I<af> was not a valid address family."
msgstr "I<af> がサポートされているアドレスファミリーでなかった。"

#. type: TP
#: build/C/man3/inet_ntop.3:96
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man3/inet_ntop.3:100
msgid "The converted address string would exceed the size given by I<size>."
msgstr ""
"変換されたアドレス文字列の長さが I<size> で指定されたサイズを超過してしまう。"

#.  2.1.3: size_t, 2.1.91: socklen_t
#. type: Plain text
#: build/C/man3/inet_ntop.3:112
msgid ""
"POSIX.1-2001.  Note that RFC\\ 2553 defines a prototype where the last "
"argument I<size> is of type I<size_t>.  Many systems follow RFC\\ 2553.  "
"Glibc 2.0 and 2.1 have I<size_t>, but 2.2 and later have I<socklen_t>."
msgstr ""
"POSIX.1-2001.  RFC\\ 2553 では最後の引き数 I<size> のプロトタイプを "
"I<size_t> 型と定義している。多くのシステムでは RFC\\ 2553 にしたがっている。 "
"glibc 2.0 と 2.1 では I<size_t> だが、 glibc 2.2 以降では I<socklen_t> となっ"
"ている。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:115
msgid "B<AF_INET6> converts IPv4-mapped IPv6 addresses into an IPv6 format."
msgstr ""
"B<AF_INET6> は IPv4 がマップされた IPv6 アドレスを IPv6 形式に変換してしま"
"う。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:118
msgid "See B<inet_pton>(3)."
msgstr "B<inet_pton>(3)  を参照。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:122
msgid "B<getnameinfo>(3), B<inet>(3), B<inet_pton>(3)"
msgstr "B<getnameinfo>(3), B<inet>(3), B<inet_pton>(3)"

#. type: TH
#: build/C/man3/inet_pton.3:27
#, no-wrap
msgid "INET_PTON"
msgstr "INET_PTON"

#. type: TH
#: build/C/man3/inet_pton.3:27
#, no-wrap
msgid "2008-06-18"
msgstr "2008-06-18"

#. type: Plain text
#: build/C/man3/inet_pton.3:30
msgid "inet_pton - convert IPv4 and IPv6 addresses from text to binary form"
msgstr "inet_pton - IPv4/IPv6 アドレスをテキスト形式からバイナリ形式に変換する"

#. type: Plain text
#: build/C/man3/inet_pton.3:35
#, no-wrap
msgid "B<int inet_pton(int >I<af>B<, const char *>I<src>B<, void *>I<dst>B<);>\n"
msgstr "B<int inet_pton(int >I<af>B<, const char *>I<src>B<, void *>I<dst>B<);>\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:51
msgid ""
"This function converts the character string I<src> into a network address "
"structure in the I<af> address family, then copies the network address "
"structure to I<dst>.  The I<af> argument must be either B<AF_INET> or "
"B<AF_INET6>."
msgstr ""
"この関数は文字列 I<src> を、アドレスファミリー I<af> のネットワークアドレス構"
"造体に変換し、 I<dst> にコピーする。 I<af> 引き数は B<AF_INET> か "
"B<AF_INET6> のどちらかでなければならない。"

#. type: Plain text
#: build/C/man3/inet_pton.3:53
msgid "The following address families are currently supported:"
msgstr "現在サポートされているアドレスファミリーは以下の通りである。"

#. type: Plain text
#: build/C/man3/inet_pton.3:67
msgid ""
"I<src> points to a character string containing an IPv4 network address in "
"dotted-decimal format, \"I<ddd.ddd.ddd.ddd>\", where I<ddd> is a decimal "
"number of up to three digits in the range 0 to 255.  The address is "
"converted to a I<struct in_addr> and copied to I<dst>, which must be I<sizeof"
"(struct in_addr)> (4) bytes (32 bits) long."
msgstr ""
"I<src> はドット区切りの 10 進数形式 \"I<ddd.ddd.ddd.ddd>\" の IPv4 ネットワー"
"クアドレス文字列へのポインタである。 I<ddd> は 0 から 255 までの範囲の最大 3 "
"桁の 10 進数である。 このアドレスは I<struct in_addr> に変換されて I<dst> に"
"コピーされる。 I<dst> の長さは I<sizeof(struct in_addr)> (4) バイト (32ビッ"
"ト) でなければならない。"

#. type: Plain text
#: build/C/man3/inet_pton.3:79
msgid ""
"I<src> points to a character string containing an IPv6 network address.  The "
"address is converted to a I<struct in6_addr> and copied to I<dst>, which "
"must be I<sizeof(struct in6_addr)> (16) bytes (128 bits) long.  The allowed "
"formats for IPv6 addresses follow these rules:"
msgstr ""
"I<src> は IPv6 ネットワークアドレスが格納された文字列へのポインタである。 こ"
"のアドレスは I<struct in6_addr> に変換されて I<dst> にコピーされる。 I<dst> "
"の長さは I<sizeof(struct in6_addr)> (16) バイト (128 ビット) でなければならな"
"い。 以下の 3 つのルールにしたがった形式が IPv6 アドレスとして入力できる。"

#. type: IP
#: build/C/man3/inet_pton.3:80
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man3/inet_pton.3:87
msgid ""
"The preferred format is I<x:x:x:x:x:x:x:x>.  This form consists of eight "
"hexadecimal numbers, each of which expresses a 16-bit value (i.e., each I<x> "
"can be up to 4 hex digits)."
msgstr ""
"推奨形式は I<x:x:x:x:x:x:x:x> である。この形式は 8 個の 16 進数から構成さ"
"れ、 各々の 16 進数は 16 ビット値を表す (I<x> は最大 4 桁の 16 進数である)。"

#. type: IP
#: build/C/man3/inet_pton.3:87
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man3/inet_pton.3:100
msgid ""
"A series of contiguous zero values in the preferred format can be "
"abbreviated to I<::>.  Only one instance of I<::> can occur in an address.  "
"For example, the loopback address I<0:0:0:0:0:0:0:1> can be abbreviated as "
"I<::1>.  The wildcard address, consisting of all zeros, can be written as "
"I<::>."
msgstr ""
"推奨形式の中の連続する 0 の列は I<::> に短縮できる。アドレス中で使用できる "
"I<::> は 1 個だけである。 例えば、ループバックアドレス I<0:0:0:0:0:0:0:1> は "
"I<::1> と短縮できる。 全ビットが 0 で構成されるワイルドカードアドレスは I<::"
"> と記載できる。"

#. type: IP
#: build/C/man3/inet_pton.3:100
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man3/inet_pton.3:113
msgid ""
"An alternate format is useful for expressing IPv4-mapped IPv6 addresses.  "
"This form is written as I<x:x:x:x:x:x:d.d.d.d>, where the six leading I<x>s "
"are hexadecimal values that define the six most-significant 16-bit pieces of "
"the address (i.e., 96 bits), and the I<d>s express a value in dotted-decimal "
"notation that defines the least significant 32 bits of the address.  An "
"example of such an address is I<::FFFF:204.152.189.116>."
msgstr ""
"IPv4 をマッピングした IPv6 アドレスを表記するには別の形式が便利である。 この"
"別の形式は I<x:x:x:x:x:x:d.d.d.d> と書くことができる。 最初の 6 個の I<x> は"
"アドレスを 16 ビット単位に区切ったときの上位側 6 個分 (つまり 96 ビット分)  "
"を定義する 16 進数であり、 I<d> の部分はアドレスの下位 32 ビットをドット区切"
"りの 10 進数表記で表したものである。 I<::FFFF:204.152.189.116> はこの形式の例"
"である。"

#. type: Plain text
#: build/C/man3/inet_pton.3:116
msgid ""
"See RFC 2373 for further details on the representation of IPv6 addresses."
msgstr "IPv6 アドレスの表現方法の詳細については RFC 2373 を参照のこと。"

#. type: Plain text
#: build/C/man3/inet_pton.3:129
msgid ""
"B<inet_pton>()  returns 1 on success (network address was successfully "
"converted).  0 is returned if I<src> does not contain a character string "
"representing a valid network address in the specified address family.  If "
"I<af> does not contain a valid address family, -1 is returned and I<errno> "
"is set to B<EAFNOSUPPORT>."
msgstr ""
"成功する (ネットワークアドレスが正常に変換される) と、 B<inet_pton>()  は 1 "
"を返す。 I<src> が指定されたアドレスファミリーに対する 正しいネットワークアド"
"レス表記でない場合には、 0 を返す。 I<af> がサポートされているアドレスファミ"
"リーでない場合には、 -1 を返し、 I<errno> に B<EAFNOSUPPORT> を設定する。"

#. type: Plain text
#: build/C/man3/inet_pton.3:150
msgid ""
"Unlike B<inet_aton>(3)  and B<inet_addr>(3), B<inet_pton>()  supports IPv6 "
"addresses.  On the other hand, B<inet_pton>()  accepts only IPv4 addresses "
"in dotted-decimal notation, whereas B<inet_aton>(3)  and B<inet_addr>(3)  "
"allow the more general numbers-and-dots notation (hexadecimal and octal "
"number formats, and formats that don't require all four bytes to be "
"explicitly written).  For an interface that handles both IPv6 addresses, and "
"IPv4 addresses in numbers-and-dots notation, see B<getaddrinfo>(3)."
msgstr ""
"B<inet_aton>(3)  や B<inet_addr>(3)  と異なり、 B<inet_pton>()  は IPv6 アド"
"レスに対応している。 一方で、 B<inet_pton>()  が受け付ける IPv4 アドレスは"
"ドット区切りの 10 進数表記だけである。 これに対し、 B<inet_aton>(3)  や "
"B<inet_addr>(3)  ではもっと一般的なドット区切りの数字表記 (16 進数や 8 進数の"
"形式や、 4 バイト全てを明示的に書かなくてもよい形式) が使用できる。 ドット区"
"切りの数字表記で IPv6 アドレスと IPv4 アドレスの両方を扱える インターフェイス"
"については、 B<getaddrinfo>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/inet_pton.3:156
msgid ""
"B<AF_INET6> does not recognize IPv4 addresses.  An explicit IPv4-mapped IPv6 "
"address must be supplied in I<src> instead."
msgstr ""
"B<AF_INET6> は IPv4 アドレスを認識しない。 代わりに IPv4 アドレスをマッピング"
"した IPv6 アドレスを I<src> に与えなければならない。"

#. type: Plain text
#: build/C/man3/inet_pton.3:162
msgid ""
"The program below demonstrates the use of B<inet_pton>()  and B<inet_ntop>"
"(3).  Here are some example runs:"
msgstr ""
"以下のプログラムは B<inet_pton>()  と B<inet_ntop>(3)  の使用例を示すものであ"
"る。 実行すると以下のようになる。"

#. type: Plain text
#: build/C/man3/inet_pton.3:171
#, no-wrap
msgid ""
"$B< ./a.out i6 0:0:0:0:0:0:0:0>\n"
"::\n"
"$B< ./a.out i6 1:0:0:0:0:0:0:8>\n"
"1::8\n"
"$B< ./a.out i6 0:0:0:0:0:FFFF:204.152.189.116>\n"
"::ffff:204.152.189.116\n"
msgstr ""
"$B< ./a.out i6 0:0:0:0:0:0:0:0>\n"
"::\n"
"$B< ./a.out i6 1:0:0:0:0:0:0:8>\n"
"1::8\n"
"$B< ./a.out i6 0:0:0:0:0:FFFF:204.152.189.116>\n"
"::ffff:204.152.189.116\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:180
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:187
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    unsigned char buf[sizeof(struct in6_addr)];\n"
"    int domain, s;\n"
"    char str[INET6_ADDRSTRLEN];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    unsigned char buf[sizeof(struct in6_addr)];\n"
"    int domain, s;\n"
"    char str[INET6_ADDRSTRLEN];\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:192
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s {i4|i6|E<lt>numE<gt>} string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s {i4|i6|E<lt>numE<gt>} string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:195
#, no-wrap
msgid ""
"    domain = (strcmp(argv[1], \"i4\") == 0) ? AF_INET :\n"
"             (strcmp(argv[1], \"i6\") == 0) ? AF_INET6 : atoi(argv[1]);\n"
msgstr ""
"    domain = (strcmp(argv[1], \"i4\") == 0) ? AF_INET :\n"
"             (strcmp(argv[1], \"i6\") == 0) ? AF_INET6 : atoi(argv[1]);\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:204
#, no-wrap
msgid ""
"    s = inet_pton(domain, argv[2], buf);\n"
"    if (s E<lt>= 0) {\n"
"        if (s == 0)\n"
"            fprintf(stderr, \"Not in presentation format\");\n"
"        else\n"
"            perror(\"inet_pton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    s = inet_pton(domain, argv[2], buf);\n"
"    if (s E<lt>= 0) {\n"
"        if (s == 0)\n"
"            fprintf(stderr, \"Not in presentation format\");\n"
"        else\n"
"            perror(\"inet_pton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:209
#, no-wrap
msgid ""
"    if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {\n"
"        perror(\"inet_ntop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {\n"
"        perror(\"inet_ntop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:211
#, no-wrap
msgid "    printf(\"%s\\en\", str);\n"
msgstr "    printf(\"%s\\en\", str);\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:219
msgid "B<getaddrinfo>(3), B<inet>(3), B<inet_ntop>(3)"
msgstr "B<getaddrinfo>(3), B<inet>(3), B<inet_ntop>(3)"

#. type: TH
#: build/C/man7/ip.7:36
#, no-wrap
msgid "IP"
msgstr "IP"

#. type: TH
#: build/C/man7/ip.7:36
#, fuzzy, no-wrap
#| msgid "2013-02-13"
msgid "2013-09-17"
msgstr "2013-02-13"

#. type: Plain text
#: build/C/man7/ip.7:39
msgid "ip - Linux IPv4 protocol implementation"
msgstr "ip - Linux IPv4 プロトコルの実装"

#. type: Plain text
#: build/C/man7/ip.7:45 build/C/man7/ipv6.7:93 build/C/man7/raw.7:20
#: build/C/man7/tcp.7:72 build/C/man7/udp.7:19
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr "B<#include E<lt>netinet/in.hE<gt>>"

#. type: Plain text
#: build/C/man7/ip.7:47
msgid "B<#include E<lt>netinet/ip.hE<gt> >/* superset of previous */"
msgstr "B<#include E<lt>netinet/ip.hE<gt> >/* 上記のスーパーセット */"

#. type: Plain text
#: build/C/man7/ip.7:49
msgid "I<tcp_socket>B< = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr "I<tcp_socket>B< = socket(AF_INET, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/ip.7:51
msgid "I<udp_socket>B< = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr "I<udp_socket>B< = socket(AF_INET, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/ip.7:53
msgid "I<raw_socket>B< = socket(AF_INET, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw_socket>B< = socket(AF_INET, SOCK_RAW, >I<protocol>B<);>"

#.  FIXME has someone verified that 2.1 is really 1812 compliant?
#. type: Plain text
#: build/C/man7/ip.7:60
msgid ""
"Linux implements the Internet Protocol, version 4, described in RFC\\ 791 "
"and RFC\\ 1122.  B<ip> contains a level 2 multicasting implementation "
"conforming to RFC\\ 1112.  It also contains an IP router including a packet "
"filter."
msgstr ""
"Linux は RFC\\ 791 と RFC\\ 1122 で記述されている Internet Protocol, version "
"4 を実装している。 B<ip> には RFC\\ 1112 に準拠した level 2 マルチキャストの"
"実装が含まれている。 またパケットフィルタ機能を含む IP ルーターも実装されてい"
"る。"

#. type: Plain text
#: build/C/man7/ip.7:64
msgid ""
"The programming interface is BSD-sockets compatible.  For more information "
"on sockets, see B<socket>(7)."
msgstr ""
"プログラミング・インターフェースは BSD ソケットと互換である。 ソケットに関す"
"るより詳細な情報は B<socket>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/ip.7:95
msgid ""
"An IP socket is created by calling the B<socket>(2)  function as B<socket"
"(AF_INET, >I<socket_type>B<, >I<protocol>B<)>.  Valid socket types are "
"B<SOCK_STREAM> to open a B<tcp>(7)  socket, B<SOCK_DGRAM> to open a B<udp>"
"(7)  socket, or B<SOCK_RAW> to open a B<raw>(7)  socket to access the IP "
"protocol directly.  I<protocol> is the IP protocol in the IP header to be "
"received or sent.  The only valid values for I<protocol> are 0 and "
"B<IPPROTO_TCP> for TCP sockets, and 0 and B<IPPROTO_UDP> for UDP sockets.  "
"For B<SOCK_RAW> you may specify a valid IANA IP protocol defined in RFC\\ "
"1700 assigned numbers."
msgstr ""
"IP ソケットは、 B<socket>(2) 関数を B<socket(AF_INET, >I<socket_type>B<, >\n"
"I<protocol>B<)> のように呼び出すことで生成される。指定できるソケットタイプ"
"は\n"
"3 つあり、 B<tcp>(7) ソケットをオープンする場合 B<SOCK_STREAM>、 B<udp>(7)\n"
"ソケットをオープンする場合 B<SOCK_DGRAM>、 IP プロトコルに直接アクセスする\n"
"ために B<raw>(7) ソケットをオープンする場合には B<SOCK_RAW> である。 \n"
"I<protocol> は送受信される IP ヘッダに書かれる IP プロトコルである。\n"
"指定できる値は、 TCP ソケットには 0 か B<IPPROTO_TCP>、 UDP ソケットには \n"
"0 か B<IPPROTO_UDP> に限られる。 B<SOCK_RAW> に対しては、 RFC\\ 1700 で定義\n"
"されている有効な IANA IP プロトコルを、 割り当てられている番号で指定する\n"
"ことができる。"

#. type: Plain text
#: build/C/man7/ip.7:117
msgid ""
"When a process wants to receive new incoming packets or connections, it "
"should bind a socket to a local interface address using B<bind>(2).  In this "
"case, only one IP socket may be bound to any given local (address, port) "
"pair.  When B<INADDR_ANY> is specified in the bind call, the socket will be "
"bound to I<all> local interfaces.  When B<listen>(2)  is called on an "
"unbound socket, the socket is automatically bound to a random free port with "
"the local address set to B<INADDR_ANY>.  When B<connect>(2)  is called on an "
"unbound socket, the socket is automatically bound to a random free port or "
"to a usable shared port with the local address set to B<INADDR_ANY>."
msgstr ""
"あるプロセスで、やってくるパケットを受信したり 接続要求を受けたりしたい場合に"
"は、 そのプロセスはローカルなインターフェースアドレスに、 B<bind>(2) を用いて"
"ソケットをバインドしなければならない。 この場合、 ローカルの「アドレスとポー"
"ト」のペアに対してバインドできる IP ソケットは一つだけである。 B<bind>(2) の"
"呼び出しで B<INADDR_ANY> が指定されていた場合は、 ソケットは I<すべて> のロー"
"カルインターフェースにバインドされる。 B<listen>(2) がバインドされていないソ"
"ケットに対してコールされると、 そのソケットは、 ローカルポートはランダムに選"
"択された空いているポートで、 ローカルアドレスは B<INADDR_ANY> で自動的にバイ"
"ンドされる。 B<connect>(2) がバインドされていないソケットに対してコールされる"
"と、 そのソケットは、 ローカルポートはランダムに選択された空いているポートか"
"未使用の共有ポートで、 ローカルアドレスは B<INADDR_ANY> で自動的にバインドさ"
"れる。"

#. type: Plain text
#: build/C/man7/ip.7:123
msgid ""
"A TCP local socket address that has been bound is unavailable for some time "
"after closing, unless the B<SO_REUSEADDR> flag has been set.  Care should be "
"taken when using this flag as it makes TCP less reliable."
msgstr ""
"B<SO_REUSEADDR> フラグがセットされていない場合には、 バインドされていた TCP "
"ローカルソケットアドレスは クローズされた後しばらくの間使えなくなる。 "
"B<SO_REUSEADDR> フラグを使うと TCP の信頼性を低下させるので、 使うときには注"
"意が必要である。"

#. type: Plain text
#: build/C/man7/ip.7:134
msgid ""
"An IP socket address is defined as a combination of an IP interface address "
"and a 16-bit port number.  The basic IP protocol does not supply port "
"numbers, they are implemented by higher level protocols like B<udp>(7)  and "
"B<tcp>(7).  On raw sockets I<sin_port> is set to the IP protocol."
msgstr ""
"IP ソケットアドレスは、 IP インターフェースアドレスと 16ビットのポート番号の"
"組み合わせで定義される。 IP プロトコルそのものはポート番号を扱わない。 ポート"
"番号は、 B<udp>(7)  や B<tcp>(7)  といった、上位のプロトコルで実装される。 "
"raw ソケットでは、 I<sin_port> が IP プロトコルにセットされる。"

#. type: Plain text
#: build/C/man7/ip.7:142
#, no-wrap
msgid ""
"struct sockaddr_in {\n"
"    sa_family_t    sin_family; /* address family: AF_INET */\n"
"    in_port_t      sin_port;   /* port in network byte order */\n"
"    struct in_addr sin_addr;   /* internet address */\n"
"};\n"
msgstr ""
"struct sockaddr_in {\n"
"    sa_family_t    sin_family; /* address family: AF_INET */\n"
"    in_port_t      sin_port;   /* port in network byte order */\n"
"    struct in_addr sin_addr;   /* internet address */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:147
#, no-wrap
msgid ""
"/* Internet address. */\n"
"struct in_addr {\n"
"    uint32_t       s_addr;     /* address in network byte order */\n"
"};\n"
msgstr ""
"/* Internet address. */\n"
"struct in_addr {\n"
"    uint32_t       s_addr;     /* address in network byte order */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:172
msgid ""
"I<sin_family> is always set to B<AF_INET>.  This is required; in Linux 2.2 "
"most networking functions return B<EINVAL> when this setting is missing.  "
"I<sin_port> contains the port in network byte order.  The port numbers below "
"1024 are called I<privileged ports> (or sometimes: I<reserved ports>).  Only "
"privileged processes (i.e., those having the B<CAP_NET_BIND_SERVICE> "
"capability) may B<bind>(2)  to these sockets.  Note that the raw IPv4 "
"protocol as such has no concept of a port, they are implemented only by "
"higher protocols like B<tcp>(7)  and B<udp>(7)."
msgstr ""
"I<sin_familiy> には常に B<AF_INET> をセットする。これは必須である。 Linux "
"2.2 では、このセットを忘れると ほとんどのネットワーク関数は B<EINVAL> を返す"
"ようになっている。 I<sin_port> にはポート番号をネットワークバイトオーダーで指"
"定する。 1024 未満のポート番号は I<特権ポート (privileged ports)> と呼ばれる "
"(I<予約ポート (reserved ports)> とも時々呼ばれる)。 特権プロセス "
"(B<CAP_NET_BIND_SERVICE> ケーパビリティを持つプロセス) 以外のプロセスは、これ"
"らのポートには B<bind>(2)  できない。 IPv4 プロトコルそのものにはポートに関す"
"る概念がない。ポートが実装されるのは、 B<tcp>(7)  や B<udp>(7) といった、上位"
"のプロトコルにおいてのみである。"

#. type: Plain text
#: build/C/man7/ip.7:191
msgid ""
"I<sin_addr> is the IP host address.  The I<s_addr> member of I<struct "
"in_addr> contains the host interface address in network byte order.  "
"I<in_addr> should be assigned one of the B<INADDR_*> values (e.g., "
"B<INADDR_ANY>)  or set using the B<inet_aton>(3), B<inet_addr>(3), "
"B<inet_makeaddr>(3)  library functions or directly with the name resolver "
"(see B<gethostbyname>(3))."
msgstr ""
"I<sin_addr> は IP ホストアドレスである。 I<struct in_addr> の I<s_addr> \n"
"メンバには、ホストのインターフェースアドレスを ネットワークバイトオーダーで\n"
"指定する。 I<in_addr> は、B<INADDR_*> の一つ (例えば B<INADDR_ANY>) を代入す"
"る、\n"
"ライブラリ関数 B<inet_aton>(3), B<inet_addr>(3), B<inet_makeaddr>(3) を用い"
"る、\n"
"あるいは名前解決機構 (name resolver) を直接用いる、のどれかで設定すべきであ"
"る。\n"
"(B<gethostbyname>(3) を見よ)。"

#.  Leave a loophole for XTP @)
#. type: Plain text
#: build/C/man7/ip.7:203
msgid ""
"IPv4 addresses are divided into unicast, broadcast and multicast addresses.  "
"Unicast addresses specify a single interface of a host, broadcast addresses "
"specify all hosts on a network and multicast addresses address all hosts in "
"a multicast group.  Datagrams to broadcast addresses can be sent or received "
"only when the B<SO_BROADCAST> socket flag is set.  In the current "
"implementation, connection-oriented sockets are allowed to use only unicast "
"addresses."
msgstr ""
"IPv4 アドレスには、ユニキャストアドレス、 ブロードキャストアドレス、マルチ"
"キャストアドレスがある。 ユニキャストアドレスは、あるホストの一つのアドレスを"
"指定する。 ブロードキャストアドレスは、あるネットワーク上の全てのホストを指定"
"する。 マルチキャストアドレスは、マルチキャストグループに所属する 全てのホス"
"トを指定する。ブロードキャストアドレスへのデータグラムは、 B<SO_BROADCAST> ソ"
"ケットフラグがセットされていないと送信・受信できない。 現在の実装では、接続指"
"向のソケットにはユニキャストアドレスしか使えない。"

#. type: Plain text
#: build/C/man7/ip.7:211
msgid ""
"Note that the address and the port are always stored in network byte order.  "
"In particular, this means that you need to call B<htons>(3)  on the number "
"that is assigned to a port.  All address/port manipulation functions in the "
"standard library work in network byte order."
msgstr ""
"アドレスとポートは常にネットワークバイトオーダーで格納されることに注意せよ。 "
"具体的には、ポートを指定する数値には B<htons>(3)  を呼び出す必要がある。 標準"
"ライブラリにあるアドレス/ポート操作関数は すべてネットワークバイトオーダーで"
"動作する。"

#. type: Plain text
#: build/C/man7/ip.7:224
msgid ""
"There are several special addresses: B<INADDR_LOOPBACK> (127.0.0.1)  always "
"refers to the local host via the loopback device; B<INADDR_ANY> (0.0.0.0)  "
"means any address for binding; B<INADDR_BROADCAST> (255.255.255.255)  means "
"any host and has the same effect on bind as B<INADDR_ANY> for historical "
"reasons."
msgstr ""
"特別なアドレスがいくつか存在する: B<INADDR_LOOPBACK>(127.0.0.1)  は loopback "
"デバイスを通して常にローカルなホストを参照する。 B<INADDR_ANY>(0.0.0.0)  は任"
"意のアドレスを意味し、バインド用である。 B<INADDR_BROADCAST>"
"(255.255.255.255)  は任意のホストを意味し、歴史的理由から、バインドの際には "
"B<INADDR_ANY> と同じ効果になる。"

#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:233
msgid ""
"IP supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IP is B<IPPROTO_IP>.  A boolean integer flag is zero when it is false, "
"otherwise true."
msgstr ""
"IP にはプロトコル固有のソケットオプションがいくつか存在し、 B<setsockopt>"
"(2)  で設定が、 B<getsockopt>(2)  で取得ができる。 IP のソケットオプションレ"
"ベルは B<IPPROTO_IP> である。 ブール整数値のフラグでは、 0 は偽、それ以外は真"
"を意味する。"

#. type: TP
#: build/C/man7/ip.7:233
#, no-wrap
msgid "B<IP_ADD_MEMBERSHIP> (since Linux 1.2)"
msgstr "B<IP_ADD_MEMBERSHIP> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:239
msgid "Join a multicast group.  Argument is an I<ip_mreqn> structure."
msgstr "マルチキャストグループに参加する。 引き数は I<ip_mreqn> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:249
#, no-wrap
msgid ""
"struct ip_mreqn {\n"
"    struct in_addr imr_multiaddr; /* IP multicast group\n"
"                                     address */\n"
"    struct in_addr imr_address;   /* IP address of local\n"
"                                     interface */\n"
"    int            imr_ifindex;   /* interface index */\n"
"};\n"
msgstr ""
"struct ip_mreqn {\n"
"    struct in_addr imr_multiaddr; /* IP multicast group\n"
"                                     address */\n"
"    struct in_addr imr_address;   /* IP address of local\n"
"                                     interface */\n"
"    int            imr_ifindex;   /* interface index */\n"
"};\n"

#.  (i.e., within the 224.0.0.0-239.255.255.255 range)
#. type: Plain text
#: build/C/man7/ip.7:270
msgid ""
"I<imr_multiaddr> contains the address of the multicast group the application "
"wants to join or leave.  It must be a valid multicast address (or "
"B<setsockopt>(2)  fails with the error B<EINVAL>).  I<imr_address> is the "
"address of the local interface with which the system should join the "
"multicast group; if it is equal to B<INADDR_ANY> an appropriate interface is "
"chosen by the system.  I<imr_ifindex> is the interface index of the "
"interface that should join/leave the I<imr_multiaddr> group, or 0 to "
"indicate any interface."
msgstr ""
"I<imr_multiaddr> には、アプリケーションが参加または脱退したい マルチキャスト"
"グループのアドレスが入る。 指定するアドレスは有効なマルチキャストアドレスでな"
"ければならない (さもなければ B<setsockopt>(2)  がエラー B<EINVAL> で失敗す"
"る)。 I<imr_address> はシステムがマルチキャストグループに参加する際に用いる "
"ローカルなインターフェースのアドレスである。 これが B<INADDR_ANY> であった場"
"合には、適切なインターフェースがシステムによって選択される。 I<imr_ifindex> "
"は I<imr_multiaddr> グループに参加/脱退するインターフェースの interface "
"index である。 どのインターフェースでもよい場合は 0 にする。"

#. type: Plain text
#: build/C/man7/ip.7:285
msgid ""
"The I<ip_mreqn> structure is available only since Linux 2.2.  For "
"compatibility, the old I<ip_mreq> structure (present since Linux 1.2) is "
"still supported; it differs from I<ip_mreqn> only by not including the "
"I<imr_ifindex> field.  Only valid as a B<setsockopt>(2)."
msgstr ""
"I<ip_mreqn> 構造体は Linux 2.2 以降でのみ利用可能である。互換性のため、 古い "
"I<ip_mreq> 構造体 (Linux 1.2 以降で存在する) もまだサポートされている。 "
"I<ip_mreqn> との違いは、 I<imr_ifindex> フィールドを含まないことだけである。 "
"B<setsockopt>(2) でのみ使える。"

#. type: TP
#: build/C/man7/ip.7:285
#, no-wrap
msgid "B<IP_ADD_SOURCE_MEMBERSHIP> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_ADD_SOURCE_MEMBERSHIP> (Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:292
msgid ""
"Join a multicast group and allow receiving data only from a specified "
"source.  Argument is an I<ip_mreq_source> structure."
msgstr ""
"マルチキャストグループに参加、指定された送信元からのデータの受信のみを許可す"
"る。 引き数は I<ip_mreq_source> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:303
#, no-wrap
msgid ""
"struct ip_mreq_source {\n"
"    struct in_addr imr_multiaddr;  /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imr_interface;  /* IP address of local\n"
"                                      interface */\n"
"    struct in_addr imr_sourceaddr; /* IP address of\n"
"                                      multicast source */\n"
"};\n"
msgstr ""
"struct ip_mreq_source {\n"
"    struct in_addr imr_multiaddr;  /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imr_interface;  /* IP address of local\n"
"                                      interface */\n"
"    struct in_addr imr_sourceaddr; /* IP address of\n"
"                                      multicast source */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:324
msgid ""
"The I<ip_mreq_source> structure is similar to I<ip_mreqn> described under "
"B<IP_ADD_MEMBERSIP>.  The I<imr_multiaddr> field contains the address of the "
"multicast group the application wants to join or leave.  The "
"I<imr_interface> field is the address of the local interface with which the "
"system should join the multicast group.  Finally, the I<imr_sourceaddr> "
"field contains the address of the source the application wants to receive "
"data from."
msgstr ""
"I<ip_mreq_source> 構造体は B<IP_ADD_MEMBERSIP> の項で説明した I<ip_mreqn> に"
"似ている。 I<imr_multiaddr> フィールドには、アプリケーションが参加または脱退"
"したいマルチキャストグループのアドレスが入る。 I<imr_interface> フィールド"
"は、 マルチキャストグループに参加する際に システムが使用すべきローカルイン"
"ターフェースのアドレスである。 I<imr_sourceaddr> フィールドには、アプリケー"
"ションがデータを受信したい送信元のアドレスが入る。"

#. type: Plain text
#: build/C/man7/ip.7:327
msgid ""
"This option can be used multiple times to allow receiving data from more "
"than one source."
msgstr ""
"このオプションを複数回使うことで、 複数の送信元からのデータ受信を許可すること"
"ができる。"

#. type: TP
#: build/C/man7/ip.7:327
#, no-wrap
msgid "B<IP_BLOCK_SOURCE> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_BLOCK_SOURCE> (since Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:335
msgid ""
"Stop receiving multicast data from a specific source in a given group.  This "
"is valid only after the application has subscribed to the multicast group "
"using either B<IP_ADD_MEMBERSHIP> or B<IP_ADD_SOURCE_MEMBERSHIP>."
msgstr ""
"指定したグループで、指定した送信元からのマルチキャストデータの受信を停止す"
"る。 このオプションは、アプリケーションが  B<IP_ADD_MEMBERSHIP> か "
"B<IP_ADD_SOURCE_MEMBERSHIP> のいずれかを使ってマルチキャストグループに参加し"
"た後でのみ有効である。"

#. type: Plain text
#: build/C/man7/ip.7:340 build/C/man7/ip.7:362 build/C/man7/ip.7:923
msgid ""
"Argument is an I<ip_mreq_source> structure as described under "
"B<IP_ADD_SOURCE_MEMBERSHIP>."
msgstr ""
"引き数は I<ip_mreq_source> 構造体である。 B<IP_ADD_SOURCE_MEMBERSHIP> の項に"
"説明がある。"

#. type: TP
#: build/C/man7/ip.7:340
#, no-wrap
msgid "B<IP_DROP_MEMBERSHIP> (since Linux 1.2)"
msgstr "B<IP_DROP_MEMBERSHIP> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:349
msgid ""
"Leave a multicast group.  Argument is an I<ip_mreqn> or I<ip_mreq> structure "
"similar to B<IP_ADD_MEMBERSHIP>."
msgstr ""
"マルチキャストグループから抜ける。引き数は B<IP_ADD_MEMBERSHIP> と同様に "
"I<ip_mreqn> または I<ip_mreq> 構造体である。"

#. type: TP
#: build/C/man7/ip.7:349
#, no-wrap
msgid "B<IP_DROP_SOURCE_MEMBERSHIP> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_DROP_SOURCE_MEMBERSHIP> (Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:357
msgid ""
"Leave a source-specific group\\(emthat is, stop receiving data from a given "
"multicast group that come from a given source.  If the application has "
"subscribed to multiple sources within the same group, data from the "
"remaining sources will still be delivered.  To stop receiving data from all "
"sources at once, use B<IP_LEAVE_GROUP>."
msgstr ""
"送信元を指定してグループから抜ける。 つまり、 指定したマルチキャストグループ"
"の指定された送信元からのデータ受信を停止する。 アプリケーションは同じマルチ"
"キャストグループで複数の送信元を購読 (subscribe) している場合には、 残りの送"
"信元からのデータの受信は引き続き配信される。 すべての送信元からのデータ受信を"
"一度で停止するには B<IP_LEAVE_GROUP> を使うこと。"

#. type: TP
#: build/C/man7/ip.7:362
#, no-wrap
msgid "B<IP_FREEBIND> (since Linux 2.4)"
msgstr "B<IP_FREEBIND> (Linux 2.4 以降)"

#.  Precisely: 2.4.0-test10
#. type: Plain text
#: build/C/man7/ip.7:375
msgid ""
"If enabled, this boolean option allows binding to an IP address that is "
"nonlocal or does not (yet) exist.  This permits listening on a socket, "
"without requiring the underlying network interface or the specified dynamic "
"IP address to be up at the time that the application is trying to bind to "
"it.  This option is the per-socket equivalent of the I<ip_nonlocal_bind> I</"
"proc> interface described below."
msgstr ""
"このブール値のオプションを有効にすると、ローカルではない IP アドレスや存在\n"
"しない IP アドレスをバインドできるようになる。これを使うと、対応するネット\n"
"ワークインターフェイスがなかったり、アプリケーションがソケットをバインドしよ"
"うと\n"
"する時点で特定の動的 IP アドレスが有効になっていなかったりしても、ソケット"
"を\n"
"接続待ち状態 (listening) にできるようになる。\n"
"このオプションは、下記に説明がある I<ip_nonlocal_bind> I</proc> インターフェ"
"イス\n"
"のソケット単位の設定である。"

#. type: TP
#: build/C/man7/ip.7:375
#, no-wrap
msgid "B<IP_HDRINCL> (since Linux 2.0)"
msgstr "B<IP_HDRINCL> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man7/ip.7:391
msgid ""
"If enabled, the user supplies an IP header in front of the user data.  Only "
"valid for B<SOCK_RAW> sockets.  See B<raw>(7)  for more information.  When "
"this flag is enabled the values set by B<IP_OPTIONS>, B<IP_TTL> and "
"B<IP_TOS> are ignored."
msgstr ""
"有効になっていると、ユーザは IP ヘッダをユーザーデータの前に与える。 "
"B<SOCK_RAW> ソケットでのみ有効である。詳細は B<raw>(7)  を見よ。このフラグが"
"有効になっていると、 B<IP_OPTIONS>, B<IP_TTL>, B<IP_TOS> は無視される。"

#. type: TP
#: build/C/man7/ip.7:391
#, no-wrap
msgid "B<IP_MSFILTER> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_MSFILTER> (since Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:397
msgid ""
"This option provides access to the advanced full-state filtering API.  "
"Argument is an I<ip_msfilter> structure."
msgstr ""
"このオプションを使うと、 高度なフィルタリング API へアクセスできる。 この "
"API ではすべての状態にアクセスできる。 引き数は I<ip_msfilter> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:406
#, no-wrap
msgid ""
"struct ip_msfilter {\n"
"    struct in_addr imsf_multiaddr; /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imsf_interface; /* IP address of local\n"
"                                      interface */\n"
"    uint32_t       imsf_fmode;     /* Filter-mode */\n"
msgstr ""
"struct ip_msfilter {\n"
"    struct in_addr imsf_multiaddr; /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imsf_interface; /* IP address of local\n"
"                                      interface */\n"
"    uint32_t       imsf_fmode;     /* Filter-mode */\n"

#. type: Plain text
#: build/C/man7/ip.7:412
#, no-wrap
msgid ""
"    uint32_t       imsf_numsrc;    /* Number of sources in\n"
"                                      the following array */\n"
"    struct in_addr imsf_slist[1];  /* Array of source\n"
"                                      addresses */\n"
"};\n"
msgstr ""
"    uint32_t       imsf_numsrc;    /* Number of sources in\n"
"                                      the following array */\n"
"    struct in_addr imsf_slist[1];  /* Array of source\n"
"                                      addresses */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:427
msgid ""
"There are two macros, B<MCAST_INCLUDE> and B<MCAST_EXCLUDE>, which can be "
"used to specify the filtering mode.  Additionally, the B<IP_MSFILTER_SIZE>"
"(n)  macro exists to determine how much memory is needed to store "
"I<ip_msfilter> structure with I<n> sources in the source list."
msgstr ""
"B<MCAST_INCLUDE> と B<MCAST_EXCLUDE> の 2 つのマクロがあり、 フィルタリング"
"モードを指定するのに使用できる。 また、 B<IP_MSFILTER_SIZE>(n) マクロがあ"
"り、 送信元リストに I<n> 個の送信元が入った I<ip_msfilter> 構造体を格納するの"
"に必要なメモリ量を判定することができる。"

#. type: Plain text
#: build/C/man7/ip.7:430
msgid ""
"For the full description of multicast source filtering refer to RFC 3376."
msgstr "マルチキャスト送信元フィルタリングの全容は RFC\\ 3376 を参照のこと。"

#. type: TP
#: build/C/man7/ip.7:430
#, no-wrap
msgid "B<IP_MTU> (since Linux 2.2)"
msgstr "B<IP_MTU> (Linux 2.2 以降)"

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:438
msgid ""
"Retrieve the current known path MTU of the current socket.  Valid only when "
"the socket has been connected.  Returns an integer.  Only valid as a "
"B<getsockopt>(2)."
msgstr ""
"ソケットの、既知の path MTU を取得する。 ソケットが接続している場合のみ有効で"
"ある。 B<getsockopt>(2)  でのみ使える。"

#. type: TP
#: build/C/man7/ip.7:438
#, no-wrap
msgid "B<IP_MTU_DISCOVER> (since Linux 2.2)"
msgstr "B<IP_MTU_DISCOVER> (Linux 2.2 以降)"

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:459
msgid ""
"Set or receive the Path MTU Discovery setting for a socket.  When enabled, "
"Linux will perform Path MTU Discovery as defined in RFC\\ 1191 on "
"B<SOCK_STREAM> sockets.  For non-B<SOCK_STREAM> sockets, B<IP_PMTUDISC_DO> "
"forces the don't-fragment flag to be set on all outgoing packets.  It is the "
"user's responsibility to packetize the data in MTU-sized chunks and to do "
"the retransmits if necessary.  The kernel will reject (with B<EMSGSIZE>)  "
"datagrams that are bigger than the known path MTU.  B<IP_PMTUDISC_WANT> will "
"fragment a datagram if needed according to the path MTU, or will set the "
"don't-fragment flag otherwise."
msgstr ""
"ソケットの Path MTU Discovery の設定をセット・取得する。\n"
"有効になっていると、Linux は B<SOCK_STREAM> ソケットに対して\n"
"RFC\\ 1191 で定義されている Path MTU Discovery を行う。\n"
"B<SOCK_STREAM> でないソケットについては、 B<IP_PMTUDISC_DO> をセットする"
"と、\n"
"全ての送信パケットでフラグメント不許可フラグ (don't-fragment flag) が必ず\n"
"セットされるようになる。 B<SOCK_STREAM> でないソケットでは、\n"
"パケットを MTU のサイズの塊に分割したり、必要に応じて再送したりするのは、\n"
"ユーザが責任を持って行う必要がある。\n"
"既知の Path MTU よりも大きなデータグラムの送信が要求されると、\n"
"カーネルは (B<EMSGSIZE> で) 送信を拒否する。\n"
"B<IP_PMTUDISC_WANT> の場合は、 Path MTU に基づいて必要であればデータグラム\n"
"の分割が行われ、それ以外の場合はフラグメント不許可フラグがセットされる。"

#. type: Plain text
#: build/C/man7/ip.7:467
msgid ""
"The system-wide default can be toggled between B<IP_PMTUDISC_WANT> and "
"B<IP_PMTUDISC_DONT> by writing (respectively, zero and nonzero values) to "
"the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file."
msgstr ""
"システム全体のデフォルトは B<IP_PMTUDISC_WANT> と B<IP_PMTUDISC_DONT> の\n"
"どちらかに設定することができる。設定の変更は、\n"
"I</proc/sys/net/ipv4/ip_no_pmtu_disc> ファイルに、0 (B<IP_PMTUDISC_WANT>) "
"か\n"
"0 以外 (B<IP_PMTUDISC_DONT>) を書き込むことで行う。"

#. type: tbl table
#: build/C/man7/ip.7:471
#, no-wrap
msgid "Path MTU discovery value:Meaning\n"
msgstr "Path MTU discovery 値:意味\n"

#. type: tbl table
#: build/C/man7/ip.7:472
#, no-wrap
msgid "IP_PMTUDISC_WANT:Use per-route settings.\n"
msgstr "IP_PMTUDISC_WANT:ルートごとの設定を用いる。\n"

#. type: tbl table
#: build/C/man7/ip.7:473
#, no-wrap
msgid "IP_PMTUDISC_DONT:Never do Path MTU Discovery.\n"
msgstr "IP_PMTUDISC_DONT:Path MTU Discovery を行わない。\n"

#. type: tbl table
#: build/C/man7/ip.7:474
#, no-wrap
msgid "IP_PMTUDISC_DO:Always do Path MTU Discovery.\n"
msgstr "IP_PMTUDISC_DO:常に Path MTU Discovery を行う。\n"

#. type: tbl table
#: build/C/man7/ip.7:475
#, no-wrap
msgid "IP_PMTUDISC_PROBE:Set DF but ignore Path MTU.\n"
msgstr "IP_PMTUDISC_PROBE:DFビットをセットするが、Path MTU を無視する。\n"

#. type: Plain text
#: build/C/man7/ip.7:493
msgid ""
"When PMTU discovery is enabled, the kernel automatically keeps track of the "
"path MTU per destination host.  When it is connected to a specific peer with "
"B<connect>(2), the currently known path MTU can be retrieved conveniently "
"using the B<IP_MTU> socket option (e.g., after an B<EMSGSIZE> error "
"occurred).  The path MTU may change over time.  For connectionless sockets "
"with many destinations, the new MTU for a given destination can also be "
"accessed using the error queue (see B<IP_RECVERR>).  A new error will be "
"queued for every incoming MTU update."
msgstr ""
"path MTU discovery が有効になっていると、カーネルは宛先ホストごとに 自動的"
"に\n"
"path MTU を処理する。特定の相手に B<connect>(2) で接続した場合には、\n"
"B<IP_MTU> ソケットオプションを用いれば、既知の path MTU の取得に便利である\n"
"(たとえば B<EMSGSIZE> エラーが起きた後など)。 path MTU は時間とともに変化す"
"る\n"
"かもしれない。 宛先がたくさんあるコネクションレスなソケットでは、 与えられ"
"た\n"
"宛先に対する新しい MTU にも、 エラーキューを用いてアクセスすることができる\n"
"(B<IP_RECVERR> を見よ)。 MTU 更新が到着するごとに、新たなエラーがキューイン"
"グ\n"
"される。"

#. type: Plain text
#: build/C/man7/ip.7:498
msgid ""
"While MTU discovery is in progress, initial packets from datagram sockets "
"may be dropped.  Applications using UDP should be aware of this and not take "
"it into account for their packet retransmit strategy."
msgstr ""
"MTU discovery の進行中には、データグラムソケットからの初期パケットは 到着しな"
"いかもしれない。 UDP を用いるアプリケーションでは、 このことを気にかけてお"
"き、 パケットの再送アルゴリズムにこの分を除外させるべきである。"

#.  FIXME this is an ugly hack
#. type: Plain text
#: build/C/man7/ip.7:503
msgid ""
"To bootstrap the path MTU discovery process on unconnected sockets, it is "
"possible to start with a big datagram size (up to 64K-headers bytes long) "
"and let it shrink by updates of the path MTU."
msgstr ""
"接続していないソケットに対して path MTU discovery プロセスを立ち上げるには、 "
"大きなデータグラムサイズ (最大 64K ヘッダバイト長) からはじめて、 path MTU が"
"更新されるまでサイズを縮めていくことも可能である。"

#. type: Plain text
#: build/C/man7/ip.7:512
msgid ""
"To get an initial estimate of the path MTU, connect a datagram socket to the "
"destination address using B<connect>(2)  and retrieve the MTU by calling "
"B<getsockopt>(2)  with the B<IP_MTU> option."
msgstr ""
"path MTU の値をまず見積もってみるには、宛先アドレスに B<connect>(2)  を使って"
"データグラムソケットを接続し、 B<getsockopt>(2)  を B<IP_MTU> オプションとと"
"もに呼び、 MTU を取得することである。"

#. type: Plain text
#: build/C/man7/ip.7:524
msgid ""
"It is possible to implement RFC 4821 MTU probing with B<SOCK_DGRAM> or "
"B<SOCK_RAW> sockets by setting a value of B<IP_PMTUDISC_PROBE> (available "
"since Linux 2.6.22).  This is also particularly useful for diagnostic tools "
"such as B<tracepath>(8)  that wish to deliberately send probe packets larger "
"than the observed Path MTU."
msgstr ""
"B<IP_PMTUDISC_PROBE> (Linux 2.6.22 以降で利用可能) を設定することで、 "
"B<SOCK_DGRAM> や B<SOCK_RAW> のソケットで RFC 4821 の MTU 探索を実装すること"
"が可能である。 また、この機能は、 B<tracepath>(8)  のような診断ツールで特に有"
"用である。これらのツールでは、 観測された Path MTU よりも大きな探索パケットを"
"意図的に 送信しようとする。"

#. type: TP
#: build/C/man7/ip.7:524
#, no-wrap
msgid "B<IP_MULTICAST_ALL> (since Linux 2.6.31)"
msgstr "B<IP_MULTICAST_ALL> (Linux 2.6.31 以降)"

#. type: Plain text
#: build/C/man7/ip.7:538
msgid ""
"This option can be used to modify the delivery policy of multicast messages "
"to sockets bound to the wildcard B<INADDR_ANY> address.  The argument is a "
"boolean integer (defaults to 1).  If set to 1, the socket will receive "
"messages from all the groups that have been joined globally on the whole "
"system.  Otherwise, it will deliver messages only from the groups that have "
"been explicitly joined (for example via the B<IP_ADD_MEMBERSHIP> option) on "
"this particular socket."
msgstr ""
"このオプションを使って、 マルチキャストメッセージの、 ワイルドカードの "
"B<INADDR_ANY> アドレスにバインドされているソケットへの 配送ポリシーを変更する"
"ことができる。 引き数はブート値の整数で、 デフォルト値は 1 である。 このオプ"
"ションを 1 に設定されている場合、そのソケットでは、このシステムで参加している"
"すべてのグループからのメッセージが受信される。 それ以外の場合は、そのソケット"
"では、 そのソケットに対して (B<IP_ADD_MEMBERSHIP> などを使って) 明示的に参加"
"が指定されたグループからのメッセージだけが受信される。"

#. type: TP
#: build/C/man7/ip.7:538
#, no-wrap
msgid "B<IP_MULTICAST_IF> (since Linux 1.2)"
msgstr "B<IP_MULTICAST_IF> (Linux 1.2 以降)"

#.  net: IP_MULTICAST_IF setsockopt now recognizes struct mreq
#.  Commit: 3a084ddb4bf299a6e898a9a07c89f3917f0713f7
#. type: Plain text
#: build/C/man7/ip.7:550
#, fuzzy
#| msgid ""
#| "Set the local device for a multicast socket.  Argument is an I<ip_mreqn> "
#| "or I<ip_mreq> structure similar to B<IP_ADD_MEMBERSHIP>."
msgid ""
"Set the local device for a multicast socket.  Argument is an I<ip_mreqn> or "
"I<ip_mreq> (since Linux 3.5)  structure similar to B<IP_ADD_MEMBERSHIP>."
msgstr ""
"ローカルデバイスをマルチキャストソケットとして設定する。引き数は "
"B<IP_ADD_MEMBERSHIP> と同様に I<ip_mreqn> または I<ip_mreq> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:554
msgid "When an invalid socket option is passed, B<ENOPROTOOPT> is returned."
msgstr "不正なソケットオプションが渡されると、 B<ENOPROTOOPT> が返される。"

#. type: TP
#: build/C/man7/ip.7:554
#, no-wrap
msgid "B<IP_MULTICAST_LOOP> (since Linux 1.2)"
msgstr "B<IP_MULTICAST_LOOP> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:558
msgid ""
"Set or read a boolean integer argument that determines whether sent "
"multicast packets should be looped back to the local sockets."
msgstr ""
"マルチキャストパケットをローカルなソケットにループバックするかどうかを 定める"
"ブール値の整数引き数を設定・取得する。"

#. type: TP
#: build/C/man7/ip.7:558
#, no-wrap
msgid "B<IP_MULTICAST_TTL> (since Linux 1.2)"
msgstr "B<IP_MULTICAST_TTL> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:566
msgid ""
"Set or read the time-to-live value of outgoing multicast packets for this "
"socket.  It is very important for multicast packets to set the smallest TTL "
"possible.  The default is 1 which means that multicast packets don't leave "
"the local network unless the user program explicitly requests it.  Argument "
"is an integer."
msgstr ""
"このソケットから発信されるマルチキャストパケットの time-to-live 値を設定・取"
"得する。 マルチキャストパケットに対しては、できるだけ小さな TTL に設定するこ"
"とがとても重要である。デフォルトは 1 で、 ユーザープログラムが明示的に要求し"
"ない限り マルチキャストパケットはローカルなネットワークから出ないことにな"
"る。 引き数に整数を取る。"

#. type: TP
#: build/C/man7/ip.7:566
#, no-wrap
msgid "B<IP_NODEFRAG> (since Linux 2.6.36)"
msgstr "B<IP_NODEFRAG> (Linux 2.6.36 以降)"

#. type: Plain text
#: build/C/man7/ip.7:574
msgid ""
"If enabled (argument is nonzero), the reassembly of outgoing packets is "
"disabled in the netfilter layer.  This option is valid only for B<SOCK_RAW> "
"sockets.  The argument is an integer."
msgstr ""
"有効 (引き数が 0 以外の場合) になっていると、netfilter 層での出力パケットの\n"
"再構築 (reassembly) が行われなくなる。このオプションは B<SOCK_RAW> ソケット\n"
"においてのみ有効である。引き数は整数である。"

#. type: TP
#: build/C/man7/ip.7:574
#, no-wrap
msgid "B<IP_OPTIONS> (since Linux 2.0)"
msgstr "B<IP_OPTIONS> (Linux 2.0 以降)"

#.  Precisely: 1.3.30
#. type: Plain text
#: build/C/man7/ip.7:603
msgid ""
"Set or get the IP options to be sent with every packet from this socket.  "
"The arguments are a pointer to a memory buffer containing the options and "
"the option length.  The B<setsockopt>(2)  call sets the IP options "
"associated with a socket.  The maximum option size for IPv4 is 40 bytes.  "
"See RFC\\ 791 for the allowed options.  When the initial connection request "
"packet for a B<SOCK_STREAM> socket contains IP options, the IP options will "
"be set automatically to the options from the initial packet with routing "
"headers reversed.  Incoming packets are not allowed to change options after "
"the connection is established.  The processing of all incoming source "
"routing options is disabled by default and can be enabled by using the "
"I<accept_source_route> I</proc> interface.  Other options like timestamps "
"are still handled.  For datagram sockets, IP options can be only set by the "
"local user.  Calling B<getsockopt>(2)  with B<IP_OPTIONS> puts the current "
"IP options used for sending into the supplied buffer."
msgstr ""
"このソケットから送られるパケット全てに付随する IP オプションを 設定・取得す"
"る。オプションを保存しているメモリバッファへのポインタと オプションの長さとを"
"引き数に取る。 B<setsockopt>(2)  を呼び出すと、ソケットに関連づけられる IP オ"
"プションを設定できる。 IPv4 におけるオプションのサイズの最大値は 40 バイトで"
"ある。 用いることのできるオプションについては RFC\\ 791 を見よ。 "
"B<SOCK_STREAM> ソケットに対する初期接続要求パケットに IP オプションが含まれて"
"いると、 ルーティングヘッダを付けて戻されてくる初期パケットの IP オプションに"
"同じオプションがセットされる。接続が確立された後、 やってきたパケットのオプ"
"ションを変更することはできない。 デフォルトでは。外部から受信したパケットの全"
"ての source routing オプション の処理は無効となっており、 I</proc> インタ"
"フェースの I<accept_source_route> を使うとこれを有効にできる。これを無効にし"
"ていても timestamps など の他のオプションの処理は行われる。データグラムソケッ"
"トでは、 IP オプションはローカルユーザーしか設定できない。 B<getsockopt>(2)  "
"を B<IP_OPTIONS> をつけて呼ぶと、現在送信に用いられている IP オプションを 引"
"き数に与えたバッファに取得できる。"

#. type: TP
#: build/C/man7/ip.7:603
#, no-wrap
msgid "B<IP_PKTINFO> (since Linux 2.2)"
msgstr "B<IP_PKTINFO> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:620
msgid ""
"Pass an B<IP_PKTINFO> ancillary message that contains a I<pktinfo> structure "
"that supplies some information about the incoming packet.  This only works "
"for datagram oriented sockets.  The argument is a flag that tells the socket "
"whether the B<IP_PKTINFO> message should be passed or not.  The message "
"itself can only be sent/retrieved as control message with a packet using "
"B<recvmsg>(2)  or B<sendmsg>(2)."
msgstr ""
"B<IP_PKTINFO> 補助メッセージを渡す。これには到着パケットに関する情報を提供す"
"る I<pktinfo> 構造体が含まれている。 データグラム指向のソケットでしか動作しな"
"い。 引き数は B<IP_PKTINFO> メッセージを通過させるかどうかをソケットに知らせ"
"るフラグである。 メッセージ自身は B<recvmsg>(2)  または B<sendmsg>(2)  を用い"
"たパケットの制御メッセージとしてのみ送受信できる。"

#. type: Plain text
#: build/C/man7/ip.7:629
#, no-wrap
msgid ""
"struct in_pktinfo {\n"
"    unsigned int   ipi_ifindex;  /* Interface index */\n"
"    struct in_addr ipi_spec_dst; /* Local address */\n"
"    struct in_addr ipi_addr;     /* Header Destination\n"
"                                    address */\n"
"};\n"
msgstr ""
"struct in_pktinfo {\n"
"    unsigned int   ipi_ifindex;  /* Interface index */\n"
"    struct in_addr ipi_spec_dst; /* Local address */\n"
"    struct in_addr ipi_addr;     /* Header Destination\n"
"                                    address */\n"
"};\n"

#.  FIXME elaborate on that.
#.  This field is grossly misnamed
#. type: Plain text
#: build/C/man7/ip.7:654
msgid ""
"I<ipi_ifindex> is the unique index of the interface the packet was received "
"on.  I<ipi_spec_dst> is the local address of the packet and I<ipi_addr> is "
"the destination address in the packet header.  If B<IP_PKTINFO> is passed to "
"B<sendmsg>(2)  and I<ipi_spec_dst> is not zero, then it is used as the local "
"source address for the routing table lookup and for setting up IP source "
"route options.  When I<ipi_ifindex> is not zero, the primary local address "
"of the interface specified by the index overwrites I<ipi_spec_dst> for the "
"routing table lookup."
msgstr ""
"I<ipi_ifindex> はパケットが受信されたインターフェースの、他と重ならないイン"
"デックスである。 I<ipi_spec_dst> はパケットのローカルアドレスである。 "
"I<ipi_addr> はパケットヘッダにある宛先アドレスである。 B<IP_PKTINFO> が "
"B<sendmsg>(2)  に渡されて、かつ I<ipi_spec_dst> が 0 以外の場合、 "
"I<ipi_spec_dst> はルーティングテーブルを検索する際にローカルな送信元アドレス"
"として使用され、 IP source route オプションを設定するのにも使用される。 "
"I<ipi_ifindex> が 0 以外の場合、このインデックスによって指定されるインター"
"フェースの プライマリローカルアドレスで I<ipi_spec_dst> を上書きし、ルーティ"
"ングテーブルを検索する。"

#. type: TP
#: build/C/man7/ip.7:654
#, no-wrap
msgid "B<IP_RECVERR> (since Linux 2.2)"
msgstr "B<IP_RECVERR> (Linux 2.2 以降)"

#.  Precisely: 2.1.15
#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:676
msgid ""
"Enable extended reliable error message passing.  When enabled on a datagram "
"socket, all generated errors will be queued in a per-socket error queue.  "
"When the user receives an error from a socket operation, the errors can be "
"received by calling B<recvmsg>(2)  with the B<MSG_ERRQUEUE> flag set.  The "
"I<sock_extended_err> structure describing the error will be passed in an "
"ancillary message with the type B<IP_RECVERR> and the level B<IPPROTO_IP>.  "
"This is useful for reliable error handling on unconnected sockets.  The "
"received data portion of the error queue contains the error packet."
msgstr ""
"エラーメッセージの受け渡しに、信頼性の高い拡張された方法を有効にする。 データ"
"グラムソケットに対して有効になっていると、 発生したエラーは全てソケットごとの"
"エラーキューに保存される。 ユーザーはソケット操作からエラーを受け取ったと"
"き、 B<recvmsg>(2)  を B<MSG_ERRQUEUE> フラグとともに呼べばそのエラーを取得で"
"きる。 そのエラーを記述する I<sock_extended_err> 構造体が、タイプ "
"B<IP_RECVERR>・ レベル B<IPPROTO_IP> の補助メッセージとして渡される。 これは"
"接続志向でないソケットで信頼性の高いエラー処理を行いたい場合に 有用である。エ"
"ラーキューの受信データフラグメントには エラーパケットが含まれる。"

#. type: Plain text
#: build/C/man7/ip.7:682
msgid ""
"The B<IP_RECVERR> control message contains a I<sock_extended_err> structure:"
msgstr ""
"B<IP_RECVERR> 制御メッセージには I<sock_extended_err> 構造体が含まれる:"

#. type: Plain text
#: build/C/man7/ip.7:690
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"

#. type: Plain text
#: build/C/man7/ip.7:701
#, no-wrap
msgid ""
"struct sock_extended_err {\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""
"struct sock_extended_err {\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:703
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"

#. type: Plain text
#: build/C/man7/ip.7:726
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SO_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined."
msgstr ""
"I<ee_errno> にはキューに入っているエラーの I<errno> 番号が入る。 "
"I<ee_origin> にはエラーが発生した場所を示すコードが入る。 その他のフィールド"
"はプロトコル依存である。 B<SO_EE_OFFENDER> マクロは与えられた補助メッセージへ"
"のポインタから エラーの発生したネットワークオブジェクトのアドレスへのポインタ"
"を返す。 アドレスが不明な場合、 I<sockaddr> 構造体の I<sa_family> フィールド"
"は B<AF_UNSPEC> となり、その他のフィールド値は不定である。"

#.  FIXME . Is it a good idea to document that? It is a dubious feature.
#.  On
#.  .B SOCK_STREAM
#.  sockets,
#.  .B IP_RECVERR
#.  has slightly different semantics. Instead of
#.  saving the errors for the next timeout, it passes all incoming
#.  errors immediately to the user.
#.  This might be useful for very short-lived TCP connections which
#.  need fast error handling. Use this option with care:
#.  it makes TCP unreliable
#.  by not allowing it to recover properly from routing
#.  shifts and other normal
#.  conditions and breaks the protocol specification.
#. type: Plain text
#: build/C/man7/ip.7:785
msgid ""
"IP uses the I<sock_extended_err> structure as follows: I<ee_origin> is set "
"to B<SO_EE_ORIGIN_ICMP> for errors received as an ICMP packet, or "
"B<SO_EE_ORIGIN_LOCAL> for locally generated errors.  Unknown values should "
"be ignored.  I<ee_type> and I<ee_code> are set from the type and code fields "
"of the ICMP header.  I<ee_info> contains the discovered MTU for B<EMSGSIZE> "
"errors.  The message also contains the I<sockaddr_in of the node> caused the "
"error, which can be accessed with the B<SO_EE_OFFENDER> macro.  The "
"I<sin_family> field of the B<SO_EE_OFFENDER> address is B<AF_UNSPEC> when "
"the source was unknown.  When the error originated from the network, all IP "
"options (B<IP_OPTIONS>, B<IP_TTL>, etc.) enabled on the socket and contained "
"in the error packet are passed as control messages.  The payload of the "
"packet causing the error is returned as normal payload.  Note that TCP has "
"no error queue; B<MSG_ERRQUEUE> is not permitted on B<SOCK_STREAM> sockets.  "
"B<IP_RECVERR> is valid for TCP, but all errors are returned by socket "
"function return or B<SO_ERROR> only."
msgstr ""
"IP は以下のような I<sock_extended_err> 構造体を用いる: I<ee_origin> は、エ"
"ラー\n"
"が ICMP パケットとして受信された場合には B<SO_EE_ORIGIN_ICMP> にセットさ"
"れ、\n"
"ローカルで起こった場合には B<SO_EE_ORIGIN_LOCAL> にセットされる。 不明な値"
"は\n"
"無視される。 I<ee_type> と I<ee_code> は ICMP ヘッダの type フィールドと\n"
"code フィールドの値にセットされる。 I<ee_info> には B<EMSGSIZE> エラーに対"
"す\n"
"る discover された MTU が入る。 メッセージにはエラーを引き起こしたノードの\n"
"I<sockaddr_in> 構造体も含まれる。 これには B<SO_EE_OFFENDER> マクロを使って"
"ア\n"
"クセスできる。 ソースが不明の場合、 B<SO_EE_OFFENDER> アドレスの\n"
"I<sin_family> フィールドは B<AF_UNSPEC> となる。 エラーがネットワークで起き"
"た\n"
"場合には、 ソケットで有効になっていたすべての IP オプション (B<IP_OPTIONS>,\n"
"B<IP_TTL> など) とエラーパケットに含まれていたすべての IP オプションとが、 "
"制\n"
"御メッセージとして渡される。 エラーを起こしたパケットのペイロード (payload)\n"
"は 普通のペイロードとして返される。 TCP にはエラーキューがないことに注意し"
"て\n"
"ほしい。 B<MSG_ERRQUEUE> は B<SOCK_STREAM> ソケットに対しては使えない。 TCP\n"
"では B<IP_RECVERR> だけが有効だが、ソケット関数から返されるエラーは\n"
"B<SO_ERROR> だけになる。"

#. type: Plain text
#: build/C/man7/ip.7:790
msgid ""
"For raw sockets, B<IP_RECVERR> enables passing of all received ICMP errors "
"to the application, otherwise errors are only reported on connected sockets"
msgstr ""
"raw ソケットに対して B<IP_RECVERR> を指定すると、受信したすべての ICMP エラー"
"をアプリケーションに 渡すようになる。指定しないと、 接続済みのソケットに対す"
"るエラーだけを報告する。"

#. type: Plain text
#: build/C/man7/ip.7:794
msgid ""
"It sets or retrieves an integer boolean flag.  B<IP_RECVERR> defaults to off."
msgstr ""
"このオプションはブール値のフラグを設定・取得する。 B<IP_RECVERR> はデフォルト"
"ではオフになっている。"

#. type: TP
#: build/C/man7/ip.7:794
#, no-wrap
msgid "B<IP_RECVOPTS> (since Linux 2.2)"
msgstr "B<IP_RECVOPTS> (Linux 2.2 以降)"

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:805
msgid ""
"Pass all incoming IP options to the user in a B<IP_OPTIONS> control "
"message.  The routing header and other options are already filled in for the "
"local host.  Not supported for B<SOCK_STREAM> sockets."
msgstr ""
"到着した全ての IP オプションを B<IP_OPTION> コントロールメッセージに入れて"
"ユーザーに渡す。 ルーティングヘッダとその他のオプションとは、 ローカルホスト"
"に対してはあらかじめ記入されている。 B<SOCK_STREAM> ソケットではサポートされ"
"ていない。"

#. type: TP
#: build/C/man7/ip.7:805
#, no-wrap
msgid "B<IP_RECVORIGDSTADDR> (since Linux 2.6.29)"
msgstr "B<IP_RECVORIGDSTADDR> (Linux 2.6.29 以降)"

#.  commit e8b2dfe9b4501ed0047459b2756ba26e5a940a69
#. type: Plain text
#: build/C/man7/ip.7:816
msgid ""
"This boolean option enables the B<IP_ORIGDSTADDR> ancillary message in "
"B<recvmsg>(2), in which the kernel returns the original destination address "
"of the datagram being received.  The ancillary message contains a I<struct "
"sockaddr_in>."
msgstr ""
"このブール値のオプションがセットされると、\n"
"B<recvmsg>(2) で B<IP_ORIGDSTADDR> 補助メッセージが有効になる。\n"
"カーネルはデータグラムを受信した元の宛先アドレスをこの補助メッセージで返"
"す。\n"
"この補助メッセージには I<struct sockaddr_in> が格納される。"

#. type: TP
#: build/C/man7/ip.7:816
#, no-wrap
msgid "B<IP_RECVTOS> (since Linux 2.2)"
msgstr "B<IP_RECVTOS> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:825
msgid ""
"If enabled the B<IP_TOS> ancillary message is passed with incoming packets.  "
"It contains a byte which specifies the Type of Service/Precedence field of "
"the packet header.  Expects a boolean integer flag."
msgstr ""
"有効になっていると、 B<IP_TOS> 補助メッセージが到着パケットとともに渡され"
"る。 これにはパケットヘッダの Service/Precedence フィールドのタイプを指定する"
"バイトデータが含まれている。 ブール整数値のフラグをとる。"

#. type: TP
#: build/C/man7/ip.7:825
#, no-wrap
msgid "B<IP_RECVTTL> (since Linux 2.2)"
msgstr "B<IP_RECVTTL> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:835
msgid ""
"When this flag is set, pass a B<IP_TTL> control message with the time to "
"live field of the received packet as a byte.  Not supported for "
"B<SOCK_STREAM> sockets."
msgstr ""
"このフラグがセットされていると、 B<IP_TTL> コントロールメッセージが受信パケッ"
"トの time-to-live フィールドのバイトデータとともに渡される。 B<SOCK_STREAM> "
"ソケットではサポートされていない。"

#. type: TP
#: build/C/man7/ip.7:835
#, no-wrap
msgid "B<IP_RETOPTS> (since Linux 2.2)"
msgstr "B<IP_RETOPTS>"

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:842
msgid ""
"Identical to B<IP_RECVOPTS>, but returns raw unprocessed options with "
"timestamp and route record options not filled in for this hop."
msgstr ""
"B<IP_RETOPTS> (Linux 2.2 以降)  B<IP_RECVOPTS> と等価だが、未処理の生のオプ"
"ションを、 この hop では記入されない timestamp レコードと route レコードとと"
"もに返す。"

#. type: TP
#: build/C/man7/ip.7:842
#, no-wrap
msgid "B<IP_ROUTER_ALERT> (since Linux 2.2)"
msgstr "B<IP_ROUTER_ALERT> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:854
msgid ""
"Pass all to-be forwarded packets with the IP Router Alert option set to this "
"socket.  Only valid for raw sockets.  This is useful, for instance, for user-"
"space RSVP daemons.  The tapped packets are not forwarded by the kernel; it "
"is the user's responsibility to send them out again.  Socket binding is "
"ignored, such packets are only filtered by protocol.  Expects an integer "
"flag."
msgstr ""
"フォワードすべきパケットを IP Router Alert オプションをつけて このソケットに"
"渡す。 raw ソケットに対してのみ有効である。これはたとえばユーザー空間の RSVP "
"デーモンに対して便利である。タップされたパケットは カーネルによってはフォワー"
"ドされないので、これらを再送するのは ユーザーの責任となる。ソケットのバインド"
"は無視され、 このようなパケットはプロトコルによってのみフィルタリングされ"
"る。 整数値のフラグを取る。"

#. type: TP
#: build/C/man7/ip.7:854
#, no-wrap
msgid "B<IP_TOS> (since Linux 1.0)"
msgstr "B<IP_TOS> (Linux 1.0 以降)"

#.  FIXME elaborate on this
#.  Needs CAP_NET_ADMIN
#.  Boolean
#.  Since Linux 2.6.27
#.  Author: KOVACS Krisztian <hidden@sch.bme.hu>
#.  http://lwn.net/Articles/252545/
#. type: Plain text
#: build/C/man7/ip.7:888
msgid ""
"Set or receive the Type-Of-Service (TOS) field that is sent with every IP "
"packet originating from this socket.  It is used to prioritize packets on "
"the network.  TOS is a byte.  There are some standard TOS flags defined: "
"B<IPTOS_LOWDELAY> to minimize delays for interactive traffic, "
"B<IPTOS_THROUGHPUT> to optimize throughput, B<IPTOS_RELIABILITY> to optimize "
"for reliability, B<IPTOS_MINCOST> should be used for \"filler data\" where "
"slow transmission doesn't matter.  At most one of these TOS values can be "
"specified.  Other bits are invalid and shall be cleared.  Linux sends "
"B<IPTOS_LOWDELAY> datagrams first by default, but the exact behavior depends "
"on the configured queueing discipline.  Some high priority levels may "
"require superuser privileges (the B<CAP_NET_ADMIN> capability).  The "
"priority can also be set in a protocol independent way by the "
"(B<SOL_SOCKET>, B<SO_PRIORITY>)  socket option (see B<socket>(7))."
msgstr ""
"このソケットから送信されるすべての IP パケットに適用される Type-Of-Service "
"(TOS) フィールドを設定・取得する。 これはネットワーク上でのパケットの優先度を"
"決めるために用いられる。 TOS はバイトデータである。標準の TOS フラグがいくつ"
"か定義されている。 B<IPTOS_LOWDELAY> はインタラクティブなトラフィックの遅延を"
"最小にする。 B<IPTOS_THROUGHPUT> はスループットを最大にする。 "
"B<IPTOS_RELIABILITY> は信頼性を最高にする。 B<IPTOS_MINCOST> は転送速度が遅く"
"てもかまわないとき、「データを詰め込む」のに用いられる。 これらのうち、 1 つ"
"までだけを設定できる。 他のビットは無効で、クリアされる。 Linux はデフォルト"
"では B<IPTOS_LOWDELAY> データグラムを最初に送信する。 しかし、正確な振る舞い"
"はキュー処理の設定に依存する。 高い優先度にするにはスーパーユーザー権限 "
"(B<CAP_NET_ADMIN> ケーパビリティ) が必要となるかもしれない。 優先度は "
"(B<SOL_SOCKET>, B<SO_PRIORITY>)  ソケットオプションを用いれば、 プロトコルに"
"依存しない形でも設定できる (B<socket>(7)  を見よ)。"

#. type: TP
#: build/C/man7/ip.7:888
#, no-wrap
msgid "B<IP_TRANSPARENT> (since Linux 2.6.24)"
msgstr "B<IP_TRANSPARENT> (Linux 2.6.24 以降)"

#.  commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
#.      This patch introduces the IP_TRANSPARENT socket option: enabling that
#.      will make the IPv4 routing omit the non-local source address check on
#.      output. Setting IP_TRANSPARENT requires NET_ADMIN capability.
#.  http://lwn.net/Articles/252545/
#. type: Plain text
#: build/C/man7/ip.7:905
msgid ""
"Setting this boolean option enables transparent proxying on this socket.  "
"This socket option allows the calling application to bind to a nonlocal IP "
"address and operate both as a client and a server with the foreign address "
"as the local endpoint.  NOTE: this requires that routing be set up in a way "
"that packets going to the foreign address are routed through the TProxy "
"box.  Enabling this socket option requires superuser privileges (the "
"B<CAP_NET_ADMIN> capability)."
msgstr ""
"このブール値のオプションを有効にすると、\n"
"このソケットで透過プロキシ (transparent proxy) ができるようになる。\n"
"このソケットオプションを使うと、呼び出したアプリケーションは、\n"
"ローカルではない IP アドレスをバインドして、ローカルの端点として自分以外の\n"
"アドレス (foreign address) を持つクライアントやサーバの両方として\n"
"動作できるようになる。\n"
"B<注意>: この機能が動作するためには、自分以外のアドレス宛のパケットが\n"
"透過プロキシが動作するマシン (TProxy box) 経由で転送されるように、\n"
"ルーティングが設定される必要がある。\n"
"このソケットオプションを有効にするには、スーパーユーザ特権\n"
"(B<CAP_NET_ADMIN> ケーパビリティ) が必要である。"

#. type: Plain text
#: build/C/man7/ip.7:908
msgid ""
"TProxy redirection with the iptables TPROXY target also requires that this "
"option be set on the redirected socket."
msgstr ""
"iptables の TPROXY ターゲットで透過プロキシリダイレクション \n"
"(TProxy redirection) を行うには、リダイレクトされるソケットに対して\n"
"このオプションを設定する必要がある。"

#. type: TP
#: build/C/man7/ip.7:908
#, no-wrap
msgid "B<IP_TTL> (since Linux 1.0)"
msgstr "B<IP_TTL> (Linux 1.0 以降)"

#. type: Plain text
#: build/C/man7/ip.7:912
msgid ""
"Set or retrieve the current time-to-live field that is used in every packet "
"sent from this socket."
msgstr ""
"time-to-live フィールドの値を設定または取得する。 この値はこのソケットから送"
"信されるすべてのパケットに用いられる。"

#. type: TP
#: build/C/man7/ip.7:912
#, no-wrap
msgid "B<IP_UNBLOCK_SOURCE> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_UNBLOCK_SOURCE> (Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:918
msgid ""
"Unblock previously blocked multicast source.  Returns B<EADDRNOTAVAIL> when "
"given source is not being blocked."
msgstr ""
"それ以前はブロックされていたマルチキャストの送信元のブロックを解除する。 指定"
"した送信元がブロックされていない場合は B<EADDRNOTAVAIL> を返す。"

#.  FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
#. 	ip_queue_maxlen
#. 	ip_conntrack_max
#. type: Plain text
#: build/C/man7/ip.7:939
msgid ""
"The IP protocol supports a set of I</proc> interfaces to configure some "
"global parameters.  The parameters can be accessed by reading or writing "
"files in the directory I</proc/sys/net/ipv4/>.  Interfaces described as "
"I<Boolean> take an integer value, with a nonzero value (\"true\") meaning "
"that the corresponding option is enabled, and a zero value (\"false\")  "
"meaning that the option is disabled."
msgstr ""
"IP プロトコルでは、いくつかのグローバルパラメータを設定するための I</proc> "
"ファイル群が用意されている。 これらのパラメータには、 I</proc/sys/net/ipv4/> "
"ディレクトリ内のファイルの読み書きでアクセスできる。 I<Boolean> と書かれたイ"
"ンタフェースは整数値をとり、 0 以外の値 (\"true\") は対応するオプションが有"
"効、 0 値 (\"false\") は無効、であることを意味する。"

#. type: TP
#: build/C/man7/ip.7:939
#, no-wrap
msgid "I<ip_always_defrag> (Boolean; since Linux 2.2.13)"
msgstr "I<ip_always_defrag> (Boolean; Linux 2.2.13 以降)"

#. type: Plain text
#: build/C/man7/ip.7:945
msgid ""
"[New with kernel 2.2.13; in earlier kernel versions this feature was "
"controlled at compile time by the B<CONFIG_IP_ALWAYS_DEFRAG> option; this "
"option is not present in 2.4.x and later]"
msgstr ""
"[2.2.13 で新規登場。以前のバージョンのカーネルでは、この機能は コンパイル時"
"に B<CONFIG_IP_ALWAYS_DEFRAG> オプションによって制御されていた; このファイル"
"は 2.4.x 以降では存在しない]"

#. type: Plain text
#: build/C/man7/ip.7:952
msgid ""
"When this boolean flag is enabled (not equal 0), incoming fragments (parts "
"of IP packets that arose when some host between origin and destination "
"decided that the packets were too large and cut them into pieces) will be "
"reassembled (defragmented) before being processed, even if they are about to "
"be forwarded."
msgstr ""
"このブール値のフラグが有効になっている (0 以外になっている) と、 到着したフラ"
"グメント (IP パケットの一部で、 発信元と発信先の間のどこかのホストで、そのパ"
"ケットが 大きすぎると判断され、分割された場合に生じる)  は、たとえフォワード"
"される場合であっても 処理前に再構築 (デフラグメント) される。"

#. type: Plain text
#: build/C/man7/ip.7:959
msgid ""
"Only enable if running either a firewall that is the sole link to your "
"network or a transparent proxy; never ever use it for a normal router or "
"host.  Otherwise fragmented communication can be disturbed if the fragments "
"travel over different links.  Defragmentation also has a large memory and "
"CPU time cost."
msgstr ""
"ファイアウォールがローカル側のネットワークに唯一のリンクを持っている 場合や、"
"透過プロクシの場合に限って有効にすべきである。 通常のルーターやホストでは決し"
"て使用することのないように。 さもないとフラグメントが別のリンクを経由して伝わ"
"る場合に、 通信のフラグメント化ができなくなってしまう。 またフラグメント再構"
"築処理はメモリと CPU 時間のコストが非常に大きい。"

#. type: Plain text
#: build/C/man7/ip.7:963
msgid ""
"This is automagically turned on when masquerading or transparent proxying "
"are configured."
msgstr ""
"これはマスカレードや透過プロクシが設定されると、 不思議な仕組みによって自動的"
"に有効になる。"

#. type: TP
#: build/C/man7/ip.7:963
#, no-wrap
msgid "I<ip_autoconfig> (since Linux 2.2 to 2.6.17)"
msgstr "I<ip_autoconfig> (Linux 2.2 以降 2.6.17 まで)"

#.  Precisely: since 2.1.68
#.  FIXME document ip_autoconfig
#. type: Plain text
#: build/C/man7/ip.7:969
msgid "Not documented."
msgstr "まだ記述していない。"

#. type: TP
#: build/C/man7/ip.7:969
#, no-wrap
msgid "I<ip_default_ttl> (integer; default: 64; since Linux 2.2)"
msgstr "I<ip_default_ttl> (integer; default: 64; Linux 2.2 以降)"

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:977
msgid ""
"Set the default time-to-live value of outgoing packets.  This can be changed "
"per socket with the B<IP_TTL> option."
msgstr ""
"送出されるパケットの time-to-live 値のデフォルトをセットする。 これは "
"B<IP_TTL> オプションを用いれば、パケットごとに変えることもできる。"

#. type: TP
#: build/C/man7/ip.7:977
#, no-wrap
msgid "I<ip_dynaddr> (Boolean; default: disabled; since Linux 2.0.31)"
msgstr "I<ip_dynaddr> (Boolean; default: disabled; Linux 2.0.31 以降)"

#. type: Plain text
#: build/C/man7/ip.7:984
msgid ""
"Enable dynamic socket address and masquerading entry rewriting on interface "
"address change.  This is useful for dialup interface with changing IP "
"addresses.  0 means no rewriting, 1 turns it on and 2 enables verbose mode."
msgstr ""
"動的ソケットアドレスと、インターフェースアドレスが変更された際の マスカレード"
"エントリの再書き込みを有効にする。 ダイアルアップインターフェースで、 IP アド"
"レスが変更される場合に便利である。"

#. type: TP
#: build/C/man7/ip.7:984
#, no-wrap
msgid "I<ip_forward> (Boolean; default: disabled; since Linux 1.2)"
msgstr "I<ip_forward> (Boolean; default: disabled; Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:989
msgid ""
"Enable IP forwarding with a boolean flag.  IP forwarding can be also set on "
"a per-interface basis."
msgstr ""
"IP forwarding を有効にするかどうかのブール値フラグ。 IP forwarding するかどう"
"かはインターフェースごとにも設定できる。"

#. type: TP
#: build/C/man7/ip.7:989
#, no-wrap
msgid "I<ip_local_port_range> (since Linux 2.2)"
msgstr "I<ip_local_port_range> (Linux 2.2 以降)"

#.  Precisely: since 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:1003
msgid ""
"Contains two integers that define the default local port range allocated to "
"sockets.  Allocation starts with the first number and ends with the second "
"number.  Note that these should not conflict with the ports used by "
"masquerading (although the case is handled).  Also arbitrary choices may "
"cause problems with some firewall packet filters that make assumptions about "
"the local ports in use.  First number should be at least greater than 1024, "
"or better, greater than 4096, to avoid clashes with well known ports and to "
"minimize firewall problems."
msgstr ""
"ソケットに割り当てられているデフォルトのローカルポートの範囲を定める 二つの整"
"数を与える。割り当ては 1 番目の番号から始まり、 2 番目の番号で終わる。 これら"
"はマスカレードで用いられているポートと重なってはならない (その場合も取り扱わ"
"れるが)。 ファイアウォールのパケットフィルターが「利用中のローカルポート」 に"
"ついて何らかの仮定をしている場合には、 番号を勝手に決めてしまうと問題が起きる"
"かもしれない。 1 番目の番号は少なくとも 1024 より大きくすべきである。 良く使"
"われるポートとの衝突を避けたり、ファイアウォールの問題を 回避したければ、 "
"4096 よりも大きくするほうが良いだろう。"

#. type: TP
#: build/C/man7/ip.7:1003
#, no-wrap
msgid "I<ip_no_pmtu_disc> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<ip_no_pmtu_disc> (Boolean; default: disabled; Linux 2.2 以降)"

#.  Precisely: 2.1.15
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1015
msgid ""
"If enabled, don't do Path MTU Discovery for TCP sockets by default.  Path "
"MTU discovery may fail if misconfigured firewalls (that drop all ICMP "
"packets) or misconfigured interfaces (e.g., a point-to-point link where the "
"both ends don't agree on the MTU) are on the path.  It is better to fix the "
"broken routers on the path than to turn off Path MTU Discovery globally, "
"because not doing it incurs a high cost to the network."
msgstr ""
"有効になっていると、デフォルトで TCP ソケットに対する Path MTU Discoverty を"
"行わない。 Path MTU Discovery は、 正しく設定されていない (ICMP パケットを全"
"てドロップする) ファイアウォールや、 (point-to-point リンクで双方の MTU が一"
"致していない場合など)  正しく設定されていないインターフェースが経路上に存在す"
"ると失敗してしまう。 Path MTU Discovery をグローバルに無効にするよりは、 壊れ"
"ているルータを直すほうが良い。 Path MTU Discovery を無効にするとネットワーク"
"のコストが 大きくなってしまうからである。"

#. type: TP
#: build/C/man7/ip.7:1015
#, no-wrap
msgid "I<ip_nonlocal_bind> (Boolean; default: disabled; since Linux 2.4)"
msgstr "I<ip_nonlocal_bind> (Boolean; default: disabled; Linux 2.4 以降)"

#.  Precisely: patch-2.4.0-test10
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1024
msgid ""
"If set, allows processes to B<bind>(2)  to nonlocal IP addresses, which can "
"be quite useful, but may break some applications."
msgstr ""
"セットされていれば、プロセスが自分以外の IP アドレスを B<bind>(2)  できるよう"
"になる。これはかなり便利だが、うまく動かないアプリケーションもある。"

#. type: TP
#: build/C/man7/ip.7:1024
#, no-wrap
msgid "I<ip6frag_time> (integer; default: 30)"
msgstr "I<ip6frag_time> (integer; default: 30)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1029
msgid "Time in seconds to keep an IPv6 fragment in memory."
msgstr "IPv6 フラグメントをメモリに保持しておく時間 (秒単位)。"

#. type: TP
#: build/C/man7/ip.7:1029
#, no-wrap
msgid "I<ip6frag_secret_interval> (integer; default: 600)"
msgstr "I<ip6frag_secret_interval> (integer; default: 600)"

#. type: Plain text
#: build/C/man7/ip.7:1033
msgid ""
"Regeneration interval (in seconds) of the hash secret (or lifetime for the "
"hash secret) for IPv6 fragments."
msgstr ""
"IPv6 フラグメントの hash secret の生成間隔 (hash secret の寿命)  (秒単位)。"

#. type: TP
#: build/C/man7/ip.7:1033
#, no-wrap
msgid "I<ipfrag_high_thresh> (integer), I<ipfrag_low_thresh> (integer)"
msgstr "I<ipfrag_high_thresh> (integer), I<ipfrag_low_thresh> (integer)"

#. type: Plain text
#: build/C/man7/ip.7:1040
msgid ""
"If the amount of queued IP fragments reaches I<ipfrag_high_thresh>, the "
"queue is pruned down to I<ipfrag_low_thresh>.  Contains an integer with the "
"number of bytes."
msgstr ""
"キューイングされている IP フラグメントの量が I<ipfrag_high_thresh> に達する"
"と、キューの内容は I<ipfrag_low_thresh> にまで切り捨てられる。それぞれの大き"
"さを バイト単位で表す整数値が入っている。"

#. type: TP
#: build/C/man7/ip.7:1040
#, no-wrap
msgid "I<neigh/*>"
msgstr "I<neigh/*>"

#.  FIXME Document the conf/*/* interfaces
#.  FIXME Document the route/* interfaces
#.  FIXME document them all
#. type: Plain text
#: build/C/man7/ip.7:1047
msgid "See B<arp>(7)."
msgstr "B<arp>(7)  を見よ。"

#.  2006-04-02, mtk
#.  commented out the following because ipchains is obsolete
#.  .PP
#.  The ioctls to configure firewalling are documented in
#.  .BR ipfw (4)
#.  from the
#.  .B ipchains
#.  package.
#. type: Plain text
#: build/C/man7/ip.7:1060
msgid "All ioctls described in B<socket>(7)  apply to B<ip>."
msgstr "B<socket>(7)  に記述されている ioctl は、すべて B<ip> にも適用される。"

#.  FIXME Add a discussion of multicasting
#. type: Plain text
#: build/C/man7/ip.7:1064
msgid ""
"Ioctls to configure generic device parameters are described in B<netdevice>"
"(7)."
msgstr ""
"ジェネリックデバイスのパラメータを設定する ioctl については B<netdevice>(7)  "
"に記述されている。"

#. type: Plain text
#: build/C/man7/ip.7:1084
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include: sending a packet to a broadcast address without having the "
"B<SO_BROADCAST> flag set; sending a packet via a I<prohibit> route; "
"modifying firewall settings without superuser privileges (the "
"B<CAP_NET_ADMIN> capability); binding to a privileged port without superuser "
"privileges (the B<CAP_NET_BIND_SERVICE> capability)."
msgstr ""
"必要な権限のないユーザーが操作を実行しようとした。 以下のような場合が考えられ"
"る: B<SO_BROADCAST> フラグを設定していない状態でブロードキャストアドレスに パ"
"ケットを送ろうとした。 I<prohibit> なルートを通してパケットを送ろうとした。 "
"スーパーユーザー権限 (B<CAP_NET_ADMIN> ケーパビリティ) なしでファイアウォール"
"の設定を変更しようとした。 スーパーユーザー権限 (B<CAP_NET_BIND_SERVICE> ケー"
"パビリティ) なしで特権ポートにバインドしようとした。"

#. type: Plain text
#: build/C/man7/ip.7:1097
msgid "An connection operation on a nonblocking socket is already in progress."
msgstr "非ブロッキングソケットに対する接続操作が既に実行中である。"

#. type: Plain text
#: build/C/man7/ip.7:1106
msgid ""
"No valid routing table entry matches the destination address.  This error "
"can be caused by a ICMP message from a remote router or for the local "
"routing table."
msgstr ""
"宛先アドレスにマッチする有効なエントリがルーティングテーブルに 存在しない。こ"
"のエラーはリモートルータからの、 あるいはローカルルーティングテーブルへの "
"ICMP メッセージによって引き起こされることがある。"

#. type: Plain text
#: build/C/man7/ip.7:1112
msgid ""
"Invalid argument passed.  For send operations this can be caused by sending "
"to a I<blackhole> route."
msgstr ""
"不正な引き数が渡された。送信操作において、 I<blackhole> ルートに送信しようと"
"するとこのエラーが起こることがある。"

#. type: Plain text
#: build/C/man7/ip.7:1119
msgid "Datagram is bigger than an MTU on the path and it cannot be fragmented."
msgstr "データグラムが path MTU よりも大きく、フラグメント化もできない。"

#. type: TP
#: build/C/man7/ip.7:1119
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr "B<ENOBUFS>, B<ENOMEM>"

#. type: Plain text
#: build/C/man7/ip.7:1124
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory, but this is "
"not 100% consistent."
msgstr ""
"空きメモリが足りない。 このエラーは、メモリアロケーションがソケットバッファ"
"の 大きさによって制限されていることを意味しているのが通常であるが、 100% そう"
"だというわけではない。"

#. type: Plain text
#: build/C/man7/ip.7:1142
msgid ""
"User doesn't have permission to set high priority, change configuration, or "
"send signals to the requested process or group."
msgstr ""
"高い優先度を設定したり、設定を変更したり、要求されたプロセスや プロセスグルー"
"プにシグナルを送ったりするのに必要な権限を、 ユーザーが持っていない。"

#. type: Plain text
#: build/C/man7/ip.7:1148
msgid "The socket is not configured or an unknown socket type was requested."
msgstr "ソケットが未設定であるか、知らないソケットタイプが要求された。"

#. type: Plain text
#: build/C/man7/ip.7:1155
msgid ""
"Other errors may be generated by the overlaying protocols; see B<tcp>(7), "
"B<raw>(7), B<udp>(7)  and B<socket>(7)."
msgstr ""
"他のエラーが上層のプロトコルによって生じるかもしれない。 B<tcp>(7), B<raw>"
"(7), B<udp>(7), B<socket>(7)  などを参照のこと。"

#.  IP_PASSSEC is Linux-specific
#.  IP_XFRM_POLICY is Linux-specific
#.  IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
#. type: Plain text
#: build/C/man7/ip.7:1170
msgid ""
"B<IP_FREEBIND>, B<IP_MSFILTER>, B<IP_MTU>, B<IP_MTU_DISCOVER>, "
"B<IP_RECVORIGDSTADDR>, B<IP_PKTINFO>, B<IP_RECVERR>, B<IP_ROUTER_ALERT>, and "
"B<IP_TRANSPARENT> are Linux-specific."
msgstr ""
"B<IP_FREEBIND>, B<IP_MSFILTER>, B<IP_MTU>, B<IP_MTU_DISCOVER>, "
"B<IP_RECVORIGDSTADDR>,\n"
"B<IP_PKTINFO>, B<IP_RECVERR>, B<IP_ROUTER_ALERT>, and B<IP_TRANSPARENT> \n"
"は Linux 固有である。"

#. type: Plain text
#: build/C/man7/ip.7:1179
msgid ""
"Be very careful with the B<SO_BROADCAST> option - it is not privileged in "
"Linux.  It is easy to overload the network with careless broadcasts.  For "
"new application protocols it is better to use a multicast group instead of "
"broadcasting.  Broadcasting is discouraged."
msgstr ""
"B<SO_BROADCAST> オプションの利用には、くれぐれも注意すること。\n"
"これは Linux では特権操作ではない。\n"
"不注意なブロードキャストを行うと、ネットワークは簡単に過負荷状態になる。\n"
"新しいアプリケーションプロトコルには、ブロードキャストではなく\n"
"マルチキャストグループを用いるほうがよい。 ブロードキャストは推奨されない。"

#. type: Plain text
#: build/C/man7/ip.7:1189
msgid ""
"Some other BSD sockets implementations provide B<IP_RCVDSTADDR> and "
"B<IP_RECVIF> socket options to get the destination address and the interface "
"of received datagrams.  Linux has the more general B<IP_PKTINFO> for the "
"same task."
msgstr ""
"他の BSD のソケット実装では、 B<IP_RCVDSTADDR> と B<IP_RECVIF> といったソケッ"
"トオプションがサポートされており、 宛先アドレスや受信データグラムのインター"
"フェースが取得できるように なっていることもある。 Linux で同じことをやらせる"
"には、より一般的な B<IP_PKTINFO> が使える。"

#. type: Plain text
#: build/C/man7/ip.7:1198
msgid ""
"Some BSD sockets implementations also provide an B<IP_RECVTTL> option, but "
"an ancillary message with type B<IP_RECVTTL> is passed with the incoming "
"packet.  This is different from the B<IP_TTL> option used in Linux."
msgstr ""
"いくつかの BSD のソケット実装では B<IP_RECVTTL> オプションも提供されている"
"が、タイプ B<IP_RECVTTL> の補助メッセージは受信パケットとともに渡される。 こ"
"れは Linux で使われている B<IP_TTL> オプションとは異なる動作である。"

#. type: Plain text
#: build/C/man7/ip.7:1204
msgid ""
"Using B<SOL_IP> socket options level isn't portable, BSD-based stacks use "
"B<IPPROTO_IP> level."
msgstr ""
"B<SOL_IP> ソケットオプションレベルは移植性がない。 BSD ベースのプロトコルス"
"タックでは B<IPPROTO_IP> レベルが使用されている。"

#. type: Plain text
#: build/C/man7/ip.7:1217
msgid ""
"For compatibility with Linux 2.0, the obsolete B<socket(AF_INET, "
"SOCK_PACKET, >I<protocol>B<)> syntax is still supported to open a B<packet>"
"(7)  socket.  This is deprecated and should be replaced by B<socket"
"(AF_PACKET, SOCK_RAW, >I<protocol>B<)> instead.  The main difference is the "
"new I<sockaddr_ll> address structure for generic link layer information "
"instead of the old B<sockaddr_pkt>."
msgstr ""
"Linux 2.0 との互換性のために、 obsolete な B<socket(AF_INET, SOCK_PACKET, "
">I<protocol>B<)> という書式でも B<packet>(7)  をオープンできるようになってい"
"るが、これはお勧めできない。今後は B<socket(AF_PACKET, SOCK_RAW, "
">I<protocol>B<)> を代わりに用いるべきである。主な違いは、ジェネリックなリンク"
"層用の I<sockaddr_ll> アドレス構造体が、古い B<sockaddr_pkt> に変わって用いら"
"れるようになったことである。"

#. type: Plain text
#: build/C/man7/ip.7:1222
msgid ""
"The ioctls to configure IP-specific interface options and ARP tables are not "
"described."
msgstr ""
"IP 固有のインターフェースオプションを指定するための ioctl と ARP テーブルのこ"
"とが記述されていない。"

#. type: Plain text
#: build/C/man7/ip.7:1226
msgid ""
"Some versions of glibc forget to declare I<in_pktinfo>.  Workaround "
"currently is to copy it into your program from this man page."
msgstr ""
"glibc のバージョンによっては I<in_pktinfo> の定義を忘れているものがある。 現"
"時点でのとりあえずの対策としては、この man ページにある定義をプログラム中に "
"コピーすることである。"

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/ip.7:1236
msgid ""
"Receiving the original destination address with B<MSG_ERRQUEUE> in "
"I<msg_name> by B<recvmsg>(2)  does not work in some 2.2 kernels."
msgstr ""
"B<recvmsg>(2)  で I<msg_name> に B<MSG_ERRQUEUE> を指定して、受信パケットに"
"入っていた宛先アドレスを取得する方法は 2.2 カーネルの一部でうまく動かない。"

#. type: Plain text
#: build/C/man7/ip.7:1249
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<byteorder>(3), B<ipfw>(4), B<capabilities>"
"(7), B<icmp>(7), B<ipv6>(7), B<netlink>(7), B<raw>(7), B<socket>(7), B<tcp>"
"(7), B<udp>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<byteorder>(3), B<ipfw>(4), B<capabilities>"
"(7), B<icmp>(7), B<ipv6>(7), B<netlink>(7), B<raw>(7), B<socket>(7), B<tcp>"
"(7), B<udp>(7)"

#.  FIXME autobind INADDR REUSEADDR
#. type: Plain text
#: build/C/man7/ip.7:1254
msgid ""
"RFC\\ 791 for the original IP specification.  RFC\\ 1122 for the IPv4 host "
"requirements.  RFC\\ 1812 for the IPv4 router requirements."
msgstr ""
"RFC\\ 791: 元々の IP 仕様。 RFC\\ 1122: IPv4 ホストの要件。 RFC\\ 1812: IPv4 "
"ルータの要件。"

#. type: TH
#: build/C/man7/ipv6.7:86
#, no-wrap
msgid "IPV6"
msgstr "IPV6"

#. type: TH
#: build/C/man7/ipv6.7:86
#, no-wrap
msgid "2012-12-16"
msgstr "2012-12-16"

#. type: Plain text
#: build/C/man7/ipv6.7:89
msgid "ipv6 - Linux IPv6 protocol implementation"
msgstr "ipv6 - Linux IPv6 プロトコルの実装"

#. type: Plain text
#: build/C/man7/ipv6.7:95
msgid "I<tcp6_socket>B< = socket(AF_INET6, SOCK_STREAM, 0);>"
msgstr "I<tcp6_socket>B< = socket(AF_INET6, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/ipv6.7:97
msgid "I<raw6_socket>B< = socket(AF_INET6, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw6_socket>B< = socket(AF_INET6, SOCK_RAW, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ipv6.7:99
msgid "I<udp6_socket>B< = socket(AF_INET6, SOCK_DGRAM, >I<protocol>B<);>"
msgstr "I<udp6_socket>B< = socket(AF_INET6, SOCK_DGRAM, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ipv6.7:106
msgid ""
"Linux 2.2 optionally implements the Internet Protocol, version 6.  This man "
"page contains a description of the IPv6 basic API as implemented by the "
"Linux kernel and glibc 2.1.  The interface is based on the BSD sockets "
"interface; see B<socket>(7)."
msgstr ""
"Linux 2.2 では、Internet Protocol, version 6 を オプションとして実装してい"
"る。 この man ページでは、Linux カーネルと glibc 2.1 での実装に基づいて、 "
"IPv6 の基本的な API を解説する。 インターフェースは BSD ソケットインター"
"フェースをもとにしている。 B<socket>(7)  を参照。"

#. type: Plain text
#: build/C/man7/ipv6.7:111
msgid ""
"The IPv6 API aims to be mostly compatible with the IPv4 API (see B<ip>(7)).  "
"Only differences are described in this man page."
msgstr ""
"IPv6 API は、 IPv4 API (B<ip>(7)  参照) とほぼ互換になることを目指している。 "
"この man ページでは相違点のみを解説する。"

#. type: Plain text
#: build/C/man7/ipv6.7:123
msgid ""
"To bind an B<AF_INET6> socket to any process, the local address should be "
"copied from the I<in6addr_any> variable which has I<in6_addr> type.  In "
"static initializations, B<IN6ADDR_ANY_INIT> may also be used, which expands "
"to a constant expression.  Both of them are in network byte order."
msgstr ""
"B<AF_INET6> ソケットを何らかのプロセスにバインドするには、 ローカルアドレス"
"を I<in6_addr> 型の変数 I<in6addr_any> からコピーしてくる必要がある。 static "
"な初期値 B<IN6ADDR_ANY_INIT> も用いることができ、これは定数式に展開される。 "
"これらの両者はネットワークバイトオーダーである。"

#. type: Plain text
#: build/C/man7/ipv6.7:130
msgid ""
"The IPv6 loopback address (::1) is available in the global "
"I<in6addr_loopback> variable.  For initializations, B<IN6ADDR_LOOPBACK_INIT> "
"should be used."
msgstr ""
"IPv6 のループバックアドレス (::1) は global 変数 I<in6addr_loopback> から取得"
"できる。初期化には B<IN6ADDR_LOOPBACK_INIT> を用いるべきである。"

#. type: Plain text
#: build/C/man7/ipv6.7:137
msgid ""
"IPv4 connections can be handled with the v6 API by using the v4-mapped-on-v6 "
"address type; thus a program only needs to support this API type to support "
"both protocols.  This is handled transparently by the address handling "
"functions in the C library."
msgstr ""
"v4-mapped-on-v6 アドレス型を用いることで、 IPv4 接続も v6 API で扱うことがで"
"きる。 こうすれば、プログラムは v6 の API をサポートするだけで、 両方のプロト"
"コルをサポートできる。 v4-mapped-on-v6 アドレス型は C ライブラリ内部のアドレ"
"スを 扱う関数によって透過的に処理される。"

#. type: Plain text
#: build/C/man7/ipv6.7:142
msgid ""
"IPv4 and IPv6 share the local port space.  When you get an IPv4 connection "
"or packet to a IPv6 socket, its source address will be mapped to v6 and it "
"will be mapped to v6."
msgstr ""
"IPv4 と IPv6 はローカルポート空間を共有する。 IPv4 の接続 (またはパケット) "
"を IPv6 ソケットが取得すると、 発信元アドレスが v6 にマップされ、その接続 (パ"
"ケット) も v6 にマップされる。"

#. type: Plain text
#: build/C/man7/ipv6.7:152
#, no-wrap
msgid ""
"struct sockaddr_in6 {\n"
"    sa_family_t     sin6_family;   /* AF_INET6 */\n"
"    in_port_t       sin6_port;     /* port number */\n"
"    uint32_t        sin6_flowinfo; /* IPv6 flow information */\n"
"    struct in6_addr sin6_addr;     /* IPv6 address */\n"
"    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n"
"};\n"
msgstr ""
"struct sockaddr_in6 {\n"
"    sa_family_t     sin6_family;   /* AF_INET6 */\n"
"    in_port_t       sin6_port;     /* port number */\n"
"    uint32_t        sin6_flowinfo; /* IPv6 flow information */\n"
"    struct in6_addr sin6_addr;     /* IPv6 address */\n"
"    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ipv6.7:156
#, no-wrap
msgid ""
"struct in6_addr {\n"
"    unsigned char   s6_addr[16];   /* IPv6 address */\n"
"};\n"
msgstr ""
"struct in6_addr {\n"
"    unsigned char   s6_addr[16];   /* IPv6 address */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ipv6.7:178
msgid ""
"I<sin6_family> is always set to B<AF_INET6>; I<sin6_port> is the protocol "
"port (see I<sin_port> in B<ip>(7)); I<sin6_flowinfo> is the IPv6 flow "
"identifier; I<sin6_addr> is the 128-bit IPv6 address.  I<sin6_scope_id> is "
"an ID depending on the scope of the address.  It is new in Linux 2.4.  Linux "
"supports it only for link-local addresses, in that case I<sin6_scope_id> "
"contains the interface index (see B<netdevice>(7))"
msgstr ""
"I<sin6_family> は常に B<AF_INET6> に設定される。\n"
"I<sin6_port> はプロトコルポートである (B<ip>(7) の I<sin_port> を参照)。\n"
"I<sin6_flowinfo> は IPv6 のフロー指定子 (flow identifier) である。\n"
"I<sin6_addr> は 128 ビットの IPv6 アドレスである。 I<sin6_scope_id> は\n"
"アドレスのスコープに依存した ID である (これは Linux 2.4 で導入された)。\n"
"Linux の場合は、これはリンクローカルアドレスでのみサポートされている。\n"
"この場合 I<sin6_scope_id> にはインターフェースのインデックスが含まれる\n"
"ことになる (B<netdevice>(7) を参照)。"

#. type: Plain text
#: build/C/man7/ipv6.7:184
msgid ""
"IPv6 supports several address types: unicast to address a single host, "
"multicast to address a group of hosts, anycast to address the nearest member "
"of a group of hosts (not implemented in Linux), IPv4-on-IPv6 to address a "
"IPv4 host, and other reserved address types."
msgstr ""
"IPv6 は何種類かのアドレスタイプをサポートしている。 単一のホストをアドレスす"
"るための unicast、 ホストのグループをアドレスするための multicast、 ホストの"
"グループ中で最も近くにいるものをアドレスするための anycast (これは Linux では"
"実装されていない)、 IPv4 ホストをアドレスするための IPv4-on-IPv6。 他にも予約"
"済みのアドレスタイプがある。"

#. type: Plain text
#: build/C/man7/ipv6.7:190
msgid ""
"The address notation for IPv6 is a group of 8 4-digit hexadecimal numbers, "
"separated with a \\(aq:\\(aq.  \\&\"::\" stands for a string of 0 bits.  "
"Special addresses are ::1 for loopback and ::FFFF:E<lt>IPv4 addressE<gt> for "
"IPv4-mapped-on-IPv6."
msgstr ""
"IPv6 でのアドレス表記は 4 桁の 16 進数 8 個からなり、 \\(aq:\\(aq は区切り文"
"字はで、\"::\" は 0 ビットの文字列を表す。 特殊なアドレスとして、ループバック"
"を表す ::1、 IPv4-mapped-on-IPv6 を表す ::FFFF::E<lt>IPv4 アドレスE<gt> があ"
"る。"

#. type: Plain text
#: build/C/man7/ipv6.7:192
msgid "The port space of IPv6 is shared with IPv4."
msgstr "IPv6 のポート空間は IPv4 と共有されている。"

#. type: Plain text
#: build/C/man7/ipv6.7:200
msgid ""
"IPv6 supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IPv6 is B<IPPROTO_IPV6>.  A boolean integer flag is zero when it is "
"false, otherwise true."
msgstr ""
"IPv6 はプロトコル固有のソケットオプションをいくつかサポートしている。 これら"
"は B<setsockopt>(2)  で設定でき、 B<getsockopt>(2)  で取得できる。 IPv6 のソ"
"ケットオプションレベルは B<IPPROTO_IPV6> である。 ブール整数のフラグは、0 が"
"偽であり、それ以外は真である。"

#. type: TP
#: build/C/man7/ipv6.7:200
#, no-wrap
msgid "B<IPV6_ADDRFORM>"
msgstr "B<IPV6_ADDRFORM>"

#. type: Plain text
#: build/C/man7/ipv6.7:214
msgid ""
"Turn an B<AF_INET6> socket into a socket of a different address family.  "
"Only B<AF_INET> is currently supported for that.  It is allowed only for "
"IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address.  The "
"argument is a pointer to an integer containing B<AF_INET>.  This is useful "
"to pass v4-mapped sockets as file descriptors to programs that don't know "
"how to deal with the IPv6 API."
msgstr ""
"B<AF_INET6> ソケットを別のアドレスファミリーのソケットに変える。 現在は "
"B<AF_INET> のみが変更先のアドレスファミリーとしてサポートされている。 これが"
"許可されるのは、IPv6 が接続され、 v4-mapped-on-v6 アドレスにバインドされた場"
"合に限られる。 引き数は B<AF_INET> が入っている整数へのポインタである。 v4-"
"mapped ソケットを、IPv6 API を扱えないプログラムに対して ファイルディスクリプ"
"ターとして渡す場合に便利。"

#. type: TP
#: build/C/man7/ipv6.7:214
#, no-wrap
msgid "B<IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP>"
msgstr "B<IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP>"

#. type: Plain text
#: build/C/man7/ipv6.7:219
msgid ""
"Control membership in multicast groups.  Argument is a pointer to a I<struct "
"ipv6_mreq>."
msgstr ""
"multicast グループのメンバーを制御する。 引き数は I<struct ipv6_mreq> 構造体"
"へのポインタ。"

#. type: TP
#: build/C/man7/ipv6.7:219
#, no-wrap
msgid "B<IPV6_MTU>"
msgstr "B<IPV6_MTU>"

#. type: Plain text
#: build/C/man7/ipv6.7:225
msgid ""
"B<getsockopt>(): Retrieve the current known path MTU of the current socket.  "
"Only valid when the socket has been connected.  Returns an integer."
msgstr ""
"B<getsockopt>(): ソケットの、既知の path MTU を取得する。ソケットが接続してい"
"る場合のみ有効である。整数を返す。"

#. type: Plain text
#: build/C/man7/ipv6.7:231
msgid ""
"B<setsockopt>(): Set the MTU to be used for the socket.  The MTU is limited "
"by the device MTU or the path MTU when path MTU discovery is enabled.  "
"Argument is a pointer to integer."
msgstr ""
"B<setsockopt>(): そのソケットに対して用いる MTU の値を設定する。 MTU の大きさ"
"は、 そのデバイスの MTU または (Path MTU Discovery が可能なら) その経路の "
"MTU の大きさ以下でなければならない。 引き数は整数へのポインタ。"

#. type: TP
#: build/C/man7/ipv6.7:231
#, no-wrap
msgid "B<IPV6_MTU_DISCOVER>"
msgstr "B<IPV6_MTU_DISCOVER>"

#. type: Plain text
#: build/C/man7/ipv6.7:239
msgid ""
"Control path-MTU discovery on the socket.  See B<IP_MTU_DISCOVER> in B<ip>"
"(7)  for details."
msgstr ""
"そのソケットでの Path MTU Discovery を制御する。 詳細は B<ip>(7)  の "
"B<IP_MTU_DISCOVER> を参照。"

#. type: TP
#: build/C/man7/ipv6.7:239
#, no-wrap
msgid "B<IPV6_MULTICAST_HOPS>"
msgstr "B<IPV6_MULTICAST_HOPS>"

#. type: Plain text
#: build/C/man7/ipv6.7:246
msgid ""
"Set the multicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""
"そのソケットでの multicast の hop 数の上限値を設定する。 引き数は整数へのポイ"
"ンタである。 -1 を指定すると経路のデフォルトを用いることを意味する。 それ以外"
"の場合は 0 から 255 の範囲を指定する。"

#. type: TP
#: build/C/man7/ipv6.7:246
#, no-wrap
msgid "B<IPV6_MULTICAST_IF>"
msgstr "B<IPV6_MULTICAST_IF>"

#. type: Plain text
#: build/C/man7/ipv6.7:257
msgid ""
"Set the device for outgoing multicast packets on the socket.  This is "
"allowed only for B<SOCK_DGRAM> and B<SOCK_RAW> socket.  The argument is a "
"pointer to an interface index (see B<netdevice>(7))  in an integer."
msgstr ""
"そのソケットでの、送信 multicast パケットに用いるデバイスを設定する。 これは "
"B<SOCK_DGRAM> および B<SOCK_RAW> 各ソケットでのみ許される。 引き数はインター"
"フェースのインデックスの整数値 (B<netdevice>(7)  を参照) へのポインタである。"

#. type: TP
#: build/C/man7/ipv6.7:257
#, no-wrap
msgid "B<IPV6_MULTICAST_LOOP>"
msgstr "B<IPV6_MULTICAST_LOOP>"

#. type: Plain text
#: build/C/man7/ipv6.7:261
msgid ""
"Control whether the socket sees multicast packets that it has send itself.  "
"Argument is a pointer to boolean."
msgstr ""
"ソケットが、自分自身の送信した multicast パケットを監視するかどうかを制御す"
"る。 引き数はブール値へのポインタ。"

#. type: TP
#: build/C/man7/ipv6.7:261
#, no-wrap
msgid "B<IPV6_RECVPKTINFO> (since Linux 2.6.14)"
msgstr "B<IPV6_RECVPKTINFO> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man7/ipv6.7:275
msgid ""
"Set delivery of the B<IPV6_PKTINFO> control message on incoming datagrams.  "
"Such control messages contain a I<struct in6_pktinfo>, as per RFC 3542.  "
"Only allowed for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a "
"pointer to a boolean value in an integer."
msgstr ""
"データグラムの到着時における B<IPV6_PKTINFO> 制御メッセージを配送するかどうか"
"を設定する。 制御メッセージは RFC 3542 に基づき I<struct in6_pktinfo> に格納"
"される。 B<SOCK_DGRAM> ソケットまたは B<SOCK_RAW> ソケットに対してのみ許可さ"
"れる。 引き数はブール値の入った整数。"

#. type: Plain text
#: build/C/man7/ipv6.7:278
msgid ""
"B<IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, "
"IPV6_HOPLIMIT>"
msgstr ""
"B<IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, "
"IPV6_HOPLIMIT>"

#. type: Plain text
#: build/C/man7/ipv6.7:303
msgid ""
"Set delivery of control messages for incoming datagrams containing extension "
"headers from the received packet.  B<IPV6_RTHDR> delivers the routing "
"header, B<IPV6_AUTHHDR> delivers the authentication header, B<IPV6_DSTOPTS> "
"delivers the destination options, B<IPV6_HOPOPTS> delivers the hop options, "
"B<IPV6_FLOWINFO> delivers an integer containing the flow ID, "
"B<IPV6_HOPLIMIT> delivers an integer containing the hop count of the "
"packet.  The control messages have the same type as the socket option.  All "
"these header options can also be set for outgoing packets by putting the "
"appropriate control message into the control buffer of B<sendmsg>(2).  Only "
"allowed for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a pointer to "
"a boolean value."
msgstr ""
"受信パケットのデータグラムに拡張ヘッダが含まれている場合の、 制御メッセージの"
"配送を設定する。 B<IPV6_RTHDR>: routing ヘッダを配送するかどうか。 "
"B<IPV6_AUTHHDR>: authentication ヘッダを配送するかどうか。 B<IPV6_DSTOPTS>: "
"destination オプションを配送するかどうか。 B<IPV6_HOPOPTS>: hop オプションを"
"配送するかどうか。 B<IPV6_FLOWINFO>: flow ID を含む整数を配送するかどうか。 "
"B<IPV6_HOPLIMIT>: パケットの hop カウントを含む整数を配送するかどうか。 制御"
"メッセージはソケットオプションのものと同じタイプを持つ。 これらのすべてのヘッ"
"ダオプションは、 適切な制御メッセージを B<sendmsg>(2)  の制御バッファーに書き"
"こめば、 送信パケットにでも設定できる。 B<SOCK_DGRAM> ソケットまたは "
"B<SOCK_RAW> ソケットでのみ許される。引き数はブール値へのポインタ。"

#. type: TP
#: build/C/man7/ipv6.7:303
#, no-wrap
msgid "B<IPV6_RECVERR>"
msgstr "B<IPV6_RECVERR>"

#. type: Plain text
#: build/C/man7/ipv6.7:312
msgid ""
"Control receiving of asynchronous error options.  See B<IP_RECVERR> in B<ip>"
"(7)  for details.  Argument is a pointer to boolean."
msgstr ""
"非同期エラー (asynchronous error) オプションの受信を制御する。 詳細は B<ip>"
"(7)  の B<IP_RECVERR> を参照。 引き数はブール値へのポインタ。"

#. type: TP
#: build/C/man7/ipv6.7:312
#, no-wrap
msgid "B<IPV6_ROUTER_ALERT>"
msgstr "B<IPV6_ROUTER_ALERT>"

#. type: Plain text
#: build/C/man7/ipv6.7:325
msgid ""
"Pass forwarded packets containing a router alert hop-by-hop option to this "
"socket.  Only allowed for SOCK_RAW sockets.  The tapped packets are not "
"forwarded by the kernel, it is the user's responsibility to send them out "
"again.  Argument is a pointer to an integer.  A positive integer indicates a "
"router alert option value to intercept.  Packets carrying a router alert "
"option with a value field containing this integer will be delivered to the "
"socket.  A negative integer disables delivery of packets with router alert "
"options to this socket."
msgstr ""
"このソケットで、router alert hop-by-hop オプションの付いた転送パケットを 通す"
"かどうかを制御する。 B<SOCK_RAW> ソケットでのみ許可される。 tap されたパケッ"
"トはカーネルによっては転送されない。そうしたパケットを 再度送信するのはユー"
"ザーの責任である。 引き数は整数 (integer) へのポインタ。 正の整数は傍受を行"
"う router alert オプション値を示す。 オプション値がこの整数である router "
"alert オプションの付いたパケットは ソケットに配送される。負の整数を指定する"
"と、このソケットへの router alert オプションの付いたパケットの配送が行われな"
"い。"

#. type: TP
#: build/C/man7/ipv6.7:325
#, no-wrap
msgid "B<IPV6_UNICAST_HOPS>"
msgstr "B<IPV6_UNICAST_HOPS>"

#. type: Plain text
#: build/C/man7/ipv6.7:331
msgid ""
"Set the unicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""
"そのソケットでの unicast の hop 数の上限値を設定する。 引き数は整数へのポイン"
"タである。 -1 を指定すると経路のデフォルトを用いることを意味する。 それ以外の"
"場合は 0 から 255 の範囲を指定する。"

#. type: TP
#: build/C/man7/ipv6.7:331
#, no-wrap
msgid "B<IPV6_V6ONLY> (since Linux 2.4.21 and 2.6)"
msgstr "B<IPV6_V6ONLY> (Linux 2.4.21 以降および 2.6 以降)"

#.  See RFC 3493
#. type: Plain text
#: build/C/man7/ipv6.7:338
msgid ""
"If this flag is set to true (nonzero), then the socket is restricted to "
"sending and receiving IPv6 packets only.  In this case, an IPv4 and an IPv6 "
"application can bind to a single port at the same time."
msgstr ""
"このフラグを真 (0 以外) に設定すると、そのソケットは IPv6 パケットだけを 送受"
"信するように制限される。 この場合、IPv4 アプリケーションと IPv6 アプリケー"
"ションが同時に 一つのポートをバインドできる。"

#. type: Plain text
#: build/C/man7/ipv6.7:342
msgid ""
"If this flag is set to false (zero), then the socket can be used to send and "
"receive packets to and from an IPv6 address or an IPv4-mapped IPv6 address."
msgstr ""
"このフラグを偽 (0) に設定すると、そのソケットはパケットの送受信に IPv6 アドレ"
"スと IPv4-mapped IPv6 アドレスの両方を使用できる。"

#. type: Plain text
#: build/C/man7/ipv6.7:344
msgid "The argument is a pointer to a boolean value in an integer."
msgstr "引き数はブール値の入った整数へのポインタである。"

#.  FLOWLABEL_MGR, FLOWINFO_SEND
#. type: Plain text
#: build/C/man7/ipv6.7:349
msgid ""
"The default value for this flag is defined by the contents of the file I</"
"proc/sys/net/ipv6/bindv6only>.  The default value for that file is 0 (false)."
msgstr ""
"このフラグのデフォルト値はファイル I</proc/sys/net/ipv6/bindv6only> の内容に"
"より定義される。 このファイルのデフォルト値は 0 (偽) である。"

#. type: Plain text
#: build/C/man7/ipv6.7:361
msgid ""
"The user tried to B<bind>(2)  to a link-local IPv6 address, but the "
"I<sin6_scope_id> in the supplied I<sockaddr_in6> structure is not a valid "
"interface index."
msgstr ""
"ユーザがリンクローカルの IPv6 アドレスを B<bind>(2) しようとしたが、\n"
"指定された I<sockaddr_in6> 構造体の I<sin6_scope_id> が\n"
"有効なインターフェースのインデックスでなかった。"

#. type: Plain text
#: build/C/man7/ipv6.7:366
msgid ""
"The older I<libinet6> libc5 based IPv6 API implementation for Linux is not "
"described here and may vary in details."
msgstr ""
"IPv6 API を libc5 ベースで Linux 向けに実装した、以前の I<libinet6> について"
"はここでは記述していない。 おそらく細かいところには相違点があるだろう。"

#. type: Plain text
#: build/C/man7/ipv6.7:382
msgid ""
"Linux 2.4 will break binary compatibility for the I<sockaddr_in6> for 64-bit "
"hosts by changing the alignment of I<in6_addr> and adding an additional "
"I<sin6_scope_id> field.  The kernel interfaces stay compatible, but a "
"program including I<sockaddr_in6> or I<in6_addr> into other structures may "
"not be.  This is not a problem for 32-bit hosts like i386."
msgstr ""
"Linux 2.4 では 64 ビットのホストに対して I<sockaddr_in6> のバイナリ互換性が保"
"たれていない。 I<in6_addr> のアラインメントが変更され、また I<sin6_scope_id> "
"フィールドが新たに追加されたからである。 カーネルインターフェースの互換性は保"
"たれているが、 I<sockaddr_in6> や I<in6_addr> を他の構造体に含んでいるような"
"プログラムでは 保たれないかもしれない。 これは i386 のような 32 ビットのホス"
"トでは問題にならない。"

#. type: Plain text
#: build/C/man7/ipv6.7:390
msgid ""
"The I<sin6_flowinfo> field is new in Linux 2.4.  It is transparently passed/"
"read by the kernel when the passed address length contains it.  Some "
"programs that pass a longer address buffer and then check the outgoing "
"address length may break."
msgstr ""
"I<sin6_flowinfo> フィールドは Linux 2.4 で登場した。 これが渡されたアドレス長"
"に含まれていると、 カーネルに透過的に渡され、読まれる。 より長いアドレスバッ"
"ファを渡し、 そして送信アドレスの長さをチェックするようなプログラムは うまく"
"動かないかもしれない。"

#. type: Plain text
#: build/C/man7/ipv6.7:400
msgid ""
"The I<sockaddr_in6> structure is bigger than the generic I<sockaddr>.  "
"Programs that assume that all address types can be stored safely in a "
"I<struct sockaddr> need to be changed to use I<struct sockaddr_storage> for "
"that instead."
msgstr ""
"I<sockaddr_in6> 構造体はジェネリックな I<sockaddr> よりも大きい。 すべてのア"
"ドレスタイプが I<struct sockaddr> の中に安全に納められると仮定しているプログ"
"ラムは、代わりに I<struct sockaddr_storage> を用いるように変更する必要があ"
"る。"

#. type: Plain text
#: build/C/man7/ipv6.7:405
msgid ""
"The IPv6 extended API as in RFC\\ 2292 is currently only partly implemented; "
"although the 2.2 kernel has near complete support for receiving options, the "
"macros for generating IPv6 options are missing in glibc 2.1."
msgstr ""
"IPv6 拡張 API は、現在まだ RFC\\ 2292 を完全には実装していない。 2.2 カーネル"
"は受信オプションをほぼ完全にサポートサポートしているが、 glibc2.1 には IPv6 "
"オプションを生成するマクロが存在していない。"

#. type: Plain text
#: build/C/man7/ipv6.7:407
msgid "IPSec support for EH and AH headers is missing."
msgstr "EH および AH ヘッダ での IPSec のサポートは存在しない。"

#. type: Plain text
#: build/C/man7/ipv6.7:409
msgid "Flow label management is not complete and not documented here."
msgstr "フローラベル管理はまだ完全でなく、ここにも記述されていない。"

#. type: Plain text
#: build/C/man7/ipv6.7:411
msgid "This man page is not complete."
msgstr "この man ページはまだ完成していない。"

#. type: Plain text
#: build/C/man7/ipv6.7:414
msgid "B<cmsg>(3), B<ip>(7)"
msgstr "B<cmsg>(3), B<ip>(7)"

#. type: Plain text
#: build/C/man7/ipv6.7:418
msgid ""
"RFC\\ 2553: IPv6 BASIC API; Linux tries to be compliant to this.  RFC\\ "
"2460: IPv6 specification."
msgstr ""
"RFC\\ 2553: IPv6 BASIC API; Linux はこの RFC に準拠するようにしている。 RFC"
"\\ 2460: IPv6 specification."

#. type: TH
#: build/C/man7/netdevice.7:18
#, no-wrap
msgid "NETDEVICE"
msgstr "NETDEVICE"

#. type: TH
#: build/C/man7/netdevice.7:18
#, no-wrap
msgid "2012-04-26"
msgstr "2012-04-26"

#. type: Plain text
#: build/C/man7/netdevice.7:21
msgid "netdevice - low-level access to Linux network devices"
msgstr "netdevice - Linux ネットワークデバイスへの低レベルアクセス"

#. type: Plain text
#: build/C/man7/netdevice.7:23
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man7/netdevice.7:25
msgid "B<#include E<lt>net/if.hE<gt>>"
msgstr "B<#include E<lt>net/if.hE<gt>>"

#. type: Plain text
#: build/C/man7/netdevice.7:28
msgid ""
"This man page describes the sockets interface which is used to configure "
"network devices."
msgstr ""
"この man ページでは、ネットワークデバイスを設定するために 用いるソケットイン"
"ターフェースについて解説する。"

#. type: Plain text
#: build/C/man7/netdevice.7:35
msgid ""
"Linux supports some standard ioctls to configure network devices.  They can "
"be used on any socket's file descriptor regardless of the family or type.  "
"They pass an I<ifreq> structure:"
msgstr ""
"Linux はネットワークデバイスを設定するための標準的な ioctl を いくつか備えて"
"いる。これらはどんなソケットのファイルディスクリプタにも 用いることができる。"
"ファミリーやタイプは何でもよい。 これらの ioctl は I<ifreq> 構造体を渡す。"

#. type: Plain text
#: build/C/man7/netdevice.7:56
#, no-wrap
msgid ""
"struct ifreq {\n"
"    char ifr_name[IFNAMSIZ]; /* Interface name */\n"
"    union {\n"
"        struct sockaddr ifr_addr;\n"
"        struct sockaddr ifr_dstaddr;\n"
"        struct sockaddr ifr_broadaddr;\n"
"        struct sockaddr ifr_netmask;\n"
"        struct sockaddr ifr_hwaddr;\n"
"        short           ifr_flags;\n"
"        int             ifr_ifindex;\n"
"        int             ifr_metric;\n"
"        int             ifr_mtu;\n"
"        struct ifmap    ifr_map;\n"
"        char            ifr_slave[IFNAMSIZ];\n"
"        char            ifr_newname[IFNAMSIZ];\n"
"        char           *ifr_data;\n"
"    };\n"
"};\n"
msgstr ""
"struct ifreq {\n"
"    char ifr_name[IFNAMSIZ]; /* Interface name */\n"
"    union {\n"
"        struct sockaddr ifr_addr;\n"
"        struct sockaddr ifr_dstaddr;\n"
"        struct sockaddr ifr_broadaddr;\n"
"        struct sockaddr ifr_netmask;\n"
"        struct sockaddr ifr_hwaddr;\n"
"        short           ifr_flags;\n"
"        int             ifr_ifindex;\n"
"        int             ifr_metric;\n"
"        int             ifr_mtu;\n"
"        struct ifmap    ifr_map;\n"
"        char            ifr_slave[IFNAMSIZ];\n"
"        char            ifr_newname[IFNAMSIZ];\n"
"        char           *ifr_data;\n"
"    };\n"
"};\n"

#. type: Plain text
#: build/C/man7/netdevice.7:64
#, no-wrap
msgid ""
"struct ifconf {\n"
"    int                 ifc_len; /* size of buffer */\n"
"    union {\n"
"        char           *ifc_buf; /* buffer address */\n"
"        struct ifreq   *ifc_req; /* array of structures */\n"
"    };\n"
"};\n"
msgstr ""
"struct ifconf {\n"
"    int                 ifc_len; /* size of buffer */\n"
"    union {\n"
"        char           *ifc_buf; /* buffer address */\n"
"        struct ifreq   *ifc_req; /* array of structures */\n"
"    };\n"
"};\n"

#. type: Plain text
#: build/C/man7/netdevice.7:72
msgid ""
"Normally, the user specifies which device to affect by setting I<ifr_name> "
"to the name of the interface.  All other members of the structure may share "
"memory."
msgstr ""
"通常、ユーザーによる設定対象デバイスの指定は、 I<ifr_name> にインターフェース"
"の名前をセットすることによって行う。 他の構造体の全てのメンバは、メモリを共有"
"する。"

#. type: Plain text
#: build/C/man7/netdevice.7:80
msgid ""
"If an ioctl is marked as privileged then using it requires an effective user "
"ID of 0 or the B<CAP_NET_ADMIN> capability.  If this is not the case "
"B<EPERM> will be returned."
msgstr ""
"「特権が必要」と記述されている ioctl を実行するには、 実効ユーザー ID が 0 "
"か、 B<CAP_NET_ADMIN> 権限が必要である。これが満たされていない場合は "
"B<EPERM> が返される。"

#. type: TP
#: build/C/man7/netdevice.7:80
#, no-wrap
msgid "B<SIOCGIFNAME>"
msgstr "B<SIOCGIFNAME>"

#. type: Plain text
#: build/C/man7/netdevice.7:88
msgid ""
"Given the I<ifr_ifindex>, return the name of the interface in I<ifr_name>.  "
"This is the only ioctl which returns its result in I<ifr_name>."
msgstr ""
"I<ifr_ifindex> を受け取り、インターフェースの名前を I<ifr_name> に入れて返"
"す。これは結果を I<ifr_name> として返す唯一の ioctl である。"

#. type: TP
#: build/C/man7/netdevice.7:88
#, no-wrap
msgid "B<SIOCGIFINDEX>"
msgstr "B<SIOCGIFINDEX>"

#. type: Plain text
#: build/C/man7/netdevice.7:92
msgid "Retrieve the interface index of the interface into I<ifr_ifindex>."
msgstr ""
"インターフェースの interface index を取得し、 I<ifr_ifindex> に入れて返す。"

#. type: TP
#: build/C/man7/netdevice.7:92
#, no-wrap
msgid "B<SIOCGIFFLAGS>, B<SIOCSIFFLAGS>"
msgstr "B<SIOCGIFFLAGS>, B<SIOCSIFFLAGS>"

#.  Do not right adjust text blocks in tables
#. type: Plain text
#: build/C/man7/netdevice.7:98
msgid ""
"Get or set the active flag word of the device.  I<ifr_flags> contains a bit "
"mask of the following values:"
msgstr ""
"デバイスの active フラグワードを取得または設定する。 I<ifr_flags> には以下の"
"値のビットマスクが入る。"

#. type: tbl table
#: build/C/man7/netdevice.7:103
#, no-wrap
msgid "Device flags\n"
msgstr "デバイスフラグ\n"

#. type: tbl table
#: build/C/man7/netdevice.7:104
#, no-wrap
msgid "IFF_UP:Interface is running.\n"
msgstr "IFF_UP:インターフェースは動作中。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:105
#, no-wrap
msgid "IFF_BROADCAST:Valid broadcast address set.\n"
msgstr "IFF_BROADCAST:有効なブロードキャストアドレスがセットされている。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:106
#, no-wrap
msgid "IFF_DEBUG:Internal debugging flag.\n"
msgstr "IFF_DEBUG:内部のデバッグフラグ。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:107
#, no-wrap
msgid "IFF_LOOPBACK:Interface is a loopback interface.\n"
msgstr "IFF_LOOPBACK:インターフェースはループバックである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:108
#, no-wrap
msgid "IFF_POINTOPOINT:Interface is a point-to-point link.\n"
msgstr "IFF_POINTOPOINT:インターフェースは point-to-point リンクである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:109
#, no-wrap
msgid "IFF_RUNNING:Resources allocated.\n"
msgstr "IFF_RUNNING:リソースが割り当て済み。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:110
#, no-wrap
msgid "IFF_NOARP:T{\n"
msgstr "IFF_NOARP:T{\n"

#. type: tbl table
#: build/C/man7/netdevice.7:111
#, no-wrap
msgid "No arp protocol, L2 destination address not set.\n"
msgstr "arp プロトコルがない。 L2 宛先アドレスが設定されていない。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:112 build/C/man7/netdevice.7:123
#, no-wrap
msgid "T}\n"
msgstr "T}\n"

#. type: tbl table
#: build/C/man7/netdevice.7:113
#, no-wrap
msgid "IFF_PROMISC:Interface is in promiscuous mode.\n"
msgstr "IFF_PROMISC:インターフェースは promiscuous モードである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:114
#, no-wrap
msgid "IFF_NOTRAILERS:Avoid use of trailers.\n"
msgstr "IFF_NOTRAILERS:trailer の利用を避ける。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:115
#, no-wrap
msgid "IFF_ALLMULTI:Receive all multicast packets.\n"
msgstr "IFF_ALLMULTI:全てのマルチキャストパケットを受信する。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:116
#, no-wrap
msgid "IFF_MASTER:Master of a load balancing bundle.\n"
msgstr "IFF_MASTER:負荷分散グループのマスターである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:117
#, no-wrap
msgid "IFF_SLAVE:Slave of a load balancing bundle.\n"
msgstr "IFF_SLAVE:負荷分散グループのスレーブである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:118
#, no-wrap
msgid "IFF_MULTICAST:Supports multicast\n"
msgstr "IFF_MULTICAST:マルチキャストをサポートしている。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:119
#, no-wrap
msgid "IFF_PORTSEL:Is able to select media type via ifmap.\n"
msgstr "IFF_PORTSEL:ifmap によってメディアタイプを選択できる。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:120
#, no-wrap
msgid "IFF_AUTOMEDIA:Auto media selection active.\n"
msgstr "IFF_AUTOMEDIA:自動メディア選択が有効になっている。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:121
#, no-wrap
msgid "IFF_DYNAMIC:T{\n"
msgstr "IFF_DYNAMIC:T{\n"

#. type: tbl table
#: build/C/man7/netdevice.7:122
#, no-wrap
msgid "The addresses are lost when the interface goes down.\n"
msgstr "このインターフェースが閉じると、アドレスは失われる。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:124
#, no-wrap
msgid "IFF_LOWER_UP:Driver signals L1 up (since Linux 2.6.17)\n"
msgstr "IFF_LOWER_UP:ドライバからの L1 アップの通知 (Linux 2.6.17 以降)\n"

#. type: tbl table
#: build/C/man7/netdevice.7:125
#, no-wrap
msgid "IFF_DORMANT:Driver signals dormant (since Linux 2.6.17)\n"
msgstr "IFF_DORMANT:ドライバからの休止状態の通知 (Linux 2.6.17 以降)\n"

#. type: tbl table
#: build/C/man7/netdevice.7:126
#, no-wrap
msgid "IFF_ECHO:Echo sent packets (since Linux 2.6.25)\n"
msgstr "IFF_ECHO:送られたパケットをエコーする (Linux 2.6.25 以降)\n"

#. type: Plain text
#: build/C/man7/netdevice.7:132
msgid ""
"Setting the active flag word is a privileged operation, but any process may "
"read it."
msgstr ""
"active フラグワードの設定は特権が必要な操作である。\n"
"読み出しはどんなプロセスからも可能である。"

#. type: TP
#: build/C/man7/netdevice.7:132
#, no-wrap
msgid "B<SIOCGIFPFLAGS>, B<SIOCSIFPFLAGS>"
msgstr "B<SIOCGIFPFLAGS>, B<SIOCSIFPFLAGS>"

#. type: Plain text
#: build/C/man7/netdevice.7:137
msgid ""
"Get or set extended (private) flags for the device.  I<ifr_flags> contains a "
"bit mask of the following values:"
msgstr ""
"デバイスの拡張 (プライベート) フラグを取得または設定する。\n"
"I<ifr_flags> には以下の値のビットマスクが入る。"

#. type: tbl table
#: build/C/man7/netdevice.7:141
#, no-wrap
msgid "Private flags\n"
msgstr "プライベートフラグ\n"

#. type: tbl table
#: build/C/man7/netdevice.7:142
#, no-wrap
msgid "IFF_802_1Q_VLAN:Interface is 802.1Q VLAN device.\n"
msgstr "IFF_802_1Q_VLAN:インターフェースは 802.1Q VLAN デバイスである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:143
#, no-wrap
msgid "IFF_EBRIDGE:Interface is Ethernet bridging device.\n"
msgstr "IFF_EBRIDGE:インターフェースは Ethernet ブリッジデバイスである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:144
#, no-wrap
msgid "IFF_SLAVE_INACTIVE:Interface is inactive bonding slave.\n"
msgstr "IFF_SLAVE_INACTIVE:インターフェースは非アクティブな bonding のスレーブである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:145
#, no-wrap
msgid "IFF_MASTER_8023AD:Interface is 802.3ad bonding master.\n"
msgstr "IFF_MASTER_8023AD:インターフェースは 802.3ad bonding のマスターである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:146
#, no-wrap
msgid "IFF_MASTER_ALB:Interface is balanced-alb bonding master.\n"
msgstr "IFF_MASTER_ALB:インターフェースは balanced-alb bonding のマスターである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:147
#, no-wrap
msgid "IFF_BONDING:Interface is a bonding master or slave.\n"
msgstr "IFF_BONDING:インターフェースは bonding のマスターかスレーブである。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:148
#, no-wrap
msgid "IFF_SLAVE_NEEDARP:Interface needs ARPs for validation.\n"
msgstr "IFF_SLAVE_NEEDARP:インターフェースは検証に APR が必要である。\n"

#. type: tbl table
#: build/C/man7/netdevice.7:149
#, no-wrap
msgid "IFF_ISATAP:Interface is RFC4214 ISATAP interface.\n"
msgstr "IFF_ISATAP:インターフェースは RFC4214 ISATAP インターフェースである。\n"

#. type: Plain text
#: build/C/man7/netdevice.7:153
msgid ""
"Setting the extended (private) interface flags is a privileged operation."
msgstr "拡張 (プライベート) インターフェースフラグの設定には特権が必要である。"

#. type: TP
#: build/C/man7/netdevice.7:153
#, no-wrap
msgid "B<SIOCGIFADDR>, B<SIOCSIFADDR>"
msgstr "B<SIOCGIFADDR>, B<SIOCSIFADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:161
msgid ""
"Get or set the address of the device using I<ifr_addr>.  Setting the "
"interface address is a privileged operation.  For compatibility, only "
"B<AF_INET> addresses are accepted or returned."
msgstr ""
"I<ifr_addr> を用いてデバイスのアドレスの設定/取得を行う。\n"
"インターフェースのアドレスの設定は特権が必要な操作である。\n"
"互換性確保のため、設定/取得ができるのは B<AF_INET> アドレスだけである。"

#. type: TP
#: build/C/man7/netdevice.7:161
#, no-wrap
msgid "B<SIOCGIFDSTADDR>, B<SIOCSIFDSTADDR>"
msgstr "B<SIOCGIFDSTADDR>, B<SIOCSIFDSTADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:169
msgid ""
"Get or set the destination address of a point-to-point device using "
"I<ifr_dstaddr>.  For compatibility, only B<AF_INET> addresses are accepted "
"or returned.  Setting the destination address is a privileged operation."
msgstr ""
"point-to-point デバイスの宛先アドレスを I<ifr_dstaddr> を用いて\n"
"設定/取得する。互換性確保のため、\n"
"設定/取得ができるのは B<AF_INET> アドレスだけである。\n"
"宛先アドレスの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:169
#, no-wrap
msgid "B<SIOCGIFBRDADDR>, B<SIOCSIFBRDADDR>"
msgstr "B<SIOCGIFBRDADDR>, B<SIOCSIFBRDADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:177
msgid ""
"Get or set the broadcast address for a device using I<ifr_brdaddr>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the broadcast address is a privileged operation."
msgstr ""
"デバイスのブロードキャストアドレスを I<ifr_brdaddr> を用いて\n"
"設定/取得する。互換性確保のため、\n"
"設定/取得ができるのは B<AF_INET> アドレスだけである。\n"
"ブロードキャストアドレスの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:177
#, no-wrap
msgid "B<SIOCGIFNETMASK>, B<SIOCSIFNETMASK>"
msgstr "B<SIOCGIFNETMASK>, B<SIOCSIFNETMASK>"

#. type: Plain text
#: build/C/man7/netdevice.7:185
msgid ""
"Get or set the network mask for a device using I<ifr_netmask>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the network mask is a privileged operation."
msgstr ""
"デバイスのネットワークマスクを I<ifr_netmask> を用いて\n"
"設定/取得する。互換性確保のため、\n"
"設定/取得ができるのは B<AF_INET> アドレスだけである。\n"
"ネットワークマスクの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:185
#, no-wrap
msgid "B<SIOCGIFMETRIC>, B<SIOCSIFMETRIC>"
msgstr "B<SIOCGIFMETRIC>, B<SIOCSIFMETRIC>"

#. type: Plain text
#: build/C/man7/netdevice.7:194
msgid ""
"Get or set the metric of the device using I<ifr_metric>.  This is currently "
"not implemented; it sets I<ifr_metric> to 0 if you attempt to read it and "
"returns B<EOPNOTSUPP> if you attempt to set it."
msgstr ""
"デバイスのメトリックを I<ifr_metric> を用いて取得・設定する。 これはまだ実装"
"されていない。読み出そうとすると I<ifr_metric> に 0 をセットして返り、設定し"
"ようとすると B<EOPNOTSUPP> が返る。"

#. type: TP
#: build/C/man7/netdevice.7:194
#, no-wrap
msgid "B<SIOCGIFMTU>, B<SIOCSIFMTU>"
msgstr "B<SIOCGIFMTU>, B<SIOCSIFMTU>"

#. type: Plain text
#: build/C/man7/netdevice.7:201
msgid ""
"Get or set the MTU (Maximum Transfer Unit) of a device using I<ifr_mtu>.  "
"Setting the MTU is a privileged operation.  Setting the MTU to too small "
"values may cause kernel crashes."
msgstr ""
"デバイスの MTU (Maximum Transfer Unit) を I<ifr_mtu> を用いて取得・設定す"
"る。 MTU の設定は特権が必要な操作である。 MTU の値を小さくしすぎるとカーネル"
"がクラッシュするかもしれない。"

#. type: TP
#: build/C/man7/netdevice.7:201
#, no-wrap
msgid "B<SIOCGIFHWADDR>, B<SIOCSIFHWADDR>"
msgstr "B<SIOCGIFHWADDR>, B<SIOCSIFHWADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:212
msgid ""
"Get or set the hardware address of a device using I<ifr_hwaddr>.  The "
"hardware address is specified in a struct I<sockaddr>.  I<sa_family> "
"contains the ARPHRD_* device type, I<sa_data> the L2 hardware address "
"starting from byte 0.  Setting the hardware address is a privileged "
"operation."
msgstr ""
"デバイスのハードウェアアドレスを I<ifr_hwaddr> を用いて取得・設定する。 ハー"
"ドウェアアドレスは I<sockaddr> 構造体に設定される。 I<sa_family> には "
"ARPHRD_* デバイスタイプが入り、 I<sa_data> にはバイト 0 から始まる L2 ハード"
"ウェアアドレスが入る。 ハードウェアアドレスの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:212
#, no-wrap
msgid "B<SIOCSIFHWBROADCAST>"
msgstr "B<SIOCSIFHWBROADCAST>"

#. type: Plain text
#: build/C/man7/netdevice.7:217
msgid ""
"Set the hardware broadcast address of a device from I<ifr_hwaddr>.  This is "
"a privileged operation."
msgstr ""
"デバイスのハードウェアブロードキャストアドレスを I<ifr_hwaddr> の値に設定す"
"る。この操作には特権が必要である。"

#. type: TP
#: build/C/man7/netdevice.7:217
#, no-wrap
msgid "B<SIOCGIFMAP>, B<SIOCSIFMAP>"
msgstr "B<SIOCGIFMAP>, B<SIOCSIFMAP>"

#. type: Plain text
#: build/C/man7/netdevice.7:222
msgid ""
"Get or set the interface's hardware parameters using I<ifr_map>.  Setting "
"the parameters is a privileged operation."
msgstr ""
"インターフェースのハードウェアのパラメータを I<ifr_map> を用いて取得・設定す"
"る。 パラメータの設定は特権が必要な操作である。"

#. type: Plain text
#: build/C/man7/netdevice.7:233
#, no-wrap
msgid ""
"struct ifmap {\n"
"    unsigned long   mem_start;\n"
"    unsigned long   mem_end;\n"
"    unsigned short  base_addr;\n"
"    unsigned char   irq;\n"
"    unsigned char   dma;\n"
"    unsigned char   port;\n"
"};\n"
msgstr ""
"struct ifmap {\n"
"    unsigned long   mem_start;\n"
"    unsigned long   mem_end;\n"
"    unsigned short  base_addr;\n"
"    unsigned char   irq;\n"
"    unsigned char   dma;\n"
"    unsigned char   port;\n"
"};\n"

#. type: Plain text
#: build/C/man7/netdevice.7:238
msgid ""
"The interpretation of the ifmap structure depends on the device driver and "
"the architecture."
msgstr "ifmap 構造体の解釈はデバイスドライバとアーキテクチャに依存する。"

#. type: TP
#: build/C/man7/netdevice.7:238
#, no-wrap
msgid "B<SIOCADDMULTI>, B<SIOCDELMULTI>"
msgstr "B<SIOCADDMULTI>, B<SIOCDELMULTI>"

#. type: Plain text
#: build/C/man7/netdevice.7:247
msgid ""
"Add an address to or delete an address from the device's link layer "
"multicast filters using I<ifr_hwaddr>.  These are privileged operations.  "
"See also B<packet>(7)  for an alternative."
msgstr ""
"デバイスのリンク層のマルチキャストフィルターから、 I<ifr_hwaddr> のアドレスを"
"追加・削除する。これらの操作には特権が必要である。 別の方法が B<packet>(7)  "
"で解説されている。"

#. type: TP
#: build/C/man7/netdevice.7:247
#, no-wrap
msgid "B<SIOCGIFTXQLEN>, B<SIOCSIFTXQLEN>"
msgstr "B<SIOCGIFTXQLEN>, B<SIOCSIFTXQLEN>"

#. type: Plain text
#: build/C/man7/netdevice.7:252
msgid ""
"Get or set the transmit queue length of a device using I<ifr_qlen>.  Setting "
"the transmit queue length is a privileged operation."
msgstr ""
"デバイスの送信キューの長さを I<ifr_qlen> に取得・設定する。送信キューの長さの"
"設定には特権が必要である。"

#. type: TP
#: build/C/man7/netdevice.7:252
#, no-wrap
msgid "B<SIOCSIFNAME>"
msgstr "B<SIOCSIFNAME>"

#. type: Plain text
#: build/C/man7/netdevice.7:261
msgid ""
"Changes the name of the interface specified in I<ifr_name> to "
"I<ifr_newname>.  This is a privileged operation.  It is allowed only when "
"the interface is not up."
msgstr ""
"I<ifr_name> で指定したインターフェースの名前を I<ifr_newname> に変更する。こ"
"の操作には特権が必要である。インターフェースが up していない 時にのみ使用でき"
"る。"

#. type: TP
#: build/C/man7/netdevice.7:261
#, no-wrap
msgid "B<SIOCGIFCONF>"
msgstr "B<SIOCGIFCONF>"

#.  Slaving isn't supported in 2.2
#.  .
#.  .TP
#.  .BR SIOCGIFSLAVE ", " SIOCSIFSLAVE
#.  Get or set the slave device using
#.  .IR ifr_slave .
#.  Setting the slave device is a privileged operation.
#.  .PP
#.  FIXME add amateur radio stuff.
#. type: Plain text
#: build/C/man7/netdevice.7:301
msgid ""
"Return a list of interface (transport layer) addresses.  This currently "
"means only addresses of the B<AF_INET> (IPv4) family for compatibility.  The "
"user passes a I<ifconf> structure as argument to the ioctl.  It contains a "
"pointer to an array of I<ifreq> structures in I<ifc_req> and its length in "
"bytes in I<ifc_len>.  The kernel fills the ifreqs with all current L3 "
"interface addresses that are running: I<ifr_name> contains the interface "
"name (eth0:1 etc.), I<ifr_addr> the address.  The kernel returns with the "
"actual length in I<ifc_len>.  If I<ifc_len> is equal to the original length "
"the buffer probably has overflowed and you should retry with a bigger buffer "
"to get all addresses.  When no error occurs the ioctl returns 0; otherwise "
"-1.  Overflow is not an error."
msgstr ""
"インターフェース(トランスポート層)アドレスのリストを返す。 現在のところ、互換"
"性のために B<AF_INET> (IPv4) ファミリーのアドレスのみである。 ユーザーは "
"I<ifconf> 構造体を ioctl の引数として渡す。 I<ifconf> 構造体には、 I<ifreq> "
"構造体の配列へのポインタである I<ifc_req> と、バイト単位の配列の長さを指定す"
"る I<ifc_len> が含まれる。 カーネルは ifreqs を現在動作している全ての L3 イン"
"ターフェースアドレスで埋める。 I<ifr_name> にはインターフェース名 (eth0:1 な"
"ど) が入り、 I<ifr_addr> にはアドレスが入る。 カーネルは実際の長さを "
"I<ifc_len> に返す。 I<ifc_len> が元のバッファの長さと同じだった場合、 オー"
"バーフローを起こしている可能性があるので、 全てのアドレスを取得するためにより"
"大きなバッファで再試行するべきである。 エラーがなかった場合は ioctl は 0 を返"
"す。 エラーがあった場合は -1 を返す。 オーバーフローはエラーとは見なされな"
"い。"

#. type: Plain text
#: build/C/man7/netdevice.7:307
msgid ""
"Most protocols support their own ioctls to configure protocol-specific "
"interface options.  See the protocol man pages for a description.  For "
"configuring IP addresses see B<ip>(7)."
msgstr ""
"ほとんどのプロトコルには、専用のインターフェースオプションを 設定するための独"
"自の ioctl が存在する。 説明は各プロトコルの man ページを見よ。"

#. type: Plain text
#: build/C/man7/netdevice.7:310
msgid ""
"In addition some devices support private ioctls.  These are not described "
"here."
msgstr ""
"さらに、デバイスによってはプライベートな ioctl がある。 これらはここでは説明"
"しない。"

#. type: Plain text
#: build/C/man7/netdevice.7:318
msgid ""
"Strictly speaking, B<SIOCGIFCONF> and the other ioctls that accept or return "
"only B<AF_INET> socket addresses, are IP specific and belong in B<ip>(7)."
msgstr ""
"厳密にいうと、 B<SIOCGIFCONF> や、 B<AF_INET> ソケットアドレスだけを\n"
"引き数に取ったり返したりする他の ioctl は IP 固有であり、 B<ip>(7) \n"
"に属する。"

#. type: Plain text
#: build/C/man7/netdevice.7:323
msgid ""
"The names of interfaces with no addresses or that don't have the "
"B<IFF_RUNNING> flag set can be found via I</proc/net/dev>."
msgstr ""
"アドレスがなかったり、 B<IFF_RUNNING> フラグがセットされていないインター"
"フェースの名前は I</proc/net/dev> で知ることができる。"

#. type: Plain text
#: build/C/man7/netdevice.7:328
msgid ""
"Local IPv6 IP addresses can be found via I</proc/net> or via B<rtnetlink>(7)."
msgstr ""
"ローカル IPV6 IP アドレスは I</proc/net> か B<rtnetlink>(7)  で知ることができ"
"る。"

#. type: Plain text
#: build/C/man7/netdevice.7:334
msgid ""
"glibc 2.1 is missing the I<ifr_newname> macro in I<E<lt>net/if.hE<gt>>.  Add "
"the following to your program as a workaround:"
msgstr ""
"glibc 2.1 では I<E<lt>net/if.hE<gt>> に I<ifr_newname> マクロがない。 とりあ"
"えずの対応策として、以下のコードを追加しておくこと。"

#. type: Plain text
#: build/C/man7/netdevice.7:340
#, no-wrap
msgid ""
"#ifndef ifr_newname\n"
"#define ifr_newname     ifr_ifru.ifru_slave\n"
"#endif\n"
msgstr ""
"#ifndef ifr_newname\n"
"#define ifr_newname     ifr_ifru.ifru_slave\n"
"#endif\n"

#. type: Plain text
#: build/C/man7/netdevice.7:347
msgid "B<proc>(5), B<capabilities>(7), B<ip>(7), B<rtnetlink>(7)"
msgstr "B<proc>(5), B<capabilities>(7), B<ip>(7), B<rtnetlink>(7)"

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "NETWORKS"
msgstr "NETWORKS"

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "2008-09-04"
msgstr "2008-09-04"

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "GNU/Linux"
msgstr "GNU/Linux"

#. type: Plain text
#: build/C/man5/networks.5:29
msgid "networks - network name information"
msgstr "networks - ネットワーク名の情報"

#. type: Plain text
#: build/C/man5/networks.5:35
msgid ""
"The file I</etc/networks> is a plain ASCII file that describes known DARPA "
"networks and symbolic names for these networks.  Each line represents a "
"network and has the following structure:"
msgstr ""
"I</etc/networks> ファイルは、通常の ASCII ファイルで、よく使われる\n"
"DARPA ネットワークとその分かりやすい名前を記載したファイルである。\n"
"各行が一つのネットワークを表し、以下の構造となっている。"

#. type: Plain text
#: build/C/man5/networks.5:38
msgid "I<name number aliases ...>"
msgstr "I<name number aliases ...>"

#. type: Plain text
#: build/C/man5/networks.5:46
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"The hash character (B<#>) indicates the start of a comment: this character, "
"and the remaining characters up to the end of the current line, are ignored "
"by library functions that process the file."
msgstr ""
"フィールドはスペースかタブで区切られる。空行は無視される。\n"
"ハッシュ文字 (B<#>) はコメントの開始を示し、このファイルを処理する\n"
"ライブラリ関数はこの文字とその行のそれ以降の文字を無視する。"

#. type: Plain text
#: build/C/man5/networks.5:48 build/C/man5/protocols.5:59
msgid "The field descriptions are:"
msgstr "フィールドの説明は以下のとおり。"

#. type: TP
#: build/C/man5/networks.5:48
#, no-wrap
msgid "I<name>"
msgstr "I<name>"

#. type: Plain text
#: build/C/man5/networks.5:53
msgid ""
"The symbolic name for the network.  Network names can contain any printable "
"characters execept white-space characters or the comment character."
msgstr ""
"ネットワークの分かりやすい名前 (symbolic name)。\n"
"ネットワーク名には、ホワイトスペースとコメント文字以外の\n"
"印字可能な文字を使うことができる。"

#. type: TP
#: build/C/man5/networks.5:53 build/C/man5/protocols.5:67
#, no-wrap
msgid "I<number>"
msgstr "I<number>"

#. type: Plain text
#: build/C/man5/networks.5:58
msgid ""
"The official number for this network in numbers-and-dots notation (see "
"B<inet>(3)).  The trailing \".0\" (for the host component of the network "
"address) may be omitted."
msgstr ""
"このネットワークの正式な数字での値。\n"
"ドット区切りの数字表記 (B<inet>(3) 参照) で記載する。\n"
"末尾の \".0\" (ネットワークアドレスのホスト部分) は省略してもよい。"

#. type: TP
#: build/C/man5/networks.5:58 build/C/man5/protocols.5:71
#: build/C/man5/services.5:120
#, no-wrap
msgid "I<aliases>"
msgstr "I<aliases>"

#. type: Plain text
#: build/C/man5/networks.5:61
msgid "Optional aliases for the network."
msgstr "そのネットワークの別名 (省略可能)。"

#. type: Plain text
#: build/C/man5/networks.5:70
msgid ""
"This file is read by the B<route>(8)  and B<netstat>(8)  utilities.  Only "
"Class A, B or C networks are supported, partitioned networks (i.e., "
"network/26 or network/28) are not supported by this facility."
msgstr ""
"このファイルは、 B<route>(8) と B<netstat>(8) ユーティリティにより\n"
"利用される。クラス A, B, C のネットワークだけがサポートされており、\n"
"(network/26 や network/28 といった) 分割されたネットワークは\n"
"このファイルではサポートされていない。"

#. type: Plain text
#: build/C/man5/networks.5:74
msgid "The networks definition file."
msgstr "ネットワーク定義ファイル。"

#. type: Plain text
#: build/C/man5/networks.5:80
msgid ""
"B<getnetbyaddr>(3), B<getnetbyname>(3), B<getnetent>(3), B<netstat>(8), "
"B<route>(8)"
msgstr ""
"B<getnetbyaddr>(3), B<getnetbyname>(3), B<getnetent>(3), B<netstat>(8), "
"B<route>(8)"

#. type: TH
#: build/C/man8/nscd.8:23
#, no-wrap
msgid "NSCD"
msgstr "NSCD"

#. type: Plain text
#: build/C/man8/nscd.8:26
msgid "nscd - name service cache daemon"
msgstr "nscd - ネームサービスキャッシュデーモン"

#. type: Plain text
#: build/C/man8/nscd.8:34
msgid ""
"Nscd is a daemon that provides a cache for the most common name service "
"requests.  The default configuration file, I</etc/nscd.conf>, determines the "
"behavior of the cache daemon.  See B<nscd.conf>(5)."
msgstr ""
"nscd は一般的なネームサービスに必要な多くのものを キャッシュとして提供する"
"デーモンである。 デフォルトの設定ファイル I</etc/nscd.conf> でキャッシュデー"
"モンの動作を決定する。 B<nscd.conf>(5)  を見よ。"

#. type: Plain text
#: build/C/man8/nscd.8:47
msgid ""
"Nscd provides caching for accesses of the B<passwd>(5), B<group>(5), and "
"B<hosts>(5)  databases through standard libc interfaces, such as B<getpwnam>"
"(3), B<getpwuid>(3), B<getgrnam>(3), B<getgrgid>(3), B<gethostbyname>(3), "
"and others."
msgstr ""
"nscd は B<passwd>(5), B<group>(5), B<hosts>(5)  データベースへのアクセスの"
"キャッシュを B<getpwnam>(3), B<getpwuid>(3), B<getgrnam>(3), B<getgrgid>(3), "
"B<gethostbyname>(3)  などの標準 libc インターフェースを通して提供する。"

#. type: Plain text
#: build/C/man8/nscd.8:56
msgid ""
"There are two caches for each database: a positive one for items found, and "
"a negative one for items not found.  Each cache has a separate TTL (time-to-"
"live)  period for its data.  Note that the shadow file is specifically not "
"cached.  B<getspnam>(3)  calls remain uncached as a result."
msgstr ""
"各データベースには 2 つのキャッシュがある。 肯定的 (positive) なキャッシュは"
"見つかったアイテムをキャッシュし、 否定的 (negative) なキャッシュは見つからな"
"かったアイテムをキャッシュする。 各キャッシュはデータの TTL (time-to-live, 生"
"存時間) を個別に持っている。 特例として shadow ファイルはキャッシュされない点"
"に注意すること。 B<getspnam>(3)  を呼び出しても結果としてキャッシュされないま"
"まになる。"

#. type: SH
#: build/C/man8/nscd.8:56
#, no-wrap
msgid "OPTIONS"
msgstr "オプション"

#. type: TP
#: build/C/man8/nscd.8:57
#, no-wrap
msgid "B<--help>"
msgstr "B<--help>"

#. type: Plain text
#: build/C/man8/nscd.8:60
msgid "will give you a list with all options and what they do."
msgstr "全てのオプションとその動作をリストして表示する。"

#. type: Plain text
#: build/C/man8/nscd.8:83
msgid ""
"The daemon will try to watch for changes in configuration files appropriate "
"for each database (e.g., I</etc/passwd> for the I<passwd> database or I</etc/"
"hosts> and I</etc/resolv.conf> for the I<hosts> database), and flush the "
"cache when these are changed.  However, this will happen only after a short "
"delay (unless the B<inotify>(7)  mechanism is available and glibc 2.9 or "
"later is available), and this auto-detection does not cover configuration "
"files required by nonstandard NSS modules, if any are specified in I</etc/"
"nsswitch.conf>.  In that case, you need to run the following command after "
"changing the configuration file of the database so that B<nscd> invalidates "
"its cache:"
msgstr ""
"デーモンは( I<passwd> データベースについては I</etc/passwd>、 I<hosts> データ"
"ベースについては I</etc/hosts> と I</etc/resolv.conf> というような)それぞれの"
"データベースのための設定ファイルを見張って、 これらが変更されるとキャッシュを"
"フラッシュする。 しかし、これは( B<inotify>(7)  が利用可能で、glibc 2.9 以降"
"が利用可能な場合を除いて)  短い遅延の後に起こり、またこの自動検出は非標準 "
"NSS モジュールが I</etc/nsswitch.conf> で指定されている場合はその設定ファイル"
"には対応しない。 この場合、データベースの設定ファイルを変更した後、 B<nscd> "
"のキャッシュを無効にするために以下のコマンドを実行する必要がある:"

#. type: Plain text
#: build/C/man8/nscd.8:85
#, no-wrap
msgid "    $ B<nscd -i> I<E<lt>databaseE<gt>>\n"
msgstr "    $ B<nscd -i> I<E<lt>databaseE<gt>>\n"

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man8/nscd.8:91
msgid "B<nscd.conf>(5), B<nsswitch.conf>(5)"
msgstr "B<nscd.conf>(5), B<nsswitch.conf>(5)"

#. type: TH
#: build/C/man5/nscd.conf.5:20
#, no-wrap
msgid "NSCD.CONF"
msgstr "NSCD.CONF"

#. type: Plain text
#: build/C/man5/nscd.conf.5:23
msgid "/etc/nscd.conf - name service cache daemon configuration file"
msgstr "/etc/nscd.conf - ネームサービスキャッシュデーモンの設定ファイル"

#. type: Plain text
#: build/C/man5/nscd.conf.5:36
msgid ""
"The file I</etc/nscd.conf> is read from B<nscd>(8)  at startup.  Each line "
"specifies either an attribute and a value, or an attribute, service, and a "
"value.  Fields are separated either by SPACE or TAB characters.  A \\(aq#"
"\\(aq (number sign) indicates the beginning of a comment; following "
"characters, up to the end of the line, are not interpreted by nscd."
msgstr ""
"B<nscd>(8)  は起動時にファイル I</etc/nscd.conf> を読み込む。 各行には「属"
"性・値」または「属性・サービス・値」を指定する。 フィールドはスペース文字また"
"はタブ文字で区切られる。 \\(aq#\\(aq (ナンバー記号) はコメントの始まりを表"
"す。 この記号から行末までは nscd によって解釈されない。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:39
msgid ""
"Valid services are I<passwd>, I<group>, I<hosts>, I<services> or I<netgroup>."
msgstr ""
"指定可能なサービスは I<passwd>, I<group>, I<hosts>, I<services>, I<netgroup> "
"である。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:42
msgid "B<logfile> I<debug-file-name>"
msgstr "B<logfile> I<debug-file-name>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:44
msgid "Specifies name of the file to which debug info should be written."
msgstr "デバッグ情報が書き込まれるファイルの名前を指定する。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:48
msgid "B<debug-level> I<value>"
msgstr "B<debug-level> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:51
msgid "Sets the desired debug level.  The default is 0."
msgstr "希望するデバッグレベルを設定する。デフォルトは 0。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:55
msgid "B<threads> I<number>"
msgstr "B<threads> I<number>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:59
msgid ""
"This is the number of threads that are started to wait for requests.  At "
"least five threads will always be created."
msgstr ""
"スレッドをいくつ起動してリクエストを待つのかを指定する。 少なくとも 5 つのス"
"レッドが常に作成される。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:63
msgid "B<max-threads> I<number>"
msgstr "B<max-threads> I<number>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:66
msgid "Specifies the maximum number of threads.  The default is 32."
msgstr "スレッドの最大数を指定する。デフォルトは 32。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:70
msgid "B<server-user> I<user>"
msgstr "B<server-user> I<user>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:74
msgid ""
"If this option is set, nscd will run as this user and not as root.  If a "
"separate cache for every user is used (-S parameter), this option is ignored."
msgstr ""
"このオプションが設定されると、 nscd は root ではなく、この user として実行さ"
"れる。 (-S パラメータにより) 各ユーザー毎に別々のキャッシュが使われる場合、 "
"このオプションは無視される。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:78
msgid "B<stat-user> I<user>"
msgstr "B<stat-user> I<user>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:80
msgid "Specifies the user who is allowed to request statistics."
msgstr "統計情報の参照を許可するユーザを指定する。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:85
msgid "B<reload-count> unlimited | I<number>"
msgstr "B<reload-count> unlimited | I<number>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:89
msgid ""
"Limit on the number of times a cached entry gets reloaded without being used "
"before it gets removed.  The default is 5."
msgstr ""
"キャッシュされたエントリが使用されなかったときに、 削除される前に何回リロード"
"されるかを設定する。デフォルトは 5。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:93
msgid "B<paranoia> I<E<lt>yes|noE<gt>>"
msgstr "B<paranoia> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:96
msgid ""
"Enabling paranoia mode causes nscd to restart itself periodically.  The "
"default is no."
msgstr ""
"パラノイアモードを有効にする。 パラノイアモードでは nscd を定期的に再起動す"
"る。デフォルトは無効。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:100
msgid "B<restart-interval> I<time>"
msgstr "B<restart-interval> I<time>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:108
msgid ""
"Sets the restart interval to I<time> seconds if periodic restart is enabled "
"by enabling B<paranoia> mode.  The default is 3600."
msgstr ""
"パラノイアモードが有効で定期的に再起動する場合の、 再起動間隔を I<time> 秒に"
"設定する。デフォルトは 3600。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:113
msgid "B<enable-cache> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<enable-cache> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:118
msgid "Enables or disables the specified I<service> cache.  The default is no."
msgstr ""
"指定した I<service> のキャッシュを有効または無効にする。デフォルトは無効。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:123
msgid "B<positive-time-to-live> I<service> I<value>"
msgstr "B<positive-time-to-live> I<service> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:131
msgid ""
"Sets the TTL (time-to-live) for positive entries (successful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Larger values "
"increase cache hit rates and reduce mean response times, but increase "
"problems with cache coherence."
msgstr ""
"指定した I<service> のキャッシュにあるポジティブエントリ (成功した問い合わ"
"せ) の TTL (time-to-live) を設定する。 I<value> の単位は秒である。 値を大きく"
"すると、ヒット率が高くなり平均応答時間を短くできるが、 キャッシュのコヒーレン"
"ス (coherence, キャッシュが実際のデータと一致していること) に問題が生じる。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:136
msgid "B<negative-time-to-live> I<service> I<value>"
msgstr "B<negative-time-to-live> I<service> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:146
msgid ""
"Sets the TTL (time-to-live) for negative entries (unsuccessful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Can result in "
"significant performance improvements if there are several files owned by "
"UIDs (user IDs) not in system databases (for example untarring the Linux "
"kernel sources as root); should be kept small to reduce cache coherency "
"problems."
msgstr ""
"指定した I<service> のキャッシュにあるネガティブエントリ (失敗した問い合わ"
"せ) の TTL (time-to-live) を設定する。 I<value> の単位は秒である。 システム"
"データベースにない UID (ユーザーID) で所有されるファイル (たとえば root で "
"tar を展開した Linux カーネルのソース) が少ないと、 顕著な性能の向上が見られ"
"る。 キャッシュのコヒーレンス問題を少なくするために小さな値にすべきである。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:151
msgid "B<suggested-size> I<service> I<value>"
msgstr "B<suggested-size> I<service> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:156
msgid ""
"This is the internal hash table size, I<value> should remain a prime number "
"for optimum efficiency.  The default is 211."
msgstr ""
"内部ハッシュテーブルの大きさを指定する。 効率を最適にするために I<value> は素"
"数にしておくべきである。デフォルトは 211 である。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:161
msgid "B<check-files> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<check-files> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:173
msgid ""
"Enables or disables checking the file belonging to the specified I<service> "
"for changes.  The files are I</etc/passwd>, I</etc/group>, I</etc/hosts>, I</"
"etc/services> and I</etc/netgroup>.  The default is yes."
msgstr ""
"指定した I<service> に関連するファイルの変更のチェックを有効または無効にす"
"る。 ファイルは I</etc/passwd>, I</etc/group>, I</etc/hosts> である。デフォル"
"トは有効。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:178
msgid "B<persistent> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<persistent> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:185
msgid ""
"Keep the content of the cache for I<service> over server restarts; useful "
"when B<paranoia> mode is set.  The default is no."
msgstr ""
"サーバの再起動の前後で I<service> のキャッシュ内容を保持する。 B<paranoia> "
"モードが有効の場合に便利である。デフォルトは保持しない。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:190
msgid "B<shared> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<shared> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:197
msgid ""
"The memory mapping of the nscd databases for I<service> is shared with the "
"clients so that they can directly search in them instead of having to ask "
"the daemon over the socket each time a lookup is performed.  The default is "
"no."
msgstr ""
"I<service> の nscd データベースのメモリ・マッピングをクライアント間で共有す"
"る。 これにより、検索を実行する度にソケット経由でデーモンに問い合わせを 行わ"
"ずに、直接データベースを検索できるようになる。デフォルトは共有しない。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:202
msgid "B<max-db-size> I<service> I<bytes>"
msgstr "B<max-db-size> I<service> I<bytes>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:206
msgid ""
"The maximum allowable size, in bytes, of the database files for the "
"I<service>.  The default is 33554432."
msgstr ""
"I<service> のデータベースファイルの最大許容サイズ (バイト単位)。 デフォルト値"
"は 33554432 である。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:211
msgid "B<auto-propagate> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<auto-propagate> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:231
msgid ""
"When set to I<no> for I<passwd> or I<group> service, then the I<.byname> "
"requests are not added to I<passwd.byuid> or I<group.bygid> cache.  This can "
"help with tables containing multiple records for the same ID.  The default "
"is yes.  This option is valid only for services I<passwd> and I<group>."
msgstr ""
"サービス I<passwd> か I<group> で I<no> に設定すると、 I<.byname> 要求は "
"I<passwd.byuid> や I<group.bygid> のキャッシュに追加されない。 このオプション"
"は、 同じ ID を持つレコードが複数あるテーブルの場合に役に立つ。 デフォルトは "
"yes である。 このオプションはサービス I<passwd> と I<group> でのみ有効であ"
"る。"

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man5/nscd.conf.5:237
msgid "B<nscd>(8)"
msgstr "B<nscd>(8)"

#. type: TH
#: build/C/man5/nss.5:19
#, no-wrap
msgid "NSS"
msgstr "NSS"

#. type: Plain text
#: build/C/man5/nss.5:22
msgid "nss - Name Service Switch configuration file"
msgstr "nss - ネームサービススイッチの設定ファイル"

#. type: Plain text
#: build/C/man5/nss.5:29
msgid ""
"Each call to a function which retrieves data from a system database like the "
"password or group database is handled by the Name Service Switch "
"implementation in the GNU C library.  The various services provided are "
"implemented by independent modules, each of which naturally varies widely "
"from the other."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:38
msgid ""
"The default implementations coming with the GNU C library are by default "
"conservative and do not use unsafe data.  This might be very costly in some "
"situations, especially when the databases are large.  Some modules allow the "
"system administrator to request taking shortcuts if these are known to be "
"safe.  It is then the system administrator's responsibility to ensure the "
"assumption is correct."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:42
msgid ""
"There are other modules where the implementation changed over time.  If an "
"implementation used to sacrifice speed for memory consumption it might "
"create problems if the preference is switched."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:51
msgid ""
"The I</etc/default/nss> file contains a number of variable assignments.  "
"Each variable controls the behavior of one or more NSS modules.  White "
"spaces are ignored.  Lines beginning with \\(aq#\\(aq are treated as "
"comments."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:53
msgid "The variables currently recognized are:"
msgstr "現在のところ認識される変数は次の通り。"

#. type: TP
#: build/C/man5/nss.5:53
#, no-wrap
msgid "B<NETID_AUTHORITATIVE => I<TRUE>|I<FALSE>"
msgstr "B<NETID_AUTHORITATIVE => I<TRUE>|I<FALSE>"

#. type: Plain text
#: build/C/man5/nss.5:68
msgid ""
"If set to TRUE, the NIS backend for the B<initgroups>(3)  function will "
"accept the information from the I<netid.byname> NIS map as authoritative.  "
"This can speed up the function significantly if the I<group.byname> map is "
"large.  The content of the I<netid.byname> map is used B<as is>.  The system "
"administrator has to make sure it is correctly generated."
msgstr ""

#. type: TP
#: build/C/man5/nss.5:68
#, no-wrap
msgid "B<SERVICES_AUTHORITATIVE => I<TRUE>|I<FALSE>"
msgstr "B<SERVICES_AUTHORITATIVE => I<TRUE>|I<FALSE>"

#. type: Plain text
#: build/C/man5/nss.5:80
msgid ""
"If set to TRUE, the NIS backend for the B<getservbyname>(3)  and "
"B<getservbyname_r>(3)  functions will assume that the I<services."
"byservicename> NIS map exists and is authoritative, particularly that it "
"contains both keys with /proto and without /proto for both primary service "
"names and service aliases.  The system administrator has to make sure it is "
"correctly generated."
msgstr ""

#. type: TP
#: build/C/man5/nss.5:80
#, no-wrap
msgid "B<SETENT_BATCH_READ => I<TRUE>|I<FALSE>"
msgstr "B<SETENT_BATCH_READ => I<TRUE>|I<FALSE>"

#. type: Plain text
#: build/C/man5/nss.5:98
msgid ""
"If set to TRUE, the NIS backend for the B<setpwent>(3)  and B<setgrent>(3)  "
"functions will read the entire database at once and then hand out the "
"requests one by one from memory with every corresponding B<getpwent>(3)  or "
"B<getgrent>(3)  call respectively.  Otherwise each B<getpwent>(3)  or "
"B<getgrent>(3)  call might result in a network communication with the server "
"to get the next entry."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:100
msgid "I</etc/default/nss>"
msgstr "I</etc/default/nss>"

#. type: Plain text
#: build/C/man5/nss.5:102
msgid ""
"The default configuration corresponds to the following configuration file:"
msgstr "デフォルト設定は、 以下の設定ファイルと同じである。"

#.  .SH AUTHOR
#.  Ulrich Drepper <drepper@redhat.com>
#. type: Plain text
#: build/C/man5/nss.5:110
#, no-wrap
msgid ""
"NETID_AUTHORITATIVE=FALSE\n"
"SERVICES_AUTHORITATIVE=FALSE\n"
"SETENT_BATCH_READ=FALSE\n"
msgstr ""
"NETID_AUTHORITATIVE=FALSE\n"
"SERVICES_AUTHORITATIVE=FALSE\n"
"SETENT_BATCH_READ=FALSE\n"

#. type: Plain text
#: build/C/man5/nss.5:112
msgid "I<nsswitch.conf>"
msgstr "I<nsswitch.conf>"

#. type: TH
#: build/C/man5/nsswitch.conf.5:25
#, no-wrap
msgid "NSSWITCH.CONF"
msgstr "NSSWITCH.CONF"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:28
msgid "nsswitch.conf - Name Service Switch configuration file"
msgstr "nsswitch.conf - ネームサービススイッチの設定ファイル"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:36
msgid ""
"The Name Service Switch (NSS) configuration file, I</etc/nsswitch.conf>, is "
"used by the GNU C Library to determine the sources from which to obtain name-"
"service information in a range of categories, and in what order.  Each "
"category of information is identified by a database name."
msgstr ""
"ネームサービススイッチ (Name Service Switch; NSS) の設定ファイル\n"
"I</etc/nsswitch.conf> は、 GNU C ライブラリが\n"
"いろいろなカテゴリの名前サービス情報を、どの情報源から\n"
"どの順序で取得するかを判断するのに使用される\n"
"(情報の各カテゴリはデータベース名で識別される)。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:42
msgid ""
"The file is plain ASCII text, with columns separated by spaces or tab "
"characters.  The first column specifies the database name.  The remaining "
"columns describe the order of sources to query and a limited set of actions "
"that can be performed by lookup result."
msgstr ""
"設定ファイルは通常の ASCII テキストで、列はスペースかタブ文字で\n"
"区切られる。最初の列はデータベース名を示す。\n"
"残りの列は、情報を問い合わせる情報源の順序と、\n"
"検索結果に対して実行するアクションを規定する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:44
msgid "The following databases are understood by the GNU C Library:"
msgstr "GNU C ライブラリでは以下のデータベースを扱うことができる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:49
msgid "Mail aliases, used by B<getaliasent>(3)  and related functions."
msgstr "メールのエイリアス。 B<getaliasent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:52
msgid "Ethernet numbers."
msgstr "イーサーネット番号。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:57
msgid "Groups of users, used by B<getgrent>(3)  and related functions."
msgstr "ユーザーのグループ。 B<getgrent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:62
msgid ""
"Host names and numbers, used by B<gethostbyname>(3)  and related functions."
msgstr "ホスト名とホスト番号。 B<gethostbyname>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:67
msgid "Supplementary group access list, used by B<getgrouplist>(3)  function."
msgstr "補助グループアクセスリスト。 B<getgrouplist>(3) 関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:71
msgid ""
"Network-wide list of hosts and users, used for access rules.  C libraries "
"before glibc 2.1 supported netgroups only over NIS."
msgstr ""
"ネットワークワイドに用いられるホストやユーザーのリスト。アクセス制限に利用\n"
"される。 glibc 2.1 より前の C ライブラリは、 NIS による netgroup のみを\n"
"サポートしていた。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:76
msgid ""
"Network names and numbers, used by B<getnetent>(3)  and related functions."
msgstr "ネットワーク名と番号。 B<getnetent>(3) と関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:81
msgid "User passwords, used by B<getpwent>(3)  and related functions."
msgstr "ユーザーパスワード。 B<getpwent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:86
msgid "Network protocols, used by B<getprotoent>(3)  and related functions."
msgstr "ネットワークプロトコル。 B<getprotoent>(3) や関連する関数が使用する。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:86
#, no-wrap
msgid "B<publickey>"
msgstr "B<publickey>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:89
msgid "Public and secret keys for Secure_RPC used by NFS and NIS+."
msgstr "NIS+ と NFS によって用いられる secure_rpc の公開鍵と秘密鍵。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:94
msgid ""
"Remote procedure call names and numbers, used by B<getrpcbyname>(3)  and "
"related functions."
msgstr ""
"リモート手続き呼び出し (remote procedure call) の名前と番号。 \n"
"B<getrpcbyname>(3) と関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:99
msgid "Network services, used by B<getservent>(3)  and related functions."
msgstr "ネットワークサービス。 B<getservent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:104
msgid "Shadow user passwords, used by B<getspnam>(3)  and related functions."
msgstr "シャドウユーザーパスワード。 B<getspnam>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:108
msgid "Here is an example I</etc/nsswitch.conf> file:"
msgstr "以下は I</etc/nsswitch.conf> ファイルの例である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:111
#, no-wrap
msgid "passwd:"
msgstr "passwd:"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:114 build/C/man5/nsswitch.conf.5:117
#: build/C/man5/nsswitch.conf.5:120
msgid "compat"
msgstr "compat"

#. type: TP
#: build/C/man5/nsswitch.conf.5:114
#, no-wrap
msgid "group:"
msgstr "group:"

#. type: TP
#: build/C/man5/nsswitch.conf.5:117
#, no-wrap
msgid "shadow:"
msgstr "shadow:"

#. type: TP
#: build/C/man5/nsswitch.conf.5:121
#, no-wrap
msgid "hosts:"
msgstr "hosts:"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:124
msgid "dns [!UNAVAIL=return] files"
msgstr "dns [!UNAVAIL=return] files"

#. type: TP
#: build/C/man5/nsswitch.conf.5:124
#, no-wrap
msgid "networks:"
msgstr "networks:"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:127 build/C/man5/nsswitch.conf.5:130
#: build/C/man5/nsswitch.conf.5:133 build/C/man5/nsswitch.conf.5:136
#: build/C/man5/nsswitch.conf.5:139
msgid "nis [NOTFOUND=return] files"
msgstr "nis [NOTFOUND=return] files"

#. type: TP
#: build/C/man5/nsswitch.conf.5:127
#, no-wrap
msgid "ethers:"
msgstr "ethers:"

#. type: TP
#: build/C/man5/nsswitch.conf.5:130
#, no-wrap
msgid "protocols:"
msgstr "protocols:"

#. type: TP
#: build/C/man5/nsswitch.conf.5:133
#, no-wrap
msgid "rpc:"
msgstr "rpc:"

#. type: TP
#: build/C/man5/nsswitch.conf.5:136
#, no-wrap
msgid "services:"
msgstr "services:"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:144
msgid "The first column is the database name.  The remaining columns specify:"
msgstr ""
"最初の列はデータベース名である。\n"
"残りの列で以下を指定する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:148
msgid ""
"One or more service specifications e.g., \"files\", \"db\", or \"nis\".  The "
"order of the services on the line determines the order in which those "
"services will be queried, in turn, until a result is found."
msgstr ""
"1 個以上のサービス指定 (例: \"files\", \"db\", \"nis\")。この行に記載された\n"
"サービスの順序で、結果が得られるまで、指定されたサービスに対する\n"
"問い合わせが順番に行われる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:151
msgid ""
"Optional actions to perform if a particular result is obtained from the "
"preceding service, e.g., \"[NOTFOUND=return]\"."
msgstr ""
"特定の結果が直前のサービスで得られた場合に実行されるアクション\n"
"(例: \"[NOTFOUND=return]\")。アクションは省略可能である。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:177
msgid ""
"The service specifications supported on your system depend on the presence "
"of shared libraries, and are therefore extensible.  Libraries called I</lib/"
"libnss_SERVICE.so.>B<X> will provide the named I<SERVICE>.  On a standard "
"installation, you can use \"files\", \"db\", \"nis\", and \"nisplus\".  For "
"the B<hosts> database, you can additionally specify \"dns\".  For the "
"B<passwd>, B<group>, and B<shadow> databases, you can additionally specify "
"\"compat\" (see B<Compatibility mode> below).  The version number B<X> may "
"be 1 for glibc 2.0, or 2 for glibc 2.1 and later.  On systems with "
"additional libraries installed, you may have access to further services such "
"as \"hesiod\", \"ldap\", \"winbind\" and \"wins\"."
msgstr ""
"利用しているシステムでどのサービス指定が利用できるかは、共有ライブラリ\n"
"があるかどうかに依存しており、そのためサービス指定は拡張できるように\n"
"なっている。I</lib/libnss_SERVICE.so.>B<X> という名前のライブラリが\n"
"I<SERVICE> という名前のサービスを提供する。標準のインストールを行った\n"
"場合、\"files\", \"db\", \"nis\", \"nisplus\" が利用できる。\n"
"データベース B<hosts> の場合には、追加で \"dns\" も指定できる。\n"
"データベース B<passwd>, B<group>, B<shadow> の場合には、追加で\n"
"\"compat\" (下記の B<互換モード> を参照)。バージョン番号 B<X> は、\n"
"glibc 2.0 の場合は 1、glibc 2.1 の場合は 2 で、それ以降も同様である。\n"
"追加のライブラリがインストールされているシステムでは、\"hesiod\",\n"
"\"ldap\", \"winbind\", \"wins\" などの追加のサービスが利用できる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:182
msgid ""
"An action may also be specified following a service specification.  The "
"action modifies the behavior following a result obtained from the preceding "
"data source.  Action items take the general form:"
msgstr ""
"サービス指定の次にアクションを指定することもできる。アクションを\n"
"使うと、直前のデータ源から結果が得られた後の動作を変更できる。\n"
"アクション指定は、一般的には以下の形式となる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:185
msgid "[I<STATUS>=I<ACTION>]"
msgstr "[I<STATUS>=I<ACTION>]"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:187
msgid "[!I<STATUS>=I<ACTION>]"
msgstr "[!I<STATUS>=I<ACTION>]"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:190
msgid "where"
msgstr "STATUS と ACTION はそれぞれ以下の値を取る。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:201
msgid "I<STATUS> =E<gt> B<success> | B<notfound> | B<unavail> | B<tryagain>"
msgstr "I<STATUS> =E<gt> B<success> | B<notfound> | B<unavail> | B<tryagain>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:207
msgid "I<ACTION> =E<gt> B<return> | B<continue>"
msgstr "I<ACTION> =E<gt> B<return> | B<continue>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:212
msgid ""
"The ! negates the test, matching all possible results except the one "
"specified.  The case of the keywords is not significant."
msgstr ""
"! はテスト結果を反転させる。\n"
"つまり、指定された以外の全ての結果にマッチする。\n"
"キーワードの大文字、小文字は無視される。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:217
msgid ""
"The I<STATUS> value is matched against the result of the lookup function "
"called by the preceding service specification, and can be one of:"
msgstr ""
"I<STATUS> は、直前のサービス指定で呼び出しされた検索処理の結果に\n"
"対して照合が行われる。 I<STATUS> には以下のいずれかを指定できる。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:218
#, no-wrap
msgid "B<success>"
msgstr "B<success>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:222
msgid ""
"No error occurred and the requested entry is returned.  The default action "
"for this condition is \"return\"."
msgstr ""
"エラーは発生せず、要求されたエントリが返された。\n"
"この場合のデフォルトのアクションは \"return\" である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:222
#, no-wrap
msgid "B<notfound>"
msgstr "B<notfound>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:226
msgid ""
"The lookup succeeded, but the requested entry was not found.  The default "
"action for this condition is \"continue\"."
msgstr ""
"検索は成功したが、要求されたエントリが見つからなかった。\n"
"この場合のデフォルトのアクションは \"continue\" である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:226
#, no-wrap
msgid "B<unavail>"
msgstr "B<unavail>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:233
msgid ""
"The service is permanently unavailable.  This can mean either that the "
"required file cannot be read, or, for network services, that the server is "
"not available or does not allow queries.  The default action for this "
"condition is \"continue\"."
msgstr ""
"サービスが永続的に利用できない。\n"
"必要なファイルを読み込むことができない、\n"
"ネットワークサービスの場合には、サーバが利用できないとか、\n"
"サーバが問い合わせを許可していない、などが考えられる。\n"
"この場合のデフォルトのアクションは \"continue\" である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:233
#, no-wrap
msgid "B<tryagain>"
msgstr "B<tryagain>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:239
msgid ""
"The service is temporarily unavailable.  This could mean a file is locked or "
"a server currently cannot accept more connections.  The default action for "
"this condition is \"continue\"."
msgstr ""
"サービスが一時的に利用できない。\n"
"ファイルがロックされている、サーバがこれ以上接続を受け付けることができな"
"い、\n"
"などが考えられる。デフォル トのアクションは \"continue\" である。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:244
msgid "The I<ACTION> value can be one of:"
msgstr "I<ACTION> には以下のいずれかを指定できる。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:245
#, no-wrap
msgid "B<return>"
msgstr "B<return>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:257
msgid ""
"Return a result now.  Do not call any further lookup functions.  However, "
"for compatibility reasons, if this is the selected action for the B<group> "
"database and the B<notfound> status, and the configuration file does not "
"contain the B<initgroups> line, the next lookup function is always called, "
"without affecting the search result."
msgstr ""
"結果をすぐに返す。 これ以上検索処理は呼び出されない。 ただし、互換性のため、 "
"選択されたアクションが B<group> データベースに対するもので、 ステータスが "
"B<notfound> であった場合で、 設定ファイルに B<initgroups> の行が含まれていな"
"い場合には、次の検索処理は常に呼び出される (検索結果への影響はない)。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:257
#, no-wrap
msgid "B<continue>"
msgstr "B<continue>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:260
msgid "Call the next lookup function."
msgstr "次の検索処理を呼び出す。"

#. type: SS
#: build/C/man5/nsswitch.conf.5:261
#, no-wrap
msgid "Compatibility mode (compat)"
msgstr "互換モード (compat)"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:267
msgid ""
"The NSS \"compat\" service is similar to \"files\" except that it "
"additionally permits special entries in I</etc/passwd> for granting users or "
"members of netgroups access to the system.  The following entries are valid "
"in this mode:"
msgstr ""
"NSS \"compat\" サービスは \"files\" と似ているが、システムにアクセスできる\n"
"ユーザやネットグループ (netgroup) のメンバの指定に I</etc/passwd> で\n"
"特別なエントリを追加で使うことができる点が異なる。\n"
"このモードでは、以下のエントリを使うことができる。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:268
#, no-wrap
msgid "B<+>I<user>"
msgstr "B<+>I<user>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:273
msgid "Include the specified I<user> from the NIS passwd map."
msgstr "NIS パスワードマップの指定された I<user> を含める。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:273
#, no-wrap
msgid "B<+@>I<netgroup>"
msgstr "B<+@>I<netgroup>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:277
msgid "Include all users in the given I<netgroup>."
msgstr "指定された I<netgroup> の全ユーザを含める。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:277
#, no-wrap
msgid "B<->I<user>"
msgstr "B<->I<user>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:282
msgid "Exclude the specified I<user> from the NIS passwd map."
msgstr "NIS パスワードマップの指定された I<user> を除外する。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:282
#, no-wrap
msgid "B<-@>I<netgroup>"
msgstr "B<-@>I<netgroup>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:286
msgid "Exclude all users in the given I<netgroup>."
msgstr "指定された I<netgroup> の全ユーザを除外する。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:286
#, no-wrap
msgid "B<+>"
msgstr "B<+>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:290
msgid ""
"Include every user, except previously excluded ones, from the NIS passwd map."
msgstr ""
"NIS パスワードマップのユーザのうち、\n"
"それまでに除外されていない全てのユーザを含める。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:298
msgid ""
"By default the source is \"nis\", but this may be overridden by specifying "
"\"nisplus\" as the source for the pseudo-databases B<passwd_compat>, "
"B<group_compat>, and B<shadow_compat>."
msgstr ""
"デフォルトでは、データ源は \"nis\" だが、\n"
"擬似データベース B<passwd_compat>, B<group_compat>, B<shadow_compat>\n"
"ではデータ源として \"nisplus\" を指定することもできる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:305
msgid ""
"A service named I<SERVICE> is implemented by a shared object library named "
"I<libnss_SERVICE.so.>B<X> that resides in I</lib>."
msgstr ""
"I<SERVICE> という名前のサービスは I<libnss_SERVICE.so.>B<X> という\n"
"名前の共有オブジェクトライブラリで実装されている。\n"
"これは I</lib> に置かれる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:310
msgid "NSS configuration file."
msgstr "NSS の設定ファイル。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:310
#, no-wrap
msgid "I</lib/libnss_compat.so.>B<X>"
msgstr "I</lib/libnss_compat.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:313
msgid "implements \"compat\" source."
msgstr "\"compat\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:313
#, no-wrap
msgid "I</lib/libnss_db.so.>B<X>"
msgstr "I</lib/libnss_db.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:316
msgid "implements \"db\" source."
msgstr "\"db\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:316
#, no-wrap
msgid "I</lib/libnss_dns.so.>B<X>"
msgstr "I</lib/libnss_dns.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:319
msgid "implements \"dns\" source."
msgstr "\"dns\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:319
#, no-wrap
msgid "I</lib/libnss_files.so.>B<X>"
msgstr "I</lib/libnss_files.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:322
msgid "implements \"files\" source."
msgstr "\"files\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:322
#, no-wrap
msgid "I</lib/libnss_hesiod.so.>B<X>"
msgstr "I</lib/libnss_hesiod.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:325
msgid "implements \"hesiod\" source."
msgstr "\"hesoid\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:325
#, no-wrap
msgid "I</lib/libnss_nis.so.>B<X>"
msgstr "I</lib/libnss_nis.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:328
msgid "implements \"nis\" source."
msgstr "\"nis\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:328
#, no-wrap
msgid "I</lib/libnss_nisplus.so.>B<X>"
msgstr "I</lib/libnss_nisplus.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:331
msgid "implements \"nisplus\" source."
msgstr "\"nisplus\" ソースを実装したもの。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:339
msgid ""
"Within each process that uses B<nsswitch.conf>, the entire file is read only "
"once.  If the file is later changed, the process will continue using the old "
"configuration."
msgstr ""
"I<nsswitch.conf> を利用するプロセスは、ファイルは一度しか読み込まない。\n"
"その後で nsswitch.conf が書き換えられても、そのプロセスは古い設定のままで\n"
"動作を継続する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:352
msgid ""
"Traditionally, there was only a single source for service information, often "
"in the form of a single configuration file (e.g., I</etc/passwd>).  However, "
"as other name services, such as the Network Information Service (NIS) and "
"the Domain Name Service (DNS), became popular, a method was needed that "
"would be more flexible than fixed search orders coded into the C library.  "
"The Name Service Switch mechanism, which was based on the mechanism used by "
"Sun Microsystems in the Solaris 2 C library, introduced a cleaner solution "
"to the problem."
msgstr ""
"伝統的には、サービス情報の情報源は一つだけであり、\n"
"その設定ファイルの形式も一つであった (例えば I</etc/passwd>)。\n"
"一方で、 Network Information Service (NIS) や Domain Name Service\n"
"(DNS) などの他の名前サービスが一般的になるに連れて、C ライブラリに埋め\n"
"込まれた固定順序ではなく、検索順序を柔軟に指定する方法が必要になった。\n"
"ネームサービススイッチ機構は、この問題に対するよりきれいな解決方法と\n"
"なっている。ネームサービススイッチ機構は、 Sun Microsystems が \n"
"Solaris 2 の C ライブラリで使った機構が基になっている。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:355
msgid "B<getent>(1), B<nss>(5)"
msgstr "B<getent>(1), B<nss>(5)"

#. type: TH
#: build/C/man7/packet.7:12
#, no-wrap
msgid "PACKET"
msgstr "PACKET"

#. type: Plain text
#: build/C/man7/packet.7:15
msgid "packet - packet interface on device level."
msgstr "packet - デバイスレベルのパケットインターフェース"

#. type: Plain text
#: build/C/man7/packet.7:18
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man7/packet.7:20
#, no-wrap
msgid "B<#include E<lt>netpacket/packet.hE<gt>>\n"
msgstr "B<#include E<lt>netpacket/packet.hE<gt>>\n"

#. type: Plain text
#: build/C/man7/packet.7:22
#, no-wrap
msgid "B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
msgstr "B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"

#. type: Plain text
#: build/C/man7/packet.7:24
#, no-wrap
msgid "B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int >I<protocol>B<);>\n"
msgstr "B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int >I<protocol>B<);>\n"

#. type: Plain text
#: build/C/man7/packet.7:30
msgid ""
"Packet sockets are used to receive or send raw packets at the device driver "
"(OSI Layer 2) level.  They allow the user to implement protocol modules in "
"user space on top of the physical layer."
msgstr ""
"packet ソケットは、デバイスドライバ (OSI レイヤ 2) レベルで 生のパケット "
"(raw packet) を送受信するために用いられる。 packet ソケットを使うと、ユーザー"
"空間で物理層の上に プロトコルモジュールを実装することができる。"

#. type: Plain text
#: build/C/man7/packet.7:52
msgid ""
"The I<socket_type> is either B<SOCK_RAW> for raw packets including the link "
"level header or B<SOCK_DGRAM> for cooked packets with the link level header "
"removed.  The link level header information is available in a common format "
"in a I<sockaddr_ll>.  I<protocol> is the IEEE 802.3 protocol number in "
"network order.  See the I<E<lt>linux/if_ether.hE<gt>> include file for a "
"list of allowed protocols.  When protocol is set to B<htons(ETH_P_ALL)> then "
"all protocols are received.  All incoming packets of that protocol type will "
"be passed to the packet socket before they are passed to the protocols "
"implemented in the kernel."
msgstr ""
"I<socket_type> には B<SOCK_RAW> と B<SOCK_DGRAM> のいずれかを指定する。 "
"B<SOCK_RAW> はリンクレベルヘッダを含む raw パケットを、 B<SOCK_DGRAM> はリン"
"クレベルヘッダが削除された加工済みパケットを示す。 リンクレベルヘッダ情報は "
"I<sockaddr_ll> で共通のフォーマットで入手できる。 I<protocol> には IEEE "
"802.3 プロトコル番号を ネットワークバイトオーダーで指定する。 指定できるプロ"
"トコルのリストは、インクルードファイル I<E<lt>linux/if_ether.hE<gt>> を参照。"
"プロトコルを B<htons(ETH_P_ALL)> にすると、全てのプロトコルが受信される。 外"
"部から来たパケットのうち指定したプロトコルのものは、 カーネルに実装されている"
"プロトコルに渡される前の段階で、 packet ソケットに渡される。"

#. type: Plain text
#: build/C/man7/packet.7:56
msgid ""
"Only processes with effective UID 0 or the B<CAP_NET_RAW> capability may "
"open packet sockets."
msgstr ""
"packet ソケットをオープンできるのは、 実効ユーザーID が 0 のプロセスか、 "
"B<CAP_NET_RAW> ケーパビリティを持つプロセスだけである。"

#. type: Plain text
#: build/C/man7/packet.7:74
msgid ""
"B<SOCK_RAW> packets are passed to and from the device driver without any "
"changes in the packet data.  When receiving a packet, the address is still "
"parsed and passed in a standard I<sockaddr_ll> address structure.  When "
"transmitting a packet, the user supplied buffer should contain the physical "
"layer header.  That packet is then queued unmodified to the network driver "
"of the interface defined by the destination address.  Some device drivers "
"always add other headers.  B<SOCK_RAW> is similar to but not compatible with "
"the obsolete B<AF_INET/SOCK_PACKET> of Linux 2.0."
msgstr ""
"B<SOCK_RAW> パケットでは、パケットをデバイスドライバと受け渡しする際、 パケッ"
"トデータに変更が行われることはない。 パケットの受信時には、アドレスの解析だけ"
"は行われ、 標準的な I<sockaddr_ll> アドレス構造体に渡される。パケットの送信時"
"には、ユーザが指定する バッファに物理層のヘッダが含まれている必要がある。 パ"
"ケットはそのまま修正を受けずに、行き先アドレスから決定される インターフェース"
"のネットワークドライバにキューイングされる。 デバイスドライバによっては、他の"
"ヘッダを常に追加するものもある。 B<SOCK_RAW> は Linux 2.0 の obosolete な "
"B<AF_INET/SOCK_PACKET> と似ているが、互換性があるわけではない。"

#. type: Plain text
#: build/C/man7/packet.7:84
msgid ""
"B<SOCK_DGRAM> operates on a slightly higher level.  The physical header is "
"removed before the packet is passed to the user.  Packets sent through a "
"B<SOCK_DGRAM> packet socket get a suitable physical layer header based on "
"the information in the I<sockaddr_ll> destination address before they are "
"queued."
msgstr ""
"B<SOCK_DGRAM> はやや高位のレベルで動作する。物理ヘッダは、パケットがユーザー"
"に 渡される前に削除される。 B<SOCK_DGRAM> の packet ソケットを通して送られる"
"パケットは、 I<sockaddr_ll> の行き先アドレスの情報に基づき、適切な物理層の"
"ヘッダが付加されてから、 キューに送られる。"

#. type: Plain text
#: build/C/man7/packet.7:97
msgid ""
"By default all packets of the specified protocol type are passed to a packet "
"socket.  To get packets only from a specific interface use B<bind>(2)  "
"specifying an address in a I<struct sockaddr_ll> to bind the packet socket "
"to an interface.  Only the I<sll_protocol> and the I<sll_ifindex> address "
"fields are used for purposes of binding."
msgstr ""
"デフォルトでは、指定したプロトコル型のパケットはすべて packet ソケットに送ら"
"れる。特定のインターフェースからのパケットだけを 取得したい場合には、 "
"I<struct sockaddr_ll> にアドレスを指定して B<bind>(2)  を呼び、 packet ソケッ"
"トをそのインターフェースに結び付ける (バインドする)。 バインドの際には、アド"
"レスフィールドのうち I<sll_protocol> と I<sll_ifindex> だけが用いられる。"

#. type: Plain text
#: build/C/man7/packet.7:101
msgid "The B<connect>(2)  operation is not supported on packet sockets."
msgstr "B<connect>(2)  操作は packet ソケットではサポートされていない。"

#. type: Plain text
#: build/C/man7/packet.7:110
msgid ""
"When the B<MSG_TRUNC> flag is passed to B<recvmsg>(2), B<recv>(2), "
"B<recvfrom>(2)  the real length of the packet on the wire is always "
"returned, even when it is longer than the buffer."
msgstr ""
"B<MSG_TRUNC> フラグが B<recvmsg>(2), B<recv>(2), B<recvfrom>(2)  に渡される"
"と、 (バッファサイズより大きかったとしても) 常に実際に通信された パケットの長"
"さが返される。"

#. type: SS
#: build/C/man7/packet.7:110
#, no-wrap
msgid "Address types"
msgstr "アドレスのタイプ"

#. type: Plain text
#: build/C/man7/packet.7:112
msgid "The sockaddr_ll is a device independent physical layer address."
msgstr "sockaddr_ll はデバイスに依存しない物理層のアドレスである。"

#. type: Plain text
#: build/C/man7/packet.7:124
#, no-wrap
msgid ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* Always AF_PACKET */\n"
"    unsigned short sll_protocol; /* Physical layer protocol */\n"
"    int            sll_ifindex;  /* Interface number */\n"
"    unsigned short sll_hatype;   /* ARP hardware type */\n"
"    unsigned char  sll_pkttype;  /* Packet type */\n"
"    unsigned char  sll_halen;    /* Length of address */\n"
"    unsigned char  sll_addr[8];  /* Physical layer address */\n"
"};\n"
msgstr ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* 常に AF_PACKET */\n"
"    unsigned short sll_protocol; /* 物理層のプロトコル */\n"
"    int            sll_ifindex;  /* インターフェース番号 */\n"
"    unsigned short sll_hatype;   /* ARP ハードウェア種別 */\n"
"    unsigned char  sll_pkttype;  /* パケット種別 */\n"
"    unsigned char  sll_halen;    /* アドレスの長さ */\n"
"    unsigned char  sll_addr[8];  /* 物理層のアドレス */\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:163
msgid ""
"I<sll_protocol> is the standard ethernet protocol type in network order as "
"defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It defaults to "
"the socket's protocol.  I<sll_ifindex> is the interface index of the "
"interface (see B<netdevice>(7)); 0 matches any interface (only permitted for "
"binding).  I<sll_hatype> is an ARP type as defined in the I<E<lt>linux/"
"if_arp.hE<gt>> include file.  I<sll_pkttype> contains the packet type.  "
"Valid types are B<PACKET_HOST> for a packet addressed to the local host, "
"B<PACKET_BROADCAST> for a physical layer broadcast packet, "
"B<PACKET_MULTICAST> for a packet sent to a physical layer multicast address, "
"B<PACKET_OTHERHOST> for a packet to some other host that has been caught by "
"a device driver in promiscuous mode, and B<PACKET_OUTGOING> for a packet "
"originated from the local host that is looped back to a packet socket.  "
"These types make sense only for receiving.  I<sll_addr> and I<sll_halen> "
"contain the physical layer (e.g., IEEE 802.3) address and its length.  The "
"exact interpretation depends on the device."
msgstr ""
"I<sll_protocol> は標準的なイーサネットプロトコルのタイプで、 ネットワーク\n"
"バイトオーダーで記述する。 インクルードファイル\n"
"I<E<lt>linux/if_ether.hE<gt>> で定義されている。 これがこのソケットのプロト\n"
"コルのデフォルトとなる。 I<sll_ifindex> はそのインターフェースの interface\n"
"index である (B<netdevice>(7) を参照)。 0 は (バインドが許可されている) 任\n"
"意のインターフェースにマッチする。 I<sll_hatype> は、インクルードファイル\n"
"I<E<lt>linux/if_arp.hE<gt>> で定義されている ARP 種別である。\n"
"I<sll_pkttype> はパケット種別である。指定できる種別は以下のいずれかである:\n"
"B<PACKET_HOST> (ローカルホスト向けのパケット)、 B<PACKET_BORADCAST> (物理層\n"
"のブロードキャストパケット)、 B<PACKET_MULTICAST> (物理層のマルチキャストア\n"
"ドレスに送るパケット)、 B<PACKET_OTHERHOST> (他のホストに向けられたパケット\n"
"のうち、 無差別モード (promiscuous mode: 後述) のデバイスドライバにより補足\n"
"されたもの)、 B<PACKET_OUTGOING> (ローカルホストから発信され、 packet ソ"
"ケッ\n"
"トにループバックしてきたパケット)。 これらの種別が意味を持つのは受信時のみ\n"
"である。 I<sll_addr> と I<sll_halen> は、物理層の (つまり IEEE 802.3 の) \n"
"アドレスとその長さである。 厳密な解釈はデバイスに依存する。"

#. type: Plain text
#: build/C/man7/packet.7:179
msgid ""
"When you send packets it is enough to specify I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex>.  The other fields should be 0.  I<sll_hatype> "
"and I<sll_pkttype> are set on received packets for your information.  For "
"bind only I<sll_protocol> and I<sll_ifindex> are used."
msgstr ""
"パケットを送る場合は、 I<sll_family>, I<sll_addr>, I<sll_halen>, "
"I<sll_ifindex> を指定すれば十分である。 その他のフィールドは 0 にしておくべき"
"である。 I<sll_hatype> と I<sll_pkttype> には受信したパケットの情報が設定され"
"る。 バインドの際には、 I<sll_protocol> と I<sll_ifindex> だけが使用される。"

#. type: Plain text
#: build/C/man7/packet.7:194
msgid ""
"Packet sockets can be used to configure physical layer multicasting and "
"promiscuous mode.  It works by calling B<setsockopt>(2)  on a packet socket "
"for B<SOL_PACKET> and one of the options B<PACKET_ADD_MEMBERSHIP> to add a "
"binding or B<PACKET_DROP_MEMBERSHIP> to drop it.  They both expect a "
"B<packet_mreq> structure as argument:"
msgstr ""
"packet ソケットは、物理層のマルチキャストや 無差別モード (promiscuous mode) "
"を設定して使うことができる。 これには B<SOL_PACKET> と以下のオプションのいず"
"れかを指定して B<setsockopt>(2)  を呼べばよい。 バインドを追加する場合は "
"B<PACKET_ADD_MEMBERSHIP> であり、取り去る場合は B<PACKET_DROP_MEMBERSHIP> で"
"ある。これらはいずれも B<packet_mreq> 構造体を引き数に取る。"

#. type: Plain text
#: build/C/man7/packet.7:203
#, no-wrap
msgid ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* interface index */\n"
"    unsigned short mr_type;       /* action */\n"
"    unsigned short mr_alen;       /* address length */\n"
"    unsigned char  mr_address[8]; /* physical layer address */\n"
"};\n"
msgstr ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* インターフェース番号 */\n"
"    unsigned short mr_type;       /* 動作 */\n"
"    unsigned short mr_alen;       /* アドレスの長さ */\n"
"    unsigned char  mr_address[8]; /* 物理層のアドレス */\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:224
msgid ""
"B<mr_ifindex> contains the interface index for the interface whose status "
"should be changed.  The B<mr_type> parameter specifies which action to "
"perform.  B<PACKET_MR_PROMISC> enables receiving all packets on a shared "
"medium (often known as \"promiscuous mode\"), B<PACKET_MR_MULTICAST> binds "
"the socket to the physical layer multicast group specified in B<mr_address> "
"and B<mr_alen>, and B<PACKET_MR_ALLMULTI> sets the socket up to receive all "
"multicast packets arriving at the interface."
msgstr ""
"I<mr_ifindex> は、ステータスを変更したいインターフェースの インターフェース番"
"号である。 I<mr_type> パラメータは実行する動作を指定する: "
"B<PACKET_MR_PROMISC> は、共有している媒体からの全てのパケットを受信できるよう"
"にする (しばしば \"無差別モード (promiscuous mode)\" と呼ばれる)。 "
"B<PACKET_MR_MULTICAST> は、そのソケットを、 I<mr_address> と I<mr_alen> で指"
"定される物理層のマルチキャストブループにバインドする。 B<PACKET_MR_ALLMULTI> "
"は socket を up にして、そのインターフェースに到達したすべての マルチキャスト"
"パケットを受信できるようにする。"

#. type: Plain text
#: build/C/man7/packet.7:230
msgid ""
"In addition the traditional ioctls B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> can be used for the same purpose."
msgstr ""
"昔からある ioctl だけでなく、 B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> を同じ目的に用いることができる。"

#.  FIXME Document SIOCGSTAMPNS
#. type: Plain text
#: build/C/man7/packet.7:236
msgid ""
"B<SIOCGSTAMP> can be used to receive the timestamp of the last received "
"packet.  Argument is a I<struct timeval.>"
msgstr ""
"B<SIOCGSTAMP> を用いると、最後に受信したパケットのタイムスタンプを得ることが"
"できる。 引き数は I<struct timeval> である。"

#. type: Plain text
#: build/C/man7/packet.7:242
msgid ""
"In addition all standard ioctls defined in B<netdevice>(7)  and B<socket>"
"(7)  are valid on packet sockets."
msgstr ""
"さらに、 B<netdevice>(7)  および B<socket>(7)  で定義されている標準の ioctl "
"はいずれも packet ソケットに指定可能である。"

#. type: SS
#: build/C/man7/packet.7:242 build/C/man7/raw.7:131 build/C/man7/tcp.7:1115
#: build/C/man7/udp.7:103
#, no-wrap
msgid "Error handling"
msgstr "エラー処理"

#. type: Plain text
#: build/C/man7/packet.7:246
msgid ""
"Packet sockets do no error handling other than errors occurred while passing "
"the packet to the device driver.  They don't have the concept of a pending "
"error."
msgstr ""
"packet ソケットは、パケットをデバイスドライバに渡すときに 起きたエラーしか処"
"理しない。遅延エラー (pending error)  に関する概念は持っていない。"

#. type: Plain text
#: build/C/man7/packet.7:250
msgid "Unknown multicast group address passed."
msgstr "不明なマルチキャストグループアドレスが渡された。"

#. type: Plain text
#: build/C/man7/packet.7:253
msgid "User passed invalid memory address."
msgstr "ユーザが渡したメモリアドレスが不正。"

#. type: Plain text
#: build/C/man7/packet.7:256 build/C/man7/raw.7:155
msgid "Invalid argument."
msgstr "引き数が不正。"

#. type: Plain text
#: build/C/man7/packet.7:259
msgid "Packet is bigger than interface MTU."
msgstr "パケットがインターフェースの MTU より大きい。"

#. type: TP
#: build/C/man7/packet.7:259
#, no-wrap
msgid "B<ENETDOWN>"
msgstr "B<ENETDOWN>"

#. type: Plain text
#: build/C/man7/packet.7:262
msgid "Interface is not up."
msgstr "インターフェースが up でない。"

#. type: Plain text
#: build/C/man7/packet.7:265
msgid "Not enough memory to allocate the packet."
msgstr "パケットに割り当てるメモリが足りない。"

#. type: Plain text
#: build/C/man7/packet.7:268
msgid "Unknown device name or interface index specified in interface address."
msgstr ""
"デバイス名が不明。あるいはインターフェースアドレスで指定された インターフェー"
"スインデックスが不明。"

#. type: Plain text
#: build/C/man7/packet.7:271
msgid "No packet received."
msgstr "パケットを一つも受信していない。"

#. type: Plain text
#: build/C/man7/packet.7:274
msgid "No interface address passed."
msgstr "インターフェースアドレスが渡されなかった。"

#. type: TP
#: build/C/man7/packet.7:274
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man7/packet.7:277
msgid "Interface address contained an invalid interface index."
msgstr ""
"インターフェースアドレスに不正なインターフェースインデックスが含まれている。"

#. type: Plain text
#: build/C/man7/packet.7:280
msgid "User has insufficient privileges to carry out this operation."
msgstr "この操作を行うのに必要な権限をユーザが持っていない。"

#. type: Plain text
#: build/C/man7/packet.7:282
msgid "In addition other errors may be generated by the low-level driver."
msgstr "上記以外のエラーが、低レベルのドライバで生成されることがある。"

#. type: Plain text
#: build/C/man7/packet.7:287
msgid ""
"B<AF_PACKET> is a new feature in Linux 2.2.  Earlier Linux versions "
"supported only B<SOCK_PACKET>."
msgstr ""
"B<AF_PACKET> は Linux 2.2 の新機能である。これより古いバージョンの Linux で"
"は B<SOCK_PACKET> のみをサポートしていた。"

#. type: Plain text
#: build/C/man7/packet.7:292
msgid ""
"The include file I<E<lt>netpacket/packet.hE<gt>> is present since glibc "
"2.1.  Older systems need:"
msgstr ""
"インクルードファイル I<E<lt>netpacket/packet.hE<gt>> が存在するのは glibc "
"2.1 以降である。 それ以前のシステムでは以下のようにする必要がある:"

#. type: Plain text
#: build/C/man7/packet.7:298
#, no-wrap
msgid ""
"#include E<lt>asm/types.hE<gt>\n"
"#include E<lt>linux/if_packet.hE<gt>\n"
"#include E<lt>linux/if_ether.hE<gt>  /* The L2 protocols */\n"
msgstr ""
"#include E<lt>asm/types.hE<gt>\n"
"#include E<lt>linux/if_packet.hE<gt>\n"
"#include E<lt>linux/if_ether.hE<gt>  /* The L2 protocols */\n"

#. type: Plain text
#: build/C/man7/packet.7:308
msgid ""
"For portable programs it is suggested to use B<AF_PACKET> via B<pcap>(3); "
"although this covers only a subset of the B<AF_PACKET> features."
msgstr ""
"移植性の必要なプログラムでは、 B<pcap>(3)  経由で B<AF_PACKET> を用いることを"
"お薦めする。ただし、この方法では B<AF_PACKET> の機能すべてを利用することはで"
"きない。"

#. type: Plain text
#: build/C/man7/packet.7:329
msgid ""
"The B<SOCK_DGRAM> packet sockets make no attempt to create or parse the IEEE "
"802.2 LLC header for a IEEE 802.3 frame.  When B<ETH_P_802_3> is specified "
"as protocol for sending the kernel creates the 802.3 frame and fills out the "
"length field; the user has to supply the LLC header to get a fully "
"conforming packet.  Incoming 802.3 packets are not multiplexed on the DSAP/"
"SSAP protocol fields; instead they are supplied to the user as protocol "
"B<ETH_P_802_2> with the LLC header prepended.  It is thus not possible to "
"bind to B<ETH_P_802_3>; bind to B<ETH_P_802_2> instead and do the protocol "
"multiplex yourself.  The default for sending is the standard Ethernet DIX "
"encapsulation with the protocol filled in."
msgstr ""
"B<SOCK_DGRAM> packet ソケットは、IEEE 802.3 フレームの IEEE 802.2 LLC ヘッダ"
"の 生成や解析を行おうとしない。 B<ETH_P_802_3> が送信プロトコルに指定される"
"と、カーネルは 802.3 フレームを 生成して length フィールドに書き込む。 完全に"
"準拠したパケットを得るためにはユーザーが LLC ヘッダを 与える必要がある。到着"
"した 802.3 パケットでは、 DSAP/SSAP protocol の各フィールドは多重化 "
"(multiplex) されていない。 代わりにこれらは LLC ヘッダが前置された "
"B<ETH_P_802_2> プロトコルとして与えられる。したがって、 B<ETH_P_802_3> にバイ"
"ンドすることはできない。かわりに B<ETH_P_802_2> にバインドし、自分自身でプロ"
"トコルの多重化を行うこと。 送信のデフォルトは、プロトコルフィールドを持つ 標"
"準の Ethernet DIX encapsulation である。"

#. type: Plain text
#: build/C/man7/packet.7:331
msgid "Packet sockets are not subject to the input or output firewall chains."
msgstr "packet ソケットは入出力の firewall chain に影響をうけない。"

#. type: Plain text
#: build/C/man7/packet.7:341
msgid ""
"In Linux 2.0, the only way to get a packet socket was by calling B<socket"
"(AF_INET, SOCK_PACKET, >I<protocol>B<)>.  This is still supported but "
"strongly deprecated.  The main difference between the two methods is that "
"B<SOCK_PACKET> uses the old I<struct sockaddr_pkt> to specify an interface, "
"which doesn't provide physical layer independence."
msgstr ""
"Linux 2.0 では、 packet ソケットを得る方法は B<socket(AF_INET, SOCK_PACKET, "
">I<protocol>B<)> を呼ぶやり方しかなかった。この方法はまだサポートされている"
"が、 用いないことを強く推奨する。現在の方法との主な違いは、 B<SOCK_PACKET> で"
"はインターフェースの指定に古い I<struct sockaddr_pkt> を用いる点である。これ"
"には物理層からの独立性がない。"

#. type: Plain text
#: build/C/man7/packet.7:349
#, no-wrap
msgid ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"
msgstr ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:361
msgid ""
"I<spkt_family> contains the device type, I<spkt_protocol> is the IEEE 802.3 "
"protocol type as defined in I<E<lt>sys/if_ether.hE<gt>> and I<spkt_device> "
"is the device name as a null-terminated string, for example, eth0."
msgstr ""
"I<spkt_family> はデバイスのタイプ、 I<spkt_protocol> は I<E<lt>sys/if_ether."
"hE<gt>> で定義されている IEEE 802.3 プロトコルタイプ、 I<spkt_device> はデバ"
"イスの名前を NULL 終端された文字列で与えたもの (例: eth0) である。"

#. type: Plain text
#: build/C/man7/packet.7:363
msgid "This structure is obsolete and should not be used in new code."
msgstr ""
"この構造体は obsolete であり、 新しくコードを書く時には用いるべきでない。"

#. type: Plain text
#: build/C/man7/packet.7:367
msgid ""
"glibc 2.1 does not have a define for B<SOL_PACKET>.  The suggested "
"workaround is to use:"
msgstr ""
"glibc 2.1 には B<SOL_PACKET> の定義がない。回避策としては、以下のようにすると"
"よい。"

#. type: Plain text
#: build/C/man7/packet.7:373
#, no-wrap
msgid ""
"#ifndef SOL_PACKET\n"
"#define SOL_PACKET 263\n"
"#endif\n"
msgstr ""
"#ifndef SOL_PACKET\n"
"#define SOL_PACKET 263\n"
"#endif\n"

#. type: Plain text
#: build/C/man7/packet.7:378
msgid ""
"This is fixed in later glibc versions and also does not occur on libc5 "
"systems."
msgstr ""
"この問題は新しいバージョンの glibc では修正されている。 libc5 のシステムには"
"この問題はない。"

#. type: Plain text
#: build/C/man7/packet.7:380
msgid "The IEEE 802.2/803.3 LLC handling could be considered as a bug."
msgstr "IEEE 802.2/803.3 の LLC の扱い方は、バグと考えても良いだろう。"

#. type: Plain text
#: build/C/man7/packet.7:382
msgid "Socket filters are not documented."
msgstr "ソケットフィルターについて記載されていない。"

#.  .SH CREDITS
#.  This man page was written by Andi Kleen with help from Matthew Wilcox.
#.  AF_PACKET in Linux 2.2 was implemented
#.  by Alexey Kuznetsov, based on code by Alan Cox and others.
#. type: Plain text
#: build/C/man7/packet.7:394
msgid ""
"The B<MSG_TRUNC> B<recvmsg>(2)  extension is an ugly hack and should be "
"replaced by a control message.  There is currently no way to get the "
"original destination address of packets via B<SOCK_DGRAM>."
msgstr ""
"B<MSG_TRUNC> B<recvmsg>(2)  拡張は非常にまずい対処であり、制御メッセージで置"
"き換えるべきである。 今のところ B<SOCK_DGRAM> 経由でパケットについていた宛先"
"アドレスを得る方法がない。"

#. type: Plain text
#: build/C/man7/packet.7:401
msgid ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), B<socket>"
"(7)"
msgstr ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), B<socket>"
"(7)"

#. type: Plain text
#: build/C/man7/packet.7:404
msgid ""
"RFC\\ 894 for the standard IP Ethernet encapsulation.  RFC\\ 1700 for the "
"IEEE 802.3 IP encapsulation."
msgstr ""
"標準 IP Ethernet encapsulation に関しては RFC\\ 894 を、 IEEE 802.3 IP "
"encapsulation に関しては RFC\\ 1700 を参照。"

#. type: Plain text
#: build/C/man7/packet.7:408
msgid ""
"The I<E<lt>linux/if_ether.hE<gt>> include file for physical layer protocols."
msgstr ""
"物理層のプロトコルに関する記述は I<E<lt>linux/if_ether.hE<gt>> インクルード"
"ファイルにある。"

#. type: TH
#: build/C/man5/protocols.5:29
#, no-wrap
msgid "PROTOCOLS"
msgstr "PROTOCOLS"

#. type: TH
#: build/C/man5/protocols.5:29 build/C/man7/x25.7:12
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: build/C/man5/protocols.5:32
msgid "protocols - protocols definition file"
msgstr "protocols - プロトコル定義ファイル"

#. type: Plain text
#: build/C/man5/protocols.5:40
msgid ""
"This file is a plain ASCII file, describing the various DARPA internet "
"protocols that are available from the TCP/IP subsystem.  It should be "
"consulted instead of using the numbers in the ARPA include files, or, even "
"worse, just guessing them.  These numbers will occur in the protocol field "
"of any IP header."
msgstr ""
"このファイルは ASCII ファイルで、TCP/IP サブシステムから利用できる いろいろ"
"な DARPA インターネットプロトコルを記述している。 ARPA 関連のインクルードファ"
"イル内の数値を使うべきではないし、 単に推測した値を使うのはさらに良くない。 "
"代わりにこのファイルに問い合わせるべきである。 これらの数値は IP ヘッダのプロ"
"トコルフィールドに現れる。"

#.  .. by the DDN Network Information Center.
#. type: Plain text
#: build/C/man5/protocols.5:46
msgid ""
"Keep this file untouched since changes would result in incorrect IP "
"packages.  Protocol numbers and names are specified by the IANA (Internet "
"Assigned Numbers Authority)."
msgstr ""
"このファイルは変更しないこと。変更すると IP パッケージが不正になる。 プロトコ"
"ル番号とプロトコル名は IANA (Internet Assigned Numbers Authority) によって指"
"定される。"

#. type: Plain text
#: build/C/man5/protocols.5:48
msgid "Each line is of the following format:"
msgstr "それぞれの行は次のフォーマットである。"

#. type: Plain text
#: build/C/man5/protocols.5:51
msgid "I<protocol number aliases ...>"
msgstr "I<protocol number aliases ...>"

#. type: Plain text
#: build/C/man5/protocols.5:57
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"If a line contains a hash mark (#), the hash mark and the part of the line "
"following it are ignored."
msgstr ""
"各フィールドは空白かタブで区切られていて、空行は無視される。 行にハッシュ記号"
"(#)が含まれる場合、 ハッシュ記号を含むその行の残りは無視される。"

#. type: TP
#: build/C/man5/protocols.5:59 build/C/man5/services.5:109
#, no-wrap
msgid "I<protocol>"
msgstr "I<protocol>"

#. type: Plain text
#: build/C/man5/protocols.5:67
msgid ""
"the native name for the protocol.  For example I<ip>, I<tcp>, or I<udp>."
msgstr "プロトコルの固有名。たとえば I<ip>, I<tcp>, I<udp> など。"

#. type: Plain text
#: build/C/man5/protocols.5:71
msgid ""
"the official number for this protocol as it will appear within the IP header."
msgstr "プロトコルの公式番号、IP ヘッダに現れる。"

#. type: Plain text
#: build/C/man5/protocols.5:74
msgid "optional aliases for the protocol."
msgstr "プロトコルの別名、オプション。"

#.  The following is not true as at glibc 2.8 (a line with a comma is
#.  ignored by getservent()); it's not clear if/when it was ever true.
#.    As a backward compatibility feature, the slash (/) between the
#.    .I port
#.    number and
#.    .I protocol
#.    name can in fact be either a slash or a comma (,).
#.    Use of the comma in
#.    modern installations is deprecated.
#. type: Plain text
#: build/C/man5/protocols.5:77 build/C/man5/services.5:165
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr ""
"このファイルは Yellow Pages/NIS や BIND/Hesiod のようなネットワーク上の名前"
"サービスを用いて、ネットワークを通じて配布される可能性もある。"

#. type: Plain text
#: build/C/man5/protocols.5:81
msgid "The protocols definition file."
msgstr "プロトコル定義ファイル。"

#. type: Plain text
#: build/C/man5/protocols.5:83
msgid "B<getprotoent>(3)"
msgstr "B<getprotoent>(3)"

#. type: Plain text
#: build/C/man5/protocols.5:86
msgid "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"
msgstr "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"

#. type: TH
#: build/C/man7/raw.7:13
#, no-wrap
msgid "RAW"
msgstr "RAW"

#. type: Plain text
#: build/C/man7/raw.7:16
msgid "raw - Linux IPv4 raw sockets"
msgstr "raw - Linux の IPv4 raw ソケット"

#. type: Plain text
#: build/C/man7/raw.7:22
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/raw.7:26
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw "
"socket receives or sends the raw datagram not including link level headers."
msgstr ""
"raw ソケットを使うと、新しい IPv4 プロトコルをユーザ空間で 実装できるようにな"
"る。 raw ソケットは、リンクレベルヘッダを 含まない raw データグラムの送受信が"
"できる。"

#. type: Plain text
#: build/C/man7/raw.7:32
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving the IP header is always "
"included in the packet."
msgstr ""
"IPv4 レイヤは、扱っているソケットで B<IP_HDRINCL> ソケットオプションが有効に"
"なっていなければ、 パケットを送信するときに IP ヘッダを生成する。 "
"B<IP_HDRINCL> オプションが有効になっているときは、パケットには IP ヘッダが含"
"まれていなければならない。 受信時には、 IP ヘッダは常にパケットに含まれてい"
"る。"

#. type: Plain text
#: build/C/man7/raw.7:36
msgid ""
"Only processes with an effective user ID of 0 or the B<CAP_NET_RAW> "
"capability are allowed to open raw sockets."
msgstr ""
"実効ユーザー ID が 0 のプロセスか、 B<CAP_NET_RAW> 権限を持つプロセスだけが "
"raw ソケットをオープンすることができる。"

#. type: Plain text
#: build/C/man7/raw.7:43
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols see "
"RFC\\ 1700 assigned numbers and B<getprotobyname>(3)."
msgstr ""
"この raw ソケットに指定された I<protocol> 番号にマッチする全てのパケットとエ"
"ラーとが、このソケットに渡される。 許可されているプロトコルのリストは RFC\\ "
"1700 の割り当て番号と B<getprotobyname>(3)  を見よ。"

#. type: Plain text
#: build/C/man7/raw.7:53
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""
"B<IPPROTO_RAW> のプロトコルは暗黙のうちに B<IP_HDRINCL> を有効にするので、 渡"
"されたヘッダで指定された、あらゆる IP プロトコルを送信できる。 "
"B<IPPROTO_RAW> 経由でのあらゆる IP プロトコルの受信は、 raw ソケットを用いて"
"は行えない。"

#. type: tbl table
#: build/C/man7/raw.7:58
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>\n"
msgstr "IP ヘッダフィールド。 B<IP_HDRINCL> によって送信時に変更される。\n"

#. type: tbl table
#: build/C/man7/raw.7:59
#, no-wrap
msgid "IP Checksum:Always filled in.\n"
msgstr "IP チェックサム:常に変更される。\n"

#. type: tbl table
#: build/C/man7/raw.7:60
#, no-wrap
msgid "Source Address:Filled in when zero.\n"
msgstr "ソースアドレス:元の値が 0 の時に変更される。\n"

#. type: tbl table
#: build/C/man7/raw.7:61
#, no-wrap
msgid "Packet Id:Filled in when zero.\n"
msgstr "パケット ID:元の値が 0 の時に変更される。\n"

#. type: tbl table
#: build/C/man7/raw.7:62
#, no-wrap
msgid "Total Length:Always filled in.\n"
msgstr "全体の長さ:常に埋められる。\n"

#. type: Plain text
#: build/C/man7/raw.7:76
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""
"B<IP_HERINCL> が指定されていて、 IP ヘッダに 0 でない送信先アドレスが記入され"
"ていた場合は、 その送信先アドレスがパケットの経路を決めるのに用いられる。 "
"B<MSG_DONTROUTE> が指定されている時には、 送信先アドレスはローカルなインター"
"フェースを参照するものでなければならない。 さもないと、ルーティングテーブルの"
"参照はいずれにせよ行われるが、 ゲートウェイが必要な経路は無視される。"

#. type: Plain text
#: build/C/man7/raw.7:84
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets "
"with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""
"B<IP_HDRINCL> がセットされていなければ、 raw ソケットの IP ヘッダオプション"
"を B<setsockopt>(2)  を用いて設定することができる。詳細な情報は B<ip>(7)  を"
"見よ。"

#. type: Plain text
#: build/C/man7/raw.7:89
msgid ""
"In Linux 2.2, all IP header fields and options can be set using IP socket "
"options.  This means raw sockets are usually needed only for new protocols "
"or protocols with no user interface (like ICMP)."
msgstr ""
"Linux 2.2 では、 IP ヘッダの全てのフィールドとオプションとを IP ソケットオプ"
"ションによって設定できる。したがって raw ソケットが必要になるのは、新しいプロ"
"トコルを設計する場合か、 ユーザーインターフェースを持たないプロトコル (ICMP "
"など) を扱う場合に 限られる。"

#. type: Plain text
#: build/C/man7/raw.7:93
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""
"パケットは、受信されるとまずプロトコルにバインドしている raw ソケットに渡さ"
"れ、 その後で他のプロトコルハンドラ (カーネルのプロトコルモジュールなど)  に"
"渡される。"

#. type: Plain text
#: build/C/man7/raw.7:109
msgid ""
"Raw sockets use the standard I<sockaddr_in> address structure defined in "
"B<ip>(7).  The I<sin_port> field could be used to specify the IP protocol "
"number, but it is ignored for sending in Linux 2.2 and should be always set "
"to 0 (see BUGS).  For incoming packets, I<sin_port> is set to the protocol "
"of the packet.  See the I<E<lt>netinet/in.hE<gt>> include file for valid IP "
"protocols."
msgstr ""
"raw ソケットは標準の I<sockaddr_in> アドレス構造体を用いる。定義は B<ip>(7)  "
"でなされている。 I<sin_port> フィールドを IP プロトコル番号の指定に用いること"
"ができるが、 Linux 2.2 ではこれは送信時には無視され、常に 0 にされる (バグ の"
"項を参照)。 受信パケットに対しては、 I<sin_port> はそのパケットのプロトコルに"
"セットされる。 用いることのできる IP プロトコルは、インクルードファイル "
"I<E<lt>netinet/in.hE<gt>> を見よ。"

#.  Or SOL_RAW on Linux
#. type: Plain text
#: build/C/man7/raw.7:118
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""
"raw ソケットのオプションは、 B<IPPROTO_RAW> ファミリーフラグを与えて "
"B<setsockopt>(2)  を呼べば設定でき、 B<getsockopt>(2)  を呼べば取得できる。"

#. type: TP
#: build/C/man7/raw.7:118
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr "B<ICMP_FILTER>"

#. type: Plain text
#: build/C/man7/raw.7:126
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""
"B<IPPROTO_ICMP> プロトコルにバインドされた raw ソケットのための特殊なフィルタ"
"を有効にする。 この値は ICMP メッセージのタイプそれぞれに対して、どれをフィル"
"ターアウト するかを表したビットセットである。デフォルトでは ICMP メッセージは"
"全くフィルターしない。"

#. type: Plain text
#: build/C/man7/raw.7:131
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""
"さらに、データグラムソケットに使える全ての B<ip>(7)  B<SOL_IP> ソケットオプ"
"ションがサポートされている。"

#. type: Plain text
#: build/C/man7/raw.7:144
msgid ""
"Errors originating from the network are passed to the user only when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""
"ネットワークで生じたエラーがユーザに渡されるのは、 ソケットが接続済みの場合"
"か B<IP_RECVERR> フラグが有効になっている場合に限られる。 接続済みのソケット"
"に対しては、 B<EMSGSIZE> および B<EPROTO> だけが渡される (互換性のため)。 "
"B<IP_RECVERR> を設定すると、全てのネットワークエラーがエラーキューに保存され"
"る。"

#. type: Plain text
#: build/C/man7/raw.7:149
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""
"ユーザーが broadcast フラグを設定していないソケットを用いて ブロードキャスト"
"アドレスに送信を行おうとした。"

#. type: Plain text
#: build/C/man7/raw.7:152
msgid "An invalid memory address was supplied."
msgstr "不正なメモリアドレスが与えられた。"

#. type: Plain text
#: build/C/man7/raw.7:162
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64KB."
msgstr ""
"パケットが大きすぎる。 Path MTU Discoverry が有効になっている "
"(B<IP_MTU_DISCOVER> ソケットフラグ) か、パケットのサイズが IPv4 で許されてい"
"る パケットサイズの最大値 64KB を越えている。"

#. type: TP
#: build/C/man7/raw.7:162 build/C/man7/unix.7:364
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man7/raw.7:166
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr "ソケット呼び出しに不正なフラグ (B<MSG_OOB> など) が渡された。"

#. type: Plain text
#: build/C/man7/raw.7:172
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""
"ユーザーは raw ソケットをオープンする権限を持っていない。 実行ユーザー ID が "
"0 のプロセスか、 B<CAP_NET_RAW> 属性を持つプロセスだけがこれを行うことができ"
"る。"

#. type: TP
#: build/C/man7/raw.7:172
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: build/C/man7/raw.7:175
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr "パラメータの問題を報告する ICMP エラーを受け取った。"

#. type: Plain text
#: build/C/man7/raw.7:181
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""
"B<IP_RECVERR> と B<ICMP_FILTER> は Linux 2.2 で登場した。これらは Linux での"
"拡張であり、 移植性の必要なプログラムでは用いるべきでない。"

#. type: Plain text
#: build/C/man7/raw.7:187
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set \\(em since Linux 2.2, "
"this option no longer has that effect."
msgstr ""
"Linux 2.0 では B<SO_BSDCOMPAT> ソケットオプションをセットすると、 BSD の raw "
"ソケットにあるバグに互換性を取ることができた \\(em Linux 2.2 以降では、このオ"
"プションはもはや効力を持たない。"

#. type: Plain text
#: build/C/man7/raw.7:205
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"デフォルトでは、raw ソケットは Path MTU Discovery を行う。 つまり、カーネルは"
"特定の宛先 IP アドレスの MTU (Maximum Transmission Unit; 最大転送単位) を記録"
"し、raw パケットの書き込みが MTU を超えた場合 B<EMSGSIZE> を返す。 "
"B<EMSGSIZE> を返された場合、アプリケーションはパケットサイズを小さくすべきで"
"ある。 ソケットオプション B<IP_MTU_DISCOVER> または I</proc/sys/net/ipv4/"
"ip_no_pmtu_disc> ファイルを使って Path MTU Discovery を無効にすることもでき"
"る (詳細は B<ip>(7)  を参照)。 Path MTU Discovery を無効にした場合は、パケッ"
"トサイズが インタフェースの MTU よりも大きいと raw ソケットはそのパケットを "
"フラグメント化して送出する。 しかしながら、性能と信頼性の理由から Path MTU "
"Discovery を 無効にするのは推奨できない。"

#. type: Plain text
#: build/C/man7/raw.7:214
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a RAW socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""
"B<bind>(2)  システムコールを用いると、 raw ソケットを 特定のローカルアドレス"
"にバインドさせることができる。 このバインドがされていない場合は、指定した IP "
"プロトコルの すべてのパケットが受信される。 さらに、 B<SO_BINDTODEVICE> を用"
"いれば raw ソケットを特定のネットワークデバイスに バインドさせることもでき"
"る。 B<socket>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/raw.7:225
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP "
"packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""
"B<IPPROTO_RAW> ソケットは送信専用である。もしどうしてもすべての IP パケット"
"を 受信したい場合は、 B<packet>(7)  ソケットを B<ETH_P_IP> プロトコルで用いる"
"こと。 packet ソケットは raw ソケットのように IP フラグメントを再構成しないこ"
"とに注意。"

#. type: Plain text
#: build/C/man7/raw.7:231
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""
"datagram ソケットに対するすべての ICMP パケットを受信したい場合は、 特定のソ"
"ケットに対して B<IP_RECVERR> を用いるほうが良い場合が多い。 B<ip>(7)  を見"
"よ。"

#. type: Plain text
#: build/C/man7/raw.7:238
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not "
"be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""
"raw ソケットは、 Linux のすべての IP プロトコルを受信することができる。 ICMP "
"や TCP のように、カーネル内部にプロトコルモジュールを持つような ものも可能で"
"ある。この場合には、パケットはカーネルモジュールと raw ソケットの両方に渡され"
"る (raw ソケットが複数あればそれぞれに渡される)。 移植性の必要なプログラムで"
"はこの機能に依存するべきではない。 他の多くの BSD におけるソケットの実装では"
"この点において制限がある。"

#. type: Plain text
#: build/C/man7/raw.7:243
msgid ""
"Linux never changes headers passed from the user (except for filling in some "
"zeroed fields as described for B<IP_HDRINCL>).  This differs from many other "
"implementations of raw sockets."
msgstr ""
"Linux はユーザーから渡されたヘッダを決して変更しない (ただし B<IP_HDRINCL> の"
"説明にあるように、 0 をいくつか埋める場合を除く)。 これは他の多くの raw ソ"
"ケットの実装では異なる。"

#. type: Plain text
#: build/C/man7/raw.7:246
msgid ""
"RAW sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""
"一般に raw ソケットは移植性がないことが多いので、 移植性が必要なプログラムで"
"は避けるべきである。"

#. type: Plain text
#: build/C/man7/raw.7:252
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""
"raw ソケットへの送信では、 IP プロトコルを I<sin_port> から取得できなければな"
"らない。この機能は Linux 2.2 では使えなくなった。 B<IP_HDRINCL> を用いれば同"
"様のことが実現できる。"

#. type: Plain text
#: build/C/man7/raw.7:254
msgid "Transparent proxy extensions are not described."
msgstr "透過プロクシ (transparent proxy) 拡張については記述していない。"

#. type: Plain text
#: build/C/man7/raw.7:259
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""
"B<IP_HDRINCL> オプションがセットされているとデータグラムはフラグメント化され"
"ず、 インターフェースの MTU の大きさに制限される。"

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/raw.7:269
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""
"送信用の IP プロトコルの設定を I<sin_port> にしておく機能は Linux 2.2 から使"
"えなくなった。 ソケットにバインドされているプロトコルか、最初の B<socket>"
"(2)  コールによって指定されたプロトコルが常に用いられる。"

#. type: Plain text
#: build/C/man7/raw.7:275
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"

#. type: Plain text
#: build/C/man7/raw.7:282
msgid ""
"B<RFC\\ 1191> for path MTU discovery.  B<RFC\\ 791> and the I<E<lt>linux/ip."
"hE<gt>> header file for the IP protocol."
msgstr ""
"Path MTU discovery に関しては B<RFC\\ 1191> を参照。 IP プロトコルに関しては "
"B<RFC\\ 791> とインクルードファイル I<E<lt>linux/ip.hE<gt>> を参照。"

#. type: TH
#: build/C/man3/rcmd.3:43
#, no-wrap
msgid "RCMD"
msgstr "RCMD"

#. type: TH
#: build/C/man3/rcmd.3:43
#, no-wrap
msgid "2012-04-23"
msgstr "2012-04-23"

#. type: Plain text
#: build/C/man3/rcmd.3:48
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, \n"
"ruserok_af - リモートコマンドにストリームを返す関数群"

#. type: Plain text
#: build/C/man3/rcmd.3:51
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems */\n"
msgstr "B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems */\n"

#. type: Plain text
#: build/C/man3/rcmd.3:54
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, int >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""
"B<int rcmd(char **>I<ahost>B<, int >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:56
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr "B<int rresvport(int *>I<port>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:59
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:62
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:66
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rcmd_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:68
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:72
#, no-wrap
msgid ""
"B<int iruserok_af(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int iruserok_af(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:76
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:92
msgid ""
"B<rcmd>(), B<rcmd_af>(), B<rresvport>(), B<rresvport_af>(), B<iruserok>(), "
"B<iruserok_af>(), B<ruserok>(), B<ruserok_af>(): _BSD_SOURCE"
msgstr ""
"B<rcmd>(), B<rcmd_af>(), B<rresvport>(), B<rresvport_af>(),\n"
"B<iruserok>(), B<iruserok_af>(), B<ruserok>(), B<ruserok_af>():\n"
"_BSD_SOURCE"

#. type: Plain text
#: build/C/man3/rcmd.3:113
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a descriptor to a socket with "
"an address in the privileged port space.  The B<iruserok>()  and B<ruserok>"
"()  functions are used by servers to authenticate clients requesting service "
"with B<rcmd>().  All four functions are used by the B<rshd>(8)  server "
"(among others)."
msgstr ""
"B<rcmd>() 関数は、スーパーユーザーがリモートマシンでコマンドを実行する\n"
"ために 用いられる。このとき特権ポート番号をもとにした認証スキームが 用\n"
"いられる。 B<rresvport>() 関数は、特権ポート空間のアドレスを持つソケッ\n"
"トの ディスクリプターを返す。 B<iruserok>() 関数と B<ruserok>() 関数は、\n"
"B<rcmd>() でサービス要求を行ったクライアントの認証を行うために サーバー\n"
"が用いる関数である。 以上の 4 つの関数は、 B<rshd>(8) サーバーによって\n"
"(他の関数とともに) 利用される。"

#. type: SS
#: build/C/man3/rcmd.3:113
#, no-wrap
msgid "rcmd()"
msgstr "rcmd()"

#. type: Plain text
#: build/C/man3/rcmd.3:129
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using B<gethostbyname>"
"(3), returning -1 if the host does not exist.  Otherwise I<*ahost> is set to "
"the standard name of the host and a connection is established to a server "
"residing at the well-known Internet port I<inport>."
msgstr ""
"B<rcmd>()  関数は B<gethostbyname>(3)  を用いて I<*ahost> の参照を行う。ホス"
"トが存在しない場合は -1 を返す。 見つかった場合は I<*ahost> にホストの標準名 "
"(standard name) をセットして、 予約されているインターネットポート I<inport> "
"経由でサーバーへの接続を確立する。"

#. type: Plain text
#: build/C/man3/rcmd.3:158
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be set up, and a descriptor for it will be placed in "
"I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote command) "
"will be made the same as the I<stdout> and no provision is made for sending "
"arbitrary signals to the remote process, although you may be able to get its "
"attention by using out-of-band data."
msgstr ""
"接続に成功したら、インターネットドメインに存在するタイプ B<SOCK_STREAM> のソ"
"ケットが呼び出しもとに返される。 このソケットの相手側はリモートコマンドの "
"I<stdin> および I<stdout> に接続される。 I<fd2p> がゼロでない場合は、制御プロ"
"セスへの接続がもう一つ用意され、 そのディスクリプターが I<*fd2p> にセットされ"
"る。 制御プロセスはリモートコマンドからの標準エラー出力 (unit 2) を このチャ"
"ンネルに返す。 また制御プロセスはこの接続から受け取ったバイトデータを UNIX シ"
"グナルの番号として扱い、リモートコマンドのプロセス グループへとシグナルを送"
"る。 I<fd2p> がゼロの場合は、 I<stderr> (リモートコマンドの unit 2) は "
"I<stdout> と一緒にまとめられる。またこの場合はリモートプロセスへ 任意のシグナ"
"ルを送ることはできなくなる。 ただし帯域外 (out-of-band) データを用いれば、 リ"
"モートプロセスの注意を引くことはできるかもしれない。"

#. type: Plain text
#: build/C/man3/rcmd.3:161
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr "プロトコルの詳細は B<rshd>(8)  に記述されている。"

#. type: SS
#: build/C/man3/rcmd.3:161
#, no-wrap
msgid "rresvport()"
msgstr "rresvport()"

#. type: Plain text
#: build/C/man3/rcmd.3:183
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several "
"other functions.  Privileged ports are those in the range 0 to 1023.  Only a "
"privileged process (B<CAP_NET_BIND_SERVICE>)  is allowed to bind to a "
"privileged port.  In the glibc implementation, this function restricts its "
"search to the ports from 512 to 1023.  The I<port> argument is value-result: "
"the value it supplies to the call is used as the starting point for a "
"circular search of the port range; on (successful) return, it contains the "
"port number that was bound to."
msgstr ""
"B<rresvport>() 関数は特権ポートにバインドされたソケットを取得するために\n"
"用いられる。 このソケットは B<rcmd>() などの関数での利用に適している。\n"
"インターネットポートの特権ポートは、 0 から 1023 の範囲である。特権プロ\n"
"セス (B<CAP_NET_BIND_SERVICE>) だけが特権ポートをバインドすることができ\n"
"る。 glibc の実装では、この関数は特権ポートの検索範囲を 512 から 1023\n"
"までの範囲に制限している。 I<port> 引き数は入出力両用で使用される。呼び\n"
"出し時にこの引き数で渡された値は特権ポートを巡回検索する際の開始ポイン\n"
"トとして使用され、(成功で) 返る際にはこの引き数にバインドされたポート\n"
"番号が格納される。"

#. type: SS
#: build/C/man3/rcmd.3:183
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr "iruserok() と ruserok()"

#. type: Plain text
#: build/C/man3/rcmd.3:201
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not> "
"the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""
"B<iruserok>()  と B<ruserok>()  関数は、まず以下の引数を取る: リモートホスト "
"(B<iruserok>()  は IP アドレスで、 B<ruserok>()  はホスト名で指定)、 2 つの"
"ユーザー名、ローカルユーザーの名前が スーパーユーザーのものであるかどうかを示"
"すフラグ、である。 もしユーザーがB<スーパーユーザーではない>場合は、これらの"
"関数は I</etc/hosts.equiv> ファイルをチェックする。ファイルが見つからなかった"
"り、 内容のチェックに失敗した場合には、 ローカルユーザーのホームディレクトリ"
"にある I<.rhosts> ファイルをチェックして、サービス要求が許可されているかどう"
"か調べる。"

#. type: Plain text
#: build/C/man3/rcmd.3:217
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other "
"than the user or the superuser, or is writable by anyone other than the "
"owner, the check automatically fails.  Zero is returned if the machine name "
"is listed in the I<hosts.equiv> file, or the host and remote username are "
"found in the I<.rhosts> file; otherwise B<iruserok>()  and B<ruserok>()  "
"return -1.  If the local domain (as obtained from B<gethostname>(2))  is the "
"same as the remote domain, only the machine name need be specified."
msgstr ""
"このファイルが存在しなかったり、 通常ファイル (regular file) ではなかった"
"り、 指定ユーザーまたはスーパーユーザー以外の所有だったり、 所有者以外から書"
"き込み可能だったりした場合には、 このチェックは自動的に失敗する。 マシンの名"
"前が I<hosts.equiv> にリストされていたり、 ホストとリモートユーザーの名前が "
"I<.rhosts> ファイルに書かれていた場合には 0 が返される。 それ以外の場合に"
"は、 B<iruserok>()  と B<ruserok>()  は -1 を返す。 (B<gethostname>(2)  に"
"よって取得される) ローカルドメインがリモートのドメインと同じ場合は、 マシンの"
"名前だけを指定すればよい。"

#. type: Plain text
#: build/C/man3/rcmd.3:223
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used "
"in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""
"リモートホストの IP アドレスがわかっている場合は、 B<ruserok>()  よりも "
"B<iruserok>()B<を用いる方が良いだろう。> B<ruserok>()  はリモートホストの所属"
"するドメインの DNS サーバーが信頼できなくても 使用できるからである。"

#. type: SS
#: build/C/man3/rcmd.3:223
#, no-wrap
msgid "*_af() variants"
msgstr "*_af() 版"

#. type: Plain text
#: build/C/man3/rcmd.3:239
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports "
"the use of B<AF_UNSPEC>."
msgstr ""
"上記で述べた関数は全て IPv4 (B<AF_INET>) ソケットで動作する。\n"
"\"_af\" 版では追加の引き数があり、この引き数でソケットアドレス\n"
"ファミリーを指定できる。これらの関数では、 I<af> 引き数には \n"
"B<AF_INET> か B<AF_INET6> が指定できる。\n"
"B<rcmd_af>() では追加で B<AF_UNSPEC> も指定できる。"

#. type: Plain text
#: build/C/man3/rcmd.3:245
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""
"B<rcmd>()  関数は成功すると有効なソケットディスクリプターを返す。 失敗すると "
"-1 を返し、標準エラー出力に診断メッセージを 表示する。"

#. type: Plain text
#: build/C/man3/rcmd.3:256
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded "
"to mean \"All network ports in use.\""
msgstr ""
"B<rresvport>()  関数は、成功するとバインドされた有効なソケットディスクリプ"
"ターを返す。 失敗すると -1 を返し、グローバル変数 I<errno> をエラーの原因に対"
"応する値にセットする。 エラーコード B<EAGAIN> は、この関数においては「すべて"
"のネットワークポートが使用中」 という意味を表す。"

#. type: Plain text
#: build/C/man3/rcmd.3:262
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr "B<ruserok>() と B<iruserok>() の返り値については、上述の説明を参照。"

#. type: Plain text
#: build/C/man3/rcmd.3:270
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""
"関数 B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(),\n"
"B<ruserok_af>() は glibc バージョン 2.2 以降で提供されている。"

#. type: Plain text
#: build/C/man3/rcmd.3:278
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems.  "
"These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系、Solaris や他の多くのシステムに存在する。\n"
"これらの関数は 4.2BSD で登場した。 \"_af\" が付くバージョンはより最近に\n"
"追加されたもので、あまり多くのシステムには存在しない。"

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: build/C/man3/rcmd.3:285
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""
"B<iruserok>() と B<iruserok_af>() は glibc バージョン 2.12 以降のヘッダ\n"
"でのみ宣言されている。"

#. type: Plain text
#: build/C/man3/rcmd.3:293
msgid ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), B<rlogind>"
"(8), B<rshd>(8)"
msgstr ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), B<rlogind>"
"(8), B<rshd>(8)"

#. type: TH
#: build/C/man5/resolv.conf.5:23
#, no-wrap
msgid "RESOLV.CONF"
msgstr "RESOLV.CONF"

#. type: TH
#: build/C/man5/resolv.conf.5:23 build/C/man7/udp.7:12
#, no-wrap
msgid "2013-07-31"
msgstr "2013-07-31"

#. type: Plain text
#: build/C/man5/resolv.conf.5:27
msgid "resolv.conf - resolver configuration file"
msgstr "resolv.conf - レゾルバ設定ファイル"

#. type: Plain text
#: build/C/man5/resolv.conf.5:29
msgid "B</etc/resolv.conf>"
msgstr "B</etc/resolv.conf>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:38
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to "
"the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information."
msgstr ""
"I<resolver> は、インターネットのドメインネームシステム (DNS) へのアクセスを提"
"供する C ライブラリのルーチン群である。 レゾルバ設定ファイルには、レゾルバ"
"ルーチンがプロセスによって最初に 起動されたときに読み込まれる情報が格納されて"
"いる。 このファイルは人間に可読なように設計されている。 キーワードと値のリス"
"トが含まれ、いろいろなタイプのレゾルバ情報を提供する。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:43
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried; the domain name is determined from the hostname and the domain "
"search path is constructed from the domain name."
msgstr ""
"このファイルが存在しない場合、問い合わせはローカルマシン上の\n"
"ネームサーバに対してのみ行われる。ドメイン名はホスト名から決定され、\n"
"ドメインの検索パスはドメイン名から作成される。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:45
msgid "The different configuration options are:"
msgstr "この状態を変更するための設定オプションには、以下のようなものがある。"

#. type: TP
#: build/C/man5/resolv.conf.5:45
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr "B<nameserver> ネームサーバの IP アドレス"

#. type: Plain text
#: build/C/man5/resolv.conf.5:62
msgid ""
"Internet address of a name server that the resolver should query, either an "
"IPv4 address (in dot notation), or an IPv6 address in colon (and possibly "
"dot) notation as per RFC 2373.  Up to B<MAXNS> (currently 3, see "
"I<E<lt>resolv.hE<gt>>) name servers may be listed, one per keyword.  If "
"there are multiple servers, the resolver library queries them in the order "
"listed.  If no B<nameserver> entries are present, the default is to use the "
"name server on the local machine.  (The algorithm used is to try a name "
"server, and if the query times out, try the next, until out of name servers, "
"then repeat trying all the name servers until a maximum number of retries "
"are made.)"
msgstr ""
"レゾルバが問い合わせをするネームサーバのインターネットアドレス。 アドレスに"
"は IPv4 アドレスか IPv6 アドレスを指定する。 IPv4 アドレスはドット表記で、 "
"IPv6 アドレスは RFC 2373 で定められたコロン表記 (おそらくドット表記も可) で指"
"定する。 このキーワード 1 つごとに 1 台づつ、 B<MAXNS> 台 (現状では 3 台、"
"I<E<lt>resolv.hE<gt>> を参照) までのネームサーバをリストできる。 複数のサーバ"
"が指定された場合、レゾルバライブラリは リストされた順に問い合わせを行う。 "
"B<nameserver> エントリがない場合、 デフォルトではローカルマシン上のネームサー"
"バが使われる。 (ここで使われるアルゴリズムは以下のようなものである。 はじめに"
"ネームサーバに問い合わせを試みる。 この問い合わせがタイムアウトになった場"
"合、 次のネームサーバに問い合わせを試みる。 これをネームサーバがなくなるまで"
"続ける。 それでも応答がない場合は、リトライ最大回数に達するまで 全てのネーム"
"サーバに問い合わせを繰り返す。)"

#. type: TP
#: build/C/man5/resolv.conf.5:62
#, no-wrap
msgid "B<domain> Local domain name."
msgstr "B<domain> ローカルドメイン名"

#. type: Plain text
#: build/C/man5/resolv.conf.5:73
msgid ""
"Most queries for names within this domain can use short names relative to "
"the local domain.  If set to \\(aq.\\(aq, the root domain is considered.  If "
"no B<domain> entry is present, the domain is determined from the local "
"hostname returned by B<gethostname>(2); the domain part is taken to be "
"everything after the first \\(aq.\\(aq.  Finally, if the hostname does not "
"contain a domain part, the root domain is assumed."
msgstr ""
"このドメインにある名前の問い合わせのほとんどに、 このローカルドメインに対する"
"短い名前を使用することができる。 \\(aq.\\(aq が設定された場合、 ルートドメイ"
"ンが指定されたとみなされる。 B<domain> エントリがない場合、ドメイン名は "
"B<gethostname>(2)  で返されるローカルホスト名から決定され、 最初の \\(aq."
"\\(aq 以降の全ての部分がドメイン名とされる。 このホスト名にもドメイン部を含ん"
"でいない場合、ルートドメインが仮定される。"

#. type: TP
#: build/C/man5/resolv.conf.5:73
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr "B<search> ホスト名ルックアップのための検索リスト"

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: build/C/man5/resolv.conf.5:103
msgid ""
"The search list is normally determined from the local domain name; by "
"default, it contains only the local domain name.  This may be changed by "
"listing the desired domain search path following the I<search> keyword with "
"spaces or tabs separating the names.  Resolver queries having fewer than "
"I<ndots> dots (default is 1) in them will be attempted using each component "
"of the search path in turn until a match is found.  For environments with "
"multiple subdomains please read B<options ndots:>I<n> below to avoid man-in-"
"the-middle attacks and unnecessary traffic for the root-dns-servers.  Note "
"that this process may be slow and will generate a lot of network traffic if "
"the servers for the listed domains are not local, and that queries will time "
"out if no server is available for one of the domains."
msgstr ""
"検索リストは通常ローカルドメイン名から決定される。 デフォルトでは、検索リスト"
"はローカルドメイン名のみである。 これを変更するには、I<search> キーワードの後"
"に 希望するドメイン検索パスをスペースまたはタブで区切ってリストすればよい。 "
"ドットの数が I<ndots> (デフォルトでは 1) より少ないレゾルバの問い合わせは、 "
"一致するものが見つかるまで検索パスの各要素を順に使って試す。 複数のサブドメイ"
"ンを持つ環境では、 第三者による攻撃 (man-in-the-middle attack) と ルート DNS "
"サーバへの不必要なトラフィックを避けるために、 以下の B<options ndots:>I<n> "
"を読んでほしい。 このプロセスは遅く、リストされたドメインがローカルのものでな"
"い場合、 多大なネットワークトラフィックを発生させることに注意すること。 さら"
"に、これらのドメインのいずれかひとつにでも適切なサーバがない場合、 問い合わせ"
"がタイムアウトになる点にも注意すること。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:106
msgid ""
"The search list is currently limited to six domains with a total of 256 "
"characters."
msgstr "現状では、検索リストは 6 ドメイン・計 256 文字に制限されている。"

#. type: TP
#: build/C/man5/resolv.conf.5:106
#, no-wrap
msgid "B<sortlist>"
msgstr "B<sortlist>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:119
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted.  "
"A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and "
"optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""
"このオプションを使うと、 B<gethostbyname>(3)  で返されるアドレスをソートさせ"
"ることができる。 sortlist は IP アドレスとネットマスクのペアで指定される。 "
"ネットマスクは省略可能であり、 デフォルトではネットに対するデフォルトのネット"
"マスクである。 IP アドレスとオプションのネットマスクのペアはスラッシュで区切"
"る。 最大 10 組のペアを指定できる。 以下に例を示す。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:122
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"

#. type: TP
#: build/C/man5/resolv.conf.5:124
#, no-wrap
msgid "B<options>"
msgstr "B<options>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:128
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""
"options により、レゾルバの内部変数を変更することができる。 書式は以下の通りで"
"ある。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:131
msgid "B<options> I<option> I<...>"
msgstr "B<options> I<option> I<...>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:133
msgid "where I<option> is one of the following:"
msgstr "ここで I<option> は次のうちのいずれかである。"

#. type: TP
#: build/C/man5/resolv.conf.5:133
#, no-wrap
msgid "B<debug>"
msgstr "B<debug>"

#.  Since glibc 2.2?
#. type: Plain text
#: build/C/man5/resolv.conf.5:142
msgid ""
"sets B<RES_DEBUG> in I<_res.options> (effective only if glibc was built with "
"debug support; see B<resolver>(3))."
msgstr ""
"B<RES_DEBUG> を I<_res.options> にセットする (glibc がデバッグを有効にしてコ"
"ンパイルされている場合にのみ有効である; B<resolver>(3) を参照)。"

#. type: TP
#: build/C/man5/resolv.conf.5:142
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr "B<ndots:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:156
msgid ""
"sets a threshold for the number of dots which must appear in a name given to "
"B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots "
"in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""
"「I<最初の完全な名前での問い合わせ>が実行される前に、 B<res_query>(3)  "
"(B<resolver>(3)  を参照) に与えられる名前に含まれているべきドットの数の閾値」"
"を設定する。 I<n> のデフォルトは 1 である。 これは、名前にドットがある場合、"
"I<search list> の要素が付加される前に、 その名前が完全な名前として最初に試さ"
"れるということを意味している。 このオプションの値の上限は 15 であり、黙ってこ"
"の値まで切り詰められる。"

#. type: TP
#: build/C/man5/resolv.conf.5:156
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr "B<timeout:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:167
msgid ""
"sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server.  Measured "
"in seconds, the default is B<RES_TIMEOUT> (currently 5, see I<E<lt>resolv."
"hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""
"「レゾルバが他のネームサーバで問い合わせをリトライする前に、 リモートネーム"
"サーバからの応答を待つ時間」を設定する。 単位は秒で、デフォルトは "
"B<RES_TIMEOUT> である (現状では 5 秒、I<E<lt>resolv.hE<gt>> を参照)。 このオ"
"プションの値の上限は 30 であり、黙ってこの値まで切り詰められる。"

#. type: TP
#: build/C/man5/resolv.conf.5:167
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr "B<attempts:>I<n>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:176
msgid ""
"sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""
"「レゾルバが諦めて呼び出し元のアプリケーションにエラーを返すまでに、 ネーム"
"サーバに問い合わせを行う回数」を設定する。 デフォルトは B<RES_DFLRETRY> 回で"
"ある (現状では 2 回、I<E<lt>resolv.hE<gt>> を参照)。 このオプションの値の上限"
"は 5 であり、黙ってこの値まで切り詰められる。"

#. type: TP
#: build/C/man5/resolv.conf.5:176
#, no-wrap
msgid "B<rotate>"
msgstr "B<rotate>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:186
msgid ""
"sets B<RES_ROTATE> in I<_res.options>, which causes round-robin selection of "
"nameservers from among those listed.  This has the effect of spreading the "
"query load among all listed servers, rather than having all clients try the "
"first listed server first every time."
msgstr ""
"I<_res.options> に RES_ROTATE を設定する。リストされているネームサーバから選"
"ぶときに、ラウンドロビン (round-robin) 選択を行わせる。リストされている全ての"
"サーバで問い合わせの負荷を分散する効果があり、最初にリストされたサーバに全て"
"のクライアントが毎回最初に問い合わせを行うわけではなくなる。"

#. type: TP
#: build/C/man5/resolv.conf.5:186
#, no-wrap
msgid "B<no-check-names>"
msgstr "B<no-check-names>"

#.  since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:196
msgid ""
"sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as "
"underscore (_), non-ASCII, or control characters."
msgstr ""
"I<_res.options> に B<RES_NOCHECKNAME> を設定する。 入ってくるホスト名とメール"
"アドレスに、 アンダースコア (_)・ASCII 以外の文字・制御文字といった 不正な文"
"字が含まれていないかを調べる 最近の BIND のチェックを無効にする。"

#. type: TP
#: build/C/man5/resolv.conf.5:196
#, no-wrap
msgid "B<inet6>"
msgstr "B<inet6>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:207
msgid ""
"sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying a "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists."
msgstr ""
"I<_res.options> に B<RES_USE_INET6> を設定する。このオプションが設定される"
"と、 B<gethostbyname>(3)  関数の内部で A レコードの問い合わせを行う前に AAAA "
"レコードの問い合わせを行うようになる。 また、AAAA レコードは見つからないが A "
"レコードセットが存在する場合に、 IPv4 の応答を IPv6「トンネル形式」にマップす"
"るようになる。"

#. type: TP
#: build/C/man5/resolv.conf.5:207
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4)"
msgstr "B<ip6-bytestring> (glibc 2.3.4 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:216
msgid ""
"sets B<RES_USE_BSTRING> in I<_res.options>.  This causes reverse IPv6 "
"lookups to be made using the bit-label format described in RFC\\ 2673; if "
"this option is not set, then nibble format is used."
msgstr ""
"I<_res.options> に B<RES_USE_BSTRING> を設定する。このオプションが設定される"
"と、IPv6 アドレスの逆引きで RFC\\ 2673 で規定された bit-label 形式が使用され"
"るようになる。 このオプションが設定されない場合、nibble 形式が使用される。"

#. type: TP
#: build/C/man5/resolv.conf.5:216
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (since glibc 2.3.4)"
msgstr "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:233
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  I<ip6."
"int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 lookups "
"are made in the I<ip6.arpa> zone by default.  This option is set by default."
msgstr ""
"I<_res.options> への B<RES_NOIP6DOTINT> のセット/クリアを行う。 このオプショ"
"ンがクリアされると (B<ip6-dotint>)、 IPv6 アドレスの逆引きが (非推奨の)  "
"I<ip6.int> ゾーンで行われるようになり、 このオプションがセットされると (B<no-"
"ip6-dotint>)、 IPv6 アドレスの逆引きがデフォルトの I<ip6.arpa> ゾーンで行われ"
"るようになる。 このオプションはデフォルトでセットされる。"

#. type: TP
#: build/C/man5/resolv.conf.5:233
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr "B<edns0> (glibc 2.6 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:240
msgid ""
"sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""
"I<_res.options> に B<RES_USE_EDNSO> をセットする。これにより、RFC\\ 2671 で規"
"定されている DNS 拡張のサポートが有効になる。"

#. type: TP
#: build/C/man5/resolv.conf.5:240
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr "B<single-request> (glibc 2.10 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:253
msgid ""
"sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and "
"IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""
"I<_res.options> に B<RES_SNGLKUP> をセットする。\n"
"glibc バージョン 2.9 以降では、 glibc はデフォルトでは\n"
"IPv4 と IPv6 の検索を並行して実行する。\n"
"アプライアンス DNS サーバの中には、このような問い合わせを\n"
"適切に処理できず、検索要求がタイムアウトになってしまう。\n"
"このオプションをセットすると、このデフォルトの動作が無効になり、\n"
"glibc は IPv6 と IPv4 の検索を順番に実行するようになる\n"
"(名前解決処理が若干遅くなるというデメリットがある)。"

#. type: TP
#: build/C/man5/resolv.conf.5:253
#, no-wrap
msgid "B<single-request-reopen> (since glibc 2.9)"
msgstr "B<single-request-reopen> (glibc 2.9 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:261
msgid ""
"The resolver uses the same socket for the A and AAAA requests.  Some "
"hardware mistakenly sends back only one reply.  When that happens the client "
"system will sit and wait for the second reply.  Turning this option on "
"changes this behavior so that if two requests from the same port are not "
"handled correctly it will close the socket and open a new one before sending "
"the second request."
msgstr ""
"リゾルバは同じソケットを使って A レコードと AAAA レコードの検索要求を行う。 "
"いくつかのハードウェアは実装が間違っており、応答を一つしか返さない。 この状況"
"になると、クライアントシステムは 2 番目の応答を待ち続けてしまう。 このオプ"
"ションを有効にすると、この動作が変更され、 同じポートからの 2 つの検索要求が"
"正しく処理されなかった場合、 2 番目の検索要求を送信する前にソケットをクローズ"
"し 新しいソケットをオープンするようになる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:266
msgid ""
"The I<domain> and I<search> keywords are mutually exclusive.  If more than "
"one instance of these keywords is present, the last instance wins."
msgstr ""
"I<domain> と I<search> キーワードは、互いに排他的である。 これらのキーワード"
"が 2 つ以上記述されている場合、 最後に記述されているものが有効になる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:271
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on "
"a per-process basis by setting the environment variable B<LOCALDOMAIN> to a "
"space-separated list of search domains."
msgstr ""
"システムの I<resolv.conf> ファイルにある I<search> キーワードは、 スペースで"
"区切った検索ドメインのリストを 環境変数 B<LOCALDOMAIN> に設定することにより、"
"各プロセス毎に上書きすることができる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:277
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a "
"per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under B<options>."
msgstr ""
"システムの I<resolv.conf> ファイルにある I<options> キーワードは、 上の "
"B<options> セクションで説明したように、 スペースで区切ったレゾルバオプション"
"のリストを 環境変数 B<RES_OPTIONS> に設定することにより、各プロセス毎に修正す"
"ることができる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:281
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""
"キーワードと値は同じ行に書かなければならない。 また、(B<nameserver> のよう"
"な) キーワードが行の先頭になければならない。 値はキーワードの後にスペースで区"
"切って続ける。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:284
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr "セミコロン (;) かハッシュ文字 (#) で始まる行はコメントとして扱われる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:287
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:292
msgid "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"
msgstr "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:294
msgid "Name Server Operations Guide for BIND"
msgstr "BIND のネームサーバオペレーションガイド"

#. type: TH
#: build/C/man3/resolver.3:32
#, no-wrap
msgid "RESOLVER"
msgstr "RESOLVER"

#. type: TH
#: build/C/man3/resolver.3:32
#, no-wrap
msgid "2013-03-05"
msgstr "2013-03-05"

#. type: Plain text
#: build/C/man3/resolver.3:36
msgid ""
"res_init, res_query, res_search, res_querydomain, res_mkquery, res_send, "
"dn_comp, dn_expand - resolver routines"
msgstr ""
"res_init, res_query, res_search, res_querydomain, res_mkquery, res_send, "
"dn_comp, dn_expand - レゾルバ・ルーチン"

#. type: Plain text
#: build/C/man3/resolver.3:42
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
"B<extern struct state _res;>\n"
msgstr ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
"B<extern struct state _res;>\n"

#. type: Plain text
#: build/C/man3/resolver.3:44
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr "B<int res_init(void);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:46
#, no-wrap
msgid "B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
msgstr "B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:48 build/C/man3/resolver.3:53
#, no-wrap
msgid "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:51
#, no-wrap
msgid "B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
msgstr "B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:56
#, no-wrap
msgid "B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
msgstr "B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:59
#, no-wrap
msgid ""
"B<int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<int >I<anslen>B<);>\n"
msgstr ""
"B<int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:62
#, no-wrap
msgid "B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
msgstr "B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:65
#, no-wrap
msgid ""
"B<int >I<type>B<, char *>I<data>B<, int >I<datalen>B<, struct rrec *>I<newrr>B<,>\n"
"B<char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<int >I<type>B<, char *>I<data>B<, int >I<datalen>B<, struct rrec *>I<newrr>B<,>\n"
"B<char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:68
#, no-wrap
msgid "B<int res_send(const char *>I<msg>B<, int >I<msglen>B<, char *>I<answer>B<,>\n"
msgstr "B<int res_send(const char *>I<msg>B<, int >I<msglen>B<, char *>I<answer>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:70
#, no-wrap
msgid "B<int >I<anslen>B<);>\n"
msgstr "B<int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:73
#, no-wrap
msgid "B<int dn_comp(unsigned char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
msgstr "B<int dn_comp(unsigned char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:75
#, no-wrap
msgid "B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char **>I<lastdnptr>B<);>\n"
msgstr "B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char **>I<lastdnptr>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:78
#, no-wrap
msgid "B<int dn_expand(unsigned char *>I<msg>B<, unsigned char *>I<eomorig>B<,>\n"
msgstr "B<int dn_expand(unsigned char *>I<msg>B<, unsigned char *>I<eomorig>B<,>\n"

#. type: Plain text
#: build/C/man3/resolver.3:81
#, no-wrap
msgid ""
"B<unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<int >I<length>B<);>\n"
msgstr ""
"B<unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<int >I<length>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:85
msgid "Link with I<-lresolv>."
msgstr "I<-lresolv> でリンクする。"

#. type: Plain text
#: build/C/man3/resolver.3:88
msgid ""
"These functions make queries to and interpret the responses from Internet "
"domain name servers."
msgstr ""
"これらの関数はインターネットのドメインネームサーバーに問い合わせ、 その応答を"
"解釈する。"

#. type: Plain text
#: build/C/man3/resolver.3:102
msgid ""
"The B<res_init>()  function reads the configuration files (see B<resolv.conf>"
"(5))  to get the default domain name, search order and name server address"
"(es).  If no server is given, the local host is tried.  If no domain is "
"given, that associated with the local host is used.  It can be overridden "
"with the environment variable B<LOCALDOMAIN>.  B<res_init>()  is normally "
"executed by the first call to one of the other functions."
msgstr ""
"B<res_init>()  関数は、デフォルトのドメイン名、検索順、ネームサーバー アドレ"
"スを得るために設定ファイル (B<resolv.conf>(5) 参照) を読む。 もしサーバーが示"
"されていなければローカルホストを試す。 ドメインが示されていなければローカルホ"
"ストに付けられたドメインを用いる。 環境変数 B<LOCALDOMAIN> でオーバーライドで"
"きる。 B<res_init>()  は、後述する関数のどれかが最初に呼び出された時、その関"
"数 から実行される。"

#. type: Plain text
#: build/C/man3/resolver.3:110
msgid ""
"The B<res_query>()  function queries the name server for the fully qualified "
"domain name I<name> of specified I<type> and I<class>.  The reply is left in "
"the buffer I<answer> of length I<anslen> supplied by the caller."
msgstr ""
"B<res_query>()  関数は、指定された I<type> と I<class> の 完全修飾ドメイン名 "
"(FQDN) I<name> を、ネームサーバーへ問い合わせる。 応答は、呼び出した側によっ"
"て用意される長さ I<anslen> の I<answer> バッファーに残される。"

#. type: Plain text
#: build/C/man3/resolver.3:123
msgid ""
"The B<res_search>()  function makes a query and waits for the response like "
"B<res_query>(), but in addition implements the default and search rules "
"controlled by B<RES_DEFNAMES> and B<RES_DNSRCH> (see description of I<_res> "
"options below)."
msgstr ""
"B<res_search>()  関数は、問い合わせを行い B<res_query>()  同様その応答を 待つ"
"が、さらにデフォルトを実装しており B<RES_DEFNAMES> と B<RES_DNSRCH> によって"
"規定される検索ルールを適用する。 (下記 I<_res> オプションの説明を参照)"

#. type: Plain text
#: build/C/man3/resolver.3:129
msgid ""
"The B<res_querydomain>()  function makes a query using B<res_query>()  on "
"the concatenation of I<name> and I<domain>."
msgstr ""
"B<res_querydomain>()  関数は I<name> と I<domain> の結合に B<res_query>()  を"
"用いて問い合わせを行う。"

#. type: Plain text
#: build/C/man3/resolver.3:132
msgid ""
"The following functions are lower-level routines used by B<res_query>()."
msgstr "次の関数は、 B<res_query>()  で使われる下位ルーチンである。"

#. type: Plain text
#: build/C/man3/resolver.3:143
msgid ""
"The B<res_mkquery>()  function constructs a query message in I<buf> of "
"length I<buflen> for the domain name I<dname>.  The query type I<op> is "
"usually B<QUERY>, but can be any of the types defined in I<E<lt>arpa/nameser."
"hE<gt>>.  I<newrr> is currently unused."
msgstr ""
"B<res_mkquery>()  関数は、ドメイン名 I<dname> の為に、長さ I<buflen> の "
"I<buf> に問い合わせるメッセージを作成する。 問い合わせの型 I<op> は通常 "
"B<QUERY> だが、 I<E<lt>arpa/nameser.hE<gt>> で定義された型のどれでも良い。 "
"I<newrr> は現在使用されていない。"

#. type: Plain text
#: build/C/man3/resolver.3:153
msgid ""
"The B<res_send>()  function sends a preformatted query given in I<msg> of "
"length I<msglen> and returns the answer in I<answer> which is of length "
"I<anslen>.  It will call B<res_init>(), if it has not already been called."
msgstr ""
"B<res_send>()  関数は、長さ I<msglen> の I<msg> に決められた書式 で問い合わ"
"せ、I<answer> に長さ I<anslen> の回答を返す。 まだ呼び出されていなければ "
"B<res_init>()  を呼び出す。"

#. type: Plain text
#: build/C/man3/resolver.3:166
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""
"B<dn_comp>()  関数はドメイン名 I<exp_dn> を圧縮して、長さ I<length> のバッ"
"ファー I<comp_dn> に保存する。 圧縮にはポインター配列 I<dnptrs> を用いる。 こ"
"れらのポインターは、現在のメッセージの中にある以前に圧縮された名前を指す。 最"
"初のポインターはメッセージの冒頭を指し、そのリストは NULL で終わる。 配列の範"
"囲は I<lastdnptr> で決められる。 I<dnptr> が NULL ならばドメイン名は圧縮され"
"ない。 I<lastdnptr> が NULL ならば、そのラベルのリストはアップデートされな"
"い。"

#. type: Plain text
#: build/C/man3/resolver.3:175
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""
"B<dn_expand>()  関数は、圧縮されたドメイン名 I<comp_dn> からサイズ が "
"I<length> の I<exp_dn> バッファーに正式なドメイン名を展開する。 その圧縮され"
"た名前は、問い合わせ、または応答メッセージに含まれていて、 I<msg> がメッセー"
"ジの冒頭を指す。"

#. type: Plain text
#: build/C/man3/resolver.3:183
msgid ""
"The resolver routines use global configuration and state information "
"contained in the structure I<_res>, which is defined in I<E<lt>resolv."
"hE<gt>>.  The only field that is normally manipulated by the user is I<_res."
"options>.  This field can contain the bitwise \"OR\" of the following "
"options:"
msgstr ""
"レゾルバ・ルーチンは、I<E<lt>resolv.hE<gt>> に定義された I<_res> 構造体に 含"
"まれている全体的な設定と状態の情報を使用する。 通常ユーザーに操作できる項目"
"は I<_res.options> だけである。 この項目は以下のオプションのビット単位の論理"
"和にできる。"

#. type: TP
#: build/C/man3/resolver.3:183
#, no-wrap
msgid "B<RES_INIT>"
msgstr "B<RES_INIT>"

#. type: Plain text
#: build/C/man3/resolver.3:188
msgid "True if B<res_init>()  has been called."
msgstr "B<res_init>()  が呼び出されていれば真。"

#. type: TP
#: build/C/man3/resolver.3:188
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr "B<RES_DEBUG>"

#.  See resolv/README.
#.  Support for RES_DEBUG was made conditional in glibc 2.2.
#. type: Plain text
#: build/C/man3/resolver.3:195
msgid ""
"Print debugging messages.  This option is available only if glibc was built "
"with debugging enabled, which is not the default."
msgstr ""
"デバッグ情報を表示する。このオプションは、 glibc がデバッグを有効にしてコンパ"
"イルされている場合にのみ利用できる。 デフォルトでは glibc のデバッグは有効に"
"なっていない。"

#. type: TP
#: build/C/man3/resolver.3:195
#, no-wrap
msgid "B<RES_AAONLY>"
msgstr "B<RES_AAONLY>"

#. type: Plain text
#: build/C/man3/resolver.3:202
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  [Not currently implemented]."
msgstr ""
"権威付けされた (authoritative) 回答のみ受け入れる。 B<res_send>()  は、最終的"
"に権威付けされた回答を得られるか、エラーが返される まで続行する。 [現在実装さ"
"れていない]"

#. type: TP
#: build/C/man3/resolver.3:202
#, no-wrap
msgid "B<RES_USEVC>"
msgstr "B<RES_USEVC>"

#. type: Plain text
#: build/C/man3/resolver.3:205
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr "問い合わせに UDP データグラムではなく TCP 接続を用いる。"

#. type: TP
#: build/C/man3/resolver.3:205
#, no-wrap
msgid "B<RES_PRIMARY>"
msgstr "B<RES_PRIMARY>"

#. type: Plain text
#: build/C/man3/resolver.3:208
msgid "Query primary domain name server only."
msgstr "プライマリ・ドメインネームサーバーのみ問い合わせる。"

#. type: TP
#: build/C/man3/resolver.3:208
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr "B<RES_IGNTC>"

#. type: Plain text
#: build/C/man3/resolver.3:213
msgid ""
"Ignore truncation errors.  Don't retry with TCP.  [Not currently "
"implemented]."
msgstr ""
"切り詰めエラー (truncation error) を無視する。TCP でリトライしない。 [現在実"
"装されていない]"

#. type: TP
#: build/C/man3/resolver.3:213
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr "B<RES_RECURSE>"

#. type: Plain text
#: build/C/man3/resolver.3:220
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""
"再帰要求 (recursion desired) ビットを問い合わせに設定する。 再帰は "
"B<res_send>()  ではなくドメインネームサーバーによって行われる。 [デフォルトで"
"有効]"

#. type: TP
#: build/C/man3/resolver.3:220
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr "B<RES_DEFNAMES>"

#. type: Plain text
#: build/C/man3/resolver.3:227
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names, i.e., those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""
"設定されていれば、 B<res_search>()  はデフォルトのドメイン名を一部分 のみから"
"なる名前、すなわちドットを含まない名前に付け加える。 [デフォルトで有効]"

#. type: TP
#: build/C/man3/resolver.3:227
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr "B<RES_STAYOPEN>"

#. type: Plain text
#: build/C/man3/resolver.3:232
msgid "Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr "問い合わせ中に TCP 接続を保つため B<RES_USEVC> と共に用いられる。"

#. type: TP
#: build/C/man3/resolver.3:232
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr "B<RES_DNSRCH>"

#. type: Plain text
#: build/C/man3/resolver.3:241
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and "
"in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled by "
"default]."
msgstr ""
"設定されていれば、 B<res_search>()  は現在のドメインおよび親ドメインの ホスト"
"名を探す。このオプションは B<gethostbyname>(3)  で用いられる。 [デフォルトで"
"有効]"

#. type: Plain text
#: build/C/man3/resolver.3:245
msgid ""
"This list is not complete.  You can find some other flags described in "
"B<resolv.conf>(5)."
msgstr ""
"このリストは完全なものではない。\n"
"B<resolv.conf>(5) には他にいくつかのフラグが記載されている。"

#. type: Plain text
#: build/C/man3/resolver.3:250
msgid ""
"The B<res_init>()  function returns 0 on success, or -1 if an error occurs."
msgstr "B<res_init>()  関数は成功すれば 0 を、エラーが発生すれば -1 を返す。"

#. type: Plain text
#: build/C/man3/resolver.3:260
msgid ""
"The B<res_query>(), B<res_search>(), B<res_querydomain>(), B<res_mkquery>()  "
"and B<res_send>()  functions return the length of the response, or -1 if an "
"error occurs."
msgstr ""
"B<res_query>(), B<res_search>(), B<res_querydomain>(), B<res_mkquery>(), "
"B<res_send>()  関数は応答の長さを返す。 また、エラーが発生すれば -1 を返す。"

#. type: Plain text
#: build/C/man3/resolver.3:267
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""
"B<dn_comp>()  と B<dn_expand>()  関数は圧縮されたドメイン名の長さを返す。 ま"
"た、エラーが発生すれば -1 を返す。"

#. type: Plain text
#: build/C/man3/resolver.3:271
#, no-wrap
msgid ""
"/etc/resolv.conf          resolver configuration file\n"
"/etc/host.conf            resolver configuration file\n"
msgstr ""
"/etc/resolv.conf          レゾルバ設定ファイル\n"
"/etc/host.conf            レゾルバ設定ファイル\n"

#. type: Plain text
#: build/C/man3/resolver.3:274
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man3/resolver.3:280
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"

#. type: TH
#: build/C/man3/rexec.3:41
#, no-wrap
msgid "REXEC"
msgstr "REXEC"

#. type: Plain text
#: build/C/man3/rexec.3:44
msgid "rexec, rexec_af - return stream to a remote command"
msgstr "rexec, rexec_af - リモートコマンドへのストリームを返す"

#. type: Plain text
#: build/C/man3/rexec.3:48
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#define _BSD_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/rexec.3:51
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, char *>I<user>B<, >\n"
"B<          char *>I<passwd>B<, char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, char *>I<user>B<, >\n"
"B<          char *>I<passwd>B<, char *>I<cmd>B<, int *>I<fd2p>B<);>\n"

#. type: Plain text
#: build/C/man3/rexec.3:55
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, char *>I<user>B<, >\n"
"B<             char *>I<passwd>B<, char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, char *>I<user>B<, >\n"
"B<             char *>I<passwd>B<, char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rexec.3:59
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr "このインタフェースは B<rcmd>(3)  によって置き換えられた。"

#. type: Plain text
#: build/C/man3/rexec.3:78
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using B<gethostbyname>"
"(3), returning -1 if the host does not exist.  Otherwise I<*ahost> is set to "
"the standard name of the host.  If a username and password are both "
"specified, then these are used to authenticate to the foreign host; "
"otherwise the environment and then the user's I<.netrc> file in his home "
"directory are searched for appropriate information.  If all this fails, the "
"user is prompted for the information."
msgstr ""
"B<rexec>()  関数は B<gethostbyname>(3)  を使ってホスト I<*ahost> を探す。ホス"
"トが存在しない場合は -1 を返し、それ以外の場合には I<*ahost> にそのホストの標"
"準的な名前を設定する。 ユーザ名とパスワードの両方が指定された場合には、これら"
"は 接続先のホストへの認証に利用される。そうでない場合には、 適切な情報を入手"
"するために、環境変数と、そのユーザの ホームディレクトリの I<.netrc> ファイル"
"が検索される。情報が見つからなかった時には、 ユーザに対して情報を入力するプロ"
"ンプトが表示される。"

#. type: Plain text
#: build/C/man3/rexec.3:89
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for "
"the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""
"ポート I<inport> には、接続に使用する DARPA Internet の well-known ポートを指"
"定する。 I<getservbyname(\"exec\", \"tcp\")> を呼び出すと構造体へのポインタが"
"返され (B<getservent>(3)  参照)、この構造体には必要なポートが入っている。 接"
"続に使用されるプロトコルについての詳細は B<rexecd>(8)  に書かれている (訳注: "
"現在のところ存在しない)。"

#. type: Plain text
#: build/C/man3/rexec.3:122
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be setup, and a descriptor for it will be placed in "
"I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  The diagnostic information returned does not include remote "
"authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr ""
"接続に成功すると、インターネットドメインの B<SOCK_STREAM> 型のソケットが返さ"
"れ、そのソケットはリモートコマンドの 標準入力および標準出力となる。 I<fd2p> "
"が 0 以外の場合、制御プロセスへの補助チャンネルがセットアップされ、 補助チャ"
"ンネルのディスクリプタが I<*fd2p> に書かれる。 制御プロセスはコマンドからの診"
"断メッセージ出力 (ファイルディスクリプタ 2)  をこのチャンネルで返す。また、こ"
"のチャンネル経由で UNIX のシグナル番号を示すバイトを受信する。受信したシグナ"
"ルは コマンドが属すプロセスグループに転送される。 診断情報にはリモートの認証"
"失敗は含まれない。なぜなら、認証の確認が行われた 後で補助チャンネルの接続は"
"セットアップされるからである。 I<fd2p> が 0 の場合、標準エラー (リモートコマ"
"ンドのファイルディスクリプタ 2) は 標準出力と同様に扱われ、リモートプロセスに"
"任意のシグナルを送るための 手段は提供されない。但し、リモートプロセスに対して"
"トリガをかけるために、 帯域外データ (out-of-band data) を使うことはできる。"

#. type: SS
#: build/C/man3/rexec.3:122
#, no-wrap
msgid "rexec_af()"
msgstr "rexec_af()"

#. type: Plain text
#: build/C/man3/rexec.3:138
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""
"B<rexec>() 関数は IPv4 (B<AF_INET>) 上で動作する。\n"
"これに対して、 B<rexec_af>() 関数は追加の引き数 I<af> があり、\n"
"この引き数で呼び出し側がプロトコルを選択できる。\n"
"この引き数には B<AF_INET>, B<AF_INET6>, B<AF_UNSPEC> を指定できる\n"
"(B<AF_UNSPEC> は実装側がプロトコルを選択することを意味する)。"

#. type: Plain text
#: build/C/man3/rexec.3:142
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr "B<rexec_af>() 関数は glibc バージョン 2.9 で追加された。"

#. type: Plain text
#: build/C/man3/rexec.3:149
msgid "The B<rexec>()  and B<rexec_af>()  functions are not thread-safe."
msgstr "関数 B<rexec>() と B<rexec_af>() はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/rexec.3:158
msgid ""
"These functions are not in POSIX.1-2001.  The B<rexec>()  function first "
"appeared in 4.2BSD, and is present on the BSDs, Solaris, and many other "
"systems.  The B<rexec_af>()  function is more recent, and less widespread."
msgstr ""
"これらの関数は POSIX.1-2001 にはない。B<rexec>() 関数は 4.2BSD で始めて\n"
"登場し、BSD 系、Solaris や他の多くのシステムに存在する。B<rexec_af>()\n"
"関数はもっと新しく、それほど広く使われているわけではない。"

#. type: Plain text
#: build/C/man3/rexec.3:162
msgid ""
"The B<rexec>()  function sends the unencrypted password across the network."
msgstr ""
"B<rexec>()  関数はネットワークに暗号化されていないパスワードを送信する。"

#. type: Plain text
#: build/C/man3/rexec.3:167
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""
"基礎的なサービスにおいては大きなセキュリティホールと考えられるため、 \n"
"多くのサイトで無効になっている。詳細は B<rexecd>(8) を参照。"

#. type: Plain text
#: build/C/man3/rexec.3:170
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr "B<rcmd>(3), B<rexecd>(8)"

#. type: TH
#: build/C/man5/services.5:34
#, no-wrap
msgid "SERVICES"
msgstr "SERVICES"

#. type: TH
#: build/C/man5/services.5:34
#, no-wrap
msgid "2010-05-22"
msgstr "2010-05-22"

#. type: Plain text
#: build/C/man5/services.5:37
msgid "services - Internet network services list"
msgstr "services - インターネット ネットワークサービス リスト"

#. type: Plain text
#: build/C/man5/services.5:52
msgid ""
"B<services> is a plain ASCII file providing a mapping between human-friendly "
"textual names for internet services, and their underlying assigned port "
"numbers and protocol types.  Every networking program should look into this "
"file to get the port number (and protocol) for its service.  The C library "
"routines B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<setservent>(3), and B<endservent>(3)  support querying this file from "
"programs."
msgstr ""
"B<services> は、人が分かりやすい形のインターネットサービスの名前と、 それらの"
"サービスに割り当てられたポート番号や プロトコル種別の対応関係が書かれているテ"
"キストファイルである。 ネットワーク上で動作するプログラムはすべて、 そのサー"
"ビスに対応するポート番号 (とプロトコル) を得るために、 このファイルを調べる必"
"要がある。 C ライブラリ関数である B<getservent>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<setservent>(3), B<endservent>(3)  を利用することで、プ"
"ログラムはこのファイルを調べることができる。"

#. type: Plain text
#: build/C/man5/services.5:58
msgid ""
"Port numbers are assigned by the IANA (Internet Assigned Numbers Authority), "
"and their current policy is to assign both TCP and UDP protocols when "
"assigning a port number.  Therefore, most entries will have two entries, "
"even for TCP-only services."
msgstr ""
"ポート番号は、IANA (Internet Assigned Numbers Authority) によって 割り当てら"
"れており、現在はポート番号を割り当てる際に TCP と UDP の両方のプロトコルを割"
"り当てることになっている。 そのため、ほとんどのサービスに対して、 たとえ TCP "
"だけのサービスの場合であっても、対応する項目が二つあることになる。"

#. type: Plain text
#: build/C/man5/services.5:70
msgid ""
"Port numbers below 1024 (so-called \"low numbered\" ports) can be bound to "
"only by root (see B<bind>(2), B<tcp>(7), and B<udp>(7)).  This is so clients "
"connecting to low numbered ports can trust that the service running on the "
"port is the standard implementation, and not a rogue service run by a user "
"of the machine.  Well-known port numbers specified by the IANA are normally "
"located in this root-only space."
msgstr ""
"1024 より小さいポート番号 (いわゆる \"low numbered\" ポート) は 管理者 "
"(root) 権限によってのみ使用することができる (B<bind>(2), B<tcp>(7), B<udp>"
"(7)  参照)。 これは、これらのポートに接続するクライアントに対して、 そのポー"
"トで動いているサービスが標準的な実装であり、 その計算機のユーザーが動かしてい"
"る 不正なサービスではないことを保証するためである。 IANA に明記されているよく"
"使用されるポート番号は、 通常このような管理者だけが使用できる範囲に配置され"
"る。"

#. type: Plain text
#: build/C/man5/services.5:85
msgid ""
"The presence of an entry for a service in the B<services> file does not "
"necessarily mean that the service is currently running on the machine.  See "
"B<inetd.conf>(5)  for the configuration of Internet services offered.  Note "
"that not all networking services are started by B<inetd>(8), and so won't "
"appear in B<inetd.conf>(5).  In particular, news (NNTP) and mail (SMTP) "
"servers are often initialized from the system boot scripts."
msgstr ""
"B<services> ファイルにあるサービスに対する項目があっても、必ずしもそのサービ"
"スが現 在その計算機で動いている訳ではない。利用可能なインターネットサービスの"
"設定に ついては B<inetd.conf>(5)  に記述されている。ただし、すべてのサービス"
"が B<inetd>(8)  によって起動されるわけではないので、 B<inetd.conf>(5)  には書"
"かれていないサービスもあることに注意する必要がある。 特に、ネットニュース "
"(NNTP) や メール (SMTP) のサーバーは、システム起動時の スクリプトから起動され"
"ることが多い。"

#. type: Plain text
#: build/C/man5/services.5:94
msgid ""
"The location of the B<services> file is defined by B<_PATH_SERVICES> in "
"I<E<lt>netdb.hE<gt>>.  This is usually set to I</etc/services>."
msgstr ""
"B<services> ファイルの場所は、 I<E<lt>netdb.hE<gt>> 中の B<_PATH_SERVICES> に"
"よって定義されている。 この値は通常 I</etc/services> に設定されている。"

#. type: Plain text
#: build/C/man5/services.5:96
msgid "Each line describes one service, and is of the form:"
msgstr "1 行につき 1 サービスが記述されており、以下の形式である。"

#. type: Plain text
#: build/C/man5/services.5:98
msgid "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"
msgstr "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"

#. type: TP
#: build/C/man5/services.5:98
#, no-wrap
msgid "where:"
msgstr "各項目は以下の通り。"

#. type: TP
#: build/C/man5/services.5:100
#, no-wrap
msgid "I<service-name>"
msgstr "I<service-name>"

#. type: Plain text
#: build/C/man5/services.5:106
msgid ""
"is the friendly name the service is known by and looked up under.  It is "
"case sensitive.  Often, the client program is named after the I<service-"
"name>."
msgstr ""
"サービスを表す分かりやすい名前であり、検索の際にも使用される。 大文字と小文字"
"は区別される。 クライアントプログラムは I<service-name> にちなんで名付けられ"
"ることが多い。"

#. type: TP
#: build/C/man5/services.5:106
#, no-wrap
msgid "I<port>"
msgstr "I<port>"

#. type: Plain text
#: build/C/man5/services.5:109
msgid "is the port number (in decimal) to use for this service."
msgstr "サービスに対して使用されるポート番号。10 進数で指定する。"

#. type: Plain text
#: build/C/man5/services.5:120
msgid ""
"is the type of protocol to be used.  This field should match an entry in the "
"B<protocols>(5)  file.  Typical values include B<tcp> and B<udp>."
msgstr ""
"使用されるプロトコルの種類。この欄は、 B<protocols>(5)  ファイルの中の項目と"
"一致している必要がある。 通常使用される値は、 B<tcp> と B<udp> である。"

#. type: Plain text
#: build/C/man5/services.5:126
msgid ""
"is an optional space or tab separated list of other names for this service.  "
"Again, the names are case sensitive."
msgstr ""
"サービスに対する別名のリスト (区切はスペースまたはタブ) で、この欄は 必要にな"
"らば書くことができる。 また、別名は大文字と小文字は区別される。"

#. type: Plain text
#: build/C/man5/services.5:128
msgid "Either spaces or tabs may be used to separate the fields."
msgstr "それぞれの欄の区切りには、スペースまたはタブが使用される。"

#. type: Plain text
#: build/C/man5/services.5:132
msgid ""
"Comments are started by the hash sign (#) and continue until the end of the "
"line.  Blank lines are skipped."
msgstr ""
"コメントはシャープ (#) で始まり、その行の終わりまでがコメントとみなされる。 "
"空行は飛ばされる。"

#. type: Plain text
#: build/C/man5/services.5:143
msgid ""
"The I<service-name> should begin in the first column of the file, since "
"leading spaces are not stripped.  I<service-names> can be any printable "
"characters excluding space and tab.  However, a conservative choice of "
"characters should be used to minimize compatibility problems.  E.g., a-z, "
"0-9, and hyphen (-) would seem a sensible choice."
msgstr ""
"行の始めのスペースは無視されないので、 I<service-name> は、行頭から書かなけれ"
"ばならない。 I<service-names> は、スペースとタブ以外の印字可能な文字なら何で"
"もよいが、しかしながら 互換性の問題を少なくするような文字を選択すべきであ"
"る。 例えば、a-z 、0-9 、ハイフォン (-) を使用するのが無難と思われる。"

#. type: Plain text
#: build/C/man5/services.5:152
msgid ""
"Lines not matching this format should not be present in the file.  "
"(Currently, they are silently skipped by B<getservent>(3), B<getservbyname>"
"(3), and B<getservbyport>(3).  However, this behavior should not be relied "
"on.)"
msgstr ""
"指定された形式に合わない行はあってはならない (現在は、そのような行は "
"B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3)  によって無視され"
"る。しかし、その場合の挙動は信頼できない)。"

#. type: Plain text
#: build/C/man5/services.5:169
msgid "A sample B<services> file might look like this:"
msgstr "B<services> ファイルの見本を以下に示す。"

#. type: Plain text
#: build/C/man5/services.5:182
#, no-wrap
msgid ""
"CW<netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp>\n"
msgstr ""
"CW<netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp>\n"

#. type: Plain text
#: build/C/man5/services.5:189
msgid "The Internet network services list"
msgstr "インターネット ネットワークサービスのリスト"

#. type: TP
#: build/C/man5/services.5:189
#, no-wrap
msgid "I<E<lt>netdb.hE<gt>>"
msgstr "I<E<lt>netdb.hE<gt>>"

#.  .SH BUGS
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     There is a maximum of 35 aliases, due to the way the
#.     .BR getservent (3)
#.     code is written.
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     Lines longer than
#.     .B BUFSIZ
#.     (currently 1024) characters will be ignored by
#.     .BR getservent (3),
#.     .BR getservbyname (3),
#.     and
#.     .BR getservbyport (3).
#.     However, this will also cause the next line to be mis-parsed.
#. type: Plain text
#: build/C/man5/services.5:210
msgid "Definition of B<_PATH_SERVICES>"
msgstr "B<_PATH_SERVICES> の定義"

#. type: Plain text
#: build/C/man5/services.5:220
msgid ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"
msgstr ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"

#. type: Plain text
#: build/C/man5/services.5:222
msgid "Assigned Numbers RFC, most recently RFC\\ 1700, (AKA STD0002)."
msgstr ""
"ポート番号の割り当てを定めている RFC (最新版は RFC\\ 1700、別名 STD0002)"

#. type: TH
#: build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "SETNETGRENT"
msgstr "SETNETGRENT"

#. type: TH
#: build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: build/C/man3/setnetgrent.3:14
msgid ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - handle "
"network group entries"
msgstr ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - ネットワー"
"ク・グループのエントリを操作する"

#. type: Plain text
#: build/C/man3/setnetgrent.3:19
#, no-wrap
msgid "B<int setnetgrent(const char *>I<netgroup>B<);>\n"
msgstr "B<int setnetgrent(const char *>I<netgroup>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:21
#, no-wrap
msgid "B<void endnetgrent(void);>\n"
msgstr "B<void endnetgrent(void);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:23
#, no-wrap
msgid "B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char **>I<domain>B<);>\n"
msgstr "B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char **>I<domain>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:26
#, no-wrap
msgid ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:29
#, no-wrap
msgid ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"
msgstr ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:43
msgid ""
"B<setnetgrent>(), B<endnetgrent>(), B<getnetgrent>(), B<getnetgrent_r>(), "
"B<innetgr>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr ""
"B<setnetgrent>(), B<endnetgrent>(), B<getnetgrent>(), B<getnetgrent_r>(), "
"B<innetgr>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/setnetgrent.3:57
msgid ""
"The I<netgroup> is a SunOS invention.  A netgroup database is a list of "
"string triples (I<hostname>, I<username>, I<domainname>)  or other netgroup "
"names.  Any of the elements in a triple can be empty, which means that "
"anything matches.  The functions described here allow access to the netgroup "
"databases.  The file I</etc/nsswitch.conf> defines what database is searched."
msgstr ""
"I<netgroup> は SunOS で考案されたものである。ネットグループのデータベースの "
"エントリは、 3 つの文字列のリスト (I<hostname>, I<username>, I<domainname>)  "
"もしくはネットグループ名である。 前記のリストの各要素は空であってもよい。 空"
"は何とでも一致することを意味する。 本ページで説明する関数を使うことで、ネット"
"グループのデータベースに アクセスすることができる。どのデータベースが検索され"
"るかは I</etc/nsswitch.conf> ファイルで定義されている。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:77
msgid ""
"The B<setnetgrent>()  call defines the netgroup that will be searched by "
"subsequent B<getnetgrent>()  calls.  The B<getnetgrent>()  function "
"retrieves the next netgroup entry, and returns pointers in I<host>, I<user>, "
"I<domain>.  A NULL pointer means that the corresponding entry matches any "
"string.  The pointers are valid only as long as there is no call to other "
"netgroup-related functions.  To avoid this problem you can use the GNU "
"function B<getnetgrent_r>()  that stores the strings in the supplied "
"buffer.  To free all allocated buffers use B<endnetgrent>()."
msgstr ""
"B<setnetgrent>()  コールは、この後で呼ばれる B<getnetgrent>()  コールが検索す"
"るネットグループを定める。 B<getnetgrent>()  関数はネットグループの次のエント"
"リを取得し、 I<host>, I<user>, I<domain> にポインタを入れて返る。 NULL ポイン"
"タは、対応するエントリがどんな文字列とも一致することを意味する。 得られたポイ"
"ンタは、ネットグループ関係の関数のいずれかが呼ばれるまでの 間だけ有効である。"
"この問題を避けるためには GNU 拡張の関数 B<getnetgrent_r>()  を使うとよい。こ"
"の関数は呼び出し側が用意したバッファに 文字列を格納する。割り当て済のバッファ"
"を全て解放するには B<endnetgrent>()  を使用する。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:86
msgid ""
"In most cases you want to check only if the triplet (I<hostname>, "
"I<username>, I<domainname>)  is a member of a netgroup.  The function "
"B<innetgr>()  can be used for this without calling the above three "
"functions.  Again, a NULL pointer is a wildcard and matches any string.  The "
"function is thread-safe."
msgstr ""
"ほとんどの場合、 (I<hostname>, I<username>, I<domainname>)  の3要素の組がネッ"
"トグループのメンバーかどうかを確認したいだけであろう。 B<innetgr>()  関数を使"
"うと、上記の3つの関数を呼び出さずにこの目的を達成できる。 もう一度書いておく"
"が、NULL ポインタはワイルドカードであり、 あらゆる文字列と一致する。この関数"
"はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:88
msgid "These functions return 1 on success and 0 for failure."
msgstr "これらの関数は成功すると 1 を、失敗すると 0 を返す。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:90
msgid "I</etc/netgroup>"
msgstr "I</etc/netgroup>"

#.  getnetgrent_r() is on Solaris 8 and AIX 5.1, but not the BSDs.
#. type: Plain text
#: build/C/man3/setnetgrent.3:103
msgid ""
"These functions are not in POSIX.1-2001, but B<setnetgrent>(), B<endnetgrent>"
"(), B<getnetgrent>(), and B<innetgr>()  are available on most UNIX systems.  "
"B<getnetgrent_r>()  is not widely available on other systems."
msgstr ""
"これらの関数は POSIX.1-2001 にはないが、 setnetgrent (), endnetgrent (), "
"getnetgrent (), innetgr ()  はほとんどの UNIX システムで利用可能である。 "
"B<getnetgrent_r>()  は広く他のシステムで利用できるわけではない。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:107
msgid "In the BSD implementation, B<setnetgrent>()  returns void."
msgstr "BSD の実装では B<setnetgrent>()  は void を返す。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:111
msgid "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"
msgstr "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"

#. type: TH
#: build/C/man2/shutdown.2:40
#, no-wrap
msgid "SHUTDOWN"
msgstr "SHUTDOWN"

#. type: TH
#: build/C/man2/shutdown.2:40
#, no-wrap
msgid "2012-09-06"
msgstr "2012-09-06"

#. type: Plain text
#: build/C/man2/shutdown.2:43
msgid "shutdown - shut down part of a full-duplex connection"
msgstr "shutdown - 全二重接続の一部を閉じる"

#. type: Plain text
#: build/C/man2/shutdown.2:47
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"

#. type: Plain text
#: build/C/man2/shutdown.2:69
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>, "
"further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr ""
"B<shutdown>()  は、 I<sockfd> に関連づけられているソケットによる全二重接続 "
"(full-duplex connection)  の一部または全てを閉じる。 I<how> が B<SHUT_RD> な"
"らば、それ以降の受信を禁止する。 I<how> が B<SHUT_WR> ならば、それ以降の送信"
"を禁止する。 I<how> が B<SHUT_RDWR> ならば、それ以降の送受信を禁止する。"

#. type: Plain text
#: build/C/man2/shutdown.2:79
msgid "I<sockfd> is not a valid descriptor."
msgstr "I<sockfd> が有効なディスクリプターでない。"

#. type: Plain text
#: build/C/man2/shutdown.2:84
msgid "An invalid value was specified in I<how> (but see BUGS)."
msgstr "I<how> に無効な値が指定された (バグが参照)。"

#. type: Plain text
#: build/C/man2/shutdown.2:87
msgid "The specified socket is not connected."
msgstr "指定されたソケットは接続されていない。"

#. type: Plain text
#: build/C/man2/shutdown.2:91
msgid "I<sockfd> is a file, not a socket."
msgstr "I<sockfd> がソケットでなくファイルである。"

#. type: Plain text
#: build/C/man2/shutdown.2:95
msgid ""
"POSIX.1-2001, 4.4BSD (the B<shutdown>()  function call first appeared in "
"4.2BSD)."
msgstr ""
"POSIX.1-2001, 4.4BSD (B<shutdown>()  関数コールは 4.2BSD で初めて登場した)。"

#. type: Plain text
#: build/C/man2/shutdown.2:104
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr ""
"B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> の各定数 (それぞれ 0, 1, 2 の値を持つ) "
"は glibc-2.1.91 以降、 I<E<lt>sys/socket.hE<gt>> で定義されている。"

#.  FIXME
#.  https://bugzilla.kernel.org/show_bug.cgi?id=47111
#. type: Plain text
#: build/C/man2/shutdown.2:113
msgid ""
"As currently implemented, checks for the validity of I<how> are done in "
"domain-specific code, and not all domains perform these checks.  Most "
"notably, UNIX domain sockets simply ignore invalid values; this may change "
"in the future."
msgstr ""
"現在の実装では I<how> の妥当性チェックはドメイン固有のコードの中で行われてい"
"るが、 すべてのドメインでこれらのチェックが行われている訳ではない。 中でも注"
"意すべきは、 UNIX ドメインソケットでは無効な値は単に無視される点である。 これ"
"は将来変更されるかもしれない。"

#. type: Plain text
#: build/C/man2/shutdown.2:117
msgid "B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr "B<connect>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man7/tcp.7:65
#, no-wrap
msgid "TCP"
msgstr "TCP"

#. type: TH
#: build/C/man7/tcp.7:65
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: build/C/man7/tcp.7:68
msgid "tcp - TCP protocol"
msgstr "tcp - TCP プロトコル"

#. type: Plain text
#: build/C/man7/tcp.7:74
msgid "B<#include E<lt>netinet/tcp.hE<gt>>"
msgstr "B<#include E<lt>netinet/tcp.hE<gt>>"

#. type: Plain text
#: build/C/man7/tcp.7:76
msgid "B<tcp_socket = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr "B<tcp_socket = socket(AF_INET, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/tcp.7:89
msgid ""
"This is an implementation of the TCP protocol defined in RFC\\ 793, RFC\\ "
"1122 and RFC\\ 2001 with the NewReno and SACK extensions.  It provides a "
"reliable, stream-oriented, full-duplex connection between two sockets on top "
"of B<ip>(7), for both v4 and v6 versions.  TCP guarantees that the data "
"arrives in order and retransmits lost packets.  It generates and checks a "
"per-packet checksum to catch transmission errors.  TCP does not preserve "
"record boundaries."
msgstr ""
"これは RFC\\ 793, RFC\\ 1122, RFC\\ 2001 で定義されている TCP プロトコルを "
"NewReno 拡張と SACK 拡張を含めて実装したものである。 TCP は、 B<ip>(7)  上の"
"二つのソケット間に、信頼性の高い、ストリーム指向の全二重 (full-duplex) 通信を"
"提供する。 v4 と v6 の両方のバージョンの B<ip>(7)  に対応している。 TCP は、"
"データが順序を守って到着すること、途中で失われたパケットが 再送されることを保"
"証する。また、パケット単位にチェックサムを 生成、検査することで、転送エラーを"
"検知する。 TCP はレコード境界 (record boundary) を保存しない。"

#. type: Plain text
#: build/C/man7/tcp.7:108
msgid ""
"A newly created TCP socket has no remote or local address and is not fully "
"specified.  To create an outgoing TCP connection use B<connect>(2)  to "
"establish a connection to another TCP socket.  To receive new incoming "
"connections, first B<bind>(2)  the socket to a local address and port and "
"then call B<listen>(2)  to put the socket into the listening state.  After "
"that a new socket for each incoming connection can be accepted using "
"B<accept>(2).  A socket which has had B<accept>(2)  or B<connect>(2)  "
"successfully called on it is fully specified and may transmit data.  Data "
"cannot be transmitted on listening or not yet connected sockets."
msgstr ""
"新しく生成されたばかりの TCP ソケットは、 リモートアドレスかローカルアドレス"
"がなく、 したがって詳細が完全に指定された状態ではない。 外部への TCP 接続を生"
"成するには、 B<connect>(2)  を用いてもう一方の TCP ソケットへの接続を確立す"
"る。 外部からの新たな接続を受けるには、まず B<bind>(2)  でソケットをローカル"
"なアドレスとポートに結びつけ、次に B<listen>(2)  を呼んでソケットを接続待ち受"
"け状態にする。 その後、到着した接続要求に対して B<accept>(2)  を用い、ソケッ"
"トを新しく生成する。 B<accept>(2)  または B<connect>(2)  のコールが成功したソ"
"ケットは、詳細が完全に指定された状態となり、 データのやりとりが可能となる。接"
"続待ち受け状態の (listening) ソケットや、 接続 (connect) されていないソケット"
"を通してデータをやりとりすることはできない。"

#. type: Plain text
#: build/C/man7/tcp.7:128
msgid ""
"Linux supports RFC\\ 1323 TCP high performance extensions.  These include "
"Protection Against Wrapped Sequence Numbers (PAWS), Window Scaling and "
"Timestamps.  Window scaling allows the use of large (E<gt> 64K) TCP windows "
"in order to support links with high latency or bandwidth.  To make use of "
"them, the send and receive buffer sizes must be increased.  They can be set "
"globally with the I</proc/sys/net/ipv4/tcp_wmem> and I</proc/sys/net/ipv4/"
"tcp_rmem> files, or on individual sockets by using the B<SO_SNDBUF> and "
"B<SO_RCVBUF> socket options with the B<setsockopt>(2)  call."
msgstr ""
"Linux は RFC\\ 1323 の TCP high performance 拡張をサポートしている。 これに"
"は、Protection Against Wrapped Sequence Numbers (PAWS)、 ウィンドウスケーリン"
"グ、タイムスタンプなどが含まれている。 ウィンドウスケーリングを利用すると、遅"
"延または帯域の大きな接続で、 (64K 以上の) 巨大な TCP ウィンドウを用いることが"
"可能となる。 これを用いるには、送受信のバッファサイズを大きくしなければならな"
"い。 システム全体に対するバッファサイズの変更は、ファイル I</proc/sys/net/"
"ipv4/tcp_wmem> と I</proc/sys/net/ipv4/tcp_rmem> を用いて行うことができる。 "
"また、個々のソケットのみを大きくしたい場合には、 B<SO_SNDBUF> や "
"B<SO_RCVBUF> ソケットオプションを用いて B<setsockopt>(2)  コールを用いて設定"
"すればよい。"

#. type: Plain text
#: build/C/man7/tcp.7:159
msgid ""
"The maximum sizes for socket buffers declared via the B<SO_SNDBUF> and "
"B<SO_RCVBUF> mechanisms are limited by the values in the I</proc/sys/net/"
"core/rmem_max> and I</proc/sys/net/core/wmem_max> files.  Note that TCP "
"actually allocates twice the size of the buffer requested in the "
"B<setsockopt>(2)  call, and so a succeeding B<getsockopt>(2)  call will not "
"return the same size of buffer as requested in the B<setsockopt>(2)  call.  "
"TCP uses the extra space for administrative purposes and internal kernel "
"structures, and the I</proc> file values reflect the larger sizes compared "
"to the actual TCP windows.  On individual connections, the socket buffer "
"size must be set prior to the B<listen>(2)  or B<connect>(2)  calls in order "
"to have it take effect.  See B<socket>(7)  for more information."
msgstr ""
"B<SO_SNDBUF> や B<SO_RCVBUF> のメカニズムで宣言されるソケットバッファの最大サ"
"イズは、ファイル I</proc/sys/net/core/rmem_max> や I</proc/sys/net/core/"
"wmem_max> で指定されたシステムとしての制限値を超えることはできない。 TCP は実"
"際には B<setsockopt>(2)  コールが要求したバッファサイズの二倍を割り当てる。 "
"そのため、この後で B<getsockopt>(2)  コールを行うと、 B<setsockopt>(2)  で要"
"求したバッファサイズとは異なる値が返る。 TCP はこの余分な空間を、管理目的や"
"カーネル内部の構造体に用いている。 I</proc> ファイルの値は、これらを反映し、"
"実際の TCP ウィンドウよりも大きな値となる。 各接続におけるソケットのバッファ"
"サイズ変更を有効にするには、 B<listen>(2)  や B<connect>(2)  コールの前に設定"
"しなければならない。 より詳しい情報は B<socket>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/tcp.7:191
msgid ""
"TCP supports urgent data.  Urgent data is used to signal the receiver that "
"some important message is part of the data stream and that it should be "
"processed as soon as possible.  To send urgent data specify the B<MSG_OOB> "
"option to B<send>(2).  When urgent data is received, the kernel sends a "
"B<SIGURG> signal to the process or process group that has been set as the "
"socket \"owner\" using the B<SIOCSPGRP> or B<FIOSETOWN> ioctls (or the "
"POSIX.1-2001-specified B<fcntl>(2)  B<F_SETOWN> operation).  When the "
"B<SO_OOBINLINE> socket option is enabled, urgent data is put into the normal "
"data stream (a program can test for its location using the B<SIOCATMARK> "
"ioctl described below), otherwise it can be received only when the "
"B<MSG_OOB> flag is set for B<recv>(2)  or B<recvmsg>(2)."
msgstr ""
"TCP は緊急データ (urgent data) をサポートしている。緊急データは 何らかの重要"
"なメッセージがデータストリームに含まれていること、 そのデータをできるだけ早く"
"処理すべきこと、を受信者に伝えるために用いられる。 緊急データを送るには、 "
"B<send>(2)  に B<MSG_OOB> オプションを指定する。 緊急データを受信すると、カー"
"ネルは B<SIGURG> シグナルを送信する。送信先は B<SIOCSPGRP> や B<FIOSETOWN> "
"ioctl (や POSIX.1-2001 で規定されている B<fcntl>(2)  B<F_SETOWN> 操作) を用い"
"てそのソケットの「所有者」として設定された プロセスかプロセスグループであ"
"る。 B<SO_OOBINLINE> ソケットオプションが有効になっていると、緊急データは 通"
"常のデータストリームの中に混ぜて送られる (プログラムは下記の B<SIOCATMARK> "
"ioctl を使って緊急データの場所を調べることができる)。 無効になっている場合に"
"は、 B<recv>(2)  や B<recvmsg>(2)  で B<MSG_OOB> フラグがセットされているとき"
"にのみ、緊急データを受信できる。"

#. type: Plain text
#: build/C/man7/tcp.7:199
msgid ""
"Linux 2.4 introduced a number of changes for improved throughput and "
"scaling, as well as enhanced functionality.  Some of these features include "
"support for zero-copy B<sendfile>(2), Explicit Congestion Notification, new "
"management of TIME_WAIT sockets, keep-alive socket options and support for "
"Duplicate SACK extensions."
msgstr ""
"Linux 2.4 では多くの変更がなされ、 スループットとスケーリングが向上し、機能も"
"高まった。 これらの機能には、ゼロコピー B<sendfile>(2)、 Explicit Congestion "
"Notification、 TIME_WAIT ソケットの新しい管理法、 keep-alive ソケットオプショ"
"ン、 Duplicate SACK 拡張のサポートなどがある。"

#. type: SS
#: build/C/man7/tcp.7:199
#, no-wrap
msgid "Address formats"
msgstr "アドレスのフォーマット"

#. type: Plain text
#: build/C/man7/tcp.7:208
msgid ""
"TCP is built on top of IP (see B<ip>(7)).  The address formats defined by "
"B<ip>(7)  apply to TCP.  TCP supports point-to-point communication only; "
"broadcasting and multicasting are not supported."
msgstr ""
"TCP は IP の上層に構築されている (B<ip>(7)  を参照)。 B<ip>(7)  に定義されて"
"いるアドレスフォーマットは TCP にも適用される。 TCP は point-to-point の通信"
"だけをサポートする。 ブロードキャストやマルチキャストはサポートしない。"

#. type: Plain text
#: build/C/man7/tcp.7:220
msgid ""
"System-wide TCP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>.  In addition, most IP I</proc> interfaces also apply "
"to TCP; see B<ip>(7).  Variables described as I<Boolean> take an integer "
"value, with a nonzero value (\"true\") meaning that the corresponding option "
"is enabled, and a zero value (\"false\")  meaning that the option is "
"disabled."
msgstr ""
"システム全体に対する TCP パラメータの設定には、 I</proc/sys/net/ipv4/> ディレ"
"クトリ内のファイルによりアクセスできる。 さらに、IP に関連する I</proc> イン"
"タフェースのほとんどは TCP についても適用される。 B<ip>(7)  を参照のこと。 "
"I<Boolean> は整数値で、 0 以外の値 (\"true\") は対応するオプションが有効、 0 "
"値 (\"false\") は無効、であることを意味する。"

#. type: TP
#: build/C/man7/tcp.7:220
#, no-wrap
msgid "I<tcp_abc> (Integer; default: 0; since Linux 2.6.15)"
msgstr "I<tcp_abc> (Integer; default: 0; Linux 2.6.15 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:228
msgid ""
"Control the Appropriate Byte Count (ABC), defined in RFC 3465.  ABC is a way "
"of increasing the congestion window (I<cwnd>)  more slowly in response to "
"partial acknowledgments.  Possible values are:"
msgstr ""
"RFC 3465 で定義されている Appropriate Byte Count (ABC) を制御する。 ABC は、"
"部分的な ACK に応じた輻輳ウィンドウ (I<cwnd>)  の増加をより緩やかにする方法で"
"ある。 以下の値を指定できる。"

#. type: IP
#: build/C/man7/tcp.7:229 build/C/man7/tcp.7:398 build/C/man7/tcp.7:419
#: build/C/man7/tcp.7:563
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man7/tcp.7:233
msgid "increase I<cwnd> once per acknowledgment (no ABC)"
msgstr "ACK を受信する毎に I<cwnd> を増やす (ABC なし)。"

#. type: IP
#: build/C/man7/tcp.7:233 build/C/man7/tcp.7:400 build/C/man7/tcp.7:426
#: build/C/man7/tcp.7:565
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man7/tcp.7:237
msgid "increase I<cwnd> once per acknowledgment of full sized segment"
msgstr "フルサイズのセグメントの ACK を受信する毎に I<cwnd> を増やす。"

#. type: IP
#: build/C/man7/tcp.7:237 build/C/man7/tcp.7:402 build/C/man7/tcp.7:433
#: build/C/man7/tcp.7:567
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man7/tcp.7:242
msgid ""
"allow increase I<cwnd> by two if acknowledgment is of two segments to "
"compensate for delayed acknowledgments."
msgstr ""
"ACK が遅延 ACK (delayed acknowledgment) を相殺するための 2 セグメントに 対す"
"る ACK の場合に、 I<cwnd> を 2 増やすことができる。"

#. type: TP
#: build/C/man7/tcp.7:243
#, no-wrap
msgid "I<tcp_abort_on_overflow> (Boolean; default: disabled; since Linux 2.4)"
msgstr "I<tcp_abort_on_overflow> (Boolean; default: disabled; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:255
msgid ""
"Enable resetting connections if the listening service is too slow and unable "
"to keep up and accept them.  It means that if overflow occurred due to a "
"burst, the connection will recover.  Enable this option I<only> if you are "
"really sure that the listening daemon cannot be tuned to accept connections "
"faster.  Enabling this option can harm the clients of your server."
msgstr ""
"接続を待ち受けているサービスが遅すぎて、受信についていけない場合に、 接続をリ"
"セットできるようにする。 これを用いると、バーストによってオーバーフローが起"
"こったときに、 接続を回復できるようになる。このオプションを用いるのは、 受信"
"デーモンを高速化できない場合に「限定する」こと。 このオプションを用いると、そ"
"のサーバに接続しているクライアント にとっては害になることがある。"

#. type: TP
#: build/C/man7/tcp.7:255
#, no-wrap
msgid "I<tcp_adv_win_scale> (integer; default: 2; since Linux 2.4)"
msgstr "I<tcp_adv_win_scale> (integer; default: 2; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:267
msgid ""
"Count buffering overhead as I<bytes/2^tcp_adv_win_scale>, if "
"I<tcp_adv_win_scale> is greater than 0; or I<bytes-bytes/2^(-"
"tcp_adv_win_scale)>, if I<tcp_adv_win_scale> is less than or equal to zero."
msgstr ""
"バッファリングのオーバーヘッドの計算方法を、 I<tcp_adv_win_scale> が正の場合"
"は I<bytes/2^tcp_adv_win_scale> に、 I<tcp_adv_win_scale> が負か 0 の場合は "
"I<bytes-bytes/2^(-tcp_adv_win_scale)> とする。"

#. type: Plain text
#: build/C/man7/tcp.7:280
msgid ""
"The socket receive buffer space is shared between the application and "
"kernel.  TCP maintains part of the buffer as the TCP window, this is the "
"size of the receive window advertised to the other end.  The rest of the "
"space is used as the \"application\" buffer, used to isolate the network "
"from scheduling and application latencies.  The I<tcp_adv_win_scale> default "
"value of 2 implies that the space used for the application buffer is one "
"fourth that of the total."
msgstr ""
"ソケットの受信バッファ空間はアプリケーションとカーネルで共有される。 TCP は"
"バッファの一部を TCP ウィンドウとして管理し、 これを受信ウィンドウとして接続"
"の他端に通知する。 空間の残りは「アプリケーション」バッファとして用いられ、 "
"スケジューリングやアプリケーションの遅延からネットワークを隔離する。 "
"I<tcp_adv_win_scale> のデフォルト値は 2 であり、 この場合アプリケーションバッ"
"ファは全体の 1/4 になる。"

#. type: TP
#: build/C/man7/tcp.7:280
#, no-wrap
msgid "I<tcp_allowed_congestion_control> (String; default: see text; since Linux 2.4.20)"
msgstr "I<tcp_allowed_congestion_control> (String; default: see text; Linux 2.4.20 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#.  FIXME How are the items in this delimited? Null bytes, spaces, commas?
#. type: Plain text
#: build/C/man7/tcp.7:292
msgid ""
"Show/set the congestion control algorithm choices available to unprivileged "
"processes (see the description of the B<TCP_CONGESTION> socket option).  The "
"list is a subset of those listed in I<tcp_available_congestion_control>.  "
"The default value for this list is \"reno\" plus the default setting of "
"I<tcp_congestion_control>."
msgstr ""
"非特権プロセスで利用できる輻輳制御アルゴリズムの選択肢を表示/設定する "
"(B<TCP_CONGESTION> ソケットオプションの説明を参照のこと)。 このリストは "
"I<tcp_available_congestion_control> で表示されるリストの部分集合となる。 この"
"リストのデフォルト値は、\"reno\" と I<tcp_congestion_control> のデフォルト設"
"定をあわせたものとなる。"

#. type: TP
#: build/C/man7/tcp.7:292
#, no-wrap
msgid "I<tcp_available_congestion_control> (String; read-only; since Linux 2.4.20)"
msgstr "I<tcp_available_congestion_control> (String; read-only; Linux 2.4.20 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#.  FIXME How are the items in this delimited? Null bytes, spaces, commas?
#. type: Plain text
#: build/C/man7/tcp.7:302
msgid ""
"Show a list of the congestion-control algorithms that are registered.  This "
"list is a limiting set for the list in I<tcp_allowed_congestion_control>.  "
"More congestion-control algorithms may be available as modules, but not "
"loaded."
msgstr ""
"登録されている輻輳制御アルゴリズムのリストを表示する。 このリストに載っている"
"ものだけが、 I<tcp_allowed_congestion_control> に表示される。 他の輻輳制御ア"
"ルゴリズムがモジュールとして利用可能だが、 モジュールがロードされていないこと"
"もある。"

#. type: TP
#: build/C/man7/tcp.7:302
#, no-wrap
msgid "I<tcp_app_win> (integer; default: 31; since Linux 2.4)"
msgstr "I<tcp_app_win> (integer; default: 31; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:307
msgid ""
"This variable defines how many bytes of the TCP window are reserved for "
"buffering overhead."
msgstr ""
"この変数は、TCP ウィンドウの何バイト分を バッファリングのオーバーヘッド用に予"
"約するかを指定する。"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:313
msgid ""
"A maximum of (I<window/2^tcp_app_win>, mss) bytes in the window are reserved "
"for the application buffer.  A value of 0 implies that no amount is reserved."
msgstr ""
"そのウィンドウの I<window/2^tcp_app_win> と mss の大きいほう (バイト単位)  が"
"アプリケーションバッファとして予約される。 0 を指定すると一切予約領域を取らな"
"い。"

#. type: TP
#: build/C/man7/tcp.7:313
#, no-wrap
msgid "I<tcp_base_mss> (Integer; default: 512; since Linux 2.6.17)"
msgstr "I<tcp_base_mss> (Integer; default: 512; Linux 2.6.17 以降)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:322
msgid ""
"The initial value of I<search_low> to be used by the packetization layer "
"Path MTU discovery (MTU probing).  If MTU probing is enabled, this is the "
"initial MSS used by the connection."
msgstr ""
"パケット化レイヤの Path MTU discovery (MTU probing) で、 I<search_low> の初期"
"値と使用される値。 MTU probing が有効な場合、この値はその接続の MSS の初期値"
"となる。"

#. type: TP
#: build/C/man7/tcp.7:322
#, no-wrap
msgid "I<tcp_bic> (Boolean; default: disabled; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr "I<tcp_bic> (Boolean; default: disabled; Linux 2.4.27/2.6.6 から 2.6.13 まで)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:336
msgid ""
"Enable BIC TCP congestion control algorithm.  BIC-TCP is a sender-side only "
"change that ensures a linear RTT fairness under large windows while offering "
"both scalability and bounded TCP-friendliness.  The protocol combines two "
"schemes called additive increase and binary search increase.  When the "
"congestion window is large, additive increase with a large increment ensures "
"linear RTT fairness as well as good scalability.  Under small congestion "
"windows, binary search increase provides TCP friendliness."
msgstr ""
"BIC TCP 輻輳制御アルゴリズムを有効にする。 BIC-TCP は送信側のみの変更で、 ス"
"ケーラビリティと TCP 親和性 (friendliness) の両方を提供しつつ、 大きなウィン"
"ドウの下での線形な RTT 公平性を保証するものである。 このプロトコルでは "
"additive increase (追加的な増加) と binary search increase (二分探索増加) と"
"いわれる二つの仕組みを 組み合わせている。輻輳ウィンドウが大きいときは、増分の"
"大きい additive increase により、スケーラビリティを確保しながら 線形な RTT 公"
"平性を保証する。 輻輳ウィンドウが小さいときには binary search increase によ"
"り TCP 親和性を達成している。"

#. type: TP
#: build/C/man7/tcp.7:336
#, no-wrap
msgid "I<tcp_bic_low_window> (integer; default: 14; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr "I<tcp_bic_low_window> (integer; default: 14; Linux 2.4.27/2.6.6 以降 2.6.13 まで)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:343
msgid ""
"Set the threshold window (in packets) where BIC TCP starts to adjust the "
"congestion window.  Below this threshold BIC TCP behaves the same as the "
"default TCP Reno."
msgstr ""
"BIC TCP が輻輳ウィンドウの調整を開始する閾値ウィンドウ (パケット単位)  を設定"
"する。この閾値を下回る場合、BIC TCP はデフォルトの TCP Reno と 同じ動作をす"
"る。"

#. type: TP
#: build/C/man7/tcp.7:343
#, no-wrap
msgid "I<tcp_bic_fast_convergence> (Boolean; default: enabled; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr "I<tcp_bic_fast_convergence> (Boolean; default: enabled; Linux 2.4.27/2.6.6 以降 2.6.13 まで)"

#. type: Plain text
#: build/C/man7/tcp.7:347
msgid ""
"Force BIC TCP to more quickly respond to changes in congestion window.  "
"Allows two flows sharing the same connection to converge more rapidly."
msgstr ""
"BIC TCP が輻輳ウィンドウの変化により速く反応するようにする。 同じコネクション"
"を共有する二つのフローが一つにまとまるのを より速く行うようにする。"

#. type: TP
#: build/C/man7/tcp.7:347
#, no-wrap
msgid "I<tcp_congestion_control> (String; default: see text; since Linux 2.4.13)"
msgstr "I<tcp_congestion_control> (String; default: 説明参照; Linux 2.4.13 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:354
msgid ""
"Set the default congestion-control algorithm to be used for new "
"connections.  The algorithm \"reno\" is always available, but additional "
"choices may be available depending on kernel configuration.  The default "
"value for this file is set as part of kernel configuration."
msgstr ""
"新規の接続で使用されるデフォルトの輻輳制御アルゴリズムを設定する。 \"reno\" "
"アルゴリズムは常に利用可能だが、 カーネル設定次第では別の選択肢が利用できるこ"
"ともある。 このファイルのデフォルト値はカーネル設定の一つとして設定される。"

#. type: TP
#: build/C/man7/tcp.7:354
#, no-wrap
msgid "I<tcp_dma_copybreak> (integer; default: 4096; since Linux 2.6.24)"
msgstr "I<tcp_dma_copybreak> (integer; default: 4096; Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:361
msgid ""
"Lower limit, in bytes, of the size of socket reads that will be offloaded to "
"a DMA copy engine, if one is present in the system and the kernel was "
"configured with the B<CONFIG_NET_DMA> option."
msgstr ""
"システムに DMA コピーエンジンが存在し、カーネルで B<CONFIG_NET_DMA> オプショ"
"ンが有効になっている場合に、 DMA コピーエンジンにオフロードされるソケットの読"
"み込みサイズの下限値 (バイト単位)。"

#. type: TP
#: build/C/man7/tcp.7:361
#, no-wrap
msgid "I<tcp_dsack> (Boolean; default: enabled; since Linux 2.4)"
msgstr "I<tcp_dsack> (Boolean; default: enabled; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:365
msgid "Enable RFC\\ 2883 TCP Duplicate SACK support."
msgstr "RFC\\ 2883 の TCP Duplicate SACK のサポートを有効にする。"

#. type: TP
#: build/C/man7/tcp.7:365
#, no-wrap
msgid "I<tcp_ecn> (Boolean; default: disabled; since Linux 2.4)"
msgstr "I<tcp_ecn> (Boolean; default: disabled; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:372
msgid ""
"Enable RFC\\ 2884 Explicit Congestion Notification.  When enabled, "
"connectivity to some destinations could be affected due to older, "
"misbehaving routers along the path causing connections to be dropped."
msgstr ""
"RFC\\ 2884 の Explicit Congestion Notification を有効にする。 これを有効にす"
"ると、間違った振舞いをする古いルータが 経路の途中にあるような接続先に対して影"
"響が生じ、 場合によっては接続が落ちるかもしれない。"

#. type: TP
#: build/C/man7/tcp.7:372
#, no-wrap
msgid "I<tcp_fack> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_fack> (Boolean; default: enabled; Linux 2.2 以降)"

#.  Since 2.1.92
#. type: Plain text
#: build/C/man7/tcp.7:376
msgid "Enable TCP Forward Acknowledgement support."
msgstr "TCP Forward Acknowledgement のサポートを有効にする。"

#. type: TP
#: build/C/man7/tcp.7:376
#, no-wrap
msgid "I<tcp_fin_timeout> (integer; default: 60; since Linux 2.2)"
msgstr "I<tcp_fin_timeout> (integer; default: 60; Linux 2.2 以降)"

#.  Since 2.1.53
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:386
msgid ""
"This specifies how many seconds to wait for a final FIN packet before the "
"socket is forcibly closed.  This is strictly a violation of the TCP "
"specification, but required to prevent denial-of-service attacks.  In Linux "
"2.2, the default value was 180."
msgstr ""
"ソケットを強制的にクローズする前に、 最後の FIN パケットを待つ時間を秒単位で"
"指定する。 これは厳密には TCP の仕様を満たしていないが、 DoS 攻撃 (denial of "
"service attack) から身を守るために必要である。 Linux 2.2 ではデフォルト値は "
"180 であった。"

#. type: TP
#: build/C/man7/tcp.7:386
#, no-wrap
msgid "I<tcp_frto> (integer; default: 0; since Linux 2.4.21/2.6)"
msgstr "I<tcp_frto> (integer; default: 0; Linux 2.4.21/2.6 以降)"

#.  Since 2.4.21/2.5.43
#. type: Plain text
#: build/C/man7/tcp.7:395
msgid ""
"Enable F-RTO, an enhanced recovery algorithm for TCP retransmission timeouts "
"(RTOs).  It is particularly beneficial in wireless environments where packet "
"loss is typically due to random radio interference rather than intermediate "
"router congestion.  See RFC 4138 for more details."
msgstr ""
"F-RTO を有効にする。F-RTO は TCP 再送タイムアウト (RTO) からの 復旧性能を向上"
"させたアルゴリズムである。 この機能は無線環境で特に効果を発揮する。 無線環境"
"では、通常は、中間ルータの輻輳ではなくランダムな無線の干渉 によりパケットロス"
"が発生する。 詳細は RFC\\ 4138 を参照。"

#. type: Plain text
#: build/C/man7/tcp.7:397
msgid "This file can have one of the following values:"
msgstr "このファイルは以下のいずれかの値を取ることができる。"

#. type: Plain text
#: build/C/man7/tcp.7:400
msgid "Disabled."
msgstr "F-RTO を無効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:402
msgid "The basic version F-RTO algorithm is enabled."
msgstr "基本版の F-RTO アルゴリズムを有効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:407
msgid ""
"Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be used "
"also when SACK is in use though in that case scenario(s) exists where F-RTO "
"interacts badly with the packet counting of the SACK-enabled TCP flow."
msgstr ""
"そのフローで SACK を使用する場合、SACK 拡張版の F-RTO を有効にする。 基本版"
"の F-RTO も SACK が使用されている場合にも使用できるが、 基本版の場合には F-"
"RTO が SACK が有効になった TCP フローでの パケット数計測と、相性が悪く相互干"
"渉が起こる場面が存在する。"

#. type: Plain text
#: build/C/man7/tcp.7:411
msgid ""
"Before Linux 2.6.22, this parameter was a Boolean value, supporting just "
"values 0 and 1 above."
msgstr ""
"Linu 2.6.22 より前では、このパラメータはブール値であり、 上記の 0 と 1 のみを"
"サポートしていた。"

#. type: TP
#: build/C/man7/tcp.7:411
#, no-wrap
msgid "I<tcp_frto_response> (integer; default: 0; since Linux 2.6.22)"
msgstr "I<tcp_frto_response> (integer; default: 0; Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:418
msgid ""
"When F-RTO has detected that a TCP retransmission timeout was spurious (i.e, "
"the timeout would have been avoided had TCP set a longer retransmission "
"timeout), TCP has several options concerning what to do next.  Possible "
"values are:"
msgstr ""
"F-RTO が TCP 再送タイムアウトが偽物だと検出した場合 (つまり、TCP がもっと長い"
"再送タイムアウトを設定していれば タイムアウトが避けられた場合)、 次にどうする"
"かに関して選択肢がいくつかある。 以下の値を選択できる。"

#. type: Plain text
#: build/C/man7/tcp.7:426
msgid ""
"Rate halving based; a smooth and conservative response, results in halved "
"congestion window (I<cwnd>)  and slow-start threshold (I<ssthresh>)  after "
"one RTT."
msgstr ""
"レートを元の半分にする。 滑らかで、保守的な反応を行い、RTT 1回分の時間後に 輻"
"輳ウィンドウ (I<cwnd>)  とスロースタートの閾値 (I<ssthresh>)  が半分になる。"

#. type: Plain text
#: build/C/man7/tcp.7:433
msgid ""
"Very conservative response; not recommended because even though being valid, "
"it interacts poorly with the rest of Linux TCP; halves I<cwnd> and "
"I<ssthresh> immediately."
msgstr ""
"非常に保守的な反応。このオプションの使用は推奨されない。 反応が正しかった場合"
"であっても、Linux TCP の他の部分と うまく連携できないからである。 I<cwnd> と "
"I<ssthresh> は直ちに半分にされる。"

#. type: Plain text
#: build/C/man7/tcp.7:442
msgid ""
"Aggressive response; undoes congestion-control measures that are now known "
"to be unnecessary (ignoring the possibility of a lost retransmission that "
"would require TCP to be more cautious); I<cwnd> and I<ssthresh> are restored "
"to the values prior to timeout."
msgstr ""
"積極的な反応。 不要と判明した輻輳制御の測定情報を取り消す (TCP がもっと注意深"
"く扱うべき再送が失われる可能性を無視する)。 。 I<cwnd> と I<ssthresh> はタイ"
"ムアウト前の値に戻される。"

#. type: TP
#: build/C/man7/tcp.7:443
#, no-wrap
msgid "I<tcp_keepalive_intvl> (integer; default: 75; since Linux 2.4)"
msgstr "I<tcp_keepalive_intvl> (integer; default: 75; Linux 2.4 以降)"

#.  Since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:447
msgid "The number of seconds between TCP keep-alive probes."
msgstr "TCP keep-alive のプローブを送る間隔 (秒単位)。"

#. type: TP
#: build/C/man7/tcp.7:447
#, no-wrap
msgid "I<tcp_keepalive_probes> (integer; default: 9; since Linux 2.2)"
msgstr "I<tcp_keepalive_probes> (integer; default: 9; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:453
msgid ""
"The maximum number of TCP keep-alive probes to send before giving up and "
"killing the connection if no response is obtained from the other end."
msgstr ""
"TCP keep-alive プローブの最大回数。 この回数だけ試しても接続先から反応が得ら"
"れない場合は、 あきらめて接続を切断する。"

#. type: TP
#: build/C/man7/tcp.7:453
#, no-wrap
msgid "I<tcp_keepalive_time> (integer; default: 7200; since Linux 2.2)"
msgstr "I<tcp_keepalive_time> (integer; default: 7200; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:465
msgid ""
"The number of seconds a connection needs to be idle before TCP begins "
"sending out keep-alive probes.  Keep-alives are sent only when the "
"B<SO_KEEPALIVE> socket option is enabled.  The default value is 7200 seconds "
"(2 hours).  An idle connection is terminated after approximately an "
"additional 11 minutes (9 probes an interval of 75 seconds apart) when keep-"
"alive is enabled."
msgstr ""
"接続がアイドル状態になってから、keep-alive プローブを送信するまでの時間を秒単"
"位で指定する。 B<SO_KEEPALIVE> ソケットオプションが有効になっている場合のみ "
"keep-alive は送信される。 デフォルト値は 7200 秒 (2 時間)。 keep-alive が有効"
"になっている場合、 さらにおよそ 11 分 (75 秒間隔の 9 プローブ分)  経過すると"
"アイドル状態の接続は終了させられる。"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:470
msgid ""
"Note that underlying connection tracking mechanisms and application timeouts "
"may be much shorter."
msgstr ""
"下層にある接続追跡機構やアプリケーションでのタイムアウトは、 もっとずっと短い"
"かもしれない。"

#. type: TP
#: build/C/man7/tcp.7:470
#, no-wrap
msgid "I<tcp_low_latency> (Boolean; default: disabled; since Linux 2.4.21/2.6)"
msgstr "I<tcp_low_latency> (Boolean; default: disabled; Linux 2.4.21/2.6 以降)"

#.  Since 2.4.21/2.5.60
#. type: Plain text
#: build/C/man7/tcp.7:478
msgid ""
"If enabled, the TCP stack makes decisions that prefer lower latency as "
"opposed to higher throughput.  It this option is disabled, then higher "
"throughput is preferred.  An example of an application where this default "
"should be changed would be a Beowulf compute cluster."
msgstr ""
"有効にすると、TCP スタックはスループットを高くするよりも 遅延を少なくすること"
"を優先して判断を行う。 このオプションを無効にすると、スループットを高くするこ"
"とが優先される。 このデフォルト値を変更した方がよいアプリケーションの例として"
"は Beowulf コンピュータクラスタが挙げられるだろう。"

#. type: TP
#: build/C/man7/tcp.7:478
#, no-wrap
msgid "I<tcp_max_orphans> (integer; default: see below; since Linux 2.4)"
msgstr "I<tcp_max_orphans> (integer; default: see below; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:492
msgid ""
"The maximum number of orphaned (not attached to any user file handle) TCP "
"sockets allowed in the system.  When this number is exceeded, the orphaned "
"connection is reset and a warning is printed.  This limit exists only to "
"prevent simple denial-of-service attacks.  Lowering this limit is not "
"recommended.  Network conditions might require you to increase the number of "
"orphans allowed, but note that each orphan can eat up to ~64K of unswappable "
"memory.  The default initial value is set equal to the kernel parameter "
"NR_FILE.  This initial default is adjusted depending on the memory in the "
"system."
msgstr ""
"システムが許容する、 orphan な (どのユーザファイルハンドルにもアタッチされて"
"いない)  TCP ソケットの最大数。 この数を越えると、orphan な接続はリセットさ"
"れ、警告が表示される。 この制限が存在するのは、単純な使用不能 (denial-of-"
"service) 攻撃を 防ぐために過ぎない。この値を小さくすることは推奨しない。 ネッ"
"トワークの条件によっては、この数値を大きくしないといけないかもしれないが、 "
"orphan なソケットひとつあたり 64K 程度のスワップ不可能なメモリを消費すること"
"も注意せよ。 デフォルトの初期値はカーネルパラメータの NR_FILE と等しい。 この"
"初期デフォルト値はシステムのメモリに応じて調整される。"

#. type: TP
#: build/C/man7/tcp.7:492
#, no-wrap
msgid "I<tcp_max_syn_backlog> (integer; default: see below; since Linux 2.2)"
msgstr "I<tcp_max_syn_backlog> (integer; default: 下記参照; Linux 2.2 以降)"

#.  Since 2.1.53
#. type: Plain text
#: build/C/man7/tcp.7:509
msgid ""
"The maximum number of queued connection requests which have still not "
"received an acknowledgement from the connecting client.  If this number is "
"exceeded, the kernel will begin dropping requests.  The default value of 256 "
"is increased to 1024 when the memory present in the system is adequate or "
"greater (E<gt>= 128Mb), and reduced to 128 for those systems with very low "
"memory (E<lt>= 32Mb).  It is recommended that if this needs to be increased "
"above 1024, TCP_SYNQ_HSIZE in I<include/net/tcp.h> be modified to keep "
"TCP_SYNQ_HSIZE*16E<lt>=tcp_max_syn_backlog, and the kernel be recompiled."
msgstr ""
"接続してきているクライアントから ack を受信していない状態の接続リクエストを"
"キューに置ける最大数。 この数値を越えると、カーネルはリクエストを捨て始め"
"る。 デフォルトの値は 256 で、 システムに充分なメモリがある (128Mb 以上) 場合"
"は 1024 になり、 メモリが非常に少ない場合 (32 Mb 以下) は 128 になる。 この数"
"値を 1024 以上に増やしたい場合は、 I<include/net/tcp.h> の TCP_SYNQ_HSIZE を "
"TCP_SYNQ_HSIZE*16E<lt>=tcp_max_syn_backlog のように修正し、 カーネルを再コン"
"パイルすることを奨める。"

#. type: TP
#: build/C/man7/tcp.7:509
#, no-wrap
msgid "I<tcp_max_tw_buckets> (integer; default: see below; since Linux 2.4)"
msgstr "I<tcp_max_tw_buckets> (integer; default: 下記参照; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:519
msgid ""
"The maximum number of sockets in TIME_WAIT state allowed in the system.  "
"This limit exists only to prevent simple denial-of-service attacks.  The "
"default value of NR_FILE*2 is adjusted depending on the memory in the "
"system.  If this number is exceeded, the socket is closed and a warning is "
"printed."
msgstr ""
"システムが許容する TIME_WAIT 状態にあるソケットの最大数。 この制限が存在する"
"のは、 単純な使用不能 (denial-of-service) 攻撃を防ぐために過ぎない。 デフォル"
"ト値は NR_FILE*2 で、システムのメモリに応じて調整される。 この数値を越える"
"と、そのようなソケットはクローズされ、警告が表示される。"

#. type: TP
#: build/C/man7/tcp.7:519
#, no-wrap
msgid "I<tcp_moderate_rcvbuf> (Boolean; default: enabled; since Linux 2.4.17/2.6.7)"
msgstr "I<tcp_moderate_rcvbuf> (Boolean; default: enabled; Linux 2.4.17/2.6.7 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:526
msgid ""
"If enabled, TCP performs receive buffer auto-tuning, attempting to "
"automatically size the buffer (no greater than I<tcp_rmem[2]>)  to match the "
"size required by the path for full throughput."
msgstr ""
"有効にすると、TCP は受信バッファの自動調整を行う。 具体的には、 (I<tcp_rmem"
"[2]> を超えない範囲で) バッファの大きさを自動的に変化させ、 その経路で最大の"
"スループットを達成するのに必要な大きさに合わせようとする。"

#. type: TP
#: build/C/man7/tcp.7:526
#, no-wrap
msgid "I<tcp_mem> (since Linux 2.4)"
msgstr "I<tcp_mem> (Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:538
msgid ""
"This is a vector of 3 integers: [low, pressure, high].  These bounds, "
"measured in units of the system page size, are used by TCP to track its "
"memory usage.  The defaults are calculated at boot time from the amount of "
"available memory.  (TCP can only use I<low memory> for this, which is "
"limited to around 900 megabytes on 32-bit systems.  64-bit systems do not "
"suffer this limitation.)"
msgstr ""
"これは 3 つの整数 [low, pressure, high] からなるベクトル値である。 これらは "
"TCP がメモリ使用量を追跡するために用いられる (使用量はシステムのページサイズ"
"単位で計測される)。 デフォルトはブート時に利用できるメモリの量から計算され"
"る。 (実際には、TCP は I<low memory> のみを使用する。値は 32ビットシステムで"
"は約 900 メガバイトに制限される。 64 ビットシステムではこの制限はない。)"

#. type: TP
#: build/C/man7/tcp.7:539
#, no-wrap
msgid "I<low>"
msgstr "I<low>"

#. type: Plain text
#: build/C/man7/tcp.7:543
msgid ""
"TCP doesn't regulate its memory allocation when the number of pages it has "
"allocated globally is below this number."
msgstr ""
"TCP は、グローバルにアロケートしたページがこの数値以下の場合は、 メモリアロ"
"ケーションを調整しない。"

#. type: TP
#: build/C/man7/tcp.7:543 build/C/man7/udp.7:151
#, no-wrap
msgid "I<pressure>"
msgstr "I<pressure>"

#. type: Plain text
#: build/C/man7/tcp.7:552
msgid ""
"When the amount of memory allocated by TCP exceeds this number of pages, TCP "
"moderates its memory consumption.  This memory pressure state is exited once "
"the number of pages allocated falls below the I<low> mark."
msgstr ""
"TCP がアロケートしたメモリがこの数値分のページ数を越えると、 TCP はメモリ消費"
"を抑えるようになる。 アロケートしたページ数が I<low> 以下になると、このメモリ"
"圧迫状態から脱する。"

#. type: TP
#: build/C/man7/tcp.7:552
#, no-wrap
msgid "I<high>"
msgstr "I<high>"

#. type: Plain text
#: build/C/man7/tcp.7:556
msgid ""
"The maximum number of pages, globally, that TCP will allocate.  This value "
"overrides any other limits imposed by the kernel."
msgstr ""
"TCP がグローバルに割り当てるページ数の最大値。 この値はカーネルによって課され"
"るあらゆる制限よりも優先される。"

#. type: TP
#: build/C/man7/tcp.7:557
#, no-wrap
msgid "I<tcp_mtu_probing> (integer; default: 0; since Linux 2.6.17)"
msgstr "I<tcp_mtu_probing> (integer; default: 0; Linux 2.6.17 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:562
msgid ""
"This parameter controls TCP Packetization-Layer Path MTU Discovery.  The "
"following values may be assigned to the file:"
msgstr ""
"このパラメータは、TCP のパケット化レイヤの Path MTU discovery を制御する。 こ"
"のファイルには以下の値を設定できる。"

#. type: Plain text
#: build/C/man7/tcp.7:565
msgid "Disabled"
msgstr "無効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:567
msgid "Disabled by default, enabled when an ICMP black hole detected"
msgstr ""
"デフォルトでは無効だが、ICMP ブラックホールが検出された場合は有効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:570
msgid "Always enabled, use initial MSS of I<tcp_base_mss>."
msgstr "常に有効にする。 MSS の初期値として I<tcp_base_mss> が使用される。"

#. type: TP
#: build/C/man7/tcp.7:571
#, no-wrap
msgid "I<tcp_no_metrics_save> (Boolean; default: disabled; since Linux 2.6.6)"
msgstr "I<tcp_no_metrics_save> (Boolean; default: disabled; Linux 2.6.6 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:582
msgid ""
"By default, TCP saves various connection metrics in the route cache when the "
"connection closes, so that connections established in the near future can "
"use these to set initial conditions.  Usually, this increases overall "
"performance, but it may sometimes cause performance degradation.  If "
"I<tcp_no_metrics_save> is enabled, TCP will not cache metrics on closing "
"connections."
msgstr ""
"デフォルトでは、TCP は接続クローズ時に各種の接続パラメータを ルートキャッ"
"シュ (route cache) に保存し、近い将来に接続が確立された際に これらの情報を初"
"期状態として使用できるようになっている。 通常は、これにより全体として性能が向"
"上するが、 時として性能の劣化を引き起こすこともある。 I<tcp_no_metrics_save> "
"を有効にすると、TCP は接続クローズ時に接続パラメータをキャッシュ しなくなる。"

#. type: TP
#: build/C/man7/tcp.7:582
#, no-wrap
msgid "I<tcp_orphan_retries> (integer; default: 8; since Linux 2.4)"
msgstr "I<tcp_orphan_retries> (integer; default: 8; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:587
msgid ""
"The maximum number of attempts made to probe the other end of a connection "
"which has been closed by our end."
msgstr "こちらからクローズした接続について、 先方をプローブする最大試行数。"

#. type: TP
#: build/C/man7/tcp.7:587
#, no-wrap
msgid "I<tcp_reordering> (integer; default: 3; since Linux 2.4)"
msgstr "I<tcp_reordering> (integer; default: 3; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:596
msgid ""
"The maximum a packet can be reordered in a TCP packet stream without TCP "
"assuming packet loss and going into slow start.  It is not advisable to "
"change this number.  This is a packet reordering detection metric designed "
"to minimize unnecessary back off and retransmits provoked by reordering of "
"packets on a connection."
msgstr ""
"TCP パケットストリームでパケット順序の逆転が発生しただけであり、 パケットロス"
"が起こったとはみなさない、パケット数の最大値。 この値を超えてパケットの順序逆"
"転が起こると、パケットロスが生じたと みなし、slow start に入る。 この数値は変"
"更しないほうが良い。 これは、接続中のパケットの並び替えによって生じる 不必要"
"な速度低下や再送を最小化するように設計された、 パケット並び替え (packet "
"reordering) の検知メトリックなのである。"

#. type: TP
#: build/C/man7/tcp.7:596
#, no-wrap
msgid "I<tcp_retrans_collapse> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_retrans_collapse> (Boolean; default: enabled; Linux 2.2 以降)"

#.  Since 2.1.96
#. type: Plain text
#: build/C/man7/tcp.7:600
msgid "Try to send full-sized packets during retransmit."
msgstr "再送の際にフルサイズのパケットを送ろうとする。"

#. type: TP
#: build/C/man7/tcp.7:600
#, no-wrap
msgid "I<tcp_retries1> (integer; default: 3; since Linux 2.2)"
msgstr "I<tcp_retries1> (integer; default: 3; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:610
msgid ""
"The number of times TCP will attempt to retransmit a packet on an "
"established connection normally, without the extra effort of getting the "
"network layers involved.  Once we exceed this number of retransmits, we "
"first have the network layer update the route if possible before each new "
"retransmit.  The default is the RFC specified minimum of 3."
msgstr ""
"普通に確立されている接続上に、 TCP がネットワーク層を巻き込まずに再送を試みる"
"回数。 再送がこの回数を越えると、まず最初に、 新しい再送を送る前に可能なら"
"ネットワーク層に経路を更新させる。 デフォルトは RFC が指定している最少数であ"
"る 3。"

#. type: TP
#: build/C/man7/tcp.7:610
#, no-wrap
msgid "I<tcp_retries2> (integer; default: 15; since Linux 2.2)"
msgstr "I<tcp_retries2> (integer; default: 15; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:620
msgid ""
"The maximum number of times a TCP packet is retransmitted in established "
"state before giving up.  The default value is 15, which corresponds to a "
"duration of approximately between 13 to 30 minutes, depending on the "
"retransmission timeout.  The RFC\\ 1122 specified minimum limit of 100 "
"seconds is typically deemed too short."
msgstr ""
"確立状態の接続に、この回数 TCP パケットの再送信を 行なってもだめな場合はあき"
"らめる。 デフォルト値は 15 で、これは (再送のタイムアウトに依存するが)  およ"
"そ 13〜30 分程度の期間に対応する。 RFC\\ 1122 は最小の限界を 100 秒と置いてい"
"るが、 これはたいていの場合には短すぎると思われる。"

#. type: TP
#: build/C/man7/tcp.7:620
#, no-wrap
msgid "I<tcp_rfc1337> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<tcp_rfc1337> (Boolean; default: disabled; Linux 2.2 以降)"

#.  Since 2.1.90
#. type: Plain text
#: build/C/man7/tcp.7:628
msgid ""
"Enable TCP behavior conformant with RFC\\ 1337.  When disabled, if a RST is "
"received in TIME_WAIT state, we close the socket immediately without waiting "
"for the end of the TIME_WAIT period."
msgstr ""
"TCP の動作を RFC\\ 1337 に準拠させる。 無効にすると、TIME_WAIT 状態のときに "
"RST が受信された場合、 TIME_WAIT 期間の終了を待たずにそのソケットを直ちにク"
"ローズする。"

#. type: TP
#: build/C/man7/tcp.7:628
#, no-wrap
msgid "I<tcp_rmem> (since Linux 2.4)"
msgstr "I<tcp_rmem> (Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:636
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate receive buffer sizes.  TCP dynamically adjusts the "
"size of the receive buffer from the defaults listed below, in the range of "
"these values, depending on memory available in the system."
msgstr ""
"これは 3 つの整数 [min, default, max] からなるベクトル値である。 これらは "
"TCP が受信バッファサイズを調整するために用いられる。 TCP は、システムで利用で"
"きるメモリに応じて、 受信バッファのサイズをこれらの変数の範囲で 以下に示すデ"
"フォルトから動的に調整する。"

#. type: TP
#: build/C/man7/tcp.7:637 build/C/man7/tcp.7:813 build/C/man7/udp.7:145
#, no-wrap
msgid "I<min>"
msgstr "I<min>"

#. type: Plain text
#: build/C/man7/tcp.7:652
msgid ""
"minimum size of the receive buffer used by each TCP socket.  The default "
"value is the system page size.  (On Linux 2.4, the default value is 4K, "
"lowered to B<PAGE_SIZE> bytes in low-memory systems.)  This value is used to "
"ensure that in memory pressure mode, allocations below this size will still "
"succeed.  This is not used to bound the size of the receive buffer declared "
"using B<SO_RCVBUF> on a socket."
msgstr ""
"各 TCP ソケットが用いる受信バッファの最小サイズ。 デフォルト値はシステムの"
"ページサイズである (Linux 2.4 では、デフォルト値は 4K バイトで、 メモリの少な"
"いシステムでは B<PAGE_SIZE> バイトに減らされる)。 この値は、メモリ圧迫モード"
"においても、 このサイズの割り当てが成功することを保証するために用いられる。 "
"これは、 B<SO_RCVBUF> を用いてソケットの最低受信バッファサイズを宣言する際に"
"は用いられない。"

#. type: TP
#: build/C/man7/tcp.7:652 build/C/man7/tcp.7:823
#, no-wrap
msgid "I<default>"
msgstr "I<default>"

#. type: Plain text
#: build/C/man7/tcp.7:666
msgid ""
"the default size of the receive buffer for a TCP socket.  This value "
"overwrites the initial default buffer size from the generic global I<net."
"core.rmem_default> defined for all protocols.  The default value is 87380 "
"bytes.  (On Linux 2.4, this will be lowered to 43689 in low-memory "
"systems.)  If larger receive buffer sizes are desired, this value should be "
"increased (to affect all sockets).  To employ large TCP windows, the I<net."
"ipv4.tcp_window_scaling> must be enabled (default)."
msgstr ""
"TCP ソケットの受信バッファのデフォルトサイズ。 この値は、すべてのプロトコルに"
"対して定義されている、 ジェネリックなグローバルのデフォルトバッファサイズ "
"I<net.core.rmem_default> より優先される。 デフォルト値は 87380 バイトである "
"(Linux 2.4 では、メモリの少ないシステムの場合 43689 まで減らされる)。 大きな"
"受信バッファサイズが必要な場合は、 この値を増やすべきである (すべてのソケット"
"に影響する)。 大きな TCP ウィンドウを用いるには、 I<net.ipv4."
"tcp_window_scaling> を有効にしておかなければならない (デフォルトは有効)。"

#. type: TP
#: build/C/man7/tcp.7:666 build/C/man7/tcp.7:837 build/C/man7/udp.7:157
#, no-wrap
msgid "I<max>"
msgstr "I<max>"

#. type: Plain text
#: build/C/man7/tcp.7:675
msgid ""
"the maximum size of the receive buffer used by each TCP socket.  This value "
"does not override the global I<net.core.rmem_max>.  This is not used to "
"limit the size of the receive buffer declared using B<SO_RCVBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""
"各 TCP ソケットで用いる受信バッファの最大サイズ。 この値よりもグローバルの "
"I<net.core.rmem_max> が優先される。 これは、 B<SO_RCVBUF> を用いてソケットの"
"受信バッファサイズ制限を宣言する際には用いられない。 デフォルト値は以下の式で"
"計算される。"

#. type: Plain text
#: build/C/man7/tcp.7:677
#, no-wrap
msgid "    max(87380, min(4MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr "    max(87380, min(4MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"

#. type: Plain text
#: build/C/man7/tcp.7:680
msgid ""
"(On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in low-memory "
"systems)."
msgstr ""
"(Linux 2.4 では、デフォルト値は 87380*2 バイトで、 メモリの少ないシステムで"
"は 87380 まで減らされる。)"

#. type: TP
#: build/C/man7/tcp.7:681
#, no-wrap
msgid "I<tcp_sack> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_sack> (Boolean; default: enabled; Linux 2.2 以降)"

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:685
msgid "Enable RFC\\ 2018 TCP Selective Acknowledgements."
msgstr "RFC\\ 2018 の TCP Selective Acknowledgements を有効にする。"

#. type: TP
#: build/C/man7/tcp.7:685
#, no-wrap
msgid "I<tcp_slow_start_after_idle> (Boolean; default: enabled; since Linux 2.6.18)"
msgstr "I<tcp_slow_start_after_idle> (Boolean; default: enabled; Linux 2.6.18 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:693
msgid ""
"If enabled, provide RFC 2861 behavior and time out the congestion window "
"after an idle period.  An idle period is defined as the current RTO "
"(retransmission timeout).  If disabled, the congestion window will not be "
"timed out after an idle period."
msgstr ""
"有効にすると、RFC 2861 の動作が行われ、 アイドル時間経過後に輻輳ウィンドウを"
"タイムアウトさせる。 アイドル時間は現在の RTO (再送タイムアウト) で定義され"
"る。 無効にすると、輻輳ウィンドウはアイドル時間経過後もタイムアウトされない。"

#. type: TP
#: build/C/man7/tcp.7:693
#, no-wrap
msgid "I<tcp_stdurg> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<tcp_stdurg> (Boolean; default: disabled; Linux 2.2 以降)"

#.  Since 2.1.44
#.  RFC 793 was ambiguous in its specification of the meaning of the
#.  urgent pointer.  RFC 1122 (and RFC 961) fixed on a particular
#.  resolution of this ambiguity (unfortunately the "wrong" one).
#. type: Plain text
#: build/C/man7/tcp.7:707
msgid ""
"If this option is enabled, then use the RFC\\ 1122 interpretation of the TCP "
"urgent-pointer field.  According to this interpretation, the urgent pointer "
"points to the last byte of urgent data.  If this option is disabled, then "
"use the BSD-compatible interpretation of the urgent pointer: the urgent "
"pointer points to the first byte after the urgent data.  Enabling this "
"option may lead to interoperability problems."
msgstr ""
"このオプションを有効にすると、 TCP 緊急ポインタ (urgent-pointer)  フィールド"
"を RFC\\ 1122 に従った解釈を行う。 この解釈に従うと、緊急ポインタは緊急データ"
"の最後のバイトを指す。 このオプションを無効にすると、緊急ポインタの解釈が "
"BSD 互換の方法で 行われる: 緊急ポインタは緊急データの後の最初のバイトを指"
"す。 このオプションを有効にすると、相互運用性に問題が生じるかもしれない。"

#. type: TP
#: build/C/man7/tcp.7:707
#, no-wrap
msgid "I<tcp_syn_retries> (integer; default: 5; since Linux 2.2)"
msgstr "I<tcp_syn_retries> (integer; default: 5; Linux 2.2 以降)"

#.  Since 2.1.38
#. type: Plain text
#: build/C/man7/tcp.7:714
msgid ""
"The maximum number of times initial SYNs for an active TCP connection "
"attempt will be retransmitted.  This value should not be higher than 255.  "
"The default value is 5, which corresponds to approximately 180 seconds."
msgstr ""
"アクティブな TCP 接続に初期 SYN の再送を試みる最大回数。 この数値は 255 より"
"も大きくすべきではない。 デフォルトの値は 5 で、およそ 180 秒に対応する。"

#. type: TP
#: build/C/man7/tcp.7:714
#, no-wrap
msgid "I<tcp_synack_retries> (integer; default: 5; since Linux 2.2)"
msgstr "I<tcp_synack_retries> (integer; default: 5; Linux 2.2 以降)"

#.  Since 2.1.38
#. type: Plain text
#: build/C/man7/tcp.7:720
msgid ""
"The maximum number of times a SYN/ACK segment for a passive TCP connection "
"will be retransmitted.  This number should not be higher than 255."
msgstr ""
"passive な TCP 接続の SYN/ACK セグメントで再送を試みる最大数。 この数値は "
"255 よりも大きくすべきではない。"

#. type: TP
#: build/C/man7/tcp.7:720
#, no-wrap
msgid "I<tcp_syncookies> (Boolean; since Linux 2.2)"
msgstr "I<tcp_syncookies> (Boolean; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:740
msgid ""
"Enable TCP syncookies.  The kernel must be compiled with "
"B<CONFIG_SYN_COOKIES>.  Send out syncookies when the syn backlog queue of a "
"socket overflows.  The syncookies feature attempts to protect a socket from "
"a SYN flood attack.  This should be used as a last resort, if at all.  This "
"is a violation of the TCP protocol, and conflicts with other areas of TCP "
"such as TCP extensions.  It can cause problems for clients and relays.  It "
"is not recommended as a tuning mechanism for heavily loaded servers to help "
"with overloaded or misconfigured conditions.  For recommended alternatives "
"see I<tcp_max_syn_backlog>, I<tcp_synack_retries>, and "
"I<tcp_abort_on_overflow>."
msgstr ""
"TCP syncookies を有効にする。カーネルは B<CONFIG_SYNCOOKIES> をつけてコンパイ"
"ルしておかなければならない。 ソケットのバックログキューがオーバーフローする"
"と、 syncookies が送信される。 syncookies 機能は、SYN flood 攻撃からソケット"
"を守ろうとする。 これはいずれにしても、最終手段として用いるべきである。 これ"
"は TCP プロトコルに違反しており、 TCP 拡張のような、TCP の他の部分と衝突して"
"しまう。 クライアントやリレーで問題が起こることもある。 過負荷や設定間違いに"
"よって負荷の大きな状態にあるサーバを調整して救うための 機構とみなすべきではな"
"い。 そのような用途には、代わりに I<tcp_max_syn_backlog>, "
"I<tcp_synack_retries>, I<tcp_abort_on_overflow> などの使用を考えること。"

#. type: TP
#: build/C/man7/tcp.7:740
#, no-wrap
msgid "I<tcp_timestamps> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_timestamps> (Boolean; default: enabled; Linux 2.2 以降)"

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:744
msgid "Enable RFC\\ 1323 TCP timestamps."
msgstr "RFC\\ 1323 の TCP timestamps を有効にする。"

#. type: TP
#: build/C/man7/tcp.7:744
#, no-wrap
msgid "I<tcp_tso_win_divisor> (integer; default: 3; since Linux 2.6.9)"
msgstr "I<tcp_tso_win_divisor> (integer; default: 3; Linux 2.6.9 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:750
msgid ""
"This parameter controls what percentage of the congestion window can be "
"consumed by a single TCP Segmentation Offload (TSO) frame.  The setting of "
"this parameter is a tradeoff between burstiness and building larger TSO "
"frames."
msgstr ""
"このパラメータは、一つの TCP Segmentation Offload (TSO) フレームで 消費できる"
"輻輳ウィンドウの割合 (パーセント) を制御する。 バースト性と、どれだけ大きな "
"TSO フレームを構築するかのはトレードオフであり、 このパラメータはその度合いを"
"設定する。"

#. type: TP
#: build/C/man7/tcp.7:750
#, no-wrap
msgid "I<tcp_tw_recycle> (Boolean; default: disabled; since Linux 2.4)"
msgstr "I<tcp_tw_recycle> (Boolean; default: disabled; Linux 2.4 以降)"

#.  Since 2.3.15
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:759
msgid ""
"Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not "
"recommended since this causes problems when working with NAT (Network "
"Address Translation)."
msgstr ""
"TIME_WAIT ソケットの素早い再利用を有効にする。 このオプションを有効にする"
"と、 NAT (ネットワークアドレス変換) を用いていると問題が生じるので、 あまり推"
"奨しない。"

#. type: TP
#: build/C/man7/tcp.7:759
#, no-wrap
msgid "I<tcp_tw_reuse> (Boolean; default: disabled; since Linux 2.4.19/2.6)"
msgstr "I<tcp_tw_reuse> (Boolean; default: disabled; Linux 2.4.19/2.6 以降)"

#.  Since 2.4.19/2.5.43
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:767
msgid ""
"Allow to reuse TIME_WAIT sockets for new connections when it is safe from "
"protocol viewpoint.  It should not be changed without advice/request of "
"technical experts."
msgstr ""
"プロトコルの面から見て問題ない場合に新規コネクションに TIME_WAIT 状態のソケッ"
"トを再利用することを許可する。技術的に詳しい人の助言や 要請なしにこのオプショ"
"ンを変更すべきではない。"

#. type: TP
#: build/C/man7/tcp.7:767
#, no-wrap
msgid "I<tcp_vegas_cong_avoid> (Boolean; default: disabled; Linux 2.2 to 2.6.13)"
msgstr "I<tcp_vegas_cong_avoid> (Boolean; default: disabled; Linux 2.2 から 2.6.13 まで)"

#.  Since 2.1.8; removed in 2.6.13
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:778
msgid ""
"Enable TCP Vegas congestion avoidance algorithm.  TCP Vegas is a sender-side "
"only change to TCP that anticipates the onset of congestion by estimating "
"the bandwidth.  TCP Vegas adjusts the sending rate by modifying the "
"congestion window.  TCP Vegas should provide less packet loss, but it is not "
"as aggressive as TCP Reno."
msgstr ""
"TCP Vegas 輻輳制御アルゴリズムを有効にする。 TCP Vegas は帯域を推測することで"
"輻輳の起こり始めを予想するように TCP の送信側のみに変更を加えたものである。 "
"TCP Vegas は輻輳ウィンドウを修正することで、送信レートを調整する。 TCP Vegas "
"は TCP Reno と比べてパケットロスは少ないが、 TCP Reno ほど積極的な挙動はしな"
"い。"

#. type: TP
#: build/C/man7/tcp.7:778
#, no-wrap
msgid "I<tcp_westwood> (Boolean; default: disabled; Linux 2.4.26/2.6.3 to 2.6.13)"
msgstr "I<tcp_westwood> (Boolean; default: disabled; Linux 2.4.26/2.6.3 から 2.6.13 まで)"

#. type: Plain text
#: build/C/man7/tcp.7:790
msgid ""
"Enable TCP Westwood+ congestion control algorithm.  TCP Westwood+ is a "
"sender-side only modification of the TCP Reno protocol stack that optimizes "
"the performance of TCP congestion control.  It is based on end-to-end "
"bandwidth estimation to set congestion window and slow start threshold after "
"a congestion episode.  Using this estimation, TCP Westwood+ adaptively sets "
"a slow start threshold and a congestion window which takes into account the "
"bandwidth used at the time congestion is experienced.  TCP Westwood+ "
"significantly increases fairness with respect to TCP Reno in wired networks "
"and throughput over wireless links."
msgstr ""
"TCP Westwood+ 輻輳制御アルゴリズムを有効にする。 TCP Westwood+ は TCP 輻輳制"
"御の性能を最適化するように TCP Reno の プロトコルスタックの送信側のみに修正を"
"加えたものである。 輻輳が起こった後で、輻輳ウィンドウや slow start の閾値を "
"通信両端間の帯域の推測に基づいて設定する。 この推測を使って、TCP Westwood+ は"
"輻輳が発生した時に使っていた 帯域を考慮に入れた slow start の閾値と輻輳ウィン"
"ドウを設定する。 TCP Westwood+ は、有線ネットワークにおける TCP Reno の公平"
"性 (fairness) と、無線リンクでのスループットを大きく向上する。"

#. type: TP
#: build/C/man7/tcp.7:790
#, no-wrap
msgid "I<tcp_window_scaling> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_window_scaling> (Boolean; default: enabled; Linux 2.2 以降)"

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:804
msgid ""
"Enable RFC\\ 1323 TCP window scaling.  This feature allows the use of a "
"large window (E<gt> 64K) on a TCP connection, should the other end support "
"it.  Normally, the 16 bit window length field in the TCP header limits the "
"window size to less than 64K bytes.  If larger windows are desired, "
"applications can increase the size of their socket buffers and the window "
"scaling option will be employed.  If I<tcp_window_scaling> is disabled, TCP "
"will not negotiate the use of window scaling with the other end during "
"connection setup."
msgstr ""
"RFC\\ 1323 の TCP ウィンドウスケーリングを有効にする。 この機能を用いると、接"
"続先が対応していれば、 TCP 接続で大きな (64K 以上の) ウィンドウが使えるように"
"なる。 通常は TCP ヘッダのウインドウ長フィールドは 16 ビットなので、 ウィンド"
"ウサイズは 64K バイト以下に限られる。 もっと大きなウィンドウを使いたい場合"
"は、 アプリケーションはソケットバッファのサイズを増やして、 ウィンドウスケー"
"リングのオプションを利用すればよい。 I<tcp_window_scaling> を無効にしている"
"と、 TCP は他端との接続設定の際に、 ウィンドウスケーリングのネゴシエーション"
"を行なわない。"

#. type: TP
#: build/C/man7/tcp.7:804
#, no-wrap
msgid "I<tcp_wmem> (since Linux 2.4)"
msgstr "I<tcp_wmem> (Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:812
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate send buffer sizes.  TCP dynamically adjusts the size "
"of the send buffer from the default values listed below, in the range of "
"these values, depending on memory available."
msgstr ""
"これは 3 つの整数 [min, default, max] からなるベクトル値である。 これらは "
"TCP が送信バッファサイズを調整するために用いられる。 TCP は、システムで利用で"
"きるメモリに応じて、送信バッファのサイズを これらの変数の範囲で以下に示すデ"
"フォルトから動的に調整する。"

#. type: Plain text
#: build/C/man7/tcp.7:823
msgid ""
"Minimum size of the send buffer used by each TCP socket.  The default value "
"is the system page size.  (On Linux 2.4, the default value is 4K bytes.)  "
"This value is used to ensure that in memory pressure mode, allocations below "
"this size will still succeed.  This is not used to bound the size of the "
"send buffer declared using B<SO_SNDBUF> on a socket."
msgstr ""
"各 TCP ソケットが用いる送信バッファの最小サイズ。 デフォルト値はシステムの"
"ページサイズである (Linux 2.4 では、デフォルト値は 4K である)。 この値は、メ"
"モリ圧迫モードにおいても、 このサイズ以下の割り当てが成功することを保証するた"
"めに用いられる。 これは、 B<SO_SNDBUF> を用いてソケットの最低送信バッファサイ"
"ズを宣言する際には用いられない。"

#.  True in Linux 2.4 and 2.6
#. type: Plain text
#: build/C/man7/tcp.7:837
msgid ""
"The default size of the send buffer for a TCP socket.  This value overwrites "
"the initial default buffer size from the generic global I</proc/sys/net/core/"
"wmem_default> defined for all protocols.  The default value is 16K bytes.  "
"If larger send buffer sizes are desired, this value should be increased (to "
"affect all sockets).  To employ large TCP windows, the I</proc/sys/net/ipv4/"
"tcp_window_scaling> must be set to a nonzero value (default)."
msgstr ""
"TCP ソケットの送信バッファのデフォルトサイズ。 この値は、すべてのプロトコルに"
"対して定義されている、 ジェネリックなグローバルのデフォルトバッファサイズ I</"
"proc/sys/net/core/wmem_default> より優先される。 デフォルト値は 16K バイトで"
"ある。 大きな送信バッファサイズが必要な場合は、 この値を増やすべきである (す"
"べてのソケットに影響する)。 大きな TCP ウィンドウを用いるには、 I</proc/sys/"
"net/ipv4/tcp_window_scaling> を 0 以外の値 (デフォルト値) にしておかなければ"
"ならない。"

#. type: Plain text
#: build/C/man7/tcp.7:846
msgid ""
"The maximum size of the send buffer used by each TCP socket.  This value "
"does not override the value in I</proc/sys/net/core/wmem_max>.  This is not "
"used to limit the size of the send buffer declared using B<SO_SNDBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""
"各 TCP ソケットで用いる送信バッファの最大サイズ。 この値よりも I</proc/sys/"
"net/core/wmem_max> が優先される。 これは B<SO_SNDBUF> を用いてソケットの送信"
"バッファサイズ制限を宣言する際には用いられない。 デフォルト値は以下の式で計算"
"される。"

#. type: Plain text
#: build/C/man7/tcp.7:848
#, no-wrap
msgid "    max(65536, min(4MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr "    max(65536, min(4MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"

#. type: Plain text
#: build/C/man7/tcp.7:851
msgid ""
"(On Linux 2.4, the default value is 128K bytes, lowered 64K depending on low-"
"memory systems.)"
msgstr ""
"(Linux 2.4 では、デフォルト値は 128K バイトで、 メモリの少ないシステムでは "
"64K にまで減らされる。)"

#. type: TP
#: build/C/man7/tcp.7:852
#, no-wrap
msgid "I<tcp_workaround_signed_windows> (Boolean; default: disabled; since Linux 2.6.26)"
msgstr "I<tcp_workaround_signed_windows> (Boolean; default: disabled; Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:858
msgid ""
"If enabled, assume that no receipt of a window-scaling option means that the "
"remote TCP is broken and treats the window as a signed quantity.  If "
"disabled, assume that the remote TCP is not broken even if we do not receive "
"a window scaling option from it."
msgstr ""
"有効にすると、ウィンドウスケーリングオプションを受信しないのは、 接続相手の "
"TCP が壊れていると考え、ウィンドウを符号付きの量とみなす。 無効にすると、接続"
"相手からウィンドウスケーリングオプションを受信しなかった 場合であっても、接続"
"相手の TCP が壊れているとはみなさない。"

#.  or SOL_TCP on Linux
#. type: Plain text
#: build/C/man7/tcp.7:876
msgid ""
"To set or get a TCP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_TCP>.  Unless otherwise noted, I<optval> is a pointer to an "
"I<int>.  In addition, most B<IPPROTO_IP> socket options are valid on TCP "
"sockets.  For more information see B<ip>(7)."
msgstr ""
"TCP ソケットのオプションは、 オプションレベル引数に I<IPPROTO_TCP> を指定し"
"た B<setsockopt>(2)  で設定でき、 B<getsockopt>(2)  で取得できる。 注釈がない"
"限り、 I<optval> は I<int> へのポインタである。 さらに、ほとんどの "
"B<IPPROTO_IP> ソケットオプションも TCP ソケットに対して有効である。詳細は "
"B<ip>(7)  を見よ。"

#. type: TP
#: build/C/man7/tcp.7:876
#, no-wrap
msgid "B<TCP_CORK> (since Linux 2.2)"
msgstr "B<TCP_CORK> (Linux 2.2 以降)"

#.  precisely: since 2.1.127
#. type: Plain text
#: build/C/man7/tcp.7:892
msgid ""
"If set, don't send out partial frames.  All queued partial frames are sent "
"when the option is cleared again.  This is useful for prepending headers "
"before calling B<sendfile>(2), or for throughput optimization.  As currently "
"implemented, there is a 200 millisecond ceiling on the time for which output "
"is corked by B<TCP_CORK>.  If this ceiling is reached, then queued data is "
"automatically transmitted.  This option can be combined with B<TCP_NODELAY> "
"only since Linux 2.5.71.  This option should not be used in code intended to "
"be portable."
msgstr ""
"セットされると、 partial フレームを送信しない。 このオプションが解除される"
"と、 キューイングされた partial フレームが送られる。これは B<sendfile>(2)  を"
"呼ぶ前にヘッダを前置したり、 スループットを最適化したい場合に便利である。 現"
"在の実装では、 B<TCP_CORK> で出力を抑えることができる時間の上限は 200 ミリ秒"
"である。 この上限に達すると、キューイングされたデータは自動的に送信される。 "
"Linux 2.5.71 以降においてのみ、このオプションを B<TCP_NODELAY> と同時に用いる"
"ことができる。 移植性の必要なプログラムではこのオプションを用いるべきではな"
"い。"

#. type: TP
#: build/C/man7/tcp.7:892
#, no-wrap
msgid "B<TCP_DEFER_ACCEPT> (since Linux 2.4)"
msgstr "B<TCP_DEFER_ACCEPT> (Linux 2.4 以降)"

#.  Precisely: since 2.3.38
#. type: Plain text
#: build/C/man7/tcp.7:900
msgid ""
"Allow a listener to be awakened only when data arrives on the socket.  Takes "
"an integer value (seconds), this can bound the maximum number of attempts "
"TCP will make to complete the connection.  This option should not be used in "
"code intended to be portable."
msgstr ""
"これを用いると、リスナはデータがソケットに到着した時のみ目覚めるようになる。 "
"整数値 (秒) をとり、 TCP が接続を完了しようと試みる回数を制限できる。 移植性"
"の必要なプログラムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:900
#, no-wrap
msgid "B<TCP_INFO> (since Linux 2.4)"
msgstr "B<TCP_INFO> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:906
msgid ""
"Used to collect information about this socket.  The kernel returns a "
"I<struct tcp_info> as defined in the file I</usr/include/linux/tcp.h>.  This "
"option should not be used in code intended to be portable."
msgstr ""
"このソケットの情報を収集するのに用いる。 カーネルは I</usr/include/linux/tcp."
"h> ファイルで定義されている I<struct tcp_info> を返す。 移植性の必要なプログ"
"ラムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:906
#, no-wrap
msgid "B<TCP_KEEPCNT> (since Linux 2.4)"
msgstr "B<TCP_KEEPCNT> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:913
msgid ""
"The maximum number of keepalive probes TCP should send before dropping the "
"connection.  This option should not be used in code intended to be portable."
msgstr ""
"接続を落とす前に TCP が試みる keepalive プローブの最大回数。 移植性の必要なプ"
"ログラムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:913
#, no-wrap
msgid "B<TCP_KEEPIDLE> (since Linux 2.4)"
msgstr "B<TCP_KEEPIDLE> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:922
msgid ""
"The time (in seconds) the connection needs to remain idle before TCP starts "
"sending keepalive probes, if the socket option B<SO_KEEPALIVE> has been set "
"on this socket.  This option should not be used in code intended to be "
"portable."
msgstr ""
"この時間 (秒単位) を越えて接続がアイドル状態に留まっていると、 このソケット"
"に B<SO_KEEPALIVE> ソケットオプションが設定されている場合、 TCP は keepalive "
"プローブを送りはじめる。 移植性の必要なプログラムではこのオプションを用いるべ"
"きではない。"

#. type: TP
#: build/C/man7/tcp.7:922
#, no-wrap
msgid "B<TCP_KEEPINTVL> (since Linux 2.4)"
msgstr "B<TCP_KEEPINTVL> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:927
msgid ""
"The time (in seconds) between individual keepalive probes.  This option "
"should not be used in code intended to be portable."
msgstr ""
"各 keepalive プローブの間隔 (秒単位)。 移植性の必要なプログラムではこのオプ"
"ションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:927
#, no-wrap
msgid "B<TCP_LINGER2> (since Linux 2.4)"
msgstr "B<TCP_LINGER2> (Linux 2.4 以降)"

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:939
msgid ""
"The lifetime of orphaned FIN_WAIT2 state sockets.  This option can be used "
"to override the system-wide setting in the file I</proc/sys/net/ipv4/"
"tcp_fin_timeout> for this socket.  This is not to be confused with the "
"B<socket>(7)  level option B<SO_LINGER>.  This option should not be used in "
"code intended to be portable."
msgstr ""
"orphan された FIN_WAIT2 状態のソケットの寿命。 このオプションを用いると、シス"
"テム全体に適用されるファイル I</proc/sys/net/ipv4/tcp_fin_timeout> の値を、こ"
"のソケットに対してのみ変更できる。 B<socket>(7)  レベルのオプション "
"B<SO_LINGER> と混同しないこと。 移植性の必要なプログラムではこのオプションを"
"用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:939
#, no-wrap
msgid "B<TCP_MAXSEG>"
msgstr "B<TCP_MAXSEG>"

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:949
msgid ""
"The maximum segment size for outgoing TCP packets.  In Linux 2.2 and "
"earlier, and in Linux 2.6.28 and later, if this option is set before "
"connection establishment, it also changes the MSS value announced to the "
"other end in the initial packet.  Values greater than the (eventual) "
"interface MTU have no effect.  TCP will also impose its minimum and maximum "
"bounds over the value provided."
msgstr ""
"送出 TCP パケットの最大セグメントサイズ。 Linux 2.2 以前と Linux\n"
"2.6.28 以降では、このオプションを接続確立の前に設定すると、初期パケット\n"
"で他端にアナウンスする MSS の値も変化する。インターフェースの MTU より\n"
"も大きな (あるいは大きくなってしまった) 値は効果を持たない。 また TCP\n"
"は、この値よりも最小・最大の制限の方を優先する。"

#. type: TP
#: build/C/man7/tcp.7:949
#, no-wrap
msgid "B<TCP_NODELAY>"
msgstr "B<TCP_NODELAY>"

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:966
msgid ""
"If set, disable the Nagle algorithm.  This means that segments are always "
"sent as soon as possible, even if there is only a small amount of data.  "
"When not set, data is buffered until there is a sufficient amount to send "
"out, thereby avoiding the frequent sending of small packets, which results "
"in poor utilization of the network.  This option is overridden by "
"B<TCP_CORK>; however, setting this option forces an explicit flush of "
"pending output, even if B<TCP_CORK> is currently set."
msgstr ""
"設定すると Nagle アルゴリズムを無効にする。 すなわち、データ量が少ない場合で"
"も 各セグメントは可能な限り早く送信される。 設定されていないと、 送信する分だ"
"け溜まるまでデータはバッファされ、 小さなパケットを頻繁に送らずにすみ、 ネッ"
"トワークを有効に利用できる。 このオプションは B<TCP_CORK> により上書きされ"
"る。しかしながら、 B<TCP_CORK> が設定されている場合であっても、このオプション"
"を設定すると、 送信待ちの出力を明示的に掃き出す (flush) ことになる。"

#. type: TP
#: build/C/man7/tcp.7:966
#, no-wrap
msgid "B<TCP_QUICKACK> (since Linux 2.4.4)"
msgstr "B<TCP_QUICKACK> (Linux 2.4.4 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:981
msgid ""
"Enable quickack mode if set or disable quickack mode if cleared.  In "
"quickack mode, acks are sent immediately, rather than delayed if needed in "
"accordance to normal TCP operation.  This flag is not permanent, it only "
"enables a switch to or from quickack mode.  Subsequent operation of the TCP "
"protocol will once again enter/leave quickack mode depending on internal "
"protocol processing and factors such as delayed ack timeouts occurring and "
"data transfer.  This option should not be used in code intended to be "
"portable."
msgstr ""
"設定されていると quickack モードを有効にし、クリアされると無効にする。 通常"
"の TCP 動作では ack は必要に応じて遅延されるのに対し、 quickack モードでは "
"ack はすぐに送信される。 このフラグは永続的なものではなく、 quickack モードか"
"ら/モードへ切り替えるためのものである。 これ以降の TCP プロトコルの動作によっ"
"ては、 内部のプロトコル処理や、遅延 ack タイムアウトの発生、 データ転送などの"
"要因によって、 再び quickack から出たり入ったりする。 移植性の必要なプログラ"
"ムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:981
#, no-wrap
msgid "B<TCP_SYNCNT> (since Linux 2.4)"
msgstr "B<TCP_SYNCNT> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:988
msgid ""
"Set the number of SYN retransmits that TCP should send before aborting the "
"attempt to connect.  It cannot exceed 255.  This option should not be used "
"in code intended to be portable."
msgstr ""
"接続の試行を中止させる前に TCP が送る SYN 再送数を設定する。 これは 255 より"
"大きくはできない。 移植性の必要なプログラムではこのオプションを用いるべきでは"
"ない。"

#. type: TP
#: build/C/man7/tcp.7:988
#, no-wrap
msgid "B<TCP_WINDOW_CLAMP> (since Linux 2.4)"
msgstr "B<TCP_WINDOW_CLAMP> (Linux 2.4 以降)"

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:995
msgid ""
"Bound the size of the advertised window to this value.  The kernel imposes a "
"minimum size of SOCK_MIN_RCVBUF/2.  This option should not be used in code "
"intended to be portable."
msgstr ""
"広報するウィンドウのサイズをこの値に固定する。 カーネルによって最小サイズは "
"SOCK_MIN_RCVBUF/2 に制限されている。 このオプションは移植性の必要なコードでは"
"用いるべきでない。"

#. type: SS
#: build/C/man7/tcp.7:995 build/C/man7/unix.7:177
#, no-wrap
msgid "Sockets API"
msgstr "ソケット API"

#. type: Plain text
#: build/C/man7/tcp.7:1004
msgid ""
"TCP provides limited support for out-of-band data, in the form of (a single "
"byte of) urgent data.  In Linux this means if the other end sends newer out-"
"of-band data the older urgent data is inserted as normal data into the "
"stream (even when B<SO_OOBINLINE> is not set).  This differs from BSD-based "
"stacks."
msgstr ""
"TCP は帯域外データ (out-of-band data) を限定的にサポートしており、 (1 バイト"
"の) 緊急データという形である。 つまり Linux においては、 接続先が (新しいやり"
"方の) 帯域外データを送ってきた場合、 (古いやり方の)  緊急データは通常のデータ"
"としてストリームに挿入されることになる (これは B<SO_OOBINLINE> がセットされて"
"いる場合でも同様である)。 これは BSD ベースのスタックとは異なる。"

#. type: Plain text
#: build/C/man7/tcp.7:1011
msgid ""
"Linux uses the BSD compatible interpretation of the urgent pointer field by "
"default.  This violates RFC\\ 1122, but is required for interoperability "
"with other stacks.  It can be changed via I</proc/sys/net/ipv4/tcp_stdurg>."
msgstr ""
"Linux は、デフォルトでは urgent ポインタフィールドの解釈に BSD 互換の方法を用"
"いる。これは RFC\\ 1122 に反しているが、 他のスタックと同時に動作させるにはや"
"むを得ない。これは I</proc/sys/net/ipv4/tcp_stdurg> によって変更できる。"

#. type: Plain text
#: build/C/man7/tcp.7:1016
msgid ""
"It is possible to peek at out-of-band data using the I<recv>(2)  B<MSG_PEEK> "
"flag."
msgstr ""
"B<recv>(2)  の B<MSG_PEEK> フラグを使うと、帯域外データを覗き見することができ"
"る。"

#. type: Plain text
#: build/C/man7/tcp.7:1032
msgid ""
"Since version 2.4, Linux supports the use of B<MSG_TRUNC> in the I<flags> "
"argument of B<recv>(2)  (and B<recvmsg>(2)).  This flag causes the received "
"bytes of data to be discarded, rather than passed back in a caller-supplied "
"buffer.  Since Linux 2.4.4, B<MSG_PEEK> also has this effect when used in "
"conjunction with B<MSG_OOB> to receive out-of-band data."
msgstr ""
"Linux 2.4 以降では、 B<recv>(2)  (や B<recvmsg>(2))  の I<flags> 引き数に "
"B<MSG_TRUNC> を使うことができる。 このフラグを指定すると、受信データは、呼び"
"出し元から渡されたバッファ にコピーされて返されるのではなく、廃棄されるように"
"なる。 Linux 2.4.4 以降では、 B<MSG_PEEK> を、帯域外データを受信するための "
"B<MSG_OOB> と組み合わせて使った場合にも、これと同じ効果を持つようになってい"
"る。"

#. type: Plain text
#: build/C/man7/tcp.7:1038 build/C/man7/unix.7:290
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""
"以下の B<ioctl>(2) 呼び出しは I<value> に情報を入れて返す。\n"
"正しい書式は以下の通り。"

#. type: Plain text
#: build/C/man7/tcp.7:1043
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<tcp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<tcp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: Plain text
#: build/C/man7/tcp.7:1048
msgid "I<ioctl_type> is one of the following:"
msgstr "I<ioctl_type> は以下のいずれか一つである:"

#. type: TP
#: build/C/man7/tcp.7:1048 build/C/man7/unix.7:300
#, no-wrap
msgid "B<SIOCINQ>"
msgstr "B<SIOCINQ>"

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
#: build/C/man7/tcp.7:1064 build/C/man7/unix.7:322
msgid ""
"Returns the amount of queued unread data in the receive buffer.  The socket "
"must not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCINQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""
"受信バッファのキューにある、まだ読んでいないデータの量を返す。ソケットは\n"
"LISTEN 状態にあってはならず、さもないとエラー (B<EINVAL>) が返る。\n"
"B<SIOCINQ> は I<E<lt>linux/sockios.hE<gt>> で定義されている。\n"
"代わりに、I<E<lt>sys/ioctl.hE<gt>> で定義されている、同義語の B<FIONREAD>\n"
"を使うこともできる。"

#. type: TP
#: build/C/man7/tcp.7:1064
#, no-wrap
msgid "B<SIOCATMARK>"
msgstr "B<SIOCATMARK>"

#. type: Plain text
#: build/C/man7/tcp.7:1069
msgid ""
"Returns true (i.e., I<value> is nonzero) if the inbound data stream is at "
"the urgent mark."
msgstr ""
"受信データストリームが緊急マークの位置であれば、真を返す (つまり I<value> が "
"0 以外)。"

#. type: Plain text
#: build/C/man7/tcp.7:1085
msgid ""
"If the B<SO_OOBINLINE> socket option is set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the urgent data.  If the "
"B<SO_OOBINLINE> socket option is not set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the bytes following the "
"urgent data (to actually read the urgent data requires the B<recv(MSG_OOB)> "
"flag)."
msgstr ""
"B<SO_OOBINLINE> ソケットオプションが設定されていて、 B<SIOCATMARK> が真を返し"
"た場合、次のソケットからの読み込みでは緊急データが 返される。 "
"B<SO_OOBINLINE> ソケットオプションが設定されておらず、 B<SIOCATMARK> が真を返"
"した場合、次のソケットからの読み込みでは緊急データに 続くデータが返される (実"
"際に緊急データを読み込むには B<recv(MSG_OOB)> とフラグをつける必要がある)。"

#. type: Plain text
#: build/C/man7/tcp.7:1099
msgid ""
"Note that a read never reads across the urgent mark.  If an application is "
"informed of the presence of urgent data via B<select>(2)  (using the "
"I<exceptfds> argument) or through delivery of a B<SIGURG> signal, then it "
"can advance up to the mark using a loop which repeatedly tests B<SIOCATMARK> "
"and performs a read (requesting any number of bytes) as long as "
"B<SIOCATMARK> returns false."
msgstr ""
"データの一回の読み込みでは緊急マークを跨がっての読み込みは行われない。 アプリ"
"ケーションが緊急データの存在を (I<exceptfds> 引き数を使って)  B<select>(2)  "
"経由または B<SIGURG> シグナルの配送を通じて知らされた場合、 B<SIOCATMARK> の"
"チェックと読み込み (何バイト読み込み要求をしてもよい) を B<SIOCATMARK> が偽を"
"返さなくなるまで繰り返し行うことで、緊急マークの位置まで 読み進めることができ"
"る。"

#. type: TP
#: build/C/man7/tcp.7:1099
#, no-wrap
msgid "B<SIOCOUTQ>"
msgstr "B<SIOCOUTQ>"

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCOUTQ to be defined in glibc headers
#. type: Plain text
#: build/C/man7/tcp.7:1115
msgid ""
"Returns the amount of unsent data in the socket send queue.  The socket must "
"not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCOUTQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<TIOCOUTQ>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""
"ソケットの送信キューに残っている未送信データの量を返す。ソケットは LISTEN "
"状\n"
"態にあってはならない。 LISTEN 状態の場合にはエラー (B<EINVAL>) となる。\n"
"B<SIOCOUTQ> は I<E<lt>linux/sockios.hE<gt>> で定義されている。\n"
"代わりに、I<E<lt>sys/ioctl.hE<gt>> で定義されている、同義語の B<TIOCOUTQ> "
"を\n"
"使うこともできる。"

#. type: Plain text
#: build/C/man7/tcp.7:1120
msgid ""
"When a network error occurs, TCP tries to resend the packet.  If it doesn't "
"succeed after some time, either B<ETIMEDOUT> or the last received error on "
"this connection is reported."
msgstr ""
"ネットワークエラーが起こると、 TCP はパケットの再送を試みる。 何回かやっても"
"成功しなければ、この接続に対して B<ETIMEOUT> エラーか最後に受信したエラーが返"
"される。"

#. type: Plain text
#: build/C/man7/tcp.7:1131
msgid ""
"Some applications require a quicker error notification.  This can be enabled "
"with the B<IPPROTO_IP> level B<IP_RECVERR> socket option.  When this option "
"is enabled, all incoming errors are immediately passed to the user program.  "
"Use this option with care \\(em it makes TCP less tolerant to routing "
"changes and other normal network conditions."
msgstr ""
"アプリケーションによっては、もっと早くエラーを知らせてほしい場合がある。 これ"
"には B<IPPROTO_IP> レベルの B<IP_RECVERR> ソケットオプションを用いると良い。"
"このオプションが有効になっていると、 到着したエラーはすべてただちにユーザープ"
"ログラムに渡される。 このオプションは慎重に用いること \\(em ルーティングの変"
"更など、 通常ありうるネットワーク状態に対して TCP をより脆弱にしてしまう。"

#. type: TP
#: build/C/man7/tcp.7:1132
#, no-wrap
msgid "B<EAFNOTSUPPORT>"
msgstr "B<EAFNOTSUPPORT>"

#. type: Plain text
#: build/C/man7/tcp.7:1138
msgid "Passed socket address type in I<sin_family> was not B<AF_INET>."
msgstr ""
"I<sin_family> に渡されたソケットアドレスのタイプが B<AF_INET> ではなかった。"

#. type: Plain text
#: build/C/man7/tcp.7:1142
msgid ""
"The other end closed the socket unexpectedly or a read is executed on a shut "
"down socket."
msgstr ""
"接続先が予期しなかったかたちでソケットをクローズした。 またはシャットダウンさ"
"れたソケットに読み込みが実行された。"

#. type: TP
#: build/C/man7/tcp.7:1142
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man7/tcp.7:1145
msgid "The other end didn't acknowledge retransmitted data after some time."
msgstr "接続先が、何回かデータを再送しても反応しない。"

#. type: Plain text
#: build/C/man7/tcp.7:1149
msgid ""
"Any errors defined for B<ip>(7)  or the generic socket layer may also be "
"returned for TCP."
msgstr ""
"B<ip>(7)  で定義されているエラーや、ジェネリックなソケット層におけるエラーも "
"TCP に返されることがある。"

#. type: Plain text
#: build/C/man7/tcp.7:1156
msgid ""
"Support for Explicit Congestion Notification, zero-copy B<sendfile>(2), "
"reordering support and some SACK extensions (DSACK) were introduced in 2.4.  "
"Support for forward acknowledgement (FACK), TIME_WAIT recycling, and per-"
"connection keepalive socket options were introduced in 2.3."
msgstr ""
"Explicit Congestion Notification、zero-copy の B<sendfile>(2)、 並び替えのサ"
"ポート、SACK 拡張 (DSACK) などのサポートは 2.4 で導入された。 フォワード確認 "
"(FACK)、TIME_WAIT リサイクル、接続ごとの keepalive に対するソケットオプション"
"は 2.3 で導入された。"

#. type: Plain text
#: build/C/man7/tcp.7:1158
msgid "Not all errors are documented."
msgstr "まだ説明されていないエラーがある。"

#.  Only a single Linux kernel version is described
#.  Info for 2.2 was lost. Should be added again,
#.  or put into a separate page.
#.  .SH AUTHORS
#.  This man page was originally written by Andi Kleen.
#.  It was updated for 2.4 by Nivedita Singhvi with input from
#.  Alexey Kuznetsov's Documentation/networking/ip-sysctl.txt
#.  document.
#. type: Plain text
#: build/C/man7/tcp.7:1168
msgid "IPv6 is not described."
msgstr "IPv6 に関する記述がない。"

#. type: Plain text
#: build/C/man7/tcp.7:1180
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getsockopt>(2), B<listen>(2), "
"B<recvmsg>(2), B<sendfile>(2), B<sendmsg>(2), B<socket>(2), B<ip>(7), "
"B<socket>(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getsockopt>(2), B<listen>(2), "
"B<recvmsg>(2), B<sendfile>(2), B<sendmsg>(2), B<socket>(2), B<ip>(7), "
"B<socket>(7)"

#. type: Plain text
#: build/C/man7/tcp.7:1182
msgid "RFC\\ 793 for the TCP specification."
msgstr "RFC\\ 793: TCP の仕様。"

#. type: Plain text
#: build/C/man7/tcp.7:1184
msgid ""
"RFC\\ 1122 for the TCP requirements and a description of the Nagle algorithm."
msgstr "RFC\\ 1122: TCP の要求事項と Nagle アルゴリズムの記述。"

#. type: Plain text
#: build/C/man7/tcp.7:1186
msgid "RFC\\ 1323 for TCP timestamp and window scaling options."
msgstr "RFC\\ 1323: TCP のタイムスタンプ・ウィンドウスケーリング各オプション。"

#. type: Plain text
#: build/C/man7/tcp.7:1188
msgid "RFC\\ 1337 for a description of TIME_WAIT assassination hazards."
msgstr "RFC\\ 1337: TIME_WAIT assassination hazard に関する説明。"

#. type: Plain text
#: build/C/man7/tcp.7:1190
msgid "RFC\\ 3168 for a description of Explicit Congestion Notification."
msgstr "RFC\\ 3168: Explicit Congestion Notification に関する説明。"

#. type: Plain text
#: build/C/man7/tcp.7:1192
msgid "RFC\\ 2581 for TCP congestion control algorithms."
msgstr "RFC\\ 2581: TCP 輻輳制御アルゴリズム。"

#. type: Plain text
#: build/C/man7/tcp.7:1194
msgid "RFC\\ 2018 and RFC\\ 2883 for SACK and extensions to SACK."
msgstr "RFC\\ 2018 と RFC\\ 2883: SACK とその拡張。"

#. type: TH
#: build/C/man7/udp.7:12
#, no-wrap
msgid "UDP"
msgstr "UDP"

#. type: Plain text
#: build/C/man7/udp.7:15
msgid "udp - User Datagram Protocol for IPv4"
msgstr "udp - IPv4 の ユーザーデータグラムプロトコル"

#. type: Plain text
#: build/C/man7/udp.7:21
msgid "B<#include E<lt>netinet/udp.hE<gt>>"
msgstr "B<#include E<lt>netinet/udp.hE<gt>>"

#. type: Plain text
#: build/C/man7/udp.7:23
msgid "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/udp.7:29
msgid ""
"This is an implementation of the User Datagram Protocol described in RFC\\ "
"768.  It implements a connectionless, unreliable datagram packet service.  "
"Packets may be reordered or duplicated before they arrive.  UDP generates "
"and checks checksums to catch transmission errors."
msgstr ""
"これは RFC\\ 768 で記述されている User Datagram Protocol の実装である。 UDP "
"はコネクションレスの、信頼性の低いデータパケットサービスである。 パケットは到"
"着前に並び替えられたり複製されたりする。 UDP は転送エラーを検出するために"
"チェックサムを生成・チェックする。"

#. type: Plain text
#: build/C/man7/udp.7:58
msgid ""
"When a UDP socket is created, its local and remote addresses are "
"unspecified.  Datagrams can be sent immediately using B<sendto>(2)  or "
"B<sendmsg>(2)  with a valid destination address as an argument.  When "
"B<connect>(2)  is called on the socket, the default destination address is "
"set and datagrams can now be sent using B<send>(2)  or B<write>(2)  without "
"specifying a destination address.  It is still possible to send to other "
"destinations by passing an address to B<sendto>(2)  or B<sendmsg>(2).  In "
"order to receive packets, the socket can be bound to a local address first "
"by using B<bind>(2).  Otherwise the socket layer will automatically assign a "
"free local port out of the range defined by I</proc/sys/net/ipv4/"
"ip_local_port_range> and bind the socket to B<INADDR_ANY>."
msgstr ""
"UDP ソケットが生成されるとき、 ローカルアドレスやリモートアドレスは指定されな"
"い。 正しい行き先アドレスを引数として B<sendto>(2)  や B<sendmsg>(2)  を呼べ"
"ば、データグラムはただちに送信される。 ソケットに対して B<connect>(2)  を呼ぶ"
"と、デフォルトの行き先アドレスが設定され、 B<send>(2)  や B<write>(2)  を使っ"
"て、行き先アドレスの指定なしにデータグラムを送信できるようになる。 この場合で"
"も、行き先アドレスを B<sendto>(2)  や B<sendmsg>(2)  に渡せば、デフォルト以外"
"のアドレスに送信可能である。 パケットを受信するために、まずソケットを B<bind>"
"(2)  を用いてローカルなアドレスにバインドさせることもできる。 そうでない場合"
"は、ソケット層は自動的に I</proc/sys/net/ipv4/ip_local_port_range> で定義され"
"ている範囲の外で空いているローカルなポートを割り当て、 ソケットを "
"B<INADDR_ANY> にバインドする。"

#. type: Plain text
#: build/C/man7/udp.7:66
msgid ""
"All receive operations return only one packet.  When the packet is smaller "
"than the passed buffer, only that much data is returned; when it is bigger, "
"the packet is truncated and the B<MSG_TRUNC> flag is set.  B<MSG_WAITALL> is "
"not supported."
msgstr ""
"受信動作はパケットを一つだけ返す。渡したバッファよりもパケットが 小さければ、"
"そのパケットの大きさのデータだけが返される。 逆にバッファよりも大きい場合はパ"
"ケットは丸められ、 B<MSG_TRUNC> フラグがセットされる。 B<MSG_WAITALL> はサ"
"ポートしていない。"

#. type: Plain text
#: build/C/man7/udp.7:75
msgid ""
"IP options may be sent or received using the socket options described in "
"B<ip>(7).  They are processed by the kernel only when the appropriate I</"
"proc> parameter is enabled (but still passed to the user even when it is "
"turned off).  See B<ip>(7)."
msgstr ""
"IP オプションは、 B<ip>(7)  に記述されているソケットオプションを用いて読み書"
"きできる。 これらは適切な I</proc> パラメータが有効な場合に限ってカーネルに"
"よって処理される (しかし無効になっている場合でもユーザーには渡される)。 B<ip>"
"(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/udp.7:80
msgid ""
"When the B<MSG_DONTROUTE> flag is set on sending, the destination address "
"must refer to a local interface address and the packet is sent only to that "
"interface."
msgstr ""
"B<MSG_DONTROUTE> フラグが送信時にセットされている場合には、 行き先アドレスは"
"ローカルなインターフェースアドレスから 参照できなければならない。パケットはそ"
"のインターフェースにしか送られない。"

#. type: Plain text
#: build/C/man7/udp.7:98
msgid ""
"By default, Linux UDP does path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a UDP packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file; see B<ip>(7)  for "
"details.  When turned off, UDP will fragment outgoing UDP packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"デフォルトでは、Linux の UDP は Path MTU Discovery を行う。 つまり、カーネル"
"は特定の宛先 IP アドレスの MTU (Maximum Transmission Unit; 最大転送単位) を記"
"録し、UDP パケットの書き込みが MTU を超えた場合 B<EMSGSIZE> を返す。 "
"B<EMSGSIZE> を返された場合、アプリケーションはパケットサイズを小さくすべきで"
"ある。 ソケットオプション B<IP_MTU_DISCOVER> または I</proc/sys/net/ipv4/"
"ip_no_pmtu_disc> ファイルを使って Path MTU Discovery を無効にすることもでき"
"る (詳細は B<ip>(7)  を参照)。 Path MTU Discovery を無効にした場合は、パケッ"
"トサイズが インタフェースの MTU よりも大きいと UDP はそのパケットを フラグメ"
"ント化して送出する。 しかしながら、性能と信頼性の理由から Path MTU Discovery "
"を 無効にするのは推奨できない。"

#. type: Plain text
#: build/C/man7/udp.7:103
msgid "UDP uses the IPv4 I<sockaddr_in> address format described in B<ip>(7)."
msgstr ""
"UDP は IPv4 の I<sockaddr_in> アドレスフォーマットを用いる。これは B<ip>(7)  "
"に記述されている。"

#. type: Plain text
#: build/C/man7/udp.7:114
msgid ""
"All fatal errors will be passed to the user as an error return even when the "
"socket is not connected.  This includes asynchronous errors received from "
"the network.  You may get an error for an earlier packet that was sent on "
"the same socket.  This behavior differs from many other BSD socket "
"implementations which don't pass any errors unless the socket is connected.  "
"Linux's behavior is mandated by B<RFC\\ 1122>."
msgstr ""
"致命的なエラーは、たとえソケットが接続されていなくても、 すべてエラー戻り値と"
"してユーザーに渡される。 これにはネットワークから受け取る非同期エラーも含まれ"
"る。 同じソケットを使って送信した昔のパケットに関するエラーを受け取るかもしれ"
"ない。 この振る舞いは他の BSD ソケットの実装の多くとは異なる。 これらではソ"
"ケットが接続されていない場合はエラーを全く返さない。 Linux の振る舞いは B<RFC"
"\\ 1122> での指定に従ったものである。"

#. type: Plain text
#: build/C/man7/udp.7:128
msgid ""
"For compatibility with legacy code, in Linux 2.0 and 2.2 it was possible to "
"set the B<SO_BSDCOMPAT> B<SOL_SOCKET> option to receive remote errors only "
"when the socket has been connected (except for B<EPROTO> and B<EMSGSIZE>).  "
"Locally generated errors are always passed.  Support for this socket option "
"was removed in later kernels; see B<socket>(7)  for further information."
msgstr ""
"Linux 2.0 と 2.2 では、古いコードとの互換性のために、 B<SO_BSDCOMPAT> "
"B<SOL_SOCKET> オプションを設定すれば、ソケットが接続されている 場合に限ってリ"
"モートのエラーを受信するようにできた (B<EPROTO> と B<EMSGSIZE> を除く)。 ロー"
"カルで生成されたエラーは常に渡される。 このソケットオプションのサポートはそれ"
"以降のバージョンの Linux で 削除された。詳細は B<socket>(7)  を参照。"

#. type: Plain text
#: build/C/man7/udp.7:137
msgid ""
"When the B<IP_RECVERR> option is enabled, all errors are stored in the "
"socket error queue, and can be received by B<recvmsg>(2)  with the "
"B<MSG_ERRQUEUE> flag set."
msgstr ""
"B<IP_RECVERR> オプションが有効になっていると、 すべてのエラーはソケットのエ"
"ラーキューに保存される。 これは B<MSG_ERRQUEUE> フラグをセットして B<recvmsg>"
"(2)  を呼べば受信できる。"

#. type: Plain text
#: build/C/man7/udp.7:140
msgid ""
"System-wide UDP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>."
msgstr ""
"システム全体の UDP パラメータ設定には、 I</proc/sys/net/ipv4/> ディレクトリ内"
"のファイルの読み書きでアクセスできる。"

#. type: TP
#: build/C/man7/udp.7:140
#, no-wrap
msgid "I<udp_mem> (since Linux 2.6.25)"
msgstr "I<udp_mem> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/udp.7:144
msgid ""
"This is a vector of three integers governing the number of pages allowed for "
"queueing by all UDP sockets."
msgstr ""
"これは 3 つの整数からなるベクトル値で、 UDP の全ソケットのキューで利用可能な"
"ページ数を制御する。"

#. type: Plain text
#: build/C/man7/udp.7:151
msgid ""
"Below this number of pages, UDP is not bothered about its memory appetite.  "
"When the amount of memory allocated by UDP exceeds this number, UDP starts "
"to moderate memory usage."
msgstr ""
"このページ数より少なければ、UDP はそのメモリ使用に関して 干渉されない。 UDP "
"に割り当てられたメモリ総量がこの値を超過すると、 UDP はメモリ使用量を調整し始"
"める。"

#. type: Plain text
#: build/C/man7/udp.7:157
msgid ""
"This value was introduced to follow the format of I<tcp_mem> (see B<tcp>(7))."
msgstr ""
"この値は I<tcp_mem> の形式 (B<tcp>(7)  参照) と合わせるために導入された"

#. type: Plain text
#: build/C/man7/udp.7:160
msgid "Number of pages allowed for queueing by all UDP sockets."
msgstr "UDP の全ソケットのキューで利用可能なページ数。"

#. type: Plain text
#: build/C/man7/udp.7:164
msgid ""
"Defaults values for these three items are calculated at boot time from the "
"amount of available memory."
msgstr ""
"これらの 3 つの値のデフォルト値は、 ブート時に利用可能なメモリ総量から計算さ"
"れる。"

#. type: TP
#: build/C/man7/udp.7:164
#, no-wrap
msgid "I<udp_rmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr "I<udp_rmem_min> (integer; デフォルト値: PAGE_SIZE; Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/udp.7:171
msgid ""
"Minimal size, in bytes, of receive buffers used by UDP sockets in "
"moderation.  Each UDP socket is able to use the size for receiving data, "
"even if total pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""
"メモリ使用量の調整中に、UDP ソケットが使用できる受信バッファの最小値 (バイト"
"単位)。 UDP の全ソケットのページ使用量の合計が I<udp_mem> pressure を超過して"
"いる場合であっても、 各 UDP ソケットはデータの受信にこのサイズ分だけは使用す"
"ることができる。"

#. type: TP
#: build/C/man7/udp.7:171
#, no-wrap
msgid "I<udp_wmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr "I<udp_wmem_min> (integer; デフォルト値: PAGE_SIZE; Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/udp.7:178
msgid ""
"Minimal size, in bytes, of send buffer used by UDP sockets in moderation.  "
"Each UDP socket is able to use the size for sending data, even if total "
"pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""
"メモリ使用量の調整中に、UDP ソケットが使用できる送信バッファの最小値 (バイト"
"単位)。 UDP の全ソケットのページ使用量の合計が I<udp_mem> pressure を超過して"
"いる場合であっても、 各 UDP ソケットはデータの送信にこのサイズ分だけは使用す"
"ることができる。"

#. type: Plain text
#: build/C/man7/udp.7:189
msgid ""
"To set or get a UDP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDP>.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""
"UDP ソケットオプションを設定または取得するには、 取得には B<getsockopt>(2)  "
"を、設定には B<setsockopt>(2)  をオプションレベル引数に B<IPPROTO_UDP> を指定"
"して呼び出す。 注釈がない限り、 I<optval> は I<int> へのポインタである。"

#. type: TP
#: build/C/man7/udp.7:189
#, no-wrap
msgid "B<UDP_CORK> (since Linux 2.5.44)"
msgstr "B<UDP_CORK> (Linux 2.5.44 以降)"

#.  FIXME document UDP_ENCAP (new in kernel 2.5.67)
#.  From include/linux/udp.h:
#.  /* UDP encapsulation types */
#.  #define UDP_ENCAP_ESPINUDP_NON_IKE      1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
#.  #define UDP_ENCAP_ESPINUDP      2 /* draft-ietf-ipsec-udp-encaps-06 */
#.  #define UDP_ENCAP_L2TPINUDP     3 /* rfc2661 */
#. type: Plain text
#: build/C/man7/udp.7:202
msgid ""
"If this option is enabled, then all data output on this socket is "
"accumulated into a single datagram that is transmitted when the option is "
"disabled.  This option should not be used in code intended to be portable."
msgstr ""
"このオプションが指定されると、このソケットの全てのデータ出力は 一つのデータグ"
"ラムに蓄積され、このオプションが無効化された時に 送信される。 このオプション"
"は移植性を考慮したコードでは用いるべきではない。"

#. type: Plain text
#: build/C/man7/udp.7:206
msgid "These ioctls can be accessed using B<ioctl>(2).  The correct syntax is:"
msgstr ""
"以下に示す ioctl は B<ioctl>(2)  を使ってアクセスできる。 正しい文法は以下の"
"通り。"

#. type: Plain text
#: build/C/man7/udp.7:211
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: TP
#: build/C/man7/udp.7:213
#, no-wrap
msgid "B<FIONREAD> (B<SIOCINQ>)"
msgstr "B<FIONREAD> (B<SIOCINQ>)"

#.  See http://www.securiteam.com/unixfocus/5KP0I15IKO.html
#.  "GNUnet DoS (UDP Socket Unreachable)", 14 May 2006
#. type: Plain text
#: build/C/man7/udp.7:231
msgid ""
"Gets a pointer to an integer as argument.  Returns the size of the next "
"pending datagram in the integer in bytes, or 0 when no datagram is pending.  "
"B<Warning:> Using B<FIONREAD>, it is impossible to distinguish the case "
"where no datagram is pending from the case where the next pending datagram "
"contains zero bytes of data.  It is safer to use B<select>(2), B<poll>(2), "
"or B<epoll>(7)  to distinguish these cases."
msgstr ""
"整数へのポインタを引き数に取り、そのポインタに、次の処理待ちのデータグラム"
"の\n"
"サイズをバイト単位で返す。処理待ちのデータグラムがない場合は 0 を返す。\n"
"B<警告>: B<FIONREAD> を使った場合、処理待ちのデータグラムがない場合と、\n"
"次の処理待ちデータグラムが 0 バイトのデータの場合を区別することができない。\n"
"この両者を区別したい場合は、B<select>(2), B<poll>(2), B<epoll>(7) \n"
"を使う方が安全である。"

#. type: TP
#: build/C/man7/udp.7:231
#, no-wrap
msgid "B<TIOCOUTQ> (B<SIOCOUTQ>)"
msgstr "B<TIOCOUTQ> (B<SIOCOUTQ>)"

#. type: Plain text
#: build/C/man7/udp.7:235
msgid ""
"Returns the number of data bytes in the local send queue.  Only supported "
"with Linux 2.4 and above."
msgstr ""
"ローカル送信キューにあるデータサイズをバイト単位で返す。 Linux 2.4 以上でのみ"
"対応している。"

#. type: Plain text
#: build/C/man7/udp.7:241
msgid ""
"In addition all ioctls documented in B<ip>(7)  and B<socket>(7)  are "
"supported."
msgstr ""
"さらに、 B<ip>(7)  と B<socket>(7)  で述べられている全ての ioctl も対応してい"
"る。"

#. type: Plain text
#: build/C/man7/udp.7:247
msgid ""
"All errors documented for B<socket>(7)  or B<ip>(7)  may be returned by a "
"send or receive on a UDP socket."
msgstr ""
"B<socket>(7)  や B<ip>(7)  に記述されている全てのエラーが、 UDP ソケットの送"
"受信で返される可能性がある。"

#. type: TP
#: build/C/man7/udp.7:247 build/C/man7/unix.7:327
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: build/C/man7/udp.7:251
msgid ""
"No receiver was associated with the destination address.  This might be "
"caused by a previous packet sent over the socket."
msgstr ""
"行き先アドレスに関連づけられている受信者がいない。 これは以前のパケットがその"
"パケットを 上書き送信してしまっているからであることが多い。"

#.  .SH CREDITS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/udp.7:256
msgid "B<IP_RECVERR> is a new feature in Linux 2.2."
msgstr "B<IP_RECVERR> は Linux 2.2 の新しい機能である。"

#. type: Plain text
#: build/C/man7/udp.7:261
msgid "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"
msgstr "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"

#. type: Plain text
#: build/C/man7/udp.7:263
msgid "RFC\\ 768 for the User Datagram Protocol."
msgstr "RFC\\ 768 : User Datagram Protocol"

#. type: Plain text
#: build/C/man7/udp.7:265
msgid "RFC\\ 1122 for the host requirements."
msgstr "RFC\\ 1122 : ホストの必要条件"

#. type: Plain text
#: build/C/man7/udp.7:267
msgid "RFC\\ 1191 for a description of path MTU discovery."
msgstr "RFC\\ 1191 : path MTU discovery の記述"

#. type: TH
#: build/C/man7/udplite.7:27
#, no-wrap
msgid "UDPLITE"
msgstr "UDPLITE"

#. type: TH
#: build/C/man7/udplite.7:27
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: build/C/man7/udplite.7:30
msgid "udplite - Lightweight User Datagram Protocol"
msgstr "udplite - 軽量なユーザーデータグラムプロトコル"

#. type: Plain text
#: build/C/man7/udplite.7:38
msgid "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"
msgstr "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"

#. type: Plain text
#: build/C/man7/udplite.7:41
msgid ""
"This is an implementation of the Lightweight User Datagram Protocol (UDP-"
"Lite), as described in RFC\\ 3828."
msgstr ""
"これは RFC\\ 3828 に書かれている軽量なユーザーデータグラムプロトコル "
"(Lightweight User Datagram Protocol; UDP-Lite) の実装である。"

#. type: Plain text
#: build/C/man7/udplite.7:47
msgid ""
"UDP-Lite is an extension of UDP (RFC\\ 768) to support variable-length "
"checksums.  This has advantages for some types of multimedia transport that "
"may be able to make use of slightly damaged datagrams, rather than having "
"them discarded by lower-layer protocols."
msgstr ""
"UDP-Lite は UDP (RFC\\ 768) の拡張で、可変長のチェックサムをサポートしてい"
"る。 このプロトコルが効果を発揮するのは、少しだけ壊れたデータグラムがあった場"
"合に、 そのデータグラムを下位レイヤーのプロトコルに廃棄させるのではなく、 そ"
"れを利用することができるような、ある種のマルチメディア転送においてである。"

#. type: Plain text
#: build/C/man7/udplite.7:53
msgid ""
"The variable-length checksum coverage is set via a B<setsockopt>(2)  "
"option.  If this option is not set, the only difference to UDP is in using a "
"different IP protocol identifier (IANA number 136)."
msgstr ""
"可変長のチェックサムの対象範囲は B<setsockopt>(2)  オプション経由で設定され"
"る。 このオプションが設定されていない場合、UDP と異なるのは 違う IP プロトコ"
"ル識別子 (IANA 番号 136) を使用する点だけである。"

#. type: Plain text
#: build/C/man7/udplite.7:58
msgid ""
"The UDP-Lite implementation is a full extension of B<udp>(7), i.e., it "
"shares the same API and API behaviour, and in addition offers two socket "
"options to control the checksum coverage."
msgstr ""
"UDP-Lite の実装は B<udp>(7)  の完全な拡張、すなわち API と API の動作は同じで"
"ある。 これに加えて、2 つのソケットオプションがチェックサムの対象範囲を 制御"
"するために提供されている。"

#. type: Plain text
#: build/C/man7/udplite.7:67
msgid ""
"UDP-Litev4 uses the I<sockaddr_in> address format described in B<ip>(7).  "
"UDP-Litev6 uses the I<sockaddr_in6> address format described in B<ipv6>(7)."
msgstr ""
"UDP-Litev4 は B<ip>(7)  で説明されている I<sockaddr_in> アドレスを使用する。 "
"UDP-Litev6 は B<ipv6>(7)  で説明されている I<sockaddr_in6> アドレスを使用す"
"る。"

#. type: Plain text
#: build/C/man7/udplite.7:80
msgid ""
"To set or get a UDP-Lite socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDPLITE>.  In addition, all B<IPPROTO_UDP> socket options are "
"valid on a UDP-Lite socket.  See B<udp>(7)  for more information."
msgstr ""
"UDP-Lite のソケットオプションを設定/取得するには、 オプションレベル引き数に "
"B<IPPROTO_UDPLITE> を指定して、取得時には B<getsockopt>(2)  を、設定時には "
"B<setsockopt>(2)  を呼び出す。さらに、全ての B<IPPROTO_UDP> のソケットオプ"
"ションが UDP-Lite ソケットでも使用できる。 詳細は B<udp>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/udplite.7:82
msgid "The following two options are specific to UDP-Lite."
msgstr "以下の 2 つが UDP-Lite に固有のオプションである。"

#. type: TP
#: build/C/man7/udplite.7:82
#, no-wrap
msgid "B<UDPLITE_SEND_CSCOV>"
msgstr "B<UDPLITE_SEND_CSCOV>"

#. type: Plain text
#: build/C/man7/udplite.7:87
msgid ""
"This option sets the sender checksum coverage and takes an I<int> as "
"argument, with a checksum coverage value in the range 0..2^16-1."
msgstr ""
"このオプションは送信側のチェックサムの対象範囲を設定する。 I<int> 型を引き数"
"として取り、設定可能な値の範囲は 0 から 2^16-1 までである。"

#. type: Plain text
#: build/C/man7/udplite.7:91
msgid ""
"A value of 0 means that the entire datagram is always covered.  Values from "
"1-7 are illegal (RFC\\ 3828, 3.1) and are rounded up to the minimum coverage "
"of 8."
msgstr ""
"値 0 はデータグラム全体が常にチェックサムの対象となることを意味する。 値 1〜"
"7 は不正であり (RFC\\ 3828 の 3.1 章)、範囲の設定として最小値である 8 に切り"
"上げられる。"

#. type: Plain text
#: build/C/man7/udplite.7:97
msgid ""
"With regard to IPv6 jumbograms (RFC\\ 2675), the UDP-Litev6 checksum "
"coverage is limited to the first 2^16-1 octets, as per RFC\\ 3828, 3.5.  "
"Higher values are therefore silently truncated to 2^16-1.  If in doubt, the "
"current coverage value can always be queried using B<getsockopt>(2)."
msgstr ""
"IPv6 の jumbograms (巨大なデータグラム; RFC\\ 2675) の場合には、 UDP-Litev6 "
"のチェックサムの対象範囲は、RFC\\ 3828 の 3.5 章にあるように、 先頭から "
"2^16-1 オクテットまでに限定される。 そのため、それより大きな値は 2^16-1 に"
"黙って切り詰められる。 現在の対象範囲の値を知りたければ、いつでも "
"B<getsockopt>(2)  を使って値を問い合わせることができる。"

#. type: TP
#: build/C/man7/udplite.7:97
#, no-wrap
msgid "B<UDPLITE_RECV_CSCOV>"
msgstr "B<UDPLITE_RECV_CSCOV>"

#. type: Plain text
#: build/C/man7/udplite.7:108
msgid ""
"This is the receiver-side analogue and uses the same argument format and "
"value range as B<UDPLITE_SEND_CSCOV>.  This option is not required to enable "
"traffic with partial checksum coverage.  Its function is that of a traffic "
"filter: when enabled, it instructs the kernel to drop all packets which have "
"a coverage I<less> than the specified coverage value."
msgstr ""
"これは受信側のチェックサムの対象範囲を設定するもので、 使用される引き数形式と"
"値の範囲は B<UDPLITE_SEND_CSCOV> と同じである。 このオプションは、部分的な"
"チェックサム対象範囲を持つトラフィックを 有効にするのに必要なわけではなく、ト"
"ラフィックフィルターとして機能する。 このオプションが有効にすると、カーネルは"
"指定されたチェックサム対象範囲 よりも「短かい」対象範囲を持つパケットを全て廃"
"棄するようになる。"

#.  SO_NO_CHECK exists and is supported by UDPv4, but is
#.  commented out in socket(7), hence also commented out here
#. .PP
#. Since UDP-Lite mandates checksums, checksumming can not be disabled
#. via the
#. .B SO_NO_CHECK
#. option from
#. .BR socket (7).
#. type: Plain text
#: build/C/man7/udplite.7:121
msgid ""
"When the value of B<UDPLITE_RECV_CSCOV> exceeds the actual packet coverage, "
"incoming packets are silently dropped, but may generate a warning message in "
"the system log."
msgstr ""
"B<UDPLITE_RECV_CSCOV> の値が実際のパケットのチェックサム対象範囲よりも大きい"
"場合、 受信したパケットは黙って廃棄される。 ただし、システムログに対して警告"
"メッセージが生成されるかもしれない。"

#. type: Plain text
#: build/C/man7/udplite.7:126
msgid ""
"All errors documented for B<udp>(7)  may be returned.  UDP-Lite does not add "
"further errors."
msgstr ""
"B<udp>(7)  について書かれている全てのエラーは返る可能性がある。 UDP-Lite 自体"
"は新たなエラーは追加していない。"

#. type: Plain text
#: build/C/man7/udplite.7:129
msgid "I</proc/net/snmp> - basic UDP-Litev4 statistics counters."
msgstr "I</proc/net/snmp> - UDP-Litev4 の基本的な統計情報カウンター。"

#. type: Plain text
#: build/C/man7/udplite.7:132
msgid "I</proc/net/snmp6> - basic UDP-Litev6 statistics counters."
msgstr "I</proc/net/snmp6> - UDP-Litev6 の基本的な統計情報カウンター。"

#. type: Plain text
#: build/C/man7/udplite.7:134
msgid "UDP-Litev4/v6 first appeared in Linux 2.6.20."
msgstr "UDP-Litev4/v6 は Linux 2.6.20 で初めて登場した。"

#.  FIXME . remove this section once glibc supports UDP-Lite
#. type: Plain text
#: build/C/man7/udplite.7:137
msgid "Where glibc support is missing, the following definitions are needed:"
msgstr "glibc によるサポートがない場合は、以下の定義を行う必要がある。"

#.  The following two are defined in the kernel in linux/net/udplite.h
#. type: Plain text
#: build/C/man7/udplite.7:144
#, no-wrap
msgid ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"
msgstr ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"

#. type: Plain text
#: build/C/man7/udplite.7:151
msgid "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"
msgstr "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"

#. type: Plain text
#: build/C/man7/udplite.7:153
msgid "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."
msgstr "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."

#. type: Plain text
#: build/C/man7/udplite.7:156
msgid "I<Documentation/networking/udplite.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/networking/udplite.txt>"

#. type: TH
#: build/C/man7/unix.7:18
#, no-wrap
msgid "UNIX"
msgstr "UNIX"

#. type: Plain text
#: build/C/man7/unix.7:21
msgid "unix - sockets for local interprocess communication"
msgstr "unix - ローカルな プロセス間通信用のソケット"

#. type: Plain text
#: build/C/man7/unix.7:25
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr "B<#include E<lt>sys/un.hE<gt>>"

#. type: Plain text
#: build/C/man7/unix.7:27
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"

#. type: Plain text
#: build/C/man7/unix.7:29
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"

#. type: Plain text
#: build/C/man7/unix.7:40
#, fuzzy
#| msgid ""
#| "The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
#| "communicate between processes on the same machine efficiently.  "
#| "Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
#| "file system pathname (marked as being of type socket).  Linux also "
#| "supports an abstract namespace which is independent of the file system."
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
"filesystem pathname (marked as being of type socket).  Linux also supports "
"an abstract namespace which is independent of the filesystem."
msgstr ""
"B<AF_UNIX> (B<AF_LOCAL> とも言われる) ソケットファミリーは、同じマシン上で\n"
"プロセス同士が 効率的に通信するために用いられる。伝統的に、UNIX ドメイン\n"
"ソケットは、名前なしにもできるし、 (ソケット型であると印のついた) ファイル\n"
"システムのパス名に 結び付けることもできる。さらに Linux では、ファイル\n"
"システムに依存しない抽象名前空間 (abstract namespace) もサポートしている。"

#. type: Plain text
#: build/C/man7/unix.7:52
msgid ""
"Valid types are: B<SOCK_STREAM>, for a stream-oriented socket and "
"B<SOCK_DGRAM>, for a datagram-oriented socket that preserves message "
"boundaries (as on most UNIX implementations, UNIX domain datagram sockets "
"are always reliable and don't reorder datagrams); and (since Linux 2.6.4)  "
"B<SOCK_SEQPACKET>, for a connection-oriented socket that preserves message "
"boundaries and delivers messages in the order that they were sent."
msgstr ""
"有効なタイプを以下に示す。 B<SOCK_STREAM> はストリーム指向のソケットであ"
"る。\n"
"B<SOCK_DGRAM> はメッセージ境界を保存するデータグラム指向のソケットである\n"
"(ほとんどの UNIX の実装では、UNIX ドメイン・データグラム・ソケットは 常に\n"
"信頼でき、データグラムの並び替えは行わない)。 \n"
"B<SOCK_SEQPACKET> はメッセージ境界を保存し、送信された順序でメッセージを\n"
"届ける接続指向ソケット である (Linux 2.6.4 以降で利用できる)。"

#. type: Plain text
#: build/C/man7/unix.7:55
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""
"UNIX ドメインソケットでは、補助データを使って ファイルディスクリプタや\n"
"プロセスの信任状 (credential) を 送受信することもできる。"

#. type: Plain text
#: build/C/man7/unix.7:57
msgid "A UNIX domain socket address is represented in the following structure:"
msgstr "UNIX ドメインソケットのアドレスは以下の構造体で表現される。"

#. type: Plain text
#: build/C/man7/unix.7:61
#, no-wrap
msgid "#define UNIX_PATH_MAX    108\n"
msgstr "#define UNIX_PATH_MAX    108\n"

#. type: Plain text
#: build/C/man7/unix.7:66
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[UNIX_PATH_MAX];  /* pathname */\n"
"};\n"
msgstr ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[UNIX_PATH_MAX];  /* pathname */\n"
"};\n"

#. type: Plain text
#: build/C/man7/unix.7:72
msgid "I<sun_family> always contains B<AF_UNIX>."
msgstr "I<sun_family> には必ず B<AF_UNIX> が入っている。"

#. type: Plain text
#: build/C/man7/unix.7:74
msgid "Three types of address are distinguished in this structure:"
msgstr "この構造体では 3 種類のアドレスが区別される。"

#. type: Plain text
#: build/C/man7/unix.7:85
#, fuzzy
#| msgid ""
#| "I<pathname>: a UNIX domain socket can be bound to a null-terminated file "
#| "system pathname using B<bind>(2).  When the address of the socket is "
#| "returned by B<getsockname>(2), B<getpeername>(2), and B<accept>(2), its "
#| "length is I<offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + "
#| "1>, and I<sun_path> contains the null-terminated pathname."
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated file "
"system pathname using B<bind>(2).  When the address of the socket is "
"returned by B<getsockname>(2), B<getpeername>(2), and B<accept>(2), its "
"length is"
msgstr ""
"I<pathname (パス名)>: B<bind>(2) を使って、UNIX ドメインソケットを NULL 終"
"端\n"
"されたファイルシステム上の パス名に結び付けることができる。\n"
"B<getsockname>(2), B<getpeername>(2), B<accept>(2) がソケットのアドレスを\n"
"返す際には、その長さは \n"
"I<offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1>\n"
"であり、 I<sun_path> に NULL 終端されたパス名が格納される。"

#. type: Plain text
#: build/C/man7/unix.7:87
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:91
msgid "and I<sun_path> contains the null-terminated pathname."
msgstr ""

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
#: build/C/man7/unix.7:111
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by B<socketpair>"
"(2)  are unnamed.  When the address of an unnamed socket is returned by "
"B<getsockname>(2), B<getpeername>(2), and B<accept>(2), its length is "
"I<sizeof(sa_family_t)>, and I<sun_path> should not be inspected."
msgstr ""
"I<unnamed (名前なし)>: B<bind>(2)  を使ってパス名に結び付けることができないス"
"トリーム型のソケットは 名前を持たない。同様に、 B<socketpair>(2)  で作成され"
"る 2 つのソケットも名前を持たない。 B<getsockname>(2), B<getpeername>(2), "
"B<accept>(2)  が名前なしのソケットのアドレスを返す際には、 その長さは "
"I<sizeof(sa_family_t)> であり、 I<sun_path> は検査すべきではない。"

#. type: Plain text
#: build/C/man7/unix.7:137
#, fuzzy
#| msgid ""
#| "I<abstract>: an abstract socket address is distinguished by the fact that "
#| "I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  The socket's address in "
#| "this namespace is given by the additional bytes in I<sun_path> that are "
#| "covered by the specified length of the address structure.  (Null bytes in "
#| "the name have no special significance.)  The name has no connection with "
#| "file system pathnames.  When the address of an abstract socket is "
#| "returned by B<getsockname>(2), B<getpeername>(2), and B<accept>(2), the "
#| "returned I<addrlen> is greater than I<sizeof(sa_family_t)> (i.e., greater "
#| "than 2), and the name of the socket is contained in the first I<(addrlen "
#| "- sizeof(sa_family_t))> bytes of I<sun_path>.  The abstract socket "
#| "namespace is a nonportable Linux extension."
msgid ""
"I<abstract>: an abstract socket address is distinguished by the fact that "
"I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  The socket's address in "
"this namespace is given by the additional bytes in I<sun_path> that are "
"covered by the specified length of the address structure.  (Null bytes in "
"the name have no special significance.)  The name has no connection with "
"filesystem pathnames.  When the address of an abstract socket is returned by "
"B<getsockname>(2), B<getpeername>(2), and B<accept>(2), the returned "
"I<addrlen> is greater than I<sizeof(sa_family_t)> (i.e., greater than 2), "
"and the name of the socket is contained in the first I<(addrlen - sizeof"
"(sa_family_t))> bytes of I<sun_path>.  The abstract socket namespace is a "
"nonportable Linux extension."
msgstr ""
"I<abstract (抽象)>: 抽象ソケットアドレスは、 I<sun_path[0]> が NULL バイト\n"
"(\\(aq\\e0\\(aq) であることで区別される。この名前空間におけるソケットのアドレ"
"ス\n"
"は、 I<sun_path> の残りのバイトの、アドレス構造体の指定された長さの範囲で表"
"さ\n"
"れる (名前中の NULL バイトには特別な意味はない)。この名前はファイルシステム"
"の\n"
"パス名とは何の関係もない。 B<getsockname>(2), B<getpeername>(2),\n"
"B<accept>(2) が抽象ソケットのアドレスを返す際には、返される I<addrlen> は\n"
"I<sizeof(sa_family_t)> より大きく (つまり 2 より大きく)、ソケットの名前は\n"
"I<sun_path> の最初の I<(addrlen - sizeof(sa_family_t))> バイトに格納され"
"る。\n"
"ソケットの抽象名前空間は Linux による拡張であり、移植性はない。"

#. type: Plain text
#: build/C/man7/unix.7:150
msgid ""
"For historical reasons these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""
"歴史的な理由により、これらのオプションは たとえ B<AF_UNIX> 固有のオプションで"
"あっても B<SOL_SOCKET> 型で指定する。 ソケットファミリーとして B<SOL_SOCKET> "
"を指定すると、 B<setsockopt>(2)  でオプションが設定でき、 B<getsockopt>(2)  "
"で取得ができる。"

#. type: TP
#: build/C/man7/unix.7:150
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#. type: Plain text
#: build/C/man7/unix.7:157
msgid ""
"Enables the receiving of the credentials of the sending process in an "
"ancillary message.  When this option is set and the socket is not yet "
"connected a unique name in the abstract namespace will be generated "
"automatically.  Expects an integer boolean flag."
msgstr ""
"送信プロセスの補助メッセージで信任状を受信できるようにする。このオプション"
"が\n"
"セットされていて、まだソケットが接続されていないと、抽象名前空間に他と重な"
"ら\n"
"ない名前が自動的に生成される。ブール整数値のフラグを取る。"

#. type: SS
#: build/C/man7/unix.7:157
#, no-wrap
msgid "Autobind feature"
msgstr "自動バインド (autobind) 機能"

#.  i.e. sizeof(short)
#. type: Plain text
#: build/C/man7/unix.7:177
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the "
"B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes "
"were used, and the limit was thus 2^32 autobind addresses.  The change to 5 "
"bytes came in Linux 2.3.15.)"
msgstr ""
"B<bind>(2) 呼び出しで I<sizeof(sa_family_t)> として I<addrlen> を指定する"
"か、\n"
"アドレスに明示的にバインドされていないソケットに対して\n"
"B<SO_PASSCRED> ソケットオプションが指定されていた場合、\n"
"そのソケットは抽象アドレスに自動的にバインドされる。\n"
"このアドレスは、1 個の NULL バイトの後に、文字集合 I<[0-9a-f]> のバイトが\n"
"5 個続く形式である。したがって、自動的にバインドされるアドレス数には\n"
"2^20 個という上限が存在する。\n"
"(Linux 2.1.15 以降で、自動バインド機能が追加されたときには、\n"
"8 バイトが使われており、自動バインドアドレス数の上限は 2^32 であった。\n"
"Linux 2.3.15 で 5 バイトに変更された。)"

#. type: Plain text
#: build/C/man7/unix.7:180
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""
"この節では、Linux の UNIX ドメインソケットでの、ドメイン固有の詳細仕様と\n"
"ソケット API でサポートされていない機能について説明する。"

#. type: Plain text
#: build/C/man7/unix.7:188
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the "
"B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""
"UNIX ドメインソケットでは、帯域外データ (out-of-band data) の 送信\n"
"(B<send>(2) と B<recv>(2) の B<MSG_OOB> フラグ) はサポートされていない。"

#. type: Plain text
#: build/C/man7/unix.7:193
msgid ""
"The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""
"B<send>(2) B<MSG_MORE> フラグは UNIX ドメインソケットではサポートされていな"
"い。"

#. type: Plain text
#: build/C/man7/unix.7:201
msgid ""
"The use of B<MSG_TRUNC> in the I<flags> argument of B<recv>(2)  is not "
"supported by UNIX domain sockets."
msgstr ""
"B<recv>(2) の I<flags> 引き数での B<MSG_TRUNC> の使用は UNIX ドメイン\n"
"ソケットではサポートされていない。"

#. type: Plain text
#: build/C/man7/unix.7:213
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing "
"datagrams.  This limit is calculated as the doubled (see B<socket>(7))  "
"option value less 32 bytes used for overhead."
msgstr ""
"B<SO_SNDBUF> ソケットオプションは UNIX ドメインソケットで効果を持つが、\n"
"B<SO_RCVBUF> は効果がない。 データグラム・ソケットでは、 B<SO_SNDBUF> の値"
"が\n"
"出力データグラムの上限サイズとなる。 実際の上限値は、 B<SO_SNDBUF> オプショ"
"ン\n"
"として設定された値の 2倍 (B<socket>(7) 参照) からオーバヘッドとして使用され"
"る\n"
"32 バイトを引いた値となる。"

#. type: SS
#: build/C/man7/unix.7:213
#, no-wrap
msgid "Ancillary messages"
msgstr "補助メッセージ"

#. type: Plain text
#: build/C/man7/unix.7:235
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2).  "
"For historical reasons the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them set the I<cmsg_level> field of the struct I<cmsghdr> "
"to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For more "
"information see B<cmsg>(3)."
msgstr ""
"補助データを送受するには、 B<sendmsg>(2)  や B<recvmsg>(2)  を使用する。 歴史"
"的な理由により、以下に示す補助メッセージの型は たとえ B<AF_UNIX> 固有のもので"
"あっても B<SOL_SOCKET> 型で指定する。 これらを送るには、構造体 I<cmsghdr> の "
"I<cmsg_level> フィールドに B<SOL_SOCKET> をセットし、 I<cmsg_type> フィールド"
"にタイプをセットする。 詳細は B<cmsg>(3)  を見よ。"

#. type: TP
#: build/C/man7/unix.7:235
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr "B<SCM_RIGHTS>"

#. type: Plain text
#: build/C/man7/unix.7:241
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors.  The passed "
"file descriptors behave as though they have been created with B<dup>(2)."
msgstr ""
"他のプロセスでオープンされたファイルディスクリプタのセットを送受信する。 デー"
"タ部分にファイルディスクリプタの整数配列が入っている。 渡されたファイルディス"
"クリプタは、あたかも B<dup>(2)  で生成されたかのように振る舞う。"

#. type: TP
#: build/C/man7/unix.7:241
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr "B<SCM_CREDENTIALS>"

#. type: Plain text
#: build/C/man7/unix.7:251
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The "
"credentials are passed as a I<struct ucred> ancillary message.  Thus "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""
"UNIX 信任状を送受信する。これは認証に用いることができる。\n"
"信任状は I<struct ucred> の補助メッセージとして渡される。\n"
"この構造体は I<E<lt>sys/socket.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man7/unix.7:259
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* process ID of the sending process */\n"
"    uid_t uid;    /* user ID of the sending process */\n"
"    gid_t gid;    /* group ID of the sending process */\n"
"};\n"
msgstr ""
"struct ucred {\n"
"    pid_t pid;    /* process ID of the sending process */\n"
"    uid_t uid;    /* user ID of the sending process */\n"
"    gid_t gid;    /* group ID of the sending process */\n"
"};\n"

#. type: Plain text
#: build/C/man7/unix.7:268
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""
"glibc 2.8 以降では、この構造体の定義を得るためには\n"
"(I<どの>ヘッダファイルをインクルードするよりも前に)\n"
"機能検査マクロ B<_GNU_SOURCE> を定義しなければならない。"

#. type: Plain text
#: build/C/man7/unix.7:284
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"process with effective user ID 0 is allowed to specify values that do not "
"match its own.  The sender must specify its own process ID (unless it has "
"the capability B<CAP_SYS_ADMIN>), its user ID, effective user ID, or saved "
"set-user-ID (unless it has B<CAP_SETUID>), and its group ID, effective group "
"ID, or saved set-group-ID (unless it has B<CAP_SETGID>).  To receive a "
"I<struct ucred> message the B<SO_PASSCRED> option must be enabled on the "
"socket."
msgstr ""
"送信側が指定した信任状は、カーネルがチェックする。 実効ユーザー ID が 0 のプ"
"ロセスには、 自分自身以外の値を指定する事が許される。 送信側は以下の 3 つを指"
"定しなければならない。 1) 自分自身のプロセス ID (B<CAP_SYS_ADMIN> 権限を持っ"
"ていない場合)、 2) 自分自身のユーザー ID あるいは実効ユーザー ID か保存 set-"
"user-ID (B<CAP_SETUID> 権限を持っていない場合)、 3) 自分自身のグループ ID あ"
"るいは実行グループ ID か保存 set-group-ID (B<CAP_SETGID> を持っていない場"
"合)。 I<struct ucred> メッセージを受信するためには、ソケットに対し "
"B<SO_PASSCRED> オプションを有効にしなくてはならない。"

#. type: Plain text
#: build/C/man7/unix.7:295
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: Plain text
#: build/C/man7/unix.7:300
msgid "I<ioctl_type> can be:"
msgstr "I<ioctl_type> には以下を指定できる:"

#. type: Plain text
#: build/C/man7/unix.7:327
#, fuzzy
#| msgid ""
#| "The specified local address is already in use or the file system socket "
#| "object already exists."
msgid ""
"The specified local address is already in use or the filesystem socket "
"object already exists."
msgstr ""
"指定したローカルアドレスが既に使用されているか、ファイルシステムの\n"
"ソケットオブジェクトが既に存在している。"

#. type: Plain text
#: build/C/man7/unix.7:333
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target filename is not a socket."
msgstr ""
"B<connect>(2) により指定されたリモートアドレスが接続待ちソケットではなかっ"
"た。\n"
"ターゲットアドレスがソケットではない場合にもこのエラーが発生する。"

#. type: TP
#: build/C/man7/unix.7:333
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: build/C/man7/unix.7:336
msgid "Remote socket was unexpectedly closed."
msgstr "リモートソケットが予期しないかたちでクローズされた。"

#. type: Plain text
#: build/C/man7/unix.7:339
msgid "User memory address was not valid."
msgstr "ユーザーメモリアドレスが不正。"

#. type: Plain text
#: build/C/man7/unix.7:348
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""
"渡した引数が不正。よくある原因としては、渡したアドレスの I<sun_type> フィー"
"ル\n"
"ドに B<AF_UNIX> が指定されていなかった、行おうとした操作に対してソケットが"
"有\n"
"効な状態ではなかった、など。"

#. type: Plain text
#: build/C/man7/unix.7:353
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was "
"specified on a connected socket."
msgstr ""
"既に接続されているソケットに対して B<connect>(2)  が呼ばれた。または、指定し"
"たターゲットアドレスが 既に接続済みのソケットだった。"

#. type: Plain text
#: build/C/man7/unix.7:358
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not exist."
msgstr "B<connect>(2) に指定されたリモートアドレスのパス名が存在しなかった。"

#. type: TP
#: build/C/man7/unix.7:358
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man7/unix.7:364
msgid ""
"Socket operation needs a target address, but the socket is not connected."
msgstr ""
"ソケット操作にターゲットアドレスが必要だが、 このソケットは接続されていない。"

#. type: Plain text
#: build/C/man7/unix.7:368
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""
"ストリーム指向でないソケットに対してストリーム操作が呼び出された。 または帯域"
"外データオプションを用いようとした。"

#. type: Plain text
#: build/C/man7/unix.7:372
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr "送信者が I<struct ucred> に不正な信任状を渡した。"

#. type: Plain text
#: build/C/man7/unix.7:384
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<sendmsg>(2)  or B<recvmsg>(2)."
msgstr ""
"リモートソケットがストリームソケット上でクローズされた。 可能な場合は "
"B<SIGPIPE> も同時に送られる。これを避けるには B<MSG_NOSIGNAL> フラグを "
"B<sendmsg>(2)  や B<recvmsg>(2)  に渡す。"

#. type: TP
#: build/C/man7/unix.7:384
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: build/C/man7/unix.7:388
msgid "Passed protocol is not B<AF_UNIX>."
msgstr "渡されたプロトコルが B<AF_UNIX> でない。"

#. type: TP
#: build/C/man7/unix.7:388
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
#: build/C/man7/unix.7:394
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)"
msgstr ""
"リモートソケットとローカルソケットのタイプが一致していなかった "
"(B<SOCK_DGRAM> と B<SOCK_STREAM>)。"

#. type: Plain text
#: build/C/man7/unix.7:397
msgid "Unknown socket type."
msgstr "未知のソケットタイプ。"

#. type: Plain text
#: build/C/man7/unix.7:401
#, fuzzy
#| msgid ""
#| "Other errors can be generated by the generic socket layer or by the file "
#| "system while generating a file system socket object.  See the appropriate "
#| "manual pages for more information."
msgid ""
"Other errors can be generated by the generic socket layer or by the "
"filesystem while generating a filesystem socket object.  See the appropriate "
"manual pages for more information."
msgstr ""
"他にも汎用のソケット層でエラーが起こったり、 ファイルシステム上にソケットオブ"
"ジェクトを作ろうとした場合に ファイルシステムのエラーが起こることがある。 そ"
"れぞれの詳細は適切な man ページを参照すること。"

#. type: Plain text
#: build/C/man7/unix.7:407
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2 "
"and should not be used in portable programs.  (Some BSD-derived systems also "
"support credential passing, but the implementation details differ.)"
msgstr ""
"B<SCM_CREDENTIALS> と抽象名前空間は、Linux 2.2 で導入された。 移植性が必要な"
"プログラムでは使うべきではない。 (BSD 由来のシステムの中にも信任状の送受信を"
"サポートしているものがあるが、 その実装の詳細はシステムによって異なる)"

#. type: Plain text
#: build/C/man7/unix.7:418
#, fuzzy
#| msgid ""
#| "In the Linux implementation, sockets which are visible in the file system "
#| "honor the permissions of the directory they are in.  Their owner, group "
#| "and their permissions can be changed.  Creation of a new socket will fail "
#| "if the process does not have write and search (execute) permission on the "
#| "directory the socket is created in.  Connecting to the socket object "
#| "requires read/write permission.  This behavior differs from many BSD-"
#| "derived systems which ignore permissions for UNIX domain sockets.  "
#| "Portable programs should not rely on this feature for security."
msgid ""
"In the Linux implementation, sockets which are visible in the filesystem "
"honor the permissions of the directory they are in.  Their owner, group and "
"their permissions can be changed.  Creation of a new socket will fail if the "
"process does not have write and search (execute) permission on the directory "
"the socket is created in.  Connecting to the socket object requires read/"
"write permission.  This behavior differs from many BSD-derived systems which "
"ignore permissions for UNIX domain sockets.  Portable programs should not "
"rely on this feature for security."
msgstr ""
"Linux の実装では、ファイルシステム上から見えるソケットは、それらが置かれて"
"い\n"
"るディレクトリのパーミッションに従う。ソケットの所有者、グループ、パーミッ"
"ショ\n"
"ンは変更できる。新しいソケットを作るとき、作ろうとするディレクトリに対して "
"プ\n"
"ロセスが書き込みと検索 (実行) 権限を持っていなければ、作成に失敗する。ソ"
"ケッ\n"
"トオブジェクトに接続するには、 read/write 権限が必要である。この動作は、多"
"く\n"
"の BSD 由来のシステムとは異なっている (BSD では UNIX ドメインソケットに対し"
"て\n"
"はパーミッションを無視する)。 移植性の必要なプログラムでは、セキュリティを"
"こ\n"
"の仕様に依存してはならない。"

#. type: Plain text
#: build/C/man7/unix.7:426
#, fuzzy
#| msgid ""
#| "Binding to a socket with a filename creates a socket in the file system "
#| "that must be deleted by the caller when it is no longer needed (using "
#| "B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket "
#| "can be unlinked at any time and will be finally removed from the file "
#| "system when the last reference to it is closed."
msgid ""
"Binding to a socket with a filename creates a socket in the filesystem that "
"must be deleted by the caller when it is no longer needed (using B<unlink>"
"(2)).  The usual UNIX close-behind semantics apply; the socket can be "
"unlinked at any time and will be finally removed from the filesystem when "
"the last reference to it is closed."
msgstr ""
"ファイル名を指定してソケットにバインドすると、ファイルシステムにソケットが\n"
"生成される。これは必要なくなったときに呼びだしたユーザーが削除しなければ\n"
"ならない (B<unlink>(2) を用いる)。 UNIX で通常使われる「背後で閉じる方式」\n"
"が適用される。ソケットはいつでも unlink することができ、最後の参照が\n"
"クローズされたときにファイルシステムから削除される。"

#. type: Plain text
#: build/C/man7/unix.7:435
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM>, you need to "
"send or receive at least one byte of nonancillary data in the same B<sendmsg>"
"(2)  or B<recvmsg>(2)  call."
msgstr ""
"B<SOCK_STREAM> 上でファイルディスクリプタや信任状を渡すためには、同じ "
"B<sendmsg>(2)  や B<recvmsg>(2)  コールで補助データ以外のデータを少なくとも "
"1 バイト送信/受信する必要がある。"

#. type: Plain text
#: build/C/man7/unix.7:437
msgid ""
"UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""
"UNIX ドメインのストリーム・ソケットでは、 帯域外データの概念はサポートされな"
"い。"

#. type: Plain text
#: build/C/man7/unix.7:440
msgid "See B<bind>(2)."
msgstr "B<bind>(2)  参照。"

#. type: Plain text
#: build/C/man7/unix.7:445
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr "B<SCM_RIGHTS> の使用例については B<cmsg>(3) を参照。"

#. type: Plain text
#: build/C/man7/unix.7:454
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7)"

#. type: TH
#: build/C/man7/x25.7:12
#, no-wrap
msgid "X25"
msgstr "X25"

#. type: Plain text
#: build/C/man7/x25.7:15
msgid "x25 - ITU-T X.25 / ISO-8208 protocol interface."
msgstr "x25 - ITU-T X.25 / ISO-8208 プロトコルインターフェース"

#. type: Plain text
#: build/C/man7/x25.7:19
msgid "B<#include E<lt>linux/x25.hE<gt>>"
msgstr "B<#include E<lt>linux/x25.hE<gt>>"

#. type: Plain text
#: build/C/man7/x25.7:21
msgid "B<x25_socket = socket(AF_X25, SOCK_SEQPACKET, 0);>"
msgstr "B<x25_socket = socket(AF_X25, SOCK_SEQPACKET, 0);>"

#. type: Plain text
#: build/C/man7/x25.7:30
msgid ""
"X25 sockets provide an interface to the X.25 packet layer protocol.  This "
"allows applications to communicate over a public X.25 data network as "
"standardized by International Telecommunication Union's recommendation X.25 "
"(X.25 DTE-DCE mode).  X25 sockets can also be used for communication without "
"an intermediate X.25 network (X.25 DTE-DTE mode) as described in ISO-8208."
msgstr ""
"X25 ソケットは X.25 パケット層プロトコルに対するインターフェースを提供する。 "
"これにより、アプリケーションはパブリックな X.25 データネットワークで 通信する"
"ことができるようになる。 X.25 は International Telecommunication Union's "
"recommendation X.25 (X.25 DTE-DCE mode) で標準化されている。 X25 ソケットは、"
"中間層のない X.25 ネットワーク (X.25 DTE-DTE mode)  での通信にも用いることが"
"できる。 DTE-DTE モードは ISO-8208 に記述されている。"

#. type: Plain text
#: build/C/man7/x25.7:47
msgid ""
"Message boundaries are preserved \\(em a B<read>(2)  from a socket will "
"retrieve the same chunk of data as output with the corresponding B<write>"
"(2)  to the peer socket.  When necessary, the kernel takes care of "
"segmenting and reassembling long messages by means of the X.25 M-bit.  There "
"is no hard-coded upper limit for the message size.  However, reassembling of "
"a long message might fail if there is a temporary lack of system resources "
"or when other constraints (such as socket memory or buffer size limits) "
"become effective.  If that occurs, the X.25 connection will be reset."
msgstr ""
"メッセージ境界は保存される。ソケットからの B<read>(2)  は、反対側のソケットか"
"らの対応する B<write>(2)  と同じ大きさのデータを受け取り、出力する。 必要があ"
"る場合は、カーネルが長いメッセージの 分割 (segmenting) と再構成 "
"(reassembling) を行う。 これには X.25 の M ビットが用いられる。 メッセージサ"
"イズには、ハードコーディングされた上限はない。 しかし、一時的にシステムリソー"
"スが足りなかったり、 他の制約 (ソケットメモリバッファのサイズ制限など) が 効"
"いてしまうと、長いメッセージの再構成には失敗するかもしれない。 この場合、そ"
"の X.25 接続はリセットされることになる。"

#. type: SS
#: build/C/man7/x25.7:47
#, no-wrap
msgid "Socket addresses"
msgstr "ソケットアドレス"

#. type: Plain text
#: build/C/man7/x25.7:54
msgid ""
"The B<AF_X25> socket address family uses the I<struct sockaddr_x25> for "
"representing network addresses as defined in ITU-T recommendation X.121."
msgstr ""
"B<AF_X25> ソケットアドレスファミリーは、ネットワークアドレスを表すために "
"I<struct sockaddr_x25> を用いる。これは ITU-T recommendation X.121 で定義され"
"ている。"

#. type: Plain text
#: build/C/man7/x25.7:61
#, no-wrap
msgid ""
"struct sockaddr_x25 {\n"
"    sa_family_t sx25_family;    /* must be AF_X25 */\n"
"    x25_address sx25_addr;      /* X.121 Address */\n"
"};\n"
msgstr ""
"struct sockaddr_x25 {\n"
"    sa_family_t sx25_family;    /* must be AF_X25 */\n"
"    x25_address sx25_addr;      /* X.121 Address */\n"
"};\n"

#. type: Plain text
#: build/C/man7/x25.7:72
msgid ""
"I<sx25_addr> contains a char array I<x25_addr[]> to be interpreted as a null-"
"terminated string.  I<sx25_addr.x25_addr[]> consists of up to 15 (not "
"counting the terminating null byte) ASCII characters forming the X.121 "
"address.  Only the decimal digit characters from \\(aq0\\(aq to \\(aq9\\(aq "
"are allowed."
msgstr ""
"I<sx25_addr> には char 配列 I<x25_addr[]> を含まれる。これは 0 で終端する文字"
"列として解釈される。 I<sx25_addr.x25_addr[]> は 15 個までの ASCII 文字を含む"
"ことができ (終端のヌルバイトは含まない)、 これが X.121 アドレスをなす。 10 進"
"の数文字、\\(aq0\\(aq から \\(aq9\\(aq までだけが許される。"

#. type: Plain text
#: build/C/man7/x25.7:81
msgid ""
"The following X.25-specific socket options can be set by using B<setsockopt>"
"(2)  and read with B<getsockopt>(2)  with the I<level> argument set to "
"B<SOL_X25>."
msgstr ""
"以下の X.25 特有のソケットオプションは、 B<setsockopt>(2)  で設定でき、 "
"B<getsockopt>(2)  で取得できる。このとき I<level> 引き数には B<SOL_X25> を指"
"定する。"

#. type: TP
#: build/C/man7/x25.7:81
#, no-wrap
msgid "B<X25_QBITINCL>"
msgstr "B<X25_QBITINCL>"

#. type: Plain text
#: build/C/man7/x25.7:100
msgid ""
"Controls whether the X.25 Q-bit (Qualified Data Bit) is accessible by the "
"user.  It expects an integer argument.  If set to 0 (default), the Q-bit is "
"never set for outgoing packets and the Q-bit of incoming packets is "
"ignored.  If set to 1, an additional first byte is prepended to each message "
"read from or written to the socket.  For data read from the socket, a 0 "
"first byte indicates that the Q-bits of the corresponding incoming data "
"packets were not set.  A first byte with value 1 indicates that the Q-bit of "
"the corresponding incoming data packets was set.  If the first byte of the "
"data written to the socket is 1 the Q-bit of the corresponding outgoing data "
"packets will be set.  If the first byte is 0 the Q-bit will not be set."
msgstr ""
"X.25 の Q ビット (Qualified データビット) にユーザーがアクセス できるかどうか"
"をコントロールする。整数の引数を取る。 0 にセットすると、 Q ビットは発信パ"
"ケットには決してセットされず、 受信パケットでは無視される (デフォルト)。 1 に"
"セットすると、ソケットから読む、あるいはソケットに送る メッセージそれぞれに先"
"頭バイトが前置される。 ソケットから読んだデータでは、先頭バイトが 0 だと、 こ"
"の到着データパケットに対応する Q ビットはセットされていなかったことになる。 "
"先頭バイトが 1 だと、到着データパケットの Q ビットがセットされていたことにな"
"る。 ソケットに書き込むデータの先頭バイトが 1 だと、 その発信パケットの Q "
"ビットをセットする。 0 だと、 Q ビットをセットしない。"

#. type: Plain text
#: build/C/man7/x25.7:102
msgid "The AF_X25 protocol family is a new feature of Linux 2.2."
msgstr "AF_X25 プロトコルファミリは Linux 2.2 の新機能である。"

#. type: Plain text
#: build/C/man7/x25.7:105
msgid "Plenty, as the X.25 PLP implementation is B<CONFIG_EXPERIMENTAL>."
msgstr "X.25 PLP 実装は B<CONFIG_EXPERIMENTAL> なので、たくさんあるだろう。"

#. type: Plain text
#: build/C/man7/x25.7:107
msgid "This man page is incomplete."
msgstr "この man ページは完成していない。"

#. type: Plain text
#: build/C/man7/x25.7:114
msgid ""
"There is no dedicated application programmer's header file yet; you need to "
"include the kernel header file I<E<lt>linux/x25.hE<gt>>.  "
"B<CONFIG_EXPERIMENTAL> might also imply that future versions of the "
"interface are not binary compatible."
msgstr ""
"まだアプリケーションプログラマー用のヘッダファイルがない。 カーネルのヘッダ"
"ファイル I<E<lt>linux/x25.hE<gt>> をインクルードしなければならない。 "
"B<CONFIG_EXPERIMENTAL> なので、将来のバージョンのインターフェースでは バイナ"
"リ互換性が失われるかもしれない。"

#. type: Plain text
#: build/C/man7/x25.7:118
msgid ""
"X.25 N-Reset events are not propagated to the user process yet.  Thus, if a "
"reset occurred, data might be lost without notice."
msgstr ""
"X.25 N-Reset イベントは、まだユーザープロセスに伝播しない。 したがってリセッ"
"トが起こると、データは通知無しに失われる。"

#. type: Plain text
#: build/C/man7/x25.7:121
msgid "B<socket>(2), B<socket>(7)"
msgstr "B<socket>(2), B<socket>(7)"

#. type: Plain text
#: build/C/man7/x25.7:127
msgid ""
"Jonathan Simon Naylor: \\(lqThe Re-Analysis and Re-Implementation of X.25."
"\\(rq The URL is E<.UR ftp://ftp.pspt.fi\\:/pub\\:/ham\\:/linux\\:/ax25\\:/"
"x25doc.tgz> E<.UE .>"
msgstr ""
"Jonathan Simon Naylor: \\(lqThe Re-Analysis and Re-Implementation of X.25."
"\\(rq The URL is E<.UR ftp://ftp.pspt.fi\\:/pub\\:/ham\\:/linux\\:/ax25\\:/"
"x25doc.tgz> E<.UE .>"

#~ msgid "2010-10-04"
#~ msgstr "2010-10-04"

#~ msgid "2013-04-16"
#~ msgstr "2013-04-16"
