# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-04-30 23:13+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/fnmatch.3:28
#, no-wrap
msgid "FNMATCH"
msgstr "FNMATCH"

#. type: TH
#: build/C/man3/fnmatch.3:28
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: build/C/man3/fnmatch.3:28 build/C/man3/glob.3:34 build/C/man3/re_comp.3:27
#: build/C/man3/regex.3:30
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: build/C/man3/fnmatch.3:28 build/C/man3/glob.3:34 build/C/man7/glob.7:26
#: build/C/man3/re_comp.3:27 build/C/man3/regex.3:30 build/C/man7/regex.7:37
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/fnmatch.3:29 build/C/man3/glob.3:35 build/C/man7/glob.7:27
#: build/C/man3/re_comp.3:28 build/C/man3/regex.3:31 build/C/man7/regex.7:38
#: build/C/man3/wordexp.3:25
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/fnmatch.3:31
msgid "fnmatch - match filename or pathname"
msgstr "fnmatch - ファイル名またはパス名へのマッチを行う"

#. type: SH
#: build/C/man3/fnmatch.3:31 build/C/man3/glob.3:37 build/C/man3/re_comp.3:30
#: build/C/man3/regex.3:33 build/C/man3/wordexp.3:27
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/fnmatch.3:34
#, no-wrap
msgid "B<#include E<lt>fnmatch.hE<gt>>\n"
msgstr "B<#include E<lt>fnmatch.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fnmatch.3:36
#, no-wrap
msgid "B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int >I<flags>B<);>\n"
msgstr "B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int >I<flags>B<);>\n"

#. type: SH
#: build/C/man3/fnmatch.3:37 build/C/man3/glob.3:46 build/C/man7/glob.7:29
#: build/C/man3/re_comp.3:40 build/C/man3/regex.3:48 build/C/man7/regex.7:40
#: build/C/man3/wordexp.3:42
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/fnmatch.3:46
msgid ""
"The B<fnmatch>()  function checks whether the I<string> argument matches the "
"I<pattern> argument, which is a shell wildcard pattern (see B<glob>(7))."
msgstr "B<fnmatch>()  関数は I<strings> 引き数が I<pattern> 引き数にマッチするかをチェックする。 I<pattern> にはシェルのワイルドカードパターンを与える (B<glob>(7) 参照)。"

#. type: Plain text
#: build/C/man3/fnmatch.3:51
msgid ""
"The I<flags> argument modifies the behavior; it is the bitwise OR of zero or "
"more of the following flags:"
msgstr ""
"I<flags> 引き数により動作を変更できる。 I<flags> は以下のフラグのビット毎の "
"OR で指定する。"

#. type: TP
#: build/C/man3/fnmatch.3:51
#, no-wrap
msgid "B<FNM_NOESCAPE>"
msgstr "B<FNM_NOESCAPE>"

#. type: Plain text
#: build/C/man3/fnmatch.3:55
msgid ""
"If this flag is set, treat backslash as an ordinary character, instead of an "
"escape character."
msgstr ""
"このフラグがセットされていると、バックスラッシュ (\\e) をエスケープ文字 では"
"なく通常の文字として扱う。"

#. type: TP
#: build/C/man3/fnmatch.3:55
#, no-wrap
msgid "B<FNM_PATHNAME>"
msgstr "B<FNM_PATHNAME>"

#. type: Plain text
#: build/C/man3/fnmatch.3:63
msgid ""
"If this flag is set, match a slash in I<string> only with a slash in "
"I<pattern> and not by an asterisk (*) or a question mark (?) metacharacter, "
"nor by a bracket expression ([]) containing a slash."
msgstr ""
"このフラグがセットされていると、 I<string> 中のスラッシュ (/) を I<pattern> "
"にあるスラッシュそのものにだけマッチさせ、 アスタリスク (*) や疑問符 (?) のメ"
"タキャラクターや、 スラッシュを含むブラケット表現 ([]) にはマッチさせない。"

#. type: TP
#: build/C/man3/fnmatch.3:63
#, no-wrap
msgid "B<FNM_PERIOD>"
msgstr "B<FNM_PERIOD>"

#. type: Plain text
#: build/C/man3/fnmatch.3:74
msgid ""
"If this flag is set, a leading period in I<string> has to be matched exactly "
"by a period in I<pattern>.  A period is considered to be leading if it is "
"the first character in I<string>, or if both B<FNM_PATHNAME> is set and the "
"period immediately follows a slash."
msgstr ""
"このフラグがセットされていると、 I<string> の先頭ピリオド (leading period) "
"は I<pattern> 中のピリオドそのものにしかマッチしない。先頭ピリオドとは、 "
"I<string> の最初の文字位置にあるピリオドのことである。ただし B<FNM_PATHNAME> "
"フラグが同時にセットされている場合には、スラッシュの直後に続くピリオド も先頭"
"ピリオドとみなされる。"

#. type: TP
#: build/C/man3/fnmatch.3:74
#, no-wrap
msgid "B<FNM_FILE_NAME>"
msgstr "B<FNM_FILE_NAME>"

#. type: Plain text
#: build/C/man3/fnmatch.3:78
msgid "This is a GNU synonym for B<FNM_PATHNAME>."
msgstr "これは B<FNM_PATHNAME> に対する GNU での同義語である."

#. type: TP
#: build/C/man3/fnmatch.3:78
#, no-wrap
msgid "B<FNM_LEADING_DIR>"
msgstr "B<FNM_LEADING_DIR>"

#. type: Plain text
#: build/C/man3/fnmatch.3:86
msgid ""
"If this flag (a GNU extension) is set, the pattern is considered to be "
"matched if it matches an initial segment of I<string> which is followed by a "
"slash.  This flag is mainly for the internal use of glibc and is implemented "
"only in certain cases."
msgstr ""
"このフラグは GNU での拡張である。これがセットされている場合には、 パターンが "
"I<string> の最初の部分 (にスラッシュを付けたもの) にマッチすれば、 マッチした"
"ものとみなされる。 このフラグは主として glibc で内部的に使用するもので、その"
"ためにのみ実装されている。"

#. type: TP
#: build/C/man3/fnmatch.3:86
#, no-wrap
msgid "B<FNM_CASEFOLD>"
msgstr "B<FNM_CASEFOLD>"

#. type: Plain text
#: build/C/man3/fnmatch.3:90
msgid ""
"If this flag (a GNU extension) is set, the pattern is matched case-"
"insensitively."
msgstr ""
"このフラグは GNU での拡張である。これがセットされている場合には、 パターンの"
"マッチに大文字小文字が区別されない。"

#. type: TP
#: build/C/man3/fnmatch.3:90
#, no-wrap
msgid "B<FNM_EXTMATCH>"
msgstr "B<FNM_EXTMATCH>"

#. type: Plain text
#: build/C/man3/fnmatch.3:96
msgid ""
"If this flag (a GNU extension) is set, extended patterns are supported, as "
"introduced by \\&'ksh' and now supported by other shells.  The extended "
"format is as follows, with I<pattern-list> being a \\&'|' separated list of "
"patterns."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:96
#, no-wrap
msgid "\\&'?(I<pattern-list>)'"
msgstr "\\&'?(I<pattern-list>)'"

#. type: Plain text
#: build/C/man3/fnmatch.3:100
msgid ""
"The pattern matches if zero or one occurrences of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:100
#, no-wrap
msgid "\\&'*(I<pattern-list>)'"
msgstr "\\&'*(I<pattern-list>)'"

#. type: Plain text
#: build/C/man3/fnmatch.3:104
msgid ""
"The pattern matches if zero or more occurrences of any of the patterns in "
"the I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:104
#, no-wrap
msgid "\\&'+(I<pattern-list>)'"
msgstr "\\&'+(I<pattern-list>)'"

#. type: Plain text
#: build/C/man3/fnmatch.3:108
msgid ""
"The pattern matches if one or more occurrences of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:108
#, no-wrap
msgid "\\&'@(I<pattern-list>)'"
msgstr "\\&'@(I<pattern-list>)'"

#. type: Plain text
#: build/C/man3/fnmatch.3:112
msgid ""
"The pattern matches if exactly one occurrence of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:112
#, no-wrap
msgid "\\&'!(I<pattern-list>)'"
msgstr "\\&'!(I<pattern-list>)'"

#. type: Plain text
#: build/C/man3/fnmatch.3:116
msgid ""
"The pattern matches if the input I<string> cannot be matched with any of the "
"patterns in the I<pattern-list>."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:116 build/C/man3/glob.3:258 build/C/man3/re_comp.3:58
#: build/C/man3/regex.3:262 build/C/man3/wordexp.3:157
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/fnmatch.3:123
msgid ""
"Zero if I<string> matches I<pattern>, B<FNM_NOMATCH> if there is no match or "
"another nonzero value if there is an error."
msgstr ""
"I<string> が I<pattern> にマッチすれば 0 を返す。マッチしなかった場合には "
"B<FNM_NOMATCH> を返す。エラーの場合にはそれ以外の非ゼロ値を返す。"

#. type: SH
#: build/C/man3/fnmatch.3:123 build/C/man3/glob.3:272 build/C/man3/re_comp.3:66
#: build/C/man3/regex.3:319 build/C/man3/wordexp.3:187
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/fnmatch.3:126 build/C/man3/glob.3:275 build/C/man3/re_comp.3:69
#: build/C/man3/regex.3:322 build/C/man3/wordexp.3:190
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/fnmatch.3:130 build/C/man3/glob.3:279 build/C/man3/re_comp.3:73
#: build/C/man3/regex.3:326 build/C/man3/wordexp.3:194
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/fnmatch.3:130 build/C/man3/glob.3:279 build/C/man3/re_comp.3:73
#: build/C/man3/regex.3:326 build/C/man3/wordexp.3:194
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/fnmatch.3:130 build/C/man3/glob.3:279 build/C/man3/re_comp.3:73
#: build/C/man3/regex.3:326 build/C/man3/wordexp.3:194
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/fnmatch.3:133
#, no-wrap
msgid "B<fnmatch>()"
msgstr "B<fnmatch>()"

#. type: tbl table
#: build/C/man3/fnmatch.3:133 build/C/man3/glob.3:282 build/C/man3/glob.3:289
#: build/C/man3/re_comp.3:77 build/C/man3/regex.3:330 build/C/man3/regex.3:333
#: build/C/man3/regex.3:336 build/C/man3/wordexp.3:197
#: build/C/man3/wordexp.3:204
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/fnmatch.3:133
#, no-wrap
msgid "MT-Safe env locale"
msgstr "MT-Safe env locale"

#. type: SH
#: build/C/man3/fnmatch.3:135 build/C/man3/glob.3:306 build/C/man3/re_comp.3:79
#: build/C/man3/regex.3:338 build/C/man3/wordexp.3:221
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/fnmatch.3:140
msgid ""
"POSIX.1-2001, POSIX.1-2008, POSIX.2.  The B<FNM_FILE_NAME>, "
"B<FNM_LEADING_DIR>, and B<FNM_CASEFOLD> flags are GNU extensions."
msgstr "POSIX.1-2001, POSIX.1-2008, POSIX.2.  B<FNM_FILE_NAME>, B<FNM_LEADING_DIR>, B<FNM_CASEFOLD> フラグは GNU の拡張である。"

#. type: SH
#: build/C/man3/fnmatch.3:140 build/C/man3/glob.3:351 build/C/man7/glob.7:208
#: build/C/man3/re_comp.3:85 build/C/man3/regex.3:383 build/C/man7/regex.7:287
#: build/C/man3/wordexp.3:246
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/fnmatch.3:146
msgid "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"
msgstr "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"

#. type: SH
#: build/C/man3/fnmatch.3:146 build/C/man3/glob.3:362 build/C/man7/glob.7:214
#: build/C/man3/re_comp.3:89 build/C/man3/regex.3:389 build/C/man7/regex.7:292
#: build/C/man3/wordexp.3:249
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/fnmatch.3:154 build/C/man3/glob.3:370 build/C/man7/glob.7:222
#: build/C/man3/re_comp.3:97 build/C/man3/regex.3:397 build/C/man7/regex.7:300
#: build/C/man3/wordexp.3:257
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/glob.3:34 build/C/man7/glob.7:26
#, no-wrap
msgid "GLOB"
msgstr "GLOB"

#. type: TH
#: build/C/man3/glob.3:34
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/glob.3:37
msgid ""
"glob, globfree - find pathnames matching a pattern, free memory from glob()"
msgstr ""
"glob, globfree - パターンにマッチするパス名を見付ける。glob() によっ て確保さ"
"れたメモリー領域を解放する。"

#. type: Plain text
#: build/C/man3/glob.3:40
#, no-wrap
msgid "B<#include E<lt>glob.hE<gt>>\n"
msgstr "B<#include E<lt>glob.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/glob.3:45
#, no-wrap
msgid ""
"B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int >I<eerrno>B<),>\n"
"B<         glob_t *>I<pglob>B<);>\n"
"B<void globfree(glob_t *>I<pglob>B<);>\n"
msgstr ""
"B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int >I<eerrno>B<),>\n"
"B<         glob_t *>I<pglob>B<);>\n"
"B<void globfree(glob_t *>I<pglob>B<);>\n"

#. type: Plain text
#: build/C/man3/glob.3:56
msgid ""
"The B<glob>()  function searches for all the pathnames matching I<pattern> "
"according to the rules used by the shell (see B<glob>(7)).  No tilde "
"expansion or parameter substitution is done; if you want these, use "
"B<wordexp>(3)."
msgstr ""
"B<glob>()  関数はシェルが用いているルール (B<glob>(7)  参照) に基づいてパター"
"ン I<pattern> にマッチするすべてのパス名を検索する。 チルダ (~) の展開やパラ"
"メーター置換は行われない。それらを行いたい場合は B<wordexp>(3)  を使うとよ"
"い。"

#. type: Plain text
#: build/C/man3/glob.3:62
msgid ""
"The B<globfree>()  function frees the dynamically allocated storage from an "
"earlier call to B<glob>()."
msgstr ""
"B<globfree>()  関数は前に呼ばれた B<glob>()  により動的に確保された記憶領域を"
"解放する。"

#. type: Plain text
#: build/C/man3/glob.3:73
msgid ""
"The results of a B<glob>()  call are stored in the structure pointed to by "
"I<pglob>.  This structure is of type I<glob_t> (declared in I<E<lt>glob."
"hE<gt>>)  and includes the following elements defined by POSIX.2 (more may "
"be present as an extension):"
msgstr ""
"B<glob>()  の結果は I<pglob> がポイントする構造体に返される。 I<pglob> は "
"I<glob_t> 型の構造体である。 I<glob_t> 型は I<E<lt>glob.hE<gt>> 内で宣言され"
"ており、以下の要素を含んでいる。これらの要素は POSIX.2 で定義 されている (さ"
"らに多くの要素が拡張として入っているかもしれない)。"

#. type: Plain text
#: build/C/man3/glob.3:81
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* Count of paths matched so far  */\n"
"    char   **gl_pathv;    /* List of matched pathnames.  */\n"
"    size_t   gl_offs;     /* Slots to reserve in I<gl_pathv>.  */\n"
"} glob_t;\n"
msgstr ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* 今までにマッチしたパスの数 */\n"
"    char   **gl_pathv;    /* マッチしたパス名のリスト */\n"
"    size_t   gl_offs;     /* I<gl_pathv> 内に確保するスロット数 */\n"
"} glob_t;\n"

#. type: Plain text
#: build/C/man3/glob.3:85
msgid "Results are stored in dynamically allocated storage."
msgstr "結果は動的に確保された記憶領域に入れられる。"

#. type: Plain text
#: build/C/man3/glob.3:91
msgid ""
"The argument I<flags> is made up of the bitwise OR of zero or more the "
"following symbolic constants, which modify the behavior of B<glob>():"
msgstr ""
"パラメーター I<flags> には以下の示す定数のうち、指定したいものをビットごとの "
"OR で与える (一つも 指定しなくてもよい)。これによって B<glob>()  の動作を変更"
"できる。"

#. type: TP
#: build/C/man3/glob.3:91
#, no-wrap
msgid "B<GLOB_ERR>"
msgstr "B<GLOB_ERR>"

#. type: Plain text
#: build/C/man3/glob.3:99
msgid ""
"Return upon a read error (because a directory does not have read permission, "
"for example).  By default, B<glob>()  attempts carry on despite errors, "
"reading all of the directories that it can."
msgstr ""
"(例えば、ディレクトリに読み取り許可属性が無い場合などで)  読み取りエラーが発"
"生した際に関数から戻る。 デフォルトでは、エラーに関わらず 読み取り可能なディ"
"レクトリを全てについて読み取りを実行しようとする。"

#. type: TP
#: build/C/man3/glob.3:99
#, no-wrap
msgid "B<GLOB_MARK>"
msgstr "B<GLOB_MARK>"

#. type: Plain text
#: build/C/man3/glob.3:102
msgid "Append a slash to each path which corresponds to a directory."
msgstr "ディレクトリに対応する各々のパスにスラッシュを付加する。"

#. type: TP
#: build/C/man3/glob.3:102
#, no-wrap
msgid "B<GLOB_NOSORT>"
msgstr "B<GLOB_NOSORT>"

#. type: Plain text
#: build/C/man3/glob.3:107
msgid ""
"Don't sort the returned pathnames.  The only reason to do this is to save "
"processing time.  By default, the returned pathnames are sorted."
msgstr ""
"返されるパス名のソートを行わない。 ソートを行わない理由は、処理時間を節約する"
"ためだけである。 デフォルトでは、返されるパス名はソートされる。"

#. type: TP
#: build/C/man3/glob.3:107
#, no-wrap
msgid "B<GLOB_DOOFFS>"
msgstr "B<GLOB_DOOFFS>"

#. type: Plain text
#: build/C/man3/glob.3:114
msgid ""
"Reserve I<pglob-E<gt>gl_offs> slots at the beginning of the list of strings "
"in I<pglob-E<gt>pathv>.  The reserved slots contain null pointers."
msgstr ""
"I<pglob-E<gt>pathv> の文字列リストの先頭に I<pglob-E<gt>gl_offs> スロット分の"
"領域を予約する。 予約されたスロットにはヌルポインターが入る。"

#. type: TP
#: build/C/man3/glob.3:114
#, no-wrap
msgid "B<GLOB_NOCHECK>"
msgstr "B<GLOB_NOCHECK>"

#. type: Plain text
#: build/C/man3/glob.3:122
msgid ""
"If no pattern matches, return the original pattern.  By default, B<glob>()  "
"returns B<GLOB_NOMATCH> if there are no matches."
msgstr ""
"マッチするパターンがなければ、元のパターンを返す。 デフォルトでは、 "
"B<glob>()  はマッチするパターンがなければ B<GLOB_NOMATCH> を返す。"

#. type: TP
#: build/C/man3/glob.3:122
#, no-wrap
msgid "B<GLOB_APPEND>"
msgstr "B<GLOB_APPEND>"

#. type: Plain text
#: build/C/man3/glob.3:129
msgid ""
"Append the results of this call to the vector of results returned by a "
"previous call to B<glob>().  Do not set this flag on the first invocation of "
"B<glob>()."
msgstr ""
"この呼び出しでの結果を直前の B<glob>()  の呼び出しで返された結果のベクトルに"
"追加する。最初の B<glob>()  の呼び出しの際にはこのフラグを設定してはいけな"
"い。"

#. type: TP
#: build/C/man3/glob.3:129
#, no-wrap
msgid "B<GLOB_NOESCAPE>"
msgstr "B<GLOB_NOESCAPE>"

#. type: Plain text
#: build/C/man3/glob.3:136
msgid ""
"Don't allow backslash (\\(aq\\e\\(aq) to be used as an escape character.  "
"Normally, a backslash can be used to quote the following character, "
"providing a mechanism to turn off the special meaning metacharacters."
msgstr ""
"バックスラッシュ (\\(aq\\e\\(aq) をエスケープ用文字として使用できない。 通常"
"は、バックスラッシュを使って、次に続く文字をクォートすることで、 特別な意味を"
"持つメタキャラクターを無効することができる。"

#. type: Plain text
#: build/C/man3/glob.3:140
msgid ""
"I<flags> may also include any of the following, which are GNU extensions and "
"not defined by POSIX.2:"
msgstr ""
"I<flags> には以下に示すものも指定できる。 これらは GNU で拡張されたもので、"
"POSIX.2 では定義されていない。"

#. type: TP
#: build/C/man3/glob.3:140
#, no-wrap
msgid "B<GLOB_PERIOD>"
msgstr "B<GLOB_PERIOD>"

#. type: Plain text
#: build/C/man3/glob.3:144
msgid ""
"Allow a leading period to be matched by metacharacters.  By default, "
"metacharacters can't match a leading period."
msgstr ""
"先頭のピリオドがメタキャラクターにマッチできるようにする。 デフォルトでは、メ"
"タキャラクターは先頭のピリオドにはマッチできない。"

#. type: TP
#: build/C/man3/glob.3:144
#, no-wrap
msgid "B<GLOB_ALTDIRFUNC>"
msgstr "B<GLOB_ALTDIRFUNC>"

#. type: Plain text
#: build/C/man3/glob.3:154
msgid ""
"Use alternative functions I<pglob-E<gt>gl_closedir>, I<pglob-"
"E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, and "
"I<pglob-E<gt>gl_stat> for filesystem access instead of the normal library "
"functions."
msgstr ""
"ファイルシステムにアクセスする際に、通常のライブラリ関数の代わりに 代替関数 "
"I<pglob-E<gt>gl_closedir>, I<pglob-E<gt>gl_readdir>, I<pglob-"
"E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, I<pglob-E<gt>gl_stat> が用いられ"
"る。"

#. type: TP
#: build/C/man3/glob.3:154
#, no-wrap
msgid "B<GLOB_BRACE>"
msgstr "B<GLOB_BRACE>"

#. type: Plain text
#: build/C/man3/glob.3:170
msgid ""
"Expand B<csh>(1)  style brace expressions of the form B<{a,b}>.  Brace "
"expressions can be nested.  Thus, for example, specifying the pattern \"{foo/"
"{,cat,dog},bar}\" would return the same results as four separate B<glob>()  "
"calls using the strings: \"foo/\", \"foo/cat\", \"foo/dog\", and \"bar\"."
msgstr ""
"B<{a,b}> という形式の B<csh>(1)  スタイルの括弧表現を展開する。 括弧表現は入"
"れ子にすることができる。 したがって、例えば、\"{foo/{,cat,dog},bar}\" という"
"パターンを 指定した場合に得られる結果は、 4つの文字列 \"foo/\", \"foo/cat\", "
"\"foo/dog\", \"bar\" のそれぞれについて B<glob>()  を呼び出した場合と同じにな"
"る。"

#. type: TP
#: build/C/man3/glob.3:170
#, no-wrap
msgid "B<GLOB_NOMAGIC>"
msgstr "B<GLOB_NOMAGIC>"

#. type: Plain text
#: build/C/man3/glob.3:175
msgid ""
"If the pattern contains no metacharacters, then it should be returned as the "
"sole matching word, even if there is no file with that name."
msgstr ""
"パターンにメタキャラクターが含まれていない場合、 マッチ結果として指定されたパ"
"ターンだけを返す。 パターンで指定された名前のファイルが存在しない場合であって"
"も、 そのパターンが返される。"

#. type: TP
#: build/C/man3/glob.3:175
#, no-wrap
msgid "B<GLOB_TILDE>"
msgstr "B<GLOB_TILDE>"

#. type: Plain text
#: build/C/man3/glob.3:187
msgid ""
"Carry out tilde expansion.  If a tilde (\\(aq\\(ti\\(aq) is the only "
"character in the pattern, or an initial tilde is followed immediately by a "
"slash (\\(aq/\\(aq), then the home directory of the caller is substituted "
"for the tilde.  If an initial tilde is followed by a username (e.g., "
"\"\\(tiandrea/bin\"), then the tilde and username are substituted by the "
"home directory of that user.  If the username is invalid, or the home "
"directory cannot be determined, then no substitution is performed."
msgstr "チルダの展開を行う。 チルダ (\\(aq\\(ti\\(aq) がパターン内の唯一の文字の場合か、先頭のチルダの直後の文字が スラッシュ (\\(aq/\\(aq) の場合、チルダを呼び出し者のホームディレクトリで置換する。 先頭のチルダにユーザー名が続く場合 (例えば \"\\(tiandrea/bin\")、 チルダとユーザー名をそのユーザーのホームディレクトリで置換する。 ユーザー名が無効な場合やホームディレクトリが決定できない場合は、 置換は実行されない。"

#. type: TP
#: build/C/man3/glob.3:187
#, no-wrap
msgid "B<GLOB_TILDE_CHECK>"
msgstr "B<GLOB_TILDE_CHECK>"

#. type: Plain text
#: build/C/man3/glob.3:198
msgid ""
"This provides behavior similar to that of B<GLOB_TILDE>.  The difference is "
"that if the username is invalid, or the home directory cannot be determined, "
"then instead of using the pattern itself as the name, B<glob>()  returns "
"B<GLOB_NOMATCH> to indicate an error."
msgstr ""
"このフラグを指定すると B<GLOB_TILDE> と同様の振舞いをする。 B<GLOB_TILDE> と"
"の違いは、ユーザー名が無効だった場合や ホームディレクトリが決定できなかった場"
"合に、 パターン自身を使用するのではなく、 B<glob>()  がエラーを示す "
"B<GLOB_NOMATCH> を返すことである。"

#. type: TP
#: build/C/man3/glob.3:198
#, no-wrap
msgid "B<GLOB_ONLYDIR>"
msgstr "B<GLOB_ONLYDIR>"

#. type: Plain text
#: build/C/man3/glob.3:211
msgid ""
"This is a I<hint> to B<glob>()  that the caller is interested only in "
"directories that match the pattern.  If the implementation can easily "
"determine file-type information, then nondirectory files are not returned to "
"the caller.  However, the caller must still check that returned files are "
"directories.  (The purpose of this flag is merely to optimize performance "
"when the caller is interested only in directories.)"
msgstr ""
"このフラグは、 B<glob>()  に対する「ヒント」であり、 呼び出し側がパターンに"
"マッチするディレクトリにしか興味がないことを知らせる。 実装においてファイルの"
"種別情報を簡単に決定できる場合は、ディレクトリでない ファイルは呼び出し側に返"
"されない。しかしながら、呼び出し側では、返された ファイルリストがディレクトリ"
"かどうかを確認しなければならない。 (このフラグが存在するのは、呼び出し側が"
"ディレクトリにしか興味がない際に 性能を最適化する目的のためだけである。)"

#. type: Plain text
#: build/C/man3/glob.3:234
msgid ""
"If I<errfunc> is not NULL, it will be called in case of an error with the "
"arguments I<epath>, a pointer to the path which failed, and I<eerrno>, the "
"value of I<errno> as returned from one of the calls to B<opendir>(3), "
"B<readdir>(3), or B<stat>(2).  If I<errfunc> returns nonzero, or if "
"B<GLOB_ERR> is set, B<glob>()  will terminate after the call to I<errfunc>."
msgstr ""
"I<errfunc> が NULL でなければ、 エラーが起こった場合には関数 I<errfunc> が呼"
"び出される。関数の引数には、失敗したパス名 I<epath> と I<errno> "
"(B<opendir>(3), B<readdir>(3), B<stat>(2).  のいずれかによってセットされた"
"値) が与えられる。 I<errfunc> が 0 以外の値を返すかもしくは B<GLOB_ERR> が"
"セットされた場合 B<glob>()  は I<errfunc> の呼び出し後に終了する。"

#. type: Plain text
#: build/C/man3/glob.3:241
msgid ""
"Upon successful return, I<pglob-E<gt>gl_pathc> contains the number of "
"matched pathnames and I<pglob-E<gt>gl_pathv> contains a pointer to the list "
"of pointers to matched pathnames.  The list of pointers is terminated by a "
"null pointer."
msgstr ""
"呼び出しが成功して戻った場合 I<pglob-E<gt>gl_pathc> にはマッチしたパス名が含"
"まれ、 I<pglob-E<gt>gl_pathv> はマッチしたパス名へのポインターのリストへのポ"
"インターとなる。 ポインターのリストはヌルポインターで終端される。"

#. type: Plain text
#: build/C/man3/glob.3:250
msgid ""
"It is possible to call B<glob>()  several times.  In that case, the "
"B<GLOB_APPEND> flag has to be set in I<flags> on the second and later "
"invocations."
msgstr ""
"B<glob>()  を何度か続けて呼び出すことができる。その際2回目以降の呼び出しでは "
"B<GLOB_APPEND> フラグが I<flags> に設定されていなければならない。"

#. type: Plain text
#: build/C/man3/glob.3:258
msgid ""
"As a GNU extension, I<pglob-E<gt>gl_flags> is set to the flags specified, "
"B<or>ed with B<GLOB_MAGCHAR> if any metacharacters were found."
msgstr ""
"GNU の拡張として、 I<pglob-E<gt>gl_flags> には指定したフラグがセットされる。"
"もし一つでもメタキャラクターが見付かれば このフラグと B<GLOB_MAGCHAR> との "
"B<OR> を取った結果がセットされる。"

#. type: Plain text
#: build/C/man3/glob.3:263
msgid ""
"On successful completion, B<glob>()  returns zero.  Other possible returns "
"are:"
msgstr ""
"呼び出しが成功して完了すると B<glob>()  は 0 を返す。 それ以外の返り値は以下"
"の通り:"

#. type: TP
#: build/C/man3/glob.3:263
#, no-wrap
msgid "B<GLOB_NOSPACE>"
msgstr "B<GLOB_NOSPACE>"

#. type: Plain text
#: build/C/man3/glob.3:266
msgid "for running out of memory,"
msgstr "メモリーを使い果たした"

#. type: TP
#: build/C/man3/glob.3:266
#, no-wrap
msgid "B<GLOB_ABORTED>"
msgstr "B<GLOB_ABORTED>"

#. type: Plain text
#: build/C/man3/glob.3:269
msgid "for a read error, and"
msgstr "読み取りエラー"

#. type: TP
#: build/C/man3/glob.3:269
#, no-wrap
msgid "B<GLOB_NOMATCH>"
msgstr "B<GLOB_NOMATCH>"

#. type: Plain text
#: build/C/man3/glob.3:272
msgid "for no found matches."
msgstr "一つもマッチしなかった"

#. type: tbl table
#: build/C/man3/glob.3:282
#, no-wrap
msgid "B<glob>()"
msgstr "B<glob>()"

#. type: tbl table
#: build/C/man3/glob.3:284
#, no-wrap
msgid "MT-Unsafe race:utent env\n"
msgstr "MT-Unsafe race:utent env\n"

#. type: tbl table
#: build/C/man3/glob.3:284 build/C/man3/wordexp.3:199
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/glob.3:286
#, no-wrap
msgid "sig:ALRM timer locale"
msgstr "sig:ALRM timer locale"

#. type: tbl table
#: build/C/man3/glob.3:289
#, no-wrap
msgid "B<globfree>()"
msgstr "B<globfree>()"

#. type: tbl table
#: build/C/man3/glob.3:289 build/C/man3/regex.3:336 build/C/man3/wordexp.3:204
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/glob.3:306
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<glob>()  calls those functions, so we use race:utent to remind users."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:308
msgid "POSIX.1-2001, POSIX.1-2008, POSIX.2."
msgstr "POSIX.1-2001, POSIX.1-2008, POSIX.2."

#. type: SH
#: build/C/man3/glob.3:308 build/C/man7/glob.7:142 build/C/man3/re_comp.3:81
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/glob.3:319
msgid ""
"The structure elements I<gl_pathc> and I<gl_offs> are declared as I<size_t> "
"in glibc 2.1, as they should be according to POSIX.2, but are declared as "
"I<int> in glibc 2.0."
msgstr ""
"glibc 2.1 では、 I<gl_pathc> と I<gl_offs> は POSIX.2 で指定されているように "
"I<size_t> として宣言されている。 glibc 2.0 では、 I<int> として宣言されてい"
"る。"

#. type: SH
#: build/C/man3/glob.3:319 build/C/man7/regex.7:260
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/glob.3:328
msgid ""
"The B<glob>()  function may fail due to failure of underlying function "
"calls, such as B<malloc>(3)  or B<opendir>(3).  These will store their error "
"code in I<errno>."
msgstr ""
"B<glob>()  関数はその中で呼び出している B<malloc>(3)  や B<opendir>(3)  など"
"の関数の呼び出しで失敗が起こると失敗する。 これにより I<errno> にそのエラー"
"コードが入る。"

#. type: SH
#: build/C/man3/glob.3:328 build/C/man3/regex.3:340 build/C/man3/wordexp.3:223
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/glob.3:330
msgid "One example of use is the following code, which simulates typing"
msgstr "使用法の一例を以下に示す。以下はシェルで"

#. type: Plain text
#: build/C/man3/glob.3:334
#, no-wrap
msgid "ls -l *.c ../*.c\n"
msgstr "ls -l *.c ../*.c\n"

#. type: Plain text
#: build/C/man3/glob.3:338
msgid "in the shell:"
msgstr "をタイプした場合をシミュレートしている。"

#. type: Plain text
#: build/C/man3/glob.3:342
#, no-wrap
msgid "glob_t globbuf;\n"
msgstr "glob_t globbuf;\n"

#. type: Plain text
#: build/C/man3/glob.3:349
#, no-wrap
msgid ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"
msgstr ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"

#. type: Plain text
#: build/C/man3/glob.3:362
msgid ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"

#. type: TH
#: build/C/man7/glob.7:26 build/C/man3/regex.3:30 build/C/man7/regex.7:37
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: TH
#: build/C/man7/glob.7:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man7/glob.7:29
msgid "glob - globbing pathnames"
msgstr "glob - パス名を glob する"

#. type: Plain text
#: build/C/man7/glob.7:34
msgid ""
"Long ago, in UNIX\\ V6, there was a program I</etc/glob> that would expand "
"wildcard patterns.  Soon afterward this became a shell built-in."
msgstr ""
"昔々 UNIX\\ V6 では、ワイルドカードパターンを展開する I</etc/glob> と言うプロ"
"グラムがあった。その後すぐに、 この機能はシェルに組み込まれるようになった。"

#. type: Plain text
#: build/C/man7/glob.7:38
msgid ""
"These days there is also a library routine B<glob>(3)  that will perform "
"this function for a user program."
msgstr ""
"今日では、この機能をユーザープログラムからも実行できるよう、 B<glob>(3)  とい"
"うライブラリルーチンも存在している。"

#. type: Plain text
#: build/C/man7/glob.7:40
msgid "The rules are as follows (POSIX.2, 3.13)."
msgstr "glob の規則を以下に述べる (POSIX.2 3.13)。"

#. type: SS
#: build/C/man7/glob.7:40
#, no-wrap
msgid "Wildcard matching"
msgstr "ワイルドカードマッチ"

#. type: Plain text
#: build/C/man7/glob.7:47
msgid ""
"A string is a wildcard pattern if it contains one of the characters \\(aq?"
"\\(aq, \\(aq*\\(aq or \\(aq[\\(aq.  Globbing is the operation that expands a "
"wildcard pattern into the list of pathnames matching the pattern.  Matching "
"is defined by:"
msgstr ""
"文字列に \\(aq?\\(aq, \\(aq*\\(aq, \\(aq[\\(aq が含まれていると、 それはワイ"
"ルドカードパターンとみなされる。 「glob する」というのは、ワイルドカードパ"
"ターンを展開して、 そのパターンにマッチするパス名のリストを得ることである。 "
"マッチは以下のように定義される。"

#. type: Plain text
#: build/C/man7/glob.7:49
msgid "A \\(aq?\\(aq (not between brackets) matches any single character."
msgstr "(ブラケット外部の) \\(aq?\\(aq はあらゆる単一の文字にマッチする。"

#. type: Plain text
#: build/C/man7/glob.7:52
msgid ""
"A \\(aq*\\(aq (not between brackets) matches any string, including the empty "
"string."
msgstr ""
"(ブラケット外部の) \\(aq*\\(aq はあらゆる文字列にマッチする。 空文字列 "
"(empty string) にもマッチする。"

#. type: Plain text
#: build/C/man7/glob.7:54
msgid "B<Character classes>"
msgstr "B<文字クラス (character class)>"

#. type: Plain text
#: build/C/man7/glob.7:63
msgid ""
"An expression \"I<[...]>\" where the first character after the leading "
"\\(aq[\\(aq is not an \\(aq!\\(aq matches a single character, namely any of "
"the characters enclosed by the brackets.  The string enclosed by the "
"brackets cannot be empty; therefore \\(aq]\\(aq can be allowed between the "
"brackets, provided that it is the first character.  (Thus, \"I<[][!]>\" "
"matches the three characters \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq.)"
msgstr ""
"\"I<[...]>\" と言う表記は、先頭の \\(aq[\\(aq に続く最初の文字が \\(aq!\\(aq "
"で なければ、ブラケットの中に含まれている文字のどれか一つにマッチする。 ブラ"
"ケットの内部に含まれる文字列は空であってはならない。 したがって \\(aq]\\(aq "
"も最初の文字に指定すればブラケットの内部に含めることが できる (つまり \"I<[]"
"[!]>\" は \\(aq[\\(aq, \\(aq]\\(aq, \\(aq!\\(aq の 3 文字のどれかにマッチす"
"る)。"

#. type: Plain text
#: build/C/man7/glob.7:65
msgid "B<Ranges>"
msgstr "B<領域指定 (range)>"

#. type: Plain text
#: build/C/man7/glob.7:76
msgid ""
"There is one special convention: two characters separated by \\(aq-\\(aq "
"denote a range.  (Thus, \"I<[A-Fa-f0-9]>\" is equivalent to "
"\"I<[ABCDEFabcdef0123456789]>\".)  One may include \\(aq-\\(aq in its "
"literal meaning by making it the first or last character between the "
"brackets.  (Thus, \"I<[]-]>\" matches just the two characters \\(aq]\\(aq "
"and \\(aq-\\(aq, and \"I<[--0]>\" matches the three characters \\(aq-\\(aq, "
"\\(aq.\\(aq, \\(aq0\\(aq, since \\(aq/\\(aq cannot be matched.)"
msgstr ""
"特殊な表記法が一つ存在する。\\(aq-\\(aq を挟む二つの文字は領域指定となる。 "
"(つまり \"I<[A-Fa-f0-9]>\" は \"I<[ABCDEFabcdef0123456789]>\" と等価とな"
"る。) \\(aq-\\(aq 文字そのものを入れたい場合は、 ブラケットの先頭または最後の"
"文字に指定すればよい。 (つまり \"I<[]-]>\" は二つの文字 \\(aq]\\(aq と \\(aq-"
"\\(aq にマッチし、\"I<[--0]>\" は \\(aq-\\(aq, \\(aq.\\(aq, \\(aq0\\(aq の 3 "
"文字にマッチする。この間の \\(aq/\\(aq にはマッチしない。後述を参照。)"

#. type: Plain text
#: build/C/man7/glob.7:78
msgid "B<Complementation>"
msgstr "B<補集合 (complementation)>"

#. type: Plain text
#: build/C/man7/glob.7:84
msgid ""
"An expression \"I<[!...]>\" matches a single character, namely any character "
"that is not matched by the expression obtained by removing the first \\(aq!"
"\\(aq from it.  (Thus, \"I<[!]a-]>\" matches any single character except "
"\\(aq]\\(aq, \\(aqa\\(aq and \\(aq-\\(aq.)"
msgstr ""
"\"I<[!...]>\" と言う表記は、ブラケットの内部に含まれない単一の文字にマッチす"
"る (ただし先頭にある \\(aq!\\(aq は除外)。 (つまり \"I<[!]a-]>\" は "
"\\(aq]\\(aq, \\(aqa\\(aq, \\(aq-\\(aq 以外のすべての文字の、どれか一つにマッ"
"チする。)"

#. type: Plain text
#: build/C/man7/glob.7:91
msgid ""
"One can remove the special meaning of \\(aq?\\(aq, \\(aq*\\(aq and "
"\\(aq[\\(aq by preceding them by a backslash, or, in case this is part of a "
"shell command line, enclosing them in quotes.  Between brackets these "
"characters stand for themselves.  Thus, \"I<[[?*\\e]>\" matches the four "
"characters \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq and \\(aq\\e\\(aq."
msgstr ""
"バックスラッシュ \\(aq\\e\\(aq を前置すれば、 \\(aq?\\(aq, \\(aq*\\(aq, "
"\\(aq[\\(aq は通常の文字として扱われる。 またはシェルのコマンドラインの一部に"
"指定する場合は、 クォートで囲っても同じ効果が得られる。ブラケットの内部で"
"は、 これらの文字はその文字自身だけを意味する。 すなわち \"I<[[?*\\e]>\" は "
"\\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq, \\(aq\\e\\(aq のどれか一文字にマッチす"
"る。"

#. type: SS
#: build/C/man7/glob.7:91
#, no-wrap
msgid "Pathnames"
msgstr "パス名 (pathname)"

#. type: Plain text
#: build/C/man7/glob.7:98
msgid ""
"Globbing is applied on each of the components of a pathname separately.  A "
"\\(aq/\\(aq in a pathname cannot be matched by a \\(aq?\\(aq or \\(aq*\\(aq "
"wildcard, or by a range like \"I<[.-0]>\".  A range containing an explicit "
"\\(aq/\\(aq character is syntactically incorrect.  (POSIX requires that "
"syntactically incorrect patterns are left unchanged.)"
msgstr "glob 動作は、パス名のそれぞれの部分に独立に適用される。 パス名に存在する \\(aq/\\(aq は \\(aq?\\(aq や \\(aq*\\(aq ワイルドカードにはマッチしない。 また \"I<[.-0]>\" のような領域指定にもマッチしない。陽に \\(aq/\\(aq 文字を含む領域指定は文法的に正しくない。 (POSIX の要件では、文法的に正しくないパターンは変更せずにそのままにすることになっている。)"

#. type: Plain text
#: build/C/man7/glob.7:103
msgid ""
"If a filename starts with a \\(aq.\\(aq, this character must be matched "
"explicitly.  (Thus, I<rm\\ *> will not remove .profile, and I<tar\\ c\\ *> "
"will not archive all your files; I<tar\\ c\\ .> is better.)"
msgstr ""
"\\(aq.\\(aq で始まるパス名では、この文字は陽にマッチさせなければならない。 "
"(つまり I<rm\\ *> は .profile を削除しない。また I<tar\\ c\\ *> ではすべての"
"ファイルはアーカイブされない。 I<tar\\ c\\ .> の方が良い。)"

#. type: SS
#: build/C/man7/glob.7:103
#, no-wrap
msgid "Empty lists"
msgstr "空のリスト"

#. type: Plain text
#: build/C/man7/glob.7:109
msgid ""
"The nice and simple rule given above: \"expand a wildcard pattern into the "
"list of matching pathnames\" was the original UNIX definition.  It allowed "
"one to have patterns that expand into an empty list, as in"
msgstr ""
"先に与えた、わかりやすく簡単なルール、 「ワイルドカードパターンをマッチしたパ"
"ス名のリストに展開する」と言うのは、 オリジナルの UNIX における定義であっ"
"た。 これはパターンが空のリストに展開されることも許可されていた。 例えば"

#. type: Plain text
#: build/C/man7/glob.7:112
#, no-wrap
msgid "    xv -wait 0 *.gif *.jpg\n"
msgstr "    xv -wait 0 *.gif *.jpg\n"

#. type: Plain text
#: build/C/man7/glob.7:122
msgid ""
"where perhaps no *.gif files are present (and this is not an error).  "
"However, POSIX requires that a wildcard pattern is left unchanged when it is "
"syntactically incorrect, or the list of matching pathnames is empty.  With "
"I<bash> one can force the classical behavior using this command:"
msgstr ""
"において、*.gif ファイルが全くない場合でも、 これは空のリストに展開されるた"
"め、エラーにならない。 しかし POSIX では、文法的に正しくないパターンや、 マッ"
"チがなかったパターンは、 そのまま変更されずに残されることになっている。 "
"I<bash> では、次のコマンドで昔からの振る舞いに設定することができる。"

#.  In Bash v1, by setting allow_null_glob_expansion=true
#. type: Plain text
#: build/C/man7/glob.7:125
#, no-wrap
msgid "    shopt -s nullglob\n"
msgstr "    shopt -s nullglob\n"

#. type: Plain text
#: build/C/man7/glob.7:128
msgid "(Similar problems occur elsewhere.  For example, where old scripts have"
msgstr ""
"(同様の問題は別のところでも起こっている。例えば、古いスクリプトにおける"

#. type: Plain text
#: build/C/man7/glob.7:131
#, no-wrap
msgid "    rm \\`find . -name \"*\\(ti\"\\`\n"
msgstr "    rm \\`find . -name \"*\\(ti\"\\`\n"

#. type: Plain text
#: build/C/man7/glob.7:134
msgid "new scripts require"
msgstr "のような記述は、新しいスクリプトでは"

#. type: Plain text
#: build/C/man7/glob.7:137
#, no-wrap
msgid "    rm -f nosuchfile \\`find . -name \"*\\(ti\"\\`\n"
msgstr "    rm -f nosuchfile \\`find . -name \"*\\(ti\"\\`\n"

#. type: Plain text
#: build/C/man7/glob.7:142
msgid "to avoid error messages from I<rm> called with an empty argument list.)"
msgstr ""
"のようにしなければならない。さもないと I<rm> を引き数リストなしで呼び出す可能"
"性があり、 エラーメッセージが出てしまう。)"

#. type: SS
#: build/C/man7/glob.7:143
#, no-wrap
msgid "Regular expressions"
msgstr "正規表現"

#. type: Plain text
#: build/C/man7/glob.7:150
msgid ""
"Note that wildcard patterns are not regular expressions, although they are a "
"bit similar.  First of all, they match filenames, rather than text, and "
"secondly, the conventions are not the same: for example, in a regular "
"expression \\(aq*\\(aq means zero or more copies of the preceding thing."
msgstr ""
"ワイルドカードパターンは正規表現と多少似ているが、しかしこの両者は異なる。 ま"
"ず第一に、前者がファイル名にマッチするのに対して、 後者はテキストにマッチす"
"る。第二に、ルールも同じではない。 例えば正規表現における \\(aq*\\(aq は、 前"
"置された文字の 0 以上の繰り返しを表す。"

#. type: Plain text
#: build/C/man7/glob.7:154
msgid ""
"Now that regular expressions have bracket expressions where the negation is "
"indicated by a \\(aq\\(ha\\(aq, POSIX has declared the effect of a wildcard "
"pattern \"I<[\\(ha...]>\" to be undefined."
msgstr "正規表現にもブラケット表現はあるが、否定は \\(aq\\(ha\\(aq でなされる。 POSIX ではワイルドカードパターンにおける \"I<[\\(ha...]>\" を未定義であるとしている。"

#. type: SS
#: build/C/man7/glob.7:154
#, no-wrap
msgid "Character classes and internationalization"
msgstr "文字クラスと国際化"

#. type: Plain text
#: build/C/man7/glob.7:172
msgid ""
"Of course ranges were originally meant to be ASCII ranges, so that \"I<[\\ -"
"%]>\" stands for \"I<[\\ !\"#$%]>\" and \"I<[a-z]>\" stands for \"any "
"lowercase letter\".  Some UNIX implementations generalized this so that a "
"range X-Y stands for the set of characters with code between the codes for X "
"and for Y.  However, this requires the user to know the character coding in "
"use on the local system, and moreover, is not convenient if the collating "
"sequence for the local alphabet differs from the ordering of the character "
"codes.  Therefore, POSIX extended the bracket notation greatly, both for "
"wildcard patterns and for regular expressions.  In the above we saw three "
"types of items that can occur in a bracket expression: namely (i) the "
"negation, (ii) explicit single characters, and (iii) ranges.  POSIX "
"specifies ranges in an internationally more useful way and adds three more "
"types:"
msgstr ""
"領域指定は、もともとはもちろん ASCII における順序並びを意味していた。 した"
"がって \"I<[\\ -%]>\" は \"I<[\\ !\"#$%]>\" の意味であり、 \"I<[a-z]>\" は"
"「すべての小文字」の意味であった。 UNIX の実装の中には、これを拡張したものが"
"存在し、 そこでは X-Y という領域指定は、X のコードと Y のコードに挟まれたコー"
"ドを持つ文字すべてを表すようになっていた。 しかし、これにはユーザーがローカル"
"なシステムにおける 文字コードを知らなければならず、 さらにローカルなアルファ"
"ベットに対する照合順序 (collating sequence) が文字コードの順序と異なっている"
"場合には不便であった。 (訳注: collating sequence に関しては B<regex>(7)  を参"
"照して下さい。)  したがって POSIX では、ワイルドカードパターンと正規表現の双"
"方において、 ブラケット表記を大幅に拡張している。 これまで我々は、ブラケット"
"表記には三つの要素が含まれうることを見てきた。 すなわち (i) 否定、(ii) 単一の"
"文字、(iii) 領域指定、の三つである。 POSIX では、領域指定をより国際化に便利な"
"ように定義しており、 また三つのタイプをブラケット表記の要素として追加してい"
"る。"

#. type: Plain text
#: build/C/man7/glob.7:178
msgid ""
"(iii) Ranges X-Y comprise all characters that fall between X and Y "
"(inclusive) in the current collating sequence as defined by the "
"B<LC_COLLATE> category in the current locale."
msgstr ""
"(iii) 領域指定 X-Y は X と Y に挟まれた (両端含む) すべての文字を意味する。 "
"このとき、カレントロケール (current locale) の B<LC_COLLATE> カテゴリーで定義"
"されている照合順序が用いられる。"

#. type: Plain text
#: build/C/man7/glob.7:180
msgid "(iv) Named character classes, like"
msgstr "(iv) 名前付き文字クラス: 以下のようなものである。"

#. type: Plain text
#: build/C/man7/glob.7:185
#, no-wrap
msgid ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"
msgstr ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"

#. type: Plain text
#: build/C/man7/glob.7:194
msgid ""
"so that one can say \"I<[[:lower:]]>\" instead of \"I<[a-z]>\", and have "
"things work in Denmark, too, where there are three letters past \\(aqz\\(aq "
"in the alphabet.  These character classes are defined by the B<LC_CTYPE> "
"category in the current locale."
msgstr ""
"これを用いれば \"I<[a-z]>\" の代わりに \"I<[[:lower:]]>\" のような指定ができ"
"る。 またデンマークのように、アルファベットの \\(aqz\\(aq 以降に 3 つの文字が"
"存在するような場合でも、同じような動作が期待できる。 これらの文字クラスはカレ"
"ントロケールの B<LC_CTYPE> カテゴリーで定義されている。"

#. type: Plain text
#: build/C/man7/glob.7:200
msgid ""
"(v) Collating symbols, like \"I<[.ch.]>\" or \"I<[.a-acute.]>\", where the "
"string between \"I<[.>\" and \"I<.]>\" is a collating element defined for "
"the current locale.  Note that this may be a multicharacter element."
msgstr ""
"(v) 照合順序におけるシンボル: \"I<[.ch.]>\" や \"I<[.a-acute.]>\" のように "
"\"I<[.>\" と \"I<.]>\" で挟まれた文字列は、カレントロケールで定義された照合順"
"序の要素となる。 ある一つの要素が複数の文字からなる場合もありうることに注意。"

#. type: Plain text
#: build/C/man7/glob.7:208
msgid ""
"(vi) Equivalence class expressions, like \"I<[=a=]>\", where the string "
"between \"I<[=>\" and \"I<=]>\" is any collating element from its "
"equivalence class, as defined for the current locale.  For example, "
"\"I<[[=a=]]>\" might be equivalent to \"I<[a\\('a\\(\\`a\\(:a\\(^a]>\", that "
"is, to \"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\"."
msgstr ""
"(vi) 等価クラス表現 (equivalence class expressions):\n"
"\"I<[=a=]>\" のように \"I<[=>\" と \"I<=]>\" とで挟まれた文字列であり、\n"
"カレントロケールで定義された等価クラスのメンバーである照合要素のいずれかを表す。\n"
"例えば、\"I<[[=a=]]>\" は \"I<[a\\('a\\(\\`a\\(:a\\(^a]>\"、つまり\n"
"\"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\" と等価になる。"

#. type: Plain text
#: build/C/man7/glob.7:214
msgid "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"
msgstr "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"

#. type: TH
#: build/C/man3/re_comp.3:27
#, no-wrap
msgid "RE_COMP"
msgstr "RE_COMP"

#. type: TH
#: build/C/man3/re_comp.3:27
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/re_comp.3:30
msgid "re_comp, re_exec - BSD regex functions"
msgstr "re_comp, re_exec - BSD の正規表現関数"

#. type: Plain text
#: build/C/man3/re_comp.3:32
msgid "B<#define _REGEX_RE_COMP>"
msgstr "B<#define _REGEX_RE_COMP>"

#. type: Plain text
#: build/C/man3/re_comp.3:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man3/re_comp.3:36
msgid "B<#include E<lt>regex.hE<gt>>"
msgstr "B<#include E<lt>regex.hE<gt>>"

#. type: Plain text
#: build/C/man3/re_comp.3:38
msgid "B<char *re_comp(const char *>I<regex>B<);>"
msgstr "B<char *re_comp(const char *>I<regex>B<);>"

#. type: Plain text
#: build/C/man3/re_comp.3:40
msgid "B<int re_exec(const char *>I<string>B<);>"
msgstr "B<int re_exec(const char *>I<string>B<);>"

#. type: Plain text
#: build/C/man3/re_comp.3:52
msgid ""
"B<re_comp>()  is used to compile the null-terminated regular expression "
"pointed to by I<regex>.  The compiled pattern occupies a static area, the "
"pattern buffer, which is overwritten by subsequent use of B<re_comp>().  If "
"I<regex> is NULL, no operation is performed and the pattern buffer's "
"contents are not altered."
msgstr ""
"B<re_comp>()  は、 I<regex> で示されるヌルで終端された正規表現をコンパイルす"
"るために使用される。 コンパイルされたパターンは静的な領域を使用しており、その"
"パターンバッファー は以降の B<re_comp>()  の使用によって上書きされる。 もし "
"I<regex> が NULL ならば何の操作も行われず、パターンバッファーの内容は 置き換"
"えられない。"

#. type: Plain text
#: build/C/man3/re_comp.3:58
msgid ""
"B<re_exec>()  is used to assess whether the null-terminated string pointed "
"to by I<string> matches the previously compiled I<regex>."
msgstr ""
"B<re_exec>()  は、 I<string> が指すヌルで終端された文字列が前回コンパイルされ"
"た I<regex> にマッチするかどうかを評価するために使用される。"

#. type: Plain text
#: build/C/man3/re_comp.3:63
msgid ""
"B<re_comp>()  returns NULL on successful compilation of I<regex> otherwise "
"it returns a pointer to an appropriate error message."
msgstr ""
"B<re_comp>()  は、 I<regex> のコンパイルに成功した場合 NULL を返し、 それ以外"
"の場合は適切なエラーメッセージへのポインターを返す。"

#. type: Plain text
#: build/C/man3/re_comp.3:66
msgid "B<re_exec>()  returns 1 for a successful match, zero for failure."
msgstr "B<re_exec>()  は、一致した場合 1 を、失敗した場合 0 を返す。"

#. type: tbl table
#: build/C/man3/re_comp.3:77
#, no-wrap
msgid ""
"B<re_comp>(),\n"
"B<re_exec>()"
msgstr ""
"B<re_comp>(),\n"
"B<re_exec>()"

#. type: tbl table
#: build/C/man3/re_comp.3:77
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: build/C/man3/re_comp.3:81
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man3/re_comp.3:85
msgid ""
"These functions are obsolete; the functions documented in B<regcomp>(3)  "
"should be used instead."
msgstr ""
"これらの関数は廃止予定である。代わりに B<regcomp>(3)  に書かれている関数を使"
"用すべきである。"

#. type: Plain text
#: build/C/man3/re_comp.3:89
msgid "B<regcomp>(3), B<regex>(7), GNU regex manual"
msgstr "B<regcomp>(3), B<regex>(7), GNU regex manual"

#. type: TH
#: build/C/man3/regex.3:30 build/C/man7/regex.7:37
#, no-wrap
msgid "REGEX"
msgstr "REGEX"

#. type: Plain text
#: build/C/man3/regex.3:33
msgid "regcomp, regexec, regerror, regfree - POSIX regex functions"
msgstr "regcomp, regexec, regerror, regfree - POSIX regex 関数"

#. type: Plain text
#: build/C/man3/regex.3:36
#, no-wrap
msgid "B<#include E<lt>regex.hE<gt>>\n"
msgstr "B<#include E<lt>regex.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/regex.3:38
#, no-wrap
msgid "B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int >I<cflags>B<);>\n"
msgstr "B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int >I<cflags>B<);>\n"

#. type: Plain text
#: build/C/man3/regex.3:42
#, no-wrap
msgid ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"
msgstr ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"

#. type: Plain text
#: build/C/man3/regex.3:45
#, no-wrap
msgid ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"
msgstr ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"

#. type: Plain text
#: build/C/man3/regex.3:47
#, no-wrap
msgid "B<void regfree(regex_t *>I<preg>B<);>\n"
msgstr "B<void regfree(regex_t *>I<preg>B<);>\n"

#. type: SS
#: build/C/man3/regex.3:49
#, no-wrap
msgid "POSIX regex compiling"
msgstr "POSIX regex コンパイル"

#. type: Plain text
#: build/C/man3/regex.3:55
msgid ""
"B<regcomp>()  is used to compile a regular expression into a form that is "
"suitable for subsequent B<regexec>()  searches."
msgstr ""
"B<regcomp>()  は、正規表現をコンパイルして、 B<regexec>()  での検索処理に適合"
"する形態にする。"

#. type: Plain text
#: build/C/man3/regex.3:64
msgid ""
"B<regcomp>()  is supplied with I<preg>, a pointer to a pattern buffer "
"storage area; I<regex>, a pointer to the null-terminated string and "
"I<cflags>, flags used to determine the type of compilation."
msgstr ""
"B<regcomp>()  はパターンを記憶するバッファーへのポインター I<preg>、 ヌル文字"
"で終端された文字列 I<regex>、 そしてコンパイルの形式を決めるためのフラグ "
"I<cflag> を引数に伴う。"

#. type: Plain text
#: build/C/man3/regex.3:71
msgid ""
"All regular expression searching must be done via a compiled pattern buffer, "
"thus B<regexec>()  must always be supplied with the address of a "
"B<regcomp>()  initialized pattern buffer."
msgstr ""
"全ての正規表現検索は、コンパイルされたパターンによって行わなければならない。 "
"よって、 B<regexec>()  に指定するのは、必ず (B<regcomp>()  によってコンパイル"
"された) パターンバッファーへのアドレスでなければならない。"

#. type: Plain text
#: build/C/man3/regex.3:76
msgid "I<cflags> is the bitwise-B<or> of zero or more of the following:"
msgstr "I<cflags> には、以下に示す定数のうち 0 個以上をビットごとの OR (bitwise-or) で指定する。"

#. type: TP
#: build/C/man3/regex.3:76
#, no-wrap
msgid "B<REG_EXTENDED>"
msgstr "B<REG_EXTENDED>"

#. type: Plain text
#: build/C/man3/regex.3:85
msgid ""
"Use B<POSIX> Extended Regular Expression syntax when interpreting I<regex>.  "
"If not set, B<POSIX> Basic Regular Expression syntax is used."
msgstr ""
"I<regex> に B<POSIX> 拡張正規表現を使用する。もしこのフラグが設定されない場"
"合、 B<POSIX> 標準正規表現が使われる。"

#. type: TP
#: build/C/man3/regex.3:85
#, no-wrap
msgid "B<REG_ICASE>"
msgstr "B<REG_ICASE>"

#. type: Plain text
#: build/C/man3/regex.3:91
msgid ""
"Do not differentiate case.  Subsequent B<regexec>()  searches using this "
"pattern buffer will be case insensitive."
msgstr ""
"大文字小文字の違いを無視する。このフラグを指定してコンパイルされた パターン"
"バッファーを用いて B<regexec>()  関数を呼び出すと、大文字小文字の区別を付けず"
"に検索が行われる。"

#. type: TP
#: build/C/man3/regex.3:91
#, no-wrap
msgid "B<REG_NOSUB>"
msgstr "B<REG_NOSUB>"

#. type: Plain text
#: build/C/man3/regex.3:101
msgid ""
"Do not report position of matches.  The I<nmatch> and I<pmatch> arguments to "
"B<regexec>()  are ignored if the pattern buffer supplied was compiled with "
"this flag set."
msgstr ""
"マッチの場所を報告しない。渡されたパターンバッファーがこのフラグを設定してコ"
"ンパイルされていた場合、 B<regexec>() の引き数 I<nmatch>, I<pmatch> が無視さ"
"れる。"

#. type: TP
#: build/C/man3/regex.3:101
#, no-wrap
msgid "B<REG_NEWLINE>"
msgstr "B<REG_NEWLINE>"

#. type: Plain text
#: build/C/man3/regex.3:104
msgid "Match-any-character operators don't match a newline."
msgstr "全ての文字にマッチするオペレータに改行をマッチさせない。"

#. type: Plain text
#: build/C/man3/regex.3:108
msgid ""
"A nonmatching list (B<[\\(ha...]>)  not containing a newline does not match "
"a newline."
msgstr "改行を含まない非マッチング文字リスト (B<[\\(ha...]>)  に改行をマッチさせない。"

#. type: Plain text
#: build/C/man3/regex.3:118
msgid ""
"Match-beginning-of-line operator (B<\\(ha>)  matches the empty string "
"immediately after a newline, regardless of whether I<eflags>, the execution "
"flags of B<regexec>(), contains B<REG_NOTBOL>."
msgstr "B<regexec>()  の実行時に指定するフラグ I<eflags> に B<REG_NOTBOL> を含むかどうかにかかわらず、行頭にマッチするオペレータ (B<\\(ha>)  を改行直後の空文字列にマッチさせる。"

#. type: Plain text
#: build/C/man3/regex.3:126
msgid ""
"Match-end-of-line operator (B<$>)  matches the empty string immediately "
"before a newline, regardless of whether I<eflags> contains B<REG_NOTEOL>."
msgstr ""
"I<eflags> に B<REG_NOTEOL> を含むかどうかにかかわらず、行末にマッチするオペ"
"レータ (B<$>)  を改行直前の空文字列にマッチさせる。"

#. type: SS
#: build/C/man3/regex.3:126
#, no-wrap
msgid "POSIX regex matching"
msgstr "POSIX regex マッチング"

#. type: Plain text
#: build/C/man3/regex.3:139
msgid ""
"B<regexec>()  is used to match a null-terminated string against the "
"precompiled pattern buffer, I<preg>.  I<nmatch> and I<pmatch> are used to "
"provide information regarding the location of any matches.  I<eflags> is the "
"bitwise-B<or> of zero or more of the following flags:"
msgstr "B<regexec>()  は、 プリコンパイルされたパターンバッファー I<preg> をヌル文字で終端された文字列にマッチさせる。 I<nmatch> と I<pmatch> はマッチングの位置に関する情報を取得するのに用いられる。 I<eflags> には、以下のフラグのうち 0 個以上をビットごとの B<OR> (bitwise-B<or>) で指定する。"

#. type: TP
#: build/C/man3/regex.3:139
#, no-wrap
msgid "B<REG_NOTBOL>"
msgstr "B<REG_NOTBOL>"

#. type: Plain text
#: build/C/man3/regex.3:149
msgid ""
"The match-beginning-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above).  This flag may be used when "
"different portions of a string are passed to B<regexec>()  and the beginning "
"of the string should not be interpreted as the beginning of the line."
msgstr ""
"行頭にマッチするオペレータは、必ずマッチに失敗する (コンパイル時のフラグ "
"B<REG_NEWLINE> の項目も参照)。 このフラグは、複数行にまたがる文字列を "
"B<regexec>()  で検索する際に、文字列の先頭を行の先頭として解釈させない場合に"
"用いる。"

#. type: TP
#: build/C/man3/regex.3:149
#, no-wrap
msgid "B<REG_NOTEOL>"
msgstr "B<REG_NOTEOL>"

#. type: Plain text
#: build/C/man3/regex.3:155
msgid ""
"The match-end-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)."
msgstr ""
"行末にマッチするオペレータは、必ずマッチに失敗する (コンパイル時のフラグ "
"B<REG_NEWLINE> の項目も参照)。"

#. type: TP
#: build/C/man3/regex.3:155
#, no-wrap
msgid "B<REG_STARTEND>"
msgstr "B<REG_STARTEND>"

#. type: Plain text
#: build/C/man3/regex.3:175
msgid ""
"Use I<pmatch[0]> on the input string, starting at byte I<pmatch[0].rm_so> "
"and ending before byte I<pmatch[0].rm_eo>.  This allows matching embedded "
"NUL bytes and avoids a B<strlen>(3)  on large strings.  It does not use "
"I<nmatch> on input, and does not change B<REG_NOTBOL> or B<REG_NEWLINE> "
"processing.  This flag is a BSD extension, not present in POSIX."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:175
#, no-wrap
msgid "Byte offsets"
msgstr "バイトオフセット"

#. type: Plain text
#: build/C/man3/regex.3:200
msgid ""
"Unless B<REG_NOSUB> was set for the compilation of the pattern buffer, it is "
"possible to obtain match addressing information.  I<pmatch> must be "
"dimensioned to have at least I<nmatch> elements.  These are filled in by "
"B<regexec>()  with substring match addresses.  The offsets of the "
"subexpression starting at the I<i>th open parenthesis are stored in "
"I<pmatch[i]>.  The entire regular expression's match addresses are stored in "
"I<pmatch[0]>.  (Note that to return the offsets of I<N> subexpression "
"matches, I<nmatch> must be at least I<N+1>.)  Any unused structure elements "
"will contain the value -1."
msgstr ""
"パターンバッファーのコンパイル時に B<REG_NOSUB> が設定されない場合は、マッチ"
"ング位置情報を得ることができる。 I<pmatch> は、少なくとも I<nmatch> の大きさ"
"を持つように指定しなければならない。 B<regexec>()  の実行によって、それらに部"
"分文字列マッチング位置情報が代入される。 I<i> 番目の括弧で始まる部分正規表現"
"のオフセットは I<pmatch[i]> に格納される。正規表現全体のマッチアドレスは "
"I<pmatch[0]> に格納される。 (I<N> 個の部分正規表現のマッチのオフセットを返す"
"ためには、 I<nmatch> は最低限 I<N+1> でなければならない点に注意すること。) 未"
"使用の構造体要素には -1 が値として代入される。"

#. type: Plain text
#: build/C/man3/regex.3:207
msgid ""
"The I<regmatch_t> structure which is the type of I<pmatch> is defined in "
"I<E<lt>regex.hE<gt>>."
msgstr ""
"I<pmatch> の型である I<regmatch_t> 構造体は、 I<E<lt>regex.hE<gt>> 内で定義さ"
"れる。"

#. type: Plain text
#: build/C/man3/regex.3:214
#, no-wrap
msgid ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"
msgstr ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"

#. type: Plain text
#: build/C/man3/regex.3:225
msgid ""
"Each I<rm_so> element that is not -1 indicates the start offset of the next "
"largest substring match within the string.  The relative I<rm_eo> element "
"indicates the end offset of the match, which is the offset of the first "
"character after the matching text."
msgstr ""
"構造体要素 I<rm_so> の値が -1 でない場合、それは文字列内での次の最大のマッチ"
"ング部分の開始 オフセット位置を示す。それに対し、構造体要素 I<rm_eo> はマッチ"
"ング部分の終了オフセット位置を示し、 マッチング部分の直後の文字のオフセット位"
"置が使用される。"

#. type: SS
#: build/C/man3/regex.3:225
#, no-wrap
msgid "POSIX error reporting"
msgstr "POSIX エラーレポート"

#. type: Plain text
#: build/C/man3/regex.3:232
msgid ""
"B<regerror>()  is used to turn the error codes that can be returned by both "
"B<regcomp>()  and B<regexec>()  into error message strings."
msgstr ""
"B<regerror>()  は、 B<regcomp>()  と B<regexec>()  の実行によって得られるエ"
"ラーコードから、エラーメッセージ文字列を 得るのに用いられる。"

#. type: Plain text
#: build/C/man3/regex.3:254
msgid ""
"B<regerror>()  is passed the error code, I<errcode>, the pattern buffer, "
"I<preg>, a pointer to a character string buffer, I<errbuf>, and the size of "
"the string buffer, I<errbuf_size>.  It returns the size of the I<errbuf> "
"required to contain the null-terminated error message string.  If both "
"I<errbuf> and I<errbuf_size> are nonzero, I<errbuf> is filled in with the "
"first I<errbuf_size - 1> characters of the error message and a terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""
"B<regerror>()  はエラーコード I<errcode>、 パターンバッファー I<preg>、 文字"
"列バッファーへのポインター I<errbuf>、 文字列バッファーのサイズ "
"I<errbuf_size> を引数にとる。 この関数は、ヌル文字で終端されたエラーメッセー"
"ジ文字列を格納するのに必要な I<errbuf> のサイズを返す。もし I<errbuf> と "
"I<errbuf_size> の両方が非 0 値であれば、 I<errbuf> には最初の I<errbuf_size "
"- 1> 文字分にエラーメッセージと終端のヌルバイト (\\(aq\\e0\\(aq)  が収まるよ"
"うに代入される。"

#. type: SS
#: build/C/man3/regex.3:254
#, no-wrap
msgid "POSIX pattern buffer freeing"
msgstr "POSIX パターンバッファー解放"

#. type: Plain text
#: build/C/man3/regex.3:262
msgid ""
"Supplying B<regfree>()  with a precompiled pattern buffer, I<preg> will free "
"the memory allocated to the pattern buffer by the compiling process, "
"B<regcomp>()."
msgstr ""
"引数にコンパイルされたパターンバッファー I<preg> を与えて B<regfree>()  を呼"
"び出すと、 B<regcomp>()  によるコンパイル時にパターンバッファーに割り当てられ"
"たメモリーが解放される。"

#. type: Plain text
#: build/C/man3/regex.3:265
msgid ""
"B<regcomp>()  returns zero for a successful compilation or an error code for "
"failure."
msgstr ""
"B<regcomp>()  は、コンパイルの成功時には 0 を返し、失敗時にはエラーコードを返"
"す。"

#. type: Plain text
#: build/C/man3/regex.3:270
msgid ""
"B<regexec>()  returns zero for a successful match or B<REG_NOMATCH> for "
"failure."
msgstr ""
"B<regexec>()  は、マッチングの成功時には 0 を返し、失敗時には B<REG_NOMATCH> "
"を返す。"

#. type: SH
#: build/C/man3/regex.3:270
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/regex.3:273
msgid "The following errors can be returned by B<regcomp>():"
msgstr "B<regcomp>()  は以下のエラーを返す。"

#. type: TP
#: build/C/man3/regex.3:273
#, no-wrap
msgid "B<REG_BADBR>"
msgstr "B<REG_BADBR>"

#. type: Plain text
#: build/C/man3/regex.3:276
msgid "Invalid use of back reference operator."
msgstr "無効な後方参照オペレータの使用。"

#. type: TP
#: build/C/man3/regex.3:276
#, no-wrap
msgid "B<REG_BADPAT>"
msgstr "B<REG_BADPAT>"

#. type: Plain text
#: build/C/man3/regex.3:279
msgid "Invalid use of pattern operators such as group or list."
msgstr "グループやリストなどの、パターンオペレータの無効な使用。"

#. type: TP
#: build/C/man3/regex.3:279
#, no-wrap
msgid "B<REG_BADRPT>"
msgstr "B<REG_BADRPT>"

#. type: Plain text
#: build/C/man3/regex.3:283
msgid ""
"Invalid use of repetition operators such as using \\(aq*\\(aq as the first "
"character."
msgstr ""
"\\(aq*\\(aq が最初の文字としてくるような、無効な繰り返しオペレータの使用。"

#. type: TP
#: build/C/man3/regex.3:283
#, no-wrap
msgid "B<REG_EBRACE>"
msgstr "B<REG_EBRACE>"

#. type: Plain text
#: build/C/man3/regex.3:286
msgid "Un-matched brace interval operators."
msgstr ""
"インターバルオペレータ B<{}> (brace interval operators) が閉じていない。"

#. type: TP
#: build/C/man3/regex.3:286
#, no-wrap
msgid "B<REG_EBRACK>"
msgstr "B<REG_EBRACK>"

#. type: Plain text
#: build/C/man3/regex.3:289
msgid "Un-matched bracket list operators."
msgstr "リストオペレータ B<[]> (bracket list operators) が閉じていない。"

#. type: TP
#: build/C/man3/regex.3:289
#, no-wrap
msgid "B<REG_ECOLLATE>"
msgstr "B<REG_ECOLLATE>"

#. type: Plain text
#: build/C/man3/regex.3:292
msgid "Invalid collating element."
msgstr ""
"照合順序の要素 (collating element) として有効ではない。 (訳注) 詳細は "
"B<regex>(7)  を参照。"

#. type: TP
#: build/C/man3/regex.3:292
#, no-wrap
msgid "B<REG_ECTYPE>"
msgstr "B<REG_ECTYPE>"

#. type: Plain text
#: build/C/man3/regex.3:295
msgid "Unknown character class name."
msgstr "未知のキャラクタークラス名。"

#. type: TP
#: build/C/man3/regex.3:295
#, no-wrap
msgid "B<REG_EEND>"
msgstr "B<REG_EEND>"

#. type: Plain text
#: build/C/man3/regex.3:299
msgid "Nonspecific error.  This is not defined by POSIX.2."
msgstr "未定義エラー。これは POSIX.2 には定義されていない。"

#. type: TP
#: build/C/man3/regex.3:299
#, no-wrap
msgid "B<REG_EESCAPE>"
msgstr "B<REG_EESCAPE>"

#. type: Plain text
#: build/C/man3/regex.3:302
msgid "Trailing backslash."
msgstr "正規表現がバックスラッシュで終っている。"

#. type: TP
#: build/C/man3/regex.3:302
#, no-wrap
msgid "B<REG_EPAREN>"
msgstr "B<REG_EPAREN>"

#. type: Plain text
#: build/C/man3/regex.3:305
msgid "Un-matched parenthesis group operators."
msgstr ""
"グループオペレータ B<()> (parenthesis group operators) が閉じていない。"

#. type: TP
#: build/C/man3/regex.3:305
#, no-wrap
msgid "B<REG_ERANGE>"
msgstr "B<REG_ERANGE>"

#. type: Plain text
#: build/C/man3/regex.3:309
msgid ""
"Invalid use of the range operator; for example, the ending point of the "
"range occurs prior to the starting point."
msgstr ""
"無効な範囲オペレータの使用。 例えば、範囲の終了位置が開始位置よりも前にあるよ"
"うな場合。"

#. type: TP
#: build/C/man3/regex.3:309
#, no-wrap
msgid "B<REG_ESIZE>"
msgstr "B<REG_ESIZE>"

#. type: Plain text
#: build/C/man3/regex.3:313
msgid ""
"Compiled regular expression requires a pattern buffer larger than 64\\ kB.  "
"This is not defined by POSIX.2."
msgstr "正規表現のコンパイルに、64\\ Kb 以上のパターンバッファーが必要。 これは POSIX.2 には定義されていない。"

#. type: TP
#: build/C/man3/regex.3:313
#, no-wrap
msgid "B<REG_ESPACE>"
msgstr "B<REG_ESPACE>"

#. type: Plain text
#: build/C/man3/regex.3:316
msgid "The regex routines ran out of memory."
msgstr "regex ルーチンがメモリーを使いはたしている。"

#. type: TP
#: build/C/man3/regex.3:316
#, no-wrap
msgid "B<REG_ESUBREG>"
msgstr "B<REG_ESUBREG>"

#. type: Plain text
#: build/C/man3/regex.3:319
msgid "Invalid back reference to a subexpression."
msgstr ""
"サブエクスプレッション \\eB<(...\\e>)  (subexpression) への無効な後方参照。"

#. type: tbl table
#: build/C/man3/regex.3:330
#, no-wrap
msgid ""
"B<regcomp>(),\n"
"B<regexec>()"
msgstr ""
"B<regcomp>(),\n"
"B<regexec>()"

#. type: tbl table
#: build/C/man3/regex.3:330
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: tbl table
#: build/C/man3/regex.3:333
#, no-wrap
msgid "B<regerror>()"
msgstr "B<regerror>()"

#. type: tbl table
#: build/C/man3/regex.3:333
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: tbl table
#: build/C/man3/regex.3:336
#, no-wrap
msgid "B<regfree>()"
msgstr "B<regfree>()"

#. type: Plain text
#: build/C/man3/regex.3:340 build/C/man3/wordexp.3:223
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/regex.3:346
#, no-wrap
msgid ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>regex.hE<gt>\n"
msgstr ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>regex.hE<gt>\n"

#. type: Plain text
#: build/C/man3/regex.3:348
#, no-wrap
msgid "#define ARRAY_SIZE(arr) (sizeof((arr)) / sizeof((arr)[0]))\n"
msgstr "#define ARRAY_SIZE(arr) (sizeof((arr)) / sizeof((arr)[0]))\n"

#. type: Plain text
#: build/C/man3/regex.3:352
#, no-wrap
msgid ""
"static const char *const str =\n"
"        \"1) John Driverhacker;\\en2) John Doe;\\en3) John Foo;\\en\";\n"
"static const char *const re = \"John.*o\";\n"
msgstr ""
"static const char *const str =\n"
"        \"1) John Driverhacker;\\en2) John Doe;\\en3) John Foo;\\en\";\n"
"static const char *const re = \"John.*o\";\n"

#. type: Plain text
#: build/C/man3/regex.3:359
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    static const char *s = str;\n"
"    regex_t     regex;\n"
"    regmatch_t  pmatch[1];\n"
"    regoff_t    off, len;\n"
msgstr ""
"int main(void)\n"
"{\n"
"    static const char *s = str;\n"
"    regex_t     regex;\n"
"    regmatch_t  pmatch[1];\n"
"    regoff_t    off, len;\n"

#. type: Plain text
#: build/C/man3/regex.3:362
#, no-wrap
msgid ""
"    if (regcomp(&regex, re, REG_NEWLINE))\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    if (regcomp(&regex, re, REG_NEWLINE))\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: build/C/man3/regex.3:365
#, no-wrap
msgid ""
"    printf(\"String = \\e\"%s\\e\"\\en\", str);\n"
"    printf(\"Matches:\\en\");\n"
msgstr ""
"    printf(\"String = \\e\"%s\\e\"\\en\", str);\n"
"    printf(\"Matches:\\en\");\n"

#. type: Plain text
#: build/C/man3/regex.3:369
#, no-wrap
msgid ""
"    for (int i = 0; ; i++) {\n"
"        if (regexec(&regex, s, ARRAY_SIZE(pmatch), pmatch, 0))\n"
"            break;\n"
msgstr ""
"    for (int i = 0; ; i++) {\n"
"        if (regexec(&regex, s, ARRAY_SIZE(pmatch), pmatch, 0))\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/regex.3:376
#, no-wrap
msgid ""
"        off = pmatch[0].rm_so + (s - str);\n"
"        len = pmatch[0].rm_eo - pmatch[0].rm_so;\n"
"        printf(\"#%d:\\en\", i);\n"
"        printf(\"offset = %jd; length = %jd\\en\", (intmax_t) off,\n"
"                (intmax_t) len);\n"
"        printf(\"substring = \\e\"%.*s\\e\"\\en\", len, s + pmatch[0].rm_so);\n"
msgstr ""
"        off = pmatch[0].rm_so + (s - str);\n"
"        len = pmatch[0].rm_eo - pmatch[0].rm_so;\n"
"        printf(\"#%d:\\en\", i);\n"
"        printf(\"offset = %jd; length = %jd\\en\", (intmax_t) off,\n"
"                (intmax_t) len);\n"
"        printf(\"substring = \\e\"%.*s\\e\"\\en\", len, s + pmatch[0].rm_so);\n"

#. type: Plain text
#: build/C/man3/regex.3:379
#, no-wrap
msgid ""
"        s += pmatch[0].rm_eo;\n"
"    }\n"
msgstr ""
"        s += pmatch[0].rm_eo;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/regex.3:382
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/regex.3:386
msgid "B<grep>(1), B<regex>(7)"
msgstr "B<grep>(1), B<regex>(7)"

#. type: Plain text
#: build/C/man3/regex.3:389
msgid "The glibc manual section, I<Regular Expressions>"
msgstr "glibc マニュアルのセクション I<Regular Expressions>"

#. type: Plain text
#: build/C/man7/regex.7:40
msgid "regex - POSIX.2 regular expressions"
msgstr "regex - POSIX.2 正規表現"

#. type: Plain text
#: build/C/man7/regex.7:54
msgid ""
"Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forms: "
"modern REs (roughly those of I<egrep>; POSIX.2 calls these \"extended\" "
"REs)  and obsolete REs (roughly those of B<ed>(1); POSIX.2 \"basic\" REs).  "
"Obsolete REs mostly exist for backward compatibility in some old programs; "
"they will be discussed at the end.  POSIX.2 leaves some aspects of RE syntax "
"and semantics open; \"\\*(dg\" marks decisions on these aspects that may not "
"be fully portable to other POSIX.2 implementations."
msgstr ""
"正規表現 (Regular expression: RE) は POSIX.2 で定義されており、 二つの形式が"
"ある。新しい正規表現 (modern RE) と古い正規表現 (obsolete RE)  である。新しい"
"正規表現はだいたい I<egrep> のものと同じで、 POSIX.2 では「拡張」正規表現 "
"(\"extended\" RE)  と呼ばれている。古い正規表現はだいたい B<ed>(1)  のものと"
"同じで、 POSIX.2 では「基本」正規表現 (\"basic\" RE) である。 古い正規表現"
"は、古いプログラムとの互換性を保つためのものである。 これについては最後に議論"
"する。 POSIX.2 では、正規表現の文法や記号の一部が、未定義のまま残されてい"
"る。 \"\\*(dg\" は、このような意味で、他の POSIX.2 の実装と 完全には互換でな"
"いかも知れない部分である。"

#. type: Plain text
#: build/C/man7/regex.7:58
msgid ""
"A (modern) RE is one\\*(dg or more nonempty\\*(dg I<branches>, separated by "
"\\(aq|\\(aq.  It matches anything that matches one of the branches."
msgstr ""
"(新しい) 正規表現は一つ以上\\*(dg の空白でない I<枝 (branch)> からなる。 枝ど"
"うしは \\(aq|\\(aq で区切られる。正規表現は、 枝のどれかにマッチ (match) した"
"ものにマッチする。"

#. type: Plain text
#: build/C/man7/regex.7:62
msgid ""
"A branch is one\\*(dg or more I<pieces>, concatenated.  It matches a match "
"for the first, followed by a match for the second, and so on."
msgstr ""
"枝は一つ以上の文節 (piece) が結合されたものである。 枝は第一の文節がマッチ"
"し、 続いて第二の文節がマッチし、... したものにマッチする。"

#. type: Plain text
#: build/C/man7/regex.7:71
msgid ""
"A piece is an I<atom> possibly followed by a single\\*(dg \\(aq*\\(aq, \\(aq+"
"\\(aq, \\(aq?\\(aq, or I<bound>.  An atom followed by \\(aq*\\(aq matches a "
"sequence of 0 or more matches of the atom.  An atom followed by \\(aq+\\(aq "
"matches a sequence of 1 or more matches of the atom.  An atom followed by "
"\\(aq?\\(aq matches a sequence of 0 or 1 matches of the atom."
msgstr ""
"文節はI<アトム (atom)> からなる。ただしアトムの後には一つ\\*(dg の \\(aq*"
"\\(aq, \\(aq+\\(aq, \\(aq?\\(aq あるいは I<繰り返し指定 (bound)> が続くことも"
"ある。 \\(aq*\\(aq が後置されたアトムは、マッチしたアトムの 0 個以上の並びに"
"マッチする。 \\(aq+\\(aq が後置されたアトムは、マッチしたアトムの 1 個以上の"
"並びにマッチする。 \\(aq?\\(aq が後置されたアトムは、マッチしたアトムの 0 個"
"または 1 個にマッチする。"

#. type: Plain text
#: build/C/man7/regex.7:89
msgid ""
"A I<bound> is \\(aq{\\(aq followed by an unsigned decimal integer, possibly "
"followed by \\(aq,\\(aq possibly followed by another unsigned decimal "
"integer, always followed by \\(aq}\\(aq.  The integers must lie between 0 "
"and B<RE_DUP_MAX> (255\\*(dg) inclusive, and if there are two of them, the "
"first may not exceed the second.  An atom followed by a bound containing one "
"integer I<i> and no comma matches a sequence of exactly I<i> matches of the "
"atom.  An atom followed by a bound containing one integer I<i> and a comma "
"matches a sequence of I<i> or more matches of the atom.  An atom followed by "
"a bound containing two integers I<i> and I<j> matches a sequence of I<i> "
"through I<j> (inclusive) matches of the atom."
msgstr ""
"I<繰り返し指定>とは \\(aq{\\(aq に続いて、符号なし 10 進整数、\\(aq,\\(aq、 "
"もう一つの 10 進整数、\\(aq}\\(aq を並べたものである。\\(aq,\\(aq と二つめの "
"10 進整数は省略できる。二つめの 10 進整数だけを省略することもできる (最後の "
"`}' は省略できない)。 整数は 0 以上 B<RE_DUP_MAX> (255\\*(dg) 以下の間で指定"
"できる。 二つ指定する場合には、最初の数値は後の数値を越えてはならない。 整数 "
"I<i> だけからなる繰り返し指定を後置されたアトムは、 アトムをぴったりちょうど "
"I<i> 個だけ並べたものにマッチする。 整数 I<i> とコンマが指定された繰り返し指"
"定を後置されたアトムは、 アトムを I<i>個以上並べたものにマッチする。 整数 "
"I<i> と I<j> が指定された繰り返し指定を後置されたアトムは、 アトムを I<i>個以"
"上 I<j> 個以下だけ並べたものにマッチする。"

#. type: Plain text
#: build/C/man7/regex.7:106
msgid ""
"An atom is a regular expression enclosed in \"I<()>\" (matching a match for "
"the regular expression), an empty set of \"I<()>\" (matching the null "
"string)\\*(dg, a I<bracket expression> (see below), \\(aq.\\(aq (matching "
"any single character), \\(aq\\(ha\\(aq (matching the null string at the "
"beginning of a line), \\(aq$\\(aq (matching the null string at the end of a "
"line), a \\(aq\\e\\(aq followed by one of the characters \"I<\\(ha.[$()|*+?"
"{\\e>\" (matching that character taken as an ordinary character), a \\(aq\\e"
"\\(aq followed by any other character\\*(dg (matching that character taken "
"as an ordinary character, as if the \\(aq\\e\\(aq had not been present"
"\\*(dg), or a single character with no other significance (matching that "
"character).  A \\(aq{\\(aq followed by a character other than a digit is an "
"ordinary character, not the beginning of a bound\\*(dg.  It is illegal to "
"end an RE with \\(aq\\e\\(aq."
msgstr "アトムの種類は以下の通り。\"I<()>\" に囲まれた正規表現 (その正規表現がマッチする文字列にマッチする)、 中身が空の \"I<()>\" (null 文字列にマッチする)\\*(dg、 I<ブラケット表現 (bracket expression> :後述)、 \\(aq.\\(aq (任意の 1 文字にマッチする)、 \\(aq\\(ha\\(aq (行頭の空白文字にマッチする)、 \\(aq$\\(aq (行末の空白文字にマッチする)、 \\(aq\\e\\(aq に \"I<\\(ha.[$()|*+?{\\e>\" のいずれか一文字を後置したもの (通常の文字として扱われ、その文字にマッチする)、 \\(aq\\e\\(aq にそれ以外の文字を後置したもの\\*(dg (\\(aq\\e\\(aq がない場合と同じように、その文字にマッチする\\*(dg)、 特に意味を持たない文字一つ (その文字にマッチする)。 \\(aq{\\(aq は数字以外の文字が後置されると通常の文字として扱われ、 繰り返し指定の始まりとはされない\\*(dg。\\(aq\\e\\(aq で終わる正規表現は不正なものとみなされる。"

#. type: Plain text
#: build/C/man7/regex.7:120
msgid ""
"A I<bracket expression> is a list of characters enclosed in \"I<[]>\".  It "
"normally matches any single character from the list (but see below).  If the "
"list begins with \\(aq\\(ha\\(aq, it matches any single character (but see "
"below) I<not> from the rest of the list.  If two characters in the list are "
"separated by \\(aq-\\(aq, this is shorthand for the full I<range> of "
"characters between those two (inclusive) in the collating sequence, for "
"example, \"I<[0-9]>\" in ASCII matches any decimal digit.  It is illegal"
"\\*(dg for two ranges to share an endpoint, for example, \"I<a-c-e>\".  "
"Ranges are very collating-sequence-dependent, and portable programs should "
"avoid relying on them."
msgstr "I<ブラケット表現>は \"I<[]>\" によって閉じられた文字のリストである。 これは通常リスト中に存在している文字にマッチする。 (例外あり、後述。) リストが \\(aq\\(ha\\(aq で始まると、 I<ブラケット表現>はリストに存在してI<いない>文字一つにマッチする (例外あり、後述)。 リスト中の二つの文字が \\(aq-\\(aq で区切られている場合は、 これは照合順序 (collating sequence) でその二つの文字に挟まれる、 すべての文字の並びを短縮したものとみなされる (両端含む)。 例えば \"I<[0-9]>\" は ASCII では 10 進の数字 (digit) のいずれかにマッチする。 二つの領域指定が端点を共有してはならない\\*(dg。 つまり \"I<a-c-e>\" のようなものは不正である。領域指定は照合順序に強く依存する。 したがって移植性の高いプログラムを作る場合は、 領域指定には頼らないほうが良いだろう。 【B<訳注>: 照合順序 (collating sequence) というのは、国際化 (Internationalization) に関連した用語です。アルファベット順に単語を並 べる際には、言語によって並べる基準が異なります。照合順序は、その差異を 吸収するための仕組みです。 例えば、スペイン語では ch という文字並びを特別扱いするため、アルファベッ ト順が a, b, c, ch, d, e, ... の順になるそうです。このようなシーケンス のことを collating sequence と言います。このとき `ch' という文字並びは、 単語整列の際にあたかも「一文字」のように扱われます。ここで、 順序付けを行う際に最小の単位となる、`a'、`b' の文字や `ch' のような特別な文字並びなど、照合順序の要素のことを collating element と言います。collating sequence は、文字単位ではなく collating element を単位として定義されます。】"

#. type: Plain text
#: build/C/man7/regex.7:131
msgid ""
"To include a literal \\(aq]\\(aq in the list, make it the first character "
"(following a possible \\(aq\\(ha\\(aq).  To include a literal \\(aq-\\(aq, "
"make it the first or last character, or the second endpoint of a range.  To "
"use a literal \\(aq-\\(aq as the first endpoint of a range, enclose it in "
"\"I<[.>\" and \"I<.]>\" to make it a collating element (see below).  With "
"the exception of these and some combinations using \\(aq[\\(aq (see next "
"paragraphs), all other special characters, including \\(aq\\e\\(aq, lose "
"their special significance within a bracket expression."
msgstr "文字 \\(aq]\\(aq そのものをリストに入れたい場合は、 最初の文字として指定すれば良い (\\(aq\\(ha\\(aq) の後に続けるのでも良い)。 文字 \\(aq-\\(aq そのものをリストに入れたい場合は、 最初か最後の文字とすれば良い。 あるいは領域指定の終端文字として指定しても良い。 \\(aq-\\(aq を領域指定の先頭文字に指定するには、\"I<[.>\" と \"I<.]>\" で囲って、 照合順序の要素 (collating element: 後述) にすれば良い。 他の特殊文字 ( も含む) は、 ブラケット表現の内部ではすべて通常の文字として扱われる。"

#. type: Plain text
#: build/C/man7/regex.7:143
msgid ""
"Within a bracket expression, a collating element (a character, a "
"multicharacter sequence that collates as if it were a single character, or a "
"collating-sequence name for either)  enclosed in \"I<[.>\" and \"I<.]>\" "
"stands for the sequence of characters of that collating element.  The "
"sequence is a single element of the bracket expression's list.  A bracket "
"expression containing a multicharacter collating element can thus match more "
"than one character, for example, if the collating sequence includes a \"ch\" "
"collating element, then the RE \"I<[[.ch.]]*c>\" matches the first five "
"characters of \"chchcc\"."
msgstr ""
"ブラケット表現の内部では、\"I<[.>\" と \"I<.]>\" に囲われた照合順序の要素"
"は、 その要素に対応する文字並びを表す。 「照合順序の要素」とは、 [1] 文字、 "
"[2] 単一文字のように扱われる複数文字のシーケンス、 [3] 1, 2 いずれかに対応す"
"る照合順序上の名前、のいずれかである。 この繰り返しは、ブラケット表現のリスト"
"における単一の要素となる。 上記 [2] の、「複数文字からなる照合順序要素」を含"
"むブラケット表現は、 したがって一文字以上にマッチすることがある。 例えば、も"
"し照合順序が \"ch\" という要素を含んでいる場合には、 正規表現 \"I<[[.ch.]]*c>"
"\" は \"chchcc\" の最初の 5 文字にマッチする。"

#. type: Plain text
#: build/C/man7/regex.7:155
msgid ""
"Within a bracket expression, a collating element enclosed in \"I<[=>\" and "
"\"I<=]>\" is an equivalence class, standing for the sequences of characters "
"of all collating elements equivalent to that one, including itself.  (If "
"there are no other equivalent collating elements, the treatment is as if the "
"enclosing delimiters were \"I<[.>\" and \"I<.]>\".)  For example, if o and "
"\\o'o\\(ha' are the members of an equivalence class, then \"I<[[=o=]]>\", "
"\"I<[[=\\o'o\\(ha'=]]>\", and \"I<[o\\o'o\\(ha']>\" are all synonymous.  An "
"equivalence class may not\\*(dg be an endpoint of a range."
msgstr "ブラケット表現の内部では、\"I<[=>\" と \"I<=]>\" に囲まれた照合順序の要素は、 等価クラス (equivalence class) となる。 これは、その要素と等価な要素すべてからなる文字シーケンス (自身も含む) を表す。 他に等価な要素がなければ、 取り扱いは \"I<[.>\" と \"I<.]>\" で囲まれている場合と同じである。 例えば o と \\o'o\\(ha' が等価クラスのメンバーであれば、 \"I<[[=o=]]>\", \"I<[[=\\o'o\\(ha'=]]>\", \"I<[o\\o'o\\(ha']>\" はすべて同じ意味になる。 等価クラスは領域指定の端点にはなれない\\*(dg。"

#. type: Plain text
#: build/C/man7/regex.7:161
msgid ""
"Within a bracket expression, the name of a I<character class> enclosed in "
"\"I<[:>\" and \"I<:]>\" stands for the list of all characters belonging to "
"that class.  Standard character class names are:"
msgstr ""
"ブラケット表現の内部では、\"I<[:>\" と \"I<:]>\" で囲われたI<文字クラス "
"(character class)> はそのクラスに属するすべての文字のリストを表す。 標準で用"
"意されている文字クラスの名前は以下の通り:"

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "alnum"
msgstr "alnum"

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "digit"
msgstr "digit"

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "punct"
msgstr "punct"

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "alpha"
msgstr "alpha"

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "graph"
msgstr "graph"

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "space"
msgstr "space"

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "blank"
msgstr "blank"

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "lower"
msgstr "lower"

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "upper"
msgstr "upper"

#. type: tbl table
#: build/C/man7/regex.7:168
#, no-wrap
msgid "cntrl"
msgstr "cntrl"

#. type: tbl table
#: build/C/man7/regex.7:168
#, no-wrap
msgid "print"
msgstr "print"

#. type: tbl table
#: build/C/man7/regex.7:168
#, no-wrap
msgid "xdigit"
msgstr "xdigit"

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  There are two special cases\*(dg of bracket expressions:
#.  the bracket expressions "\fI[[:<:]]\fP" and "\fI[[:>:]]\fP" match
#.  the null string at the beginning and end of a word respectively.
#.  A word is defined as a sequence of
#.  word characters
#.  which is neither preceded nor followed by
#.  word characters.
#.  A word character is an
#.  .I alnum
#.  character (as defined by
#.  .BR wctype (3))
#.  or an underscore.
#.  This is an extension,
#.  compatible with but not specified by POSIX.2,
#.  and should be used with
#.  caution in software intended to be portable to other systems.
#. type: Plain text
#: build/C/man7/regex.7:195
msgid ""
"These stand for the character classes defined in B<wctype>(3).  A locale may "
"provide others.  A character class may not be used as an endpoint of a range."
msgstr ""
"これらは B<wctype>(3)  で定義されている文字クラスを表している。ロケール "
"(locale) によって、 これら以外のクラスが定義されることもある。 文字クラスは領"
"域指定の端点にはなれない。"

#. type: Plain text
#: build/C/man7/regex.7:207
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string.  If the RE "
"could match more than one substring starting at that point, it matches the "
"longest.  Subexpressions also match the longest possible substrings, subject "
"to the constraint that the whole match be as long as possible, with "
"subexpressions starting earlier in the RE taking priority over ones starting "
"later.  Note that higher-level subexpressions thus take priority over their "
"lower-level component subexpressions."
msgstr ""
"正規表現が、与えられた文字列の複数の部分文字列 (substring) にマッチできるよう"
"な場合には、 最も先頭の近くから始まるものにマッチする。 その位置から始まり、"
"正規表現がマッチできる部分文字列が複数ある場合には、 最長のものにマッチす"
"る。 部分正規表現 (subexpression) も最も長い部分文字列にマッチする。 ただし、"
"全体のマッチが最長であるように、という条件が優先される。 正規表現の中で先に現"
"れる部分正規表現は、後に現れるものより優先される。 ただし、より高位の部分正規"
"表現は、 それを構成する低位の部分正規表現よりも優先されることに注意すること。"

#. type: Plain text
#: build/C/man7/regex.7:219
msgid ""
"Match lengths are measured in characters, not collating elements.  A null "
"string is considered longer than no match at all.  For example, \"I<bb*>\" "
"matches the three middle characters of \"abbbc\", \"I<(wee|week)(knights|"
"nights)>\" matches all ten characters of \"weeknights\", when \"I<(.*).*>\" "
"is matched against \"abc\" the parenthesized subexpression matches all three "
"characters, and when \"I<(a*)*>\" is matched against \"bc\" both the whole "
"RE and the parenthesized subexpression match the null string."
msgstr ""
"マッチ長は照合順序の要素ではなく、文字数を単位としてカウントされる。 null 文"
"字列は、全くマッチしなかった場合よりも長いとみなされる。 例えば \"I<bb*>\" "
"は \"abbbc\" のまん中の 3 文字にマッチする。 \"I<(wee|week)(knights|nights)>"
"\" は \"weeknights\" の全体にマッチする。 \"I<(.*).*>\" を \"abc\" にマッチさ"
"せると、 括弧の内部の部分正規表現が 3 文字すべてにマッチする。 \"I<(a*)*>\" "
"を \"bc\" にマッチさせると、正規表現全体も、 括弧で括られた部分正規表現も "
"null 文字列にマッチする。"

#. type: Plain text
#: build/C/man7/regex.7:230
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet.  When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, for example, \\(aqx\\(aq becomes \"I<[xX]>\".  When "
"it appears inside a bracket expression, all case counterparts of it are "
"added to the bracket expression, so that, for example, \"I<[x]>\" becomes "
"\"I<[xX]>\" and \"I<[\\(hax]>\" becomes \"I<[\\(haxX]>\"."
msgstr "マッチが大文字・小文字を無視するように指定されると、 アルファベット全体から大小文字の区別が無くなったかのような効果となる。 大文字・小文字を持つアルファベットがブラケット表現の外部で 通常の文字として現れると、 これは実効的に大小両方の文字のブラケット表現のように変換される。 すなわち \\(aqx\\(aq は \"I<[xX]>\" となる。ブラケット表現の内部に現れると、 大文字なら小文字が、小文字なら大文字がそのブラケット表現に加えられる。 すなわち \"I<[x]>\" は \"I<[xX]>\" に、\"I<[\\(hax]>\" は \"I<[\\(haxX]>\" になる。"

#. type: Plain text
#: build/C/man7/regex.7:236
msgid ""
"No particular limit is imposed on the length of REs\\*(dg.  Programs "
"intended to be portable should not employ REs longer than 256 bytes, as an "
"implementation can refuse to accept such REs and remain POSIX-compliant."
msgstr ""
"正規表現の長さには特に制限はない\\*(dg。 ただし移植性を高くしたいプログラムで"
"は、 256 バイトより長い正規表現は実行しないようにするほうが良い。 なぜなら、"
"そのような正規表現を拒否し、 しかも POSIX 互換を保つような実装が可能だからで"
"ある。"

#. type: Plain text
#: build/C/man7/regex.7:252
msgid ""
"Obsolete (\"basic\") regular expressions differ in several respects.  \\(aq|"
"\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq are ordinary characters and there is no "
"equivalent for their functionality.  The delimiters for bounds are \"I<\\e{>"
"\" and \"I<\\e}>\", with \\(aq{\\(aq and \\(aq}\\(aq by themselves ordinary "
"characters.  The parentheses for nested subexpressions are \"I<\\e(>\" and "
"\"I<\\e)>\", with \\(aq(\\(aq and \\(aq)\\(aq by themselves ordinary "
"characters.  \\(aq\\(ha\\(aq is an ordinary character except at the "
"beginning of the RE or\\*(dg the beginning of a parenthesized subexpression, "
"\\(aq$\\(aq is an ordinary character except at the end of the RE or\\*(dg "
"the end of a parenthesized subexpression, and \\(aq*\\(aq is an ordinary "
"character if it appears at the beginning of the RE or the beginning of a "
"parenthesized subexpression (after a possible leading \\(aq\\(ha\\(aq)."
msgstr "古い (\"基本\") 正規表現は、いくつかの点において異なる。 \\(aq|\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq は通常の文字となる。 対応する機能は存在しない。繰り返し指定の区切りは \"I<\\e{>\" および \"I<\\e}>\" となる。\\(aq{\\(aq と \\(aq}\\(aq は、 単独では通常の文字として扱われる。 部分正規表現をネストする括弧は \"I<\\e(>\" および \"I<\\e)>\" となり、 \\(aq(\\(aq と \\(aq)\\(aq は単独では通常の文字となる。 \\(aq\\(ha\\(aq は正規表現の先頭か、 括弧でくくられた部分表現の先頭\\*(dgを除いて通常の文字となる。 \\(aq$\\(aq は正規表現の末尾か、 括弧でくくられた部分正規表現の末尾\\*(dgを除いて通常の文字となる。 \\(aq*\\(aq は、正規表現の先頭か、 括弧でくくられた部分文字列の先頭に置かれた場合は通常の文字となる (\\(aq\\(ha\\(aq が前置されていてもよい)。"

#. type: Plain text
#: build/C/man7/regex.7:260
msgid ""
"Finally, there is one new type of atom, a I<back reference>: \\(aq\\e\\(aq "
"followed by a nonzero decimal digit I<d> matches the same sequence of "
"characters matched by the I<d>th parenthesized subexpression (numbering "
"subexpressions by the positions of their opening parentheses, left to "
"right), so that, for example, \"I<\\e([bc]\\e)\\e1>\" matches \"bb\" or \"cc"
"\" but not \"bc\"."
msgstr ""
"最後に、アトムとして別のタイプが存在する。 I<後方参照 (back reference)> であ"
"る。 \\(aq\\e\\(aq の後に 0 でない 10 進数値文字 I<d> が続くと、 括弧でくくら"
"れた部分正規表現の I<d> 番目にマッチした文字並びと同じものにマッチする。 (部"
"分正規表現の番号付けは、 開き括弧 `(' の位置が左のものから右のものへ向かって"
"なされる。)  したがって \"I<\\e([bc]\\e)\\e1>\" は \"bb\" または \"cc\" には"
"マッチするが、\"bc\" にはマッチしない。"

#. type: Plain text
#: build/C/man7/regex.7:262
msgid "Having two kinds of REs is a botch."
msgstr "正規表現が 2 種類あるのは格好悪い。"

#. type: Plain text
#: build/C/man7/regex.7:268
msgid ""
"The current POSIX.2 spec says that \\(aq)\\(aq is an ordinary character in "
"the absence of an unmatched \\(aq(\\(aq; this was an unintentional result of "
"a wording error, and change is likely.  Avoid relying on it."
msgstr ""
"現在の POSIX.2 規格においては、\\(aq)\\(aq は、 対応する \\(aq(\\(aq がない場"
"合には通常の文字として扱われることになっている。 しかしこれは、本来の意図とは"
"異なる記述上のエラーであり、 修正される可能性が高い。これに依存したコードは使"
"わないこと。"

#. type: Plain text
#: build/C/man7/regex.7:275
msgid ""
"Back references are a dreadful botch, posing major problems for efficient "
"implementations.  They are also somewhat vaguely defined (does \"I<a\\e(\\e(b"
"\\e)*\\e2\\e)*d>\" match \"abbbd\"?).  Avoid using them."
msgstr ""
"後方参照はひどく出来の悪い代物である。 効率の良い実装をするのはとても難し"
"い。 また定義があいまいである。 (\"I<a\\e(\\e(b\\e)*\\e2\\e)*d>\" は \"abbbd"
"\" にマッチすると思うか？)  使わないほうが良い。"

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  The syntax for word boundaries is incredibly ugly.
#. type: Plain text
#: build/C/man7/regex.7:283
msgid ""
"POSIX.2's specification of case-independent matching is vague.  The \"one "
"case implies all cases\" definition given above is current consensus among "
"implementors as to the right interpretation."
msgstr ""
"POSIX.2 の規格では、case (大文字か小文字か)  に依存しないマッチの記述があいま"
"いである。 現在のところでは「一つの case がすべての case を意味する」 という"
"上記の定義が正しい解釈であるというのが、 実装者の間での共通認識のようである。"

#. type: SH
#: build/C/man7/regex.7:283
#, no-wrap
msgid "AUTHOR"
msgstr "著者"

#.  Sigh... The page license means we must have the author's name
#.  in the formatted output.
#. type: Plain text
#: build/C/man7/regex.7:287
msgid "This page was taken from Henry Spencer's regex package."
msgstr "このページは Henry Spencer の regex パッケージから採録したものである。"

#. type: Plain text
#: build/C/man7/regex.7:290
msgid "B<grep>(1), B<regex>(3)"
msgstr "B<grep>(1), B<regex>(3)"

#. type: Plain text
#: build/C/man7/regex.7:292
msgid "POSIX.2, section 2.8 (Regular Expression Notation)."
msgstr "POSIX.2, section 2.8 (Regular Expression Notation)."

#. type: TH
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "WORDEXP"
msgstr "WORDEXP"

#. type: TH
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man3/wordexp.3:27
msgid "wordexp, wordfree - perform word expansion like a posix-shell"
msgstr "wordexp, wordfree - posix シェルのように単語の展開を行う"

#. type: Plain text
#: build/C/man3/wordexp.3:29
msgid "B<#include E<lt>wordexp.hE<gt>>"
msgstr "B<#include E<lt>wordexp.hE<gt>>"

#. type: Plain text
#: build/C/man3/wordexp.3:31
msgid ""
"B<int wordexp(const char *>I<s>B<, wordexp_t *>I<p>B<, int >I<flags>B<);>"
msgstr ""
"B<int wordexp(const char *>I<s>B<, wordexp_t *>I<p>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man3/wordexp.3:33
msgid "B<void wordfree(wordexp_t *>I<p>B<);>"
msgstr "B<void wordfree(wordexp_t *>I<p>B<);>"

#. type: Plain text
#: build/C/man3/wordexp.3:37
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/wordexp.3:42
msgid "B<wordexp>(), B<wordfree>(): _XOPEN_SOURCE"
msgstr "B<wordexp>(), B<wordfree>(): _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/wordexp.3:76
msgid ""
"The function B<wordexp>()  performs a shell-like expansion of the string "
"I<s> and returns the result in the structure pointed to by I<p>.  The data "
"type I<wordexp_t> is a structure that at least has the fields I<we_wordc>, "
"I<we_wordv>, and I<we_offs>.  The field I<we_wordc> is a I<size_t> that "
"gives the number of words in the expansion of I<s>.  The field I<we_wordv> "
"is a I<char\\ **> that points to the array of words found.  The field "
"I<we_offs> of type I<size_t> is sometimes (depending on I<flags>, see below) "
"used to indicate the number of initial elements in the I<we_wordv> array "
"that should be filled with NULLs."
msgstr ""
"関数 B<wordexp>()  はシェルのように文字列 I<s> を展開し、 I<p> で指し示す構造"
"体に結果を返す。 データ型 I<wordexp_t> は少なくともフィールド I<we_wordc>, "
"I<we_wordv>, I<we_offs> を持つ構造体である。 フィールド I<we_wordc> は "
"I<size_t> であり、 I<s> を展開した結果に単語がいくつあるかを表す。 フィール"
"ド I<we_wordv> は I<char\\ **> であり、見つかった単語の配列を指し示す。 "
"I<size_t> 型のフィールド I<we_offs> は、 I<we_wordv> 配列にある初期要素のうち"
"いくつが NULL で埋められるべきかを表すのに使われたりする (I<flags> により決定"
"される。下記を参照。)。"

#. type: Plain text
#: build/C/man3/wordexp.3:84
msgid ""
"The function B<wordfree>()  frees the allocated memory again.  More "
"precisely, it does not free its argument, but it frees the array I<we_wordv> "
"and the strings that points to."
msgstr ""
"関数 B<wordfree>()  は割り当てたメモリーを再度解放する。 より正確にいうと、こ"
"の関数はその引き数を解放するのではなく、 配列 I<we_wordv> とそれが指し示す文"
"字列を解放する。"

#. type: SS
#: build/C/man3/wordexp.3:84
#, no-wrap
msgid "The string argument"
msgstr "文字列引き数"

#. type: Plain text
#: build/C/man3/wordexp.3:94
msgid ""
"Since the expansion is the same as the expansion by the shell (see "
"B<sh>(1))  of the parameters to a command, the string I<s> must not contain "
"characters that would be illegal in shell command parameters.  In "
"particular, there must not be any unescaped newline or |, &, ;, E<lt>, "
"E<gt>, (, ), {, } characters outside a command substitution or parameter "
"substitution context."
msgstr ""
"この展開はシェルによるコマンドのパラメーターの展開 (B<sh>(1)  を参照) と同じ"
"であるので、文字列 I<s> はシェルコマンドパラメーターで不正とされる文字を含ん"
"ではならない。 特にエスケープされていない改行、|, &, ;, E<lt>, E<gt>, (, ), "
"{, } 文字を コマンド置換やパラメーター置換の場面以外に含めてはならない。"

#. type: Plain text
#: build/C/man3/wordexp.3:100
msgid ""
"If the argument I<s> contains a word that starts with an unquoted comment "
"character #, then it is unspecified whether that word and all following "
"words are ignored, or the # is treated as a non-comment character."
msgstr ""
"引き数 I<s> にクォートしていないコメント文字 # で始まる単語が含まれている場合"
"には、 その単語とそれ以降の単語が無視されるか、 それとも # がコメント文字とし"
"て扱わないかは、規定されていない。"

#. type: SS
#: build/C/man3/wordexp.3:100
#, no-wrap
msgid "The expansion"
msgstr "展開"

#. type: Plain text
#: build/C/man3/wordexp.3:107
msgid ""
"The expansion done consists of the following stages: tilde expansion "
"(replacing \\(tiuser by user's home directory), variable substitution "
"(replacing $FOO by the value of the environment variable FOO), command "
"substitution (replacing $(command) or \\`command\\` by the output of "
"command), arithmetic expansion, field splitting, wildcard expansion, quote "
"removal."
msgstr "実行される展開は、以下の段階で構成される: チルダ展開 (\\(tiuser を user のホームディレクトリに置き換える)、 変数展開 ($FOO を環境変数 FOO の値に置き換える)、 コマンド展開 ($(command) または \\`command\\` を command の出力で置き換える)、 算術展開、フィールド分割、ワイルドカード展開、クォートの除去。"

#. type: Plain text
#: build/C/man3/wordexp.3:110
msgid ""
"The result of expansion of special parameters ($@, $*, $#, $?, $-, $$, $!, "
"$0) is unspecified."
msgstr ""
"特殊なパラメーター ($@, $*, $#, $?, $-, $$, $!, $0) の 展開結果は規定されてい"
"ない。"

#. type: Plain text
#: build/C/man3/wordexp.3:113
msgid ""
"Field splitting is done using the environment variable $IFS.  If it is not "
"set, the field separators are space, tab and newline."
msgstr ""
"フィールド分割は環境変数 $IFS を用いて行われる。 この環境変数が設定されていな"
"い場合、 フィールド区切り文字はスペース・タブ・改行である。"

#. type: SS
#: build/C/man3/wordexp.3:113
#, no-wrap
msgid "The output array"
msgstr "出力される配列"

#. type: Plain text
#: build/C/man3/wordexp.3:117
msgid "The array I<we_wordv> contains the words found, followed by a NULL."
msgstr "配列 I<we_wordv> は見つかった単語をを含み、最後に NULL が続く。"

#. type: SS
#: build/C/man3/wordexp.3:117
#, no-wrap
msgid "The flags argument"
msgstr "flags 引き数"

#. type: Plain text
#: build/C/man3/wordexp.3:121
msgid "The I<flag> argument is a bitwise inclusive OR of the following values:"
msgstr "I<flags> 引き数は以下の値のビット包含的 OR である:"

#. type: TP
#: build/C/man3/wordexp.3:121
#, no-wrap
msgid "B<WRDE_APPEND>"
msgstr "B<WRDE_APPEND>"

#. type: Plain text
#: build/C/man3/wordexp.3:124
msgid "Append the words found to the array resulting from a previous call."
msgstr "見つかった単語を前回の呼び出し結果の配列に追加する。"

#. type: TP
#: build/C/man3/wordexp.3:124
#, no-wrap
msgid "B<WRDE_DOOFFS>"
msgstr "B<WRDE_DOOFFS>"

#. type: Plain text
#: build/C/man3/wordexp.3:132
msgid ""
"Insert I<we_offs> initial NULLs in the array I<we_wordv>.  (These are not "
"counted in the returned I<we_wordc>.)"
msgstr ""
"初期状態である I<we_offs> 個の NULL を配列 I<we_wordv> に挿入する (これらは返"
"される I<we_wordc> にはカウントされない)。"

#. type: TP
#: build/C/man3/wordexp.3:132
#, no-wrap
msgid "B<WRDE_NOCMD>"
msgstr "B<WRDE_NOCMD>"

#. type: Plain text
#: build/C/man3/wordexp.3:135
msgid "Don't do command substitution."
msgstr "コマンド置換を行わない。"

#. type: TP
#: build/C/man3/wordexp.3:135
#, no-wrap
msgid "B<WRDE_REUSE>"
msgstr "B<WRDE_REUSE>"

#. type: Plain text
#: build/C/man3/wordexp.3:145
msgid ""
"The argument I<p> resulted from a previous call to B<wordexp>(), and "
"B<wordfree>()  was not called.  Reuse the allocated storage."
msgstr ""
"引き数 I<p> は前回の B<wordexp>()  の呼び出し結果であり、 B<wordfree>()  が "
"(まだ) 呼び出されない。 割り当てられた領域を再利用する。"

#. type: TP
#: build/C/man3/wordexp.3:145
#, no-wrap
msgid "B<WRDE_SHOWERR>"
msgstr "B<WRDE_SHOWERR>"

#. type: Plain text
#: build/C/man3/wordexp.3:154
msgid ""
"Normally during command substitution I<stderr> is redirected to I</dev/"
"null>.  This flag specifies that I<stderr> is not to be redirected."
msgstr ""
"通常はコマンド置換のときに I<stderr> が I</dev/null> にリダイレクトされる。 "
"このフラグは I<stderr> をリダイレクトしないように指定する。"

#. type: TP
#: build/C/man3/wordexp.3:154
#, no-wrap
msgid "B<WRDE_UNDEF>"
msgstr "B<WRDE_UNDEF>"

#. type: Plain text
#: build/C/man3/wordexp.3:157
msgid "Consider it an error if an undefined shell variable is expanded."
msgstr "未定義のシェル変数を展開しようとした場合に、エラーとして扱う。"

#. type: Plain text
#: build/C/man3/wordexp.3:161
msgid ""
"In case of success 0 is returned.  In case of error one of the following "
"five values is returned."
msgstr ""
"成功した場合は 0 が返される。 エラーの場合は以下の 5 つの値のうちの 1 つが返"
"される。"

#. type: TP
#: build/C/man3/wordexp.3:161
#, no-wrap
msgid "B<WRDE_BADCHAR>"
msgstr "B<WRDE_BADCHAR>"

#. type: Plain text
#: build/C/man3/wordexp.3:164
msgid ""
"Illegal occurrence of newline or one of |, &, ;, E<lt>, E<gt>, (, ), {, }."
msgstr ""
"改行または |, &, ;, E<lt>, E<gt>, (, ), {, } のうちの 1 つが不正に出現した。"

#. type: TP
#: build/C/man3/wordexp.3:164
#, no-wrap
msgid "B<WRDE_BADVAL>"
msgstr "B<WRDE_BADVAL>"

#. type: Plain text
#: build/C/man3/wordexp.3:170
msgid ""
"An undefined shell variable was referenced, and the B<WRDE_UNDEF> flag told "
"us to consider this an error."
msgstr ""
"未定義のシェル変数が参照され、かつ B<WRDE_UNDEF> フラグでこれをエラーとして扱"
"うように指示されている。"

#. type: TP
#: build/C/man3/wordexp.3:170
#, no-wrap
msgid "B<WRDE_CMDSUB>"
msgstr "B<WRDE_CMDSUB>"

#. type: Plain text
#: build/C/man3/wordexp.3:175
msgid ""
"Command substitution requested, but the B<WRDE_NOCMD> flag told us to "
"consider this an error."
msgstr ""
"コマンド置換が要求されたが、 B<WRDE_NOCMD> フラグでこれをエラーとして扱うよう"
"に指示されていた。"

#. type: TP
#: build/C/man3/wordexp.3:175
#, no-wrap
msgid "B<WRDE_NOSPACE>"
msgstr "B<WRDE_NOSPACE>"

#. type: Plain text
#: build/C/man3/wordexp.3:178
msgid "Out of memory."
msgstr "メモリーが足りない。"

#. type: TP
#: build/C/man3/wordexp.3:178
#, no-wrap
msgid "B<WRDE_SYNTAX>"
msgstr "B<WRDE_SYNTAX>"

#. type: Plain text
#: build/C/man3/wordexp.3:182
msgid "Shell syntax error, such as unbalanced parentheses or unmatched quotes."
msgstr ""
"対応する括弧がない、クォートが合致しないといった、 シェルの書式エラー。"

#. type: SH
#: build/C/man3/wordexp.3:182
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/wordexp.3:187
msgid ""
"B<wordexp>()  and B<wordfree>()  are provided in glibc since version 2.1."
msgstr ""
"B<wordexp>()  と B<wordfree>()  は、バージョン 2.1 以降の glibc で提供されて"
"いる。"

#. type: tbl table
#: build/C/man3/wordexp.3:197
#, no-wrap
msgid "B<wordexp>()"
msgstr "B<wordexp>()"

#. type: tbl table
#: build/C/man3/wordexp.3:199
#, no-wrap
msgid "MT-Unsafe race:utent const:env\n"
msgstr "MT-Unsafe race:utent const:env\n"

#. type: tbl table
#: build/C/man3/wordexp.3:201
#, no-wrap
msgid "env sig:ALRM timer locale"
msgstr "env sig:ALRM timer locale"

#. type: tbl table
#: build/C/man3/wordexp.3:204
#, no-wrap
msgid "B<wordfree>()"
msgstr "B<wordfree>()"

#. type: Plain text
#: build/C/man3/wordexp.3:221
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<wordexp>()  calls those functions, so we use race:utent to remind users."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:226
msgid ""
"The output of the following example program is approximately that of \"ls [a-"
"c]*.c\"."
msgstr ""
"以下のサンプルプログラムの出力はだいたい \"ls [a-c]*.c\" と同じになる。"

#. type: Plain text
#: build/C/man3/wordexp.3:231
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>wordexp.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>wordexp.hE<gt>\n"

#. type: Plain text
#: build/C/man3/wordexp.3:237
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    wordexp_t p;\n"
"    char **w;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    wordexp_t p;\n"
"    char **w;\n"

#. type: Plain text
#: build/C/man3/wordexp.3:245
#, no-wrap
msgid ""
"    wordexp(\"[a-c]*.c\", &p, 0);\n"
"    w = p.we_wordv;\n"
"    for (int i = 0; i E<lt> p.we_wordc; i++)\n"
"        printf(\"%s\\en\", w[i]);\n"
"    wordfree(&p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    wordexp(\"[a-c]*.c\", &p, 0);\n"
"    w = p.we_wordv;\n"
"    for (int i = 0; i E<lt> p.we_wordc; i++)\n"
"        printf(\"%s\\en\", w[i]);\n"
"    wordfree(&p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/wordexp.3:249
msgid "B<fnmatch>(3), B<glob>(3)"
msgstr "B<fnmatch>(3), B<glob>(3)"
