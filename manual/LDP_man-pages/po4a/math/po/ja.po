# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-03-22 01:05+0900\n"
"PO-Revision-Date: 2013-03-26 11:54+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/INFINITY.3:25
#, no-wrap
msgid "INFINITY"
msgstr "INFINITY"

#. type: TH
#: build/C/man3/INFINITY.3:25
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: TH
#: build/C/man3/INFINITY.3:25 build/C/man3/abs.3:34 build/C/man3/acos.3:35
#: build/C/man3/acosh.3:35 build/C/man3/asin.3:35 build/C/man3/asinh.3:35
#: build/C/man3/atan.3:35 build/C/man3/atan2.3:35 build/C/man3/atanh.3:35
#: build/C/man3/cbrt.3:30 build/C/man3/ceil.3:27 build/C/man3/copysign.3:31
#: build/C/man3/cos.3:34 build/C/man3/cosh.3:36 build/C/man3/div.3:34
#: build/C/man3/erf.3:35 build/C/man3/erfc.3:26 build/C/man3/exp.3:36
#: build/C/man3/exp10.3:35 build/C/man3/exp2.3:36 build/C/man3/expm1.3:30
#: build/C/man3/fabs.3:32 build/C/man3/fdim.3:9 build/C/man3/fenv.3:27
#: build/C/man3/finite.3:25 build/C/man3/floor.3:27 build/C/man3/fma.3:12
#: build/C/man3/fmax.3:9 build/C/man3/fmin.3:9 build/C/man3/fmod.3:35
#: build/C/man3/fpclassify.3:10 build/C/man3/frexp.3:33 build/C/man3/gamma.3:9
#: build/C/man3/hypot.3:33 build/C/man3/ilogb.3:29 build/C/man3/infnan.3:33
#: build/C/man3/isgreater.3:10 build/C/man3/j0.3:36 build/C/man3/ldexp.3:34
#: build/C/man3/lgamma.3:11 build/C/man3/log.3:36 build/C/man3/log10.3:36
#: build/C/man3/log1p.3:29 build/C/man3/log2.3:36 build/C/man3/logb.3:29
#: build/C/man3/lrint.3:27 build/C/man3/lround.3:27
#: build/C/man7/math_error.7:26 build/C/man3/matherr.3:27
#: build/C/man3/modf.3:33 build/C/man3/nan.3:11 build/C/man3/nextafter.3:11
#: build/C/man3/pow.3:35 build/C/man3/pow10.3:25 build/C/man3/remainder.3:37
#: build/C/man3/remquo.3:12 build/C/man3/rint.3:27 build/C/man3/round.3:27
#: build/C/man3/scalb.3:27 build/C/man3/scalbln.3:27 build/C/man3/signbit.3:11
#: build/C/man3/significand.3:9 build/C/man3/sin.3:35 build/C/man3/sincos.3:9
#: build/C/man3/sinh.3:36 build/C/man3/sqrt.3:34 build/C/man3/tan.3:35
#: build/C/man3/tanh.3:35 build/C/man3/tgamma.3:13 build/C/man3/trunc.3:25
#: build/C/man3/y0.3:36
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/INFINITY.3:26 build/C/man3/abs.3:35 build/C/man3/acos.3:36
#: build/C/man3/acosh.3:36 build/C/man3/asin.3:36 build/C/man3/asinh.3:36
#: build/C/man3/atan.3:36 build/C/man3/atan2.3:36 build/C/man3/atanh.3:36
#: build/C/man3/cbrt.3:31 build/C/man3/ceil.3:28 build/C/man3/copysign.3:32
#: build/C/man3/cos.3:35 build/C/man3/cosh.3:37 build/C/man3/div.3:35
#: build/C/man3/erf.3:36 build/C/man3/erfc.3:27 build/C/man3/exp.3:37
#: build/C/man3/exp10.3:36 build/C/man3/exp2.3:37 build/C/man3/expm1.3:31
#: build/C/man3/fabs.3:33 build/C/man3/fdim.3:10 build/C/man3/fenv.3:28
#: build/C/man3/finite.3:26 build/C/man3/floor.3:28 build/C/man3/fma.3:13
#: build/C/man3/fmax.3:10 build/C/man3/fmin.3:10 build/C/man3/fmod.3:36
#: build/C/man3/fpclassify.3:11 build/C/man3/frexp.3:34
#: build/C/man3/gamma.3:10 build/C/man3/hypot.3:34 build/C/man3/ilogb.3:30
#: build/C/man3/infnan.3:34 build/C/man3/isgreater.3:11 build/C/man3/j0.3:37
#: build/C/man3/ldexp.3:35 build/C/man3/lgamma.3:12 build/C/man3/log.3:37
#: build/C/man3/log10.3:37 build/C/man3/log1p.3:30 build/C/man3/log2.3:37
#: build/C/man3/logb.3:30 build/C/man3/lrint.3:28 build/C/man3/lround.3:28
#: build/C/man7/math_error.7:27 build/C/man3/matherr.3:28
#: build/C/man3/modf.3:34 build/C/man3/nan.3:12 build/C/man3/nextafter.3:12
#: build/C/man3/pow.3:36 build/C/man3/pow10.3:26 build/C/man3/remainder.3:38
#: build/C/man3/remquo.3:13 build/C/man3/rint.3:28 build/C/man3/round.3:28
#: build/C/man3/scalb.3:28 build/C/man3/scalbln.3:28 build/C/man3/signbit.3:12
#: build/C/man3/significand.3:10 build/C/man3/sin.3:36
#: build/C/man3/sincos.3:10 build/C/man3/sinh.3:37 build/C/man3/sqrt.3:35
#: build/C/man3/tan.3:36 build/C/man3/tanh.3:36 build/C/man3/tgamma.3:14
#: build/C/man3/trunc.3:26 build/C/man3/y0.3:37
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/INFINITY.3:28
msgid ""
"INFINITY, NAN, HUGE_VAL, HUGE_VALF, HUGE_VALL - floating-point constants"
msgstr "INFINITY, NAN, HUGE_VAL, HUGE_VALF, HUGE_VALL - 浮動小数点数の定数"

#. type: SH
#: build/C/man3/INFINITY.3:28 build/C/man3/abs.3:37 build/C/man3/acos.3:38
#: build/C/man3/acosh.3:38 build/C/man3/asin.3:38 build/C/man3/asinh.3:38
#: build/C/man3/atan.3:38 build/C/man3/atan2.3:38 build/C/man3/atanh.3:38
#: build/C/man3/cbrt.3:33 build/C/man3/ceil.3:31 build/C/man3/copysign.3:34
#: build/C/man3/cos.3:37 build/C/man3/cosh.3:39 build/C/man3/div.3:38
#: build/C/man3/erf.3:38 build/C/man3/erfc.3:29 build/C/man3/exp.3:39
#: build/C/man3/exp10.3:38 build/C/man3/exp2.3:39 build/C/man3/expm1.3:33
#: build/C/man3/fabs.3:35 build/C/man3/fdim.3:12 build/C/man3/fenv.3:33
#: build/C/man3/finite.3:29 build/C/man3/floor.3:30 build/C/man3/fma.3:15
#: build/C/man3/fmax.3:12 build/C/man3/fmin.3:12 build/C/man3/fmod.3:38
#: build/C/man3/fpclassify.3:14 build/C/man3/frexp.3:37
#: build/C/man3/gamma.3:12 build/C/man3/hypot.3:36 build/C/man3/ilogb.3:32
#: build/C/man3/infnan.3:36 build/C/man3/isgreater.3:14 build/C/man3/j0.3:40
#: build/C/man3/ldexp.3:37 build/C/man3/lgamma.3:15 build/C/man3/log.3:39
#: build/C/man3/log10.3:39 build/C/man3/log1p.3:32 build/C/man3/log2.3:39
#: build/C/man3/logb.3:32 build/C/man3/lrint.3:30 build/C/man3/lround.3:31
#: build/C/man7/math_error.7:29 build/C/man3/matherr.3:30
#: build/C/man3/modf.3:37 build/C/man3/nan.3:14 build/C/man3/nextafter.3:15
#: build/C/man3/pow.3:38 build/C/man3/pow10.3:28 build/C/man3/remainder.3:41
#: build/C/man3/remquo.3:15 build/C/man3/rint.3:31 build/C/man3/round.3:30
#: build/C/man3/scalb.3:31 build/C/man3/scalbln.3:31 build/C/man3/signbit.3:14
#: build/C/man3/significand.3:13 build/C/man3/sin.3:38
#: build/C/man3/sincos.3:12 build/C/man3/sinh.3:39 build/C/man3/sqrt.3:37
#: build/C/man3/tan.3:38 build/C/man3/tanh.3:38 build/C/man3/tgamma.3:16
#: build/C/man3/trunc.3:28 build/C/man3/y0.3:40
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/INFINITY.3:31
#, no-wrap
msgid "B<#define _ISOC99_SOURCE>      /* See feature_test_macros(7) */\n"
msgstr "B<#define _ISOC99_SOURCE>      /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/INFINITY.3:33 build/C/man3/acos.3:41 build/C/man3/acosh.3:41
#: build/C/man3/asin.3:41 build/C/man3/asinh.3:41 build/C/man3/atan.3:41
#: build/C/man3/atan2.3:41 build/C/man3/atanh.3:41 build/C/man3/cbrt.3:36
#: build/C/man3/ceil.3:34 build/C/man3/copysign.3:37 build/C/man3/cos.3:40
#: build/C/man3/cosh.3:42 build/C/man3/erf.3:41 build/C/man3/erfc.3:32
#: build/C/man3/exp.3:42 build/C/man3/exp10.3:43 build/C/man3/exp2.3:42
#: build/C/man3/expm1.3:36 build/C/man3/fabs.3:38 build/C/man3/finite.3:32
#: build/C/man3/floor.3:33 build/C/man3/fma.3:18 build/C/man3/fmod.3:41
#: build/C/man3/fpclassify.3:17 build/C/man3/frexp.3:40
#: build/C/man3/hypot.3:39 build/C/man3/infnan.3:39
#: build/C/man3/isgreater.3:17 build/C/man3/j0.3:43 build/C/man3/ldexp.3:40
#: build/C/man3/lgamma.3:18 build/C/man3/log.3:42 build/C/man3/log10.3:42
#: build/C/man3/log1p.3:35 build/C/man3/log2.3:42 build/C/man3/lrint.3:33
#: build/C/man3/lround.3:34 build/C/man3/modf.3:40 build/C/man3/pow.3:41
#: build/C/man3/remainder.3:44 build/C/man3/remquo.3:18 build/C/man3/rint.3:34
#: build/C/man3/round.3:33 build/C/man3/sin.3:41 build/C/man3/sinh.3:42
#: build/C/man3/sqrt.3:40 build/C/man3/tan.3:41 build/C/man3/tanh.3:41
#: build/C/man3/trunc.3:31 build/C/man3/y0.3:43
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/INFINITY.3:35
#, no-wrap
msgid "B<INFINITY>\n"
msgstr "B<INFINITY>\n"

#. type: Plain text
#: build/C/man3/INFINITY.3:37
#, no-wrap
msgid "B<NAN>\n"
msgstr "B<NAN>\n"

#. type: Plain text
#: build/C/man3/INFINITY.3:39
#, no-wrap
msgid "B<HUGE_VAL>\n"
msgstr "B<HUGE_VAL>\n"

#. type: Plain text
#: build/C/man3/INFINITY.3:41
#, no-wrap
msgid "B<HUGE_VALF>\n"
msgstr "B<HUGE_VALF>\n"

#. type: Plain text
#: build/C/man3/INFINITY.3:43
#, no-wrap
msgid "B<HUGE_VALL>\n"
msgstr "B<HUGE_VALL>\n"

#. type: SH
#: build/C/man3/INFINITY.3:44 build/C/man3/abs.3:67 build/C/man3/acos.3:65
#: build/C/man3/acosh.3:77 build/C/man3/asin.3:67 build/C/man3/asinh.3:77
#: build/C/man3/atan.3:67 build/C/man3/atan2.3:65 build/C/man3/atanh.3:77
#: build/C/man3/cbrt.3:72 build/C/man3/ceil.3:60 build/C/man3/copysign.3:64
#: build/C/man3/cos.3:66 build/C/man3/cosh.3:68 build/C/man3/div.3:68
#: build/C/man3/erf.3:74 build/C/man3/erfc.3:65 build/C/man3/exp.3:68
#: build/C/man3/exp10.3:52 build/C/man3/exp2.3:68 build/C/man3/expm1.3:72
#: build/C/man3/fabs.3:64 build/C/man3/fdim.3:39 build/C/man3/fenv.3:61
#: build/C/man3/finite.3:90 build/C/man3/floor.3:59 build/C/man3/fma.3:45
#: build/C/man3/fmax.3:40 build/C/man3/fmin.3:40 build/C/man3/fmod.3:67
#: build/C/man3/fpclassify.3:66 build/C/man3/frexp.3:66
#: build/C/man3/gamma.3:40 build/C/man3/hypot.3:74 build/C/man3/ilogb.3:70
#: build/C/man3/infnan.3:44 build/C/man3/isgreater.3:48 build/C/man3/j0.3:89
#: build/C/man3/ldexp.3:66 build/C/man3/lgamma.3:71 build/C/man3/log.3:68
#: build/C/man3/log10.3:68 build/C/man3/log1p.3:71 build/C/man3/log2.3:68
#: build/C/man3/logb.3:69 build/C/man3/lrint.3:64 build/C/man3/lround.3:65
#: build/C/man7/math_error.7:35 build/C/man3/matherr.3:41
#: build/C/man3/modf.3:66 build/C/man3/nan.3:42 build/C/man3/nextafter.3:70
#: build/C/man3/pow.3:67 build/C/man3/pow10.3:41 build/C/man3/remainder.3:92
#: build/C/man3/remquo.3:45 build/C/man3/rint.3:86 build/C/man3/round.3:60
#: build/C/man3/scalb.3:60 build/C/man3/scalbln.3:76 build/C/man3/signbit.3:36
#: build/C/man3/significand.3:37 build/C/man3/sin.3:67
#: build/C/man3/sincos.3:25 build/C/man3/sinh.3:68 build/C/man3/sqrt.3:66
#: build/C/man3/tan.3:67 build/C/man3/tanh.3:67 build/C/man3/tgamma.3:44
#: build/C/man3/trunc.3:58 build/C/man3/y0.3:89
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/INFINITY.3:48
msgid ""
"The macro B<INFINITY> expands to a I<float> constant representing positive "
"infinity."
msgstr "マクロ B<INFINITY> は正の無限大を表す I<float> 型の定数に展開される。"

#. type: Plain text
#: build/C/man3/INFINITY.3:61
msgid ""
"The macro B<NAN> expands to a I<float> constant representing a quiet NaN "
"(when supported).  A I<quiet> NaN is a NaN (\"not-a-number\") that does not "
"raise exceptions when it is used in arithmetic.  The opposite is a "
"I<signaling> NaN.  See IEC 60559:1989."
msgstr ""
"(サポートされている場合) マクロ B<NAN> は quiet NaN を表す I<float> 型の定数"
"に展開される。 I<quiet> NaN は計算式の中で使われたときに例外を起こさない NaN "
"(\"not-a-number\") である。 この反対は I<signalling> NaN である。 IEC "
"60559:1989 を参照すること。"

#. type: Plain text
#: build/C/man3/INFINITY.3:69
msgid ""
"The macros B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> expand to constants of "
"types I<double>, I<float> and I<long double>, respectively, that represent a "
"large positive value, possibly plus infinity."
msgstr ""
"マクロ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> はそれぞれ I<double>, "
"I<float>, I<long double> 型の定数で、 大きな正の値を表し、可能な場合には正の"
"無限大を表す。"

#. type: SH
#: build/C/man3/INFINITY.3:69 build/C/man3/abs.3:82 build/C/man3/acos.3:110
#: build/C/man3/acosh.3:118 build/C/man3/asin.3:109 build/C/man3/asinh.3:103
#: build/C/man3/atan.3:94 build/C/man3/atan2.3:166 build/C/man3/atanh.3:137
#: build/C/man3/cbrt.3:89 build/C/man3/ceil.3:78 build/C/man3/copysign.3:85
#: build/C/man3/cos.3:100 build/C/man3/cosh.3:117 build/C/man3/div.3:91
#: build/C/man3/erf.3:124 build/C/man3/erfc.3:122 build/C/man3/exp.3:127
#: build/C/man3/exp10.3:76 build/C/man3/exp2.3:90 build/C/man3/expm1.3:134
#: build/C/man3/fabs.3:86 build/C/man3/fdim.3:81 build/C/man3/fenv.3:265
#: build/C/man3/floor.3:77 build/C/man3/fma.3:156 build/C/man3/fmax.3:58
#: build/C/man3/fmin.3:58 build/C/man3/fmod.3:132
#: build/C/man3/fpclassify.3:118 build/C/man3/frexp.3:98
#: build/C/man3/gamma.3:65 build/C/man3/hypot.3:158 build/C/man3/ilogb.3:146
#: build/C/man3/infnan.3:71 build/C/man3/isgreater.3:95 build/C/man3/j0.3:146
#: build/C/man3/ldexp.3:129 build/C/man3/lgamma.3:154 build/C/man3/log.3:127
#: build/C/man3/log10.3:88 build/C/man3/log1p.3:140 build/C/man3/log2.3:90
#: build/C/man3/logb.3:143 build/C/man3/lrint.3:109 build/C/man3/lround.3:112
#: build/C/man3/modf.3:90 build/C/man3/nan.3:75 build/C/man3/nextafter.3:168
#: build/C/man3/pow.3:313 build/C/man3/pow10.3:48 build/C/man3/remainder.3:180
#: build/C/man3/remquo.3:124 build/C/man3/rint.3:113 build/C/man3/round.3:83
#: build/C/man3/scalb.3:172 build/C/man3/scalbln.3:155
#: build/C/man3/signbit.3:61 build/C/man3/significand.3:51
#: build/C/man3/sin.3:104 build/C/man3/sincos.3:75 build/C/man3/sinh.3:122
#: build/C/man3/sqrt.3:106 build/C/man3/tan.3:129 build/C/man3/tanh.3:98
#: build/C/man3/tgamma.3:158 build/C/man3/trunc.3:69 build/C/man3/y0.3:217
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/INFINITY.3:71
msgid "C99."
msgstr "C99."

#. type: SH
#: build/C/man3/INFINITY.3:71
#, no-wrap
msgid "AVAILABILITY"
msgstr "可用性"

#. type: Plain text
#: build/C/man3/INFINITY.3:93
msgid ""
"On a glibc system, the macro B<HUGE_VAL> is always available.  Availability "
"of the B<NAN> macro can be tested using B<#ifdef NAN>, and similarly for "
"B<INFINITY>, B<HUGE_VALF>, B<HUGE_VALL>.  They will be defined by "
"I<E<lt>math.hE<gt>> if B<_ISOC99_SOURCE> or B<_GNU_SOURCE> is defined, or "
"B<__STDC_VERSION__> is defined and has a value not less than 199901L."
msgstr ""
"glibc システムではマクロ B<HUGE_VAL> が常に使用可能である。 B<NAN> マクロが使"
"用できるかは、 B<#ifdef NAN> を使ってテストできる。 B<INFINITY>, "
"B<HUGE_VALF>, B<HUGE_VALL> も同様である。 B<_ISOC99_SOURCE> か "
"B<_GNU_SOURCE> が定義されている場合、 または B<__STDC_VERSION__> が定義されて"
"いて、その値が 199901L 以上である場合、 これらのマクロは I<E<lt>math.hE<gt>> "
"で定義される。"

#. type: SH
#: build/C/man3/INFINITY.3:93 build/C/man3/abs.3:126 build/C/man3/acos.3:116
#: build/C/man3/acosh.3:124 build/C/man3/asin.3:115 build/C/man3/asinh.3:109
#: build/C/man3/atan.3:100 build/C/man3/atan2.3:172 build/C/man3/atanh.3:154
#: build/C/man3/cbrt.3:93 build/C/man3/ceil.3:109 build/C/man3/copysign.3:95
#: build/C/man3/cos.3:113 build/C/man3/cosh.3:128 build/C/man3/div.3:106
#: build/C/man3/erf.3:130 build/C/man3/erfc.3:135 build/C/man3/exp.3:133
#: build/C/man3/exp10.3:78 build/C/man3/exp2.3:96 build/C/man3/expm1.3:168
#: build/C/man3/fabs.3:92 build/C/man3/fdim.3:83 build/C/man3/fenv.3:323
#: build/C/man3/finite.3:125 build/C/man3/floor.3:99 build/C/man3/fma.3:158
#: build/C/man3/fmax.3:60 build/C/man3/fmin.3:60 build/C/man3/fmod.3:146
#: build/C/man3/fpclassify.3:132 build/C/man3/frexp.3:137
#: build/C/man3/gamma.3:97 build/C/man3/hypot.3:164 build/C/man3/ilogb.3:148
#: build/C/man3/isgreater.3:102 build/C/man3/j0.3:159 build/C/man3/ldexp.3:135
#: build/C/man3/lgamma.3:173 build/C/man3/log.3:140 build/C/man3/log10.3:94
#: build/C/man3/log1p.3:143 build/C/man3/log2.3:96 build/C/man3/logb.3:145
#: build/C/man3/lrint.3:111 build/C/man3/lround.3:114
#: build/C/man7/math_error.7:256 build/C/man3/matherr.3:425
#: build/C/man3/modf.3:96 build/C/man3/nan.3:79 build/C/man3/nextafter.3:177
#: build/C/man3/pow.3:362 build/C/man3/pow10.3:53 build/C/man3/remainder.3:215
#: build/C/man3/remquo.3:126 build/C/man3/rint.3:135 build/C/man3/round.3:106
#: build/C/man3/scalb.3:195 build/C/man3/scalbln.3:173
#: build/C/man3/signbit.3:65 build/C/man3/significand.3:57
#: build/C/man3/sin.3:117 build/C/man3/sincos.3:77 build/C/man3/sinh.3:128
#: build/C/man3/sqrt.3:112 build/C/man3/tan.3:142 build/C/man3/tanh.3:104
#: build/C/man3/tgamma.3:184 build/C/man3/trunc.3:80 build/C/man3/y0.3:240
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/INFINITY.3:96
msgid "B<fpclassify>(3), B<math_error>(7)"
msgstr "B<fpclassify>(3), B<math_error>(7)"

#. type: SH
#: build/C/man3/INFINITY.3:96 build/C/man3/abs.3:132 build/C/man3/acos.3:124
#: build/C/man3/acosh.3:131 build/C/man3/asin.3:123 build/C/man3/asinh.3:116
#: build/C/man3/atan.3:109 build/C/man3/atan2.3:180 build/C/man3/atanh.3:161
#: build/C/man3/cbrt.3:96 build/C/man3/ceil.3:116 build/C/man3/copysign.3:97
#: build/C/man3/cos.3:122 build/C/man3/cosh.3:135 build/C/man3/div.3:109
#: build/C/man3/erf.3:134 build/C/man3/erfc.3:139 build/C/man3/exp.3:139
#: build/C/man3/exp10.3:84 build/C/man3/exp2.3:102 build/C/man3/expm1.3:172
#: build/C/man3/fabs.3:99 build/C/man3/fdim.3:85 build/C/man3/fenv.3:325
#: build/C/man3/finite.3:127 build/C/man3/floor.3:106 build/C/man3/fma.3:161
#: build/C/man3/fmax.3:62 build/C/man3/fmin.3:62 build/C/man3/fmod.3:148
#: build/C/man3/fpclassify.3:137 build/C/man3/frexp.3:140
#: build/C/man3/gamma.3:101 build/C/man3/hypot.3:167 build/C/man3/ilogb.3:152
#: build/C/man3/infnan.3:76 build/C/man3/isgreater.3:105 build/C/man3/j0.3:161
#: build/C/man3/ldexp.3:139 build/C/man3/lgamma.3:175 build/C/man3/log.3:147
#: build/C/man3/log10.3:101 build/C/man3/log1p.3:147 build/C/man3/log2.3:102
#: build/C/man3/logb.3:148 build/C/man3/lrint.3:118 build/C/man3/lround.3:121
#: build/C/man7/math_error.7:267 build/C/man3/matherr.3:429
#: build/C/man3/modf.3:99 build/C/man3/nan.3:83 build/C/man3/nextafter.3:179
#: build/C/man3/pow.3:366 build/C/man3/pow10.3:56 build/C/man3/remainder.3:219
#: build/C/man3/remquo.3:130 build/C/man3/rint.3:141 build/C/man3/round.3:113
#: build/C/man3/scalb.3:198 build/C/man3/scalbln.3:176
#: build/C/man3/signbit.3:67 build/C/man3/significand.3:60
#: build/C/man3/sin.3:126 build/C/man3/sincos.3:81 build/C/man3/sinh.3:135
#: build/C/man3/sqrt.3:116 build/C/man3/tan.3:150 build/C/man3/tanh.3:111
#: build/C/man3/tgamma.3:187 build/C/man3/trunc.3:87 build/C/man3/y0.3:242
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/INFINITY.3:103 build/C/man3/abs.3:139 build/C/man3/acos.3:131
#: build/C/man3/acosh.3:138 build/C/man3/asin.3:130 build/C/man3/asinh.3:123
#: build/C/man3/atan.3:116 build/C/man3/atan2.3:187 build/C/man3/atanh.3:168
#: build/C/man3/cbrt.3:103 build/C/man3/ceil.3:123 build/C/man3/copysign.3:104
#: build/C/man3/cos.3:129 build/C/man3/cosh.3:142 build/C/man3/div.3:116
#: build/C/man3/erf.3:141 build/C/man3/erfc.3:146 build/C/man3/exp.3:146
#: build/C/man3/exp10.3:91 build/C/man3/exp2.3:109 build/C/man3/expm1.3:179
#: build/C/man3/fabs.3:106 build/C/man3/fdim.3:92 build/C/man3/fenv.3:332
#: build/C/man3/finite.3:134 build/C/man3/floor.3:113 build/C/man3/fma.3:168
#: build/C/man3/fmax.3:69 build/C/man3/fmin.3:69 build/C/man3/fmod.3:155
#: build/C/man3/fpclassify.3:144 build/C/man3/frexp.3:147
#: build/C/man3/gamma.3:108 build/C/man3/hypot.3:174 build/C/man3/ilogb.3:159
#: build/C/man3/infnan.3:83 build/C/man3/isgreater.3:112 build/C/man3/j0.3:168
#: build/C/man3/ldexp.3:146 build/C/man3/lgamma.3:182 build/C/man3/log.3:154
#: build/C/man3/log10.3:108 build/C/man3/log1p.3:154 build/C/man3/log2.3:109
#: build/C/man3/logb.3:155 build/C/man3/lrint.3:125 build/C/man3/lround.3:128
#: build/C/man7/math_error.7:274 build/C/man3/matherr.3:436
#: build/C/man3/modf.3:106 build/C/man3/nan.3:90 build/C/man3/nextafter.3:186
#: build/C/man3/pow.3:373 build/C/man3/pow10.3:63 build/C/man3/remainder.3:226
#: build/C/man3/remquo.3:137 build/C/man3/rint.3:148 build/C/man3/round.3:120
#: build/C/man3/scalb.3:205 build/C/man3/scalbln.3:183
#: build/C/man3/signbit.3:74 build/C/man3/significand.3:67
#: build/C/man3/sin.3:133 build/C/man3/sincos.3:88 build/C/man3/sinh.3:142
#: build/C/man3/sqrt.3:123 build/C/man3/tan.3:157 build/C/man3/tanh.3:118
#: build/C/man3/tgamma.3:194 build/C/man3/trunc.3:94 build/C/man3/y0.3:249
msgid ""
"This page is part of release 3.50 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.50 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/abs.3:34
#, no-wrap
msgid "ABS"
msgstr "ABS"

#. type: TH
#: build/C/man3/abs.3:34 build/C/man3/acos.3:35 build/C/man3/acosh.3:35
#: build/C/man3/asin.3:35 build/C/man3/asinh.3:35 build/C/man3/atan.3:35
#: build/C/man3/atan2.3:35 build/C/man3/cbrt.3:30 build/C/man3/ceil.3:27
#: build/C/man3/cosh.3:36 build/C/man3/erf.3:35 build/C/man3/erfc.3:26
#: build/C/man3/exp.3:36 build/C/man3/exp2.3:36 build/C/man3/fabs.3:32
#: build/C/man3/fdim.3:9 build/C/man3/floor.3:27 build/C/man3/fma.3:12
#: build/C/man3/fmax.3:9 build/C/man3/fmin.3:9 build/C/man3/fpclassify.3:10
#: build/C/man3/frexp.3:33 build/C/man3/hypot.3:33 build/C/man3/ilogb.3:29
#: build/C/man3/j0.3:36 build/C/man3/ldexp.3:34 build/C/man3/log.3:36
#: build/C/man3/log10.3:36 build/C/man3/log1p.3:29 build/C/man3/logb.3:29
#: build/C/man3/lrint.3:27 build/C/man3/lround.3:27 build/C/man3/modf.3:33
#: build/C/man3/nan.3:11 build/C/man3/nextafter.3:11
#: build/C/man3/remainder.3:37 build/C/man3/remquo.3:12 build/C/man3/rint.3:27
#: build/C/man3/round.3:27 build/C/man3/scalb.3:27 build/C/man3/scalbln.3:27
#: build/C/man3/signbit.3:11 build/C/man3/sinh.3:36 build/C/man3/sqrt.3:34
#: build/C/man3/tanh.3:35 build/C/man3/tgamma.3:13 build/C/man3/trunc.3:25
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: TH
#: build/C/man3/abs.3:34 build/C/man3/asinh.3:35 build/C/man3/cbrt.3:30
#: build/C/man3/copysign.3:31 build/C/man3/erf.3:35 build/C/man3/erfc.3:26
#: build/C/man3/exp10.3:35 build/C/man3/gamma.3:9 build/C/man3/infnan.3:33
#: build/C/man3/nan.3:11 build/C/man3/nextafter.3:11 build/C/man3/remquo.3:12
#: build/C/man3/signbit.3:11 build/C/man3/significand.3:9
#: build/C/man3/sincos.3:9 build/C/man3/tgamma.3:13
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/abs.3:37
msgid "abs, labs, llabs, imaxabs - compute the absolute value of an integer"
msgstr "abs, labs, llabs, imaxabs - 整数の絶対値を計算する"

#. type: Plain text
#: build/C/man3/abs.3:40 build/C/man3/div.3:41
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/abs.3:42
#, no-wrap
msgid "B<int abs(int >I<j>B<);>\n"
msgstr "B<int abs(int >I<j>B<);>\n"

#. type: Plain text
#: build/C/man3/abs.3:44
#, no-wrap
msgid "B<long int labs(long int >I<j>B<);>\n"
msgstr "B<long int labs(long int >I<j>B<);>\n"

#. type: Plain text
#: build/C/man3/abs.3:46
#, no-wrap
msgid "B<long long int llabs(long long int >I<j>B<);>\n"
msgstr "B<long long int llabs(long long int >I<j>B<);>\n"

#. type: Plain text
#: build/C/man3/abs.3:48 build/C/man3/div.3:49
#, no-wrap
msgid "B<#include E<lt>inttypes.hE<gt>>\n"
msgstr "B<#include E<lt>inttypes.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/abs.3:50
#, no-wrap
msgid "B<intmax_t imaxabs(intmax_t >I<j>B<);>\n"
msgstr "B<intmax_t imaxabs(intmax_t >I<j>B<);>\n"

#. type: Plain text
#: build/C/man3/abs.3:55 build/C/man3/acos.3:52 build/C/man3/acosh.3:54
#: build/C/man3/asin.3:54 build/C/man3/asinh.3:54 build/C/man3/atan.3:54
#: build/C/man3/atan2.3:52 build/C/man3/atanh.3:54 build/C/man3/cbrt.3:49
#: build/C/man3/ceil.3:47 build/C/man3/copysign.3:50 build/C/man3/cos.3:53
#: build/C/man3/cosh.3:55 build/C/man3/div.3:56 build/C/man3/erf.3:52
#: build/C/man3/erfc.3:43 build/C/man3/exp.3:55 build/C/man3/exp2.3:55
#: build/C/man3/expm1.3:49 build/C/man3/fabs.3:51 build/C/man3/fdim.3:26
#: build/C/man3/finite.3:55 build/C/man3/floor.3:46 build/C/man3/fma.3:31
#: build/C/man3/fmax.3:26 build/C/man3/fmin.3:26 build/C/man3/fmod.3:54
#: build/C/man3/fpclassify.3:34 build/C/man3/frexp.3:53
#: build/C/man3/gamma.3:26 build/C/man3/hypot.3:52 build/C/man3/ilogb.3:46
#: build/C/man3/isgreater.3:36 build/C/man3/j0.3:68 build/C/man3/ldexp.3:53
#: build/C/man3/lgamma.3:39 build/C/man3/log.3:55 build/C/man3/log10.3:55
#: build/C/man3/log1p.3:48 build/C/man3/log2.3:55 build/C/man3/logb.3:46
#: build/C/man3/lrint.3:52 build/C/man3/lround.3:53 build/C/man3/modf.3:53
#: build/C/man3/nan.3:28 build/C/man3/nextafter.3:35 build/C/man3/pow.3:54
#: build/C/man3/remainder.3:61 build/C/man3/remquo.3:31 build/C/man3/rint.3:53
#: build/C/man3/round.3:46 build/C/man3/scalb.3:45 build/C/man3/scalbln.3:51
#: build/C/man3/signbit.3:24 build/C/man3/significand.3:27
#: build/C/man3/sin.3:54 build/C/man3/sinh.3:55 build/C/man3/sqrt.3:53
#: build/C/man3/tan.3:54 build/C/man3/tanh.3:54 build/C/man3/tgamma.3:30
#: build/C/man3/trunc.3:44 build/C/man3/y0.3:68
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/abs.3:59
msgid "B<llabs>():"
msgstr "B<llabs>():"

#. type: Plain text
#: build/C/man3/abs.3:62 build/C/man3/div.3:63 build/C/man3/exp2.3:63
#: build/C/man3/fdim.3:34 build/C/man3/fma.3:40 build/C/man3/fmax.3:35
#: build/C/man3/fmin.3:35 build/C/man3/fpclassify.3:45
#: build/C/man3/isgreater.3:43 build/C/man3/log2.3:63 build/C/man3/lrint.3:59
#: build/C/man3/lround.3:60 build/C/man3/nan.3:37 build/C/man3/nextafter.3:65
#: build/C/man3/remquo.3:40 build/C/man3/round.3:55 build/C/man3/scalbln.3:60
#: build/C/man3/signbit.3:31 build/C/man3/tgamma.3:39 build/C/man3/trunc.3:53
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"

#. type: Plain text
#: build/C/man3/abs.3:65 build/C/man3/acos.3:63 build/C/man3/acosh.3:65
#: build/C/man3/acosh.3:75 build/C/man3/asin.3:65 build/C/man3/asinh.3:65
#: build/C/man3/asinh.3:75 build/C/man3/atan.3:65 build/C/man3/atan2.3:63
#: build/C/man3/atanh.3:65 build/C/man3/atanh.3:75 build/C/man3/cbrt.3:61
#: build/C/man3/cbrt.3:70 build/C/man3/ceil.3:58 build/C/man3/copysign.3:62
#: build/C/man3/cos.3:64 build/C/man3/cosh.3:66 build/C/man3/div.3:66
#: build/C/man3/erf.3:62 build/C/man3/erf.3:72 build/C/man3/erfc.3:53
#: build/C/man3/erfc.3:63 build/C/man3/exp.3:66 build/C/man3/exp2.3:66
#: build/C/man3/expm1.3:60 build/C/man3/expm1.3:70 build/C/man3/fabs.3:62
#: build/C/man3/fdim.3:37 build/C/man3/finite.3:70 build/C/man3/finite.3:83
#: build/C/man3/floor.3:57 build/C/man3/fma.3:43 build/C/man3/fmax.3:38
#: build/C/man3/fmin.3:38 build/C/man3/fmod.3:65 build/C/man3/fpclassify.3:48
#: build/C/man3/fpclassify.3:56 build/C/man3/fpclassify.3:64
#: build/C/man3/frexp.3:64 build/C/man3/hypot.3:62 build/C/man3/hypot.3:72
#: build/C/man3/ilogb.3:58 build/C/man3/ilogb.3:68 build/C/man3/isgreater.3:46
#: build/C/man3/ldexp.3:64 build/C/man3/lgamma.3:49 build/C/man3/lgamma.3:59
#: build/C/man3/log.3:66 build/C/man3/log10.3:66 build/C/man3/log1p.3:59
#: build/C/man3/log1p.3:69 build/C/man3/log2.3:66 build/C/man3/logb.3:57
#: build/C/man3/logb.3:67 build/C/man3/lrint.3:62 build/C/man3/lround.3:63
#: build/C/man3/modf.3:64 build/C/man3/nan.3:40 build/C/man3/nextafter.3:47
#: build/C/man3/nextafter.3:57 build/C/man3/nextafter.3:68
#: build/C/man3/pow.3:65 build/C/man3/remainder.3:73
#: build/C/man3/remainder.3:83 build/C/man3/remquo.3:43 build/C/man3/rint.3:64
#: build/C/man3/rint.3:74 build/C/man3/rint.3:84 build/C/man3/round.3:58
#: build/C/man3/scalbln.3:63 build/C/man3/scalbln.3:74
#: build/C/man3/signbit.3:34 build/C/man3/sin.3:65 build/C/man3/sinh.3:66
#: build/C/man3/sqrt.3:64 build/C/man3/tan.3:65 build/C/man3/tanh.3:65
#: build/C/man3/tgamma.3:42 build/C/man3/trunc.3:56
msgid "or I<cc\\ -std=c99>"
msgstr "or I<cc\\ -std=c99>"

#. type: Plain text
#: build/C/man3/abs.3:79
msgid ""
"The B<abs>()  function computes the absolute value of the integer argument "
"I<j>.  The B<labs>(), B<llabs>()  and B<imaxabs>()  functions compute the "
"absolute value of the argument I<j> of the appropriate integer type for the "
"function."
msgstr ""
"B<abs>()  関数は、整数の引数 I<j> の絶対値を計算する。 B<labs>(), B<llabs>"
"(), B<imaxabs>()  関数は、 それぞれの関数の型に応じた引数 I<j> の絶対値を計算"
"する。"

#. type: SH
#: build/C/man3/abs.3:79 build/C/man3/acos.3:70 build/C/man3/acosh.3:82
#: build/C/man3/asin.3:72 build/C/man3/asinh.3:82 build/C/man3/atan.3:72
#: build/C/man3/atan2.3:72 build/C/man3/atanh.3:82 build/C/man3/cbrt.3:78
#: build/C/man3/ceil.3:69 build/C/man3/copysign.3:75 build/C/man3/cos.3:71
#: build/C/man3/cosh.3:77 build/C/man3/div.3:89 build/C/man3/erf.3:81
#: build/C/man3/erfc.3:71 build/C/man3/exp.3:73 build/C/man3/exp10.3:57
#: build/C/man3/exp2.3:73 build/C/man3/expm1.3:86 build/C/man3/fabs.3:69
#: build/C/man3/fdim.3:42 build/C/man3/fenv.3:258 build/C/man3/floor.3:68
#: build/C/man3/fma.3:53 build/C/man3/fmax.3:45 build/C/man3/fmin.3:45
#: build/C/man3/fmod.3:74 build/C/man3/frexp.3:71 build/C/man3/gamma.3:59
#: build/C/man3/hypot.3:92 build/C/man3/ilogb.3:78 build/C/man3/infnan.3:54
#: build/C/man3/isgreater.3:85 build/C/man3/j0.3:110 build/C/man3/ldexp.3:73
#: build/C/man3/lgamma.3:92 build/C/man3/log.3:72 build/C/man3/log10.3:72
#: build/C/man3/log1p.3:81 build/C/man3/log2.3:72 build/C/man3/logb.3:94
#: build/C/man3/lrint.3:73 build/C/man3/lround.3:76 build/C/man3/modf.3:72
#: build/C/man3/nextafter.3:93 build/C/man3/pow.3:72
#: build/C/man3/remainder.3:118 build/C/man3/remquo.3:73
#: build/C/man3/rint.3:105 build/C/man3/round.3:73 build/C/man3/scalb.3:79
#: build/C/man3/scalbln.3:95 build/C/man3/signbit.3:53 build/C/man3/sin.3:72
#: build/C/man3/sincos.3:49 build/C/man3/sinh.3:77 build/C/man3/sqrt.3:70
#: build/C/man3/tan.3:72 build/C/man3/tanh.3:76 build/C/man3/tgamma.3:63
#: build/C/man3/trunc.3:61 build/C/man3/y0.3:113
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/abs.3:82
msgid ""
"Returns the absolute value of the integer argument, of the appropriate "
"integer type for the function."
msgstr "それぞれの関数の型に応じた整数の引数の絶対値を返す。"

#.  POSIX.1 (1996 edition) only requires the
#.  .BR abs ()
#.  function.
#. type: Plain text
#: build/C/man3/abs.3:97
msgid ""
"SVr4, POSIX.1-2001, 4.3BSD, C99.  C89 only includes the B<abs>()  and B<labs>"
"()  functions; the functions B<llabs>()  and B<imaxabs>()  were added in C99."
msgstr ""
"SVr4, POSIX.1-2001, 4.3BSD, C99.  C89 は B<abs>()  関数と B<labs>()  関数のみ"
"を含んでいる。 B<llabs>()  関数と B<imaxabs>()  関数は C99 で追加された。"

#. type: SH
#: build/C/man3/abs.3:97 build/C/man3/ceil.3:84 build/C/man3/copysign.3:90
#: build/C/man3/erfc.3:128 build/C/man3/fenv.3:267 build/C/man3/finite.3:105
#: build/C/man3/floor.3:83 build/C/man3/fpclassify.3:125
#: build/C/man3/gamma.3:68 build/C/man3/infnan.3:73
#: build/C/man3/isgreater.3:97 build/C/man7/math_error.7:187
#: build/C/man3/pow10.3:50 build/C/man3/rint.3:115 build/C/man3/round.3:85
#: build/C/man3/scalbln.3:157 build/C/man3/tgamma.3:160
#: build/C/man3/trunc.3:71
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/abs.3:100
msgid ""
"Trying to take the absolute value of the most negative integer is not "
"defined."
msgstr "最大の負整数の絶対値は、定義されていない。"

#. type: Plain text
#: build/C/man3/abs.3:109
msgid ""
"The B<llabs>()  function is included in glibc since version 2.0, but is not "
"in libc5 or libc4.  The B<imaxabs>()  function is included in glibc since "
"version 2.1.1."
msgstr ""
"B<llabs>()  関数はバージョン 2.0 から glibc に含まれるようになったが、 libc5 "
"や libc4 にはない。 B<imaxabs>()  関数は バージョン 2.1.1 から glibc に含まれ"
"るようになった。"

#. type: Plain text
#: build/C/man3/abs.3:115
msgid ""
"For B<llabs>()  to be declared, it may be necessary to define "
"B<_ISOC99_SOURCE> or B<_ISOC9X_SOURCE> (depending on the version of glibc) "
"before including any standard headers."
msgstr ""
"B<llabs>()  が宣言されるためには、標準ヘッダを include する前に "
"B<_ISOC99_SOURCE> か B<_ISOC9X_SOURCE>(どちらかは glibc の バージョンに依存す"
"る)を define しておく必要がある。"

#. type: Plain text
#: build/C/man3/abs.3:126
msgid ""
"GCC handles B<abs>()  and B<labs>()  as built-in functions.  GCC 3.0 also "
"handles B<llabs>()  and B<imaxabs>()  as built-ins."
msgstr ""
"GCC は B<abs>()  と B<labs>()  をビルドイン関数として扱う。 GCC 3.0 は "
"B<llabs>()  と B<imaxabs>()  もビルドインとして扱う。"

#. type: Plain text
#: build/C/man3/abs.3:132
msgid "B<cabs>(3), B<ceil>(3), B<fabs>(3), B<floor>(3), B<rint>(3)"
msgstr "B<cabs>(3), B<ceil>(3), B<fabs>(3), B<floor>(3), B<rint>(3)"

#. type: TH
#: build/C/man3/acos.3:35
#, no-wrap
msgid "ACOS"
msgstr "ACOS"

#. type: Plain text
#: build/C/man3/acos.3:38
msgid "acos, acosf, acosl - arc cosine function"
msgstr "acos, acosf, acosl - 逆余弦（arc cosine）関数"

#. type: Plain text
#: build/C/man3/acos.3:45
#, no-wrap
msgid ""
"B<double acos(double >I<x>B<);>\n"
"B<float acosf(float >I<x>B<);>\n"
"B<long double acosl(long double >I<x>B<);>\n"
msgstr ""
"B<double acos(double >I<x>B<);>\n"
"B<float acosf(float >I<x>B<);>\n"
"B<long double acosl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/acos.3:48 build/C/man3/acosh.3:50 build/C/man3/asin.3:50
#: build/C/man3/asinh.3:50 build/C/man3/atan.3:50 build/C/man3/atan2.3:48
#: build/C/man3/atanh.3:50 build/C/man3/cbrt.3:45 build/C/man3/ceil.3:43
#: build/C/man3/copysign.3:46 build/C/man3/cos.3:49 build/C/man3/cosh.3:51
#: build/C/man3/erf.3:48 build/C/man3/erfc.3:39 build/C/man3/exp.3:51
#: build/C/man3/exp10.3:52 build/C/man3/exp2.3:51 build/C/man3/expm1.3:45
#: build/C/man3/fabs.3:47 build/C/man3/fdim.3:22 build/C/man3/fenv.3:61
#: build/C/man3/floor.3:42 build/C/man3/fma.3:27 build/C/man3/fmax.3:22
#: build/C/man3/fmin.3:22 build/C/man3/fmod.3:50 build/C/man3/fpclassify.3:30
#: build/C/man3/frexp.3:49 build/C/man3/gamma.3:22 build/C/man3/hypot.3:48
#: build/C/man3/ilogb.3:42 build/C/man3/infnan.3:44
#: build/C/man3/isgreater.3:32 build/C/man3/j0.3:64 build/C/man3/ldexp.3:49
#: build/C/man3/lgamma.3:35 build/C/man3/log.3:51 build/C/man3/log10.3:51
#: build/C/man3/log1p.3:44 build/C/man3/log2.3:51 build/C/man3/logb.3:42
#: build/C/man3/lrint.3:48 build/C/man3/lround.3:49 build/C/man3/matherr.3:41
#: build/C/man3/modf.3:49 build/C/man3/nan.3:24 build/C/man3/nextafter.3:31
#: build/C/man3/pow.3:50 build/C/man3/pow10.3:41 build/C/man3/remainder.3:57
#: build/C/man3/remquo.3:27 build/C/man3/rint.3:49 build/C/man3/round.3:42
#: build/C/man3/scalb.3:41 build/C/man3/scalbln.3:47 build/C/man3/signbit.3:20
#: build/C/man3/significand.3:23 build/C/man3/sin.3:50
#: build/C/man3/sincos.3:25 build/C/man3/sinh.3:51 build/C/man3/sqrt.3:49
#: build/C/man3/tan.3:50 build/C/man3/tanh.3:50 build/C/man3/tgamma.3:26
#: build/C/man3/trunc.3:40 build/C/man3/y0.3:64
msgid "Link with I<-lm>."
msgstr "I<-lm> でリンクする。"

#. type: Plain text
#: build/C/man3/acos.3:57
msgid "B<acosf>(), B<acosl>():"
msgstr "B<acosf>(), B<acosl>():"

#. type: Plain text
#: build/C/man3/acos.3:60 build/C/man3/acosh.3:72 build/C/man3/asin.3:62
#: build/C/man3/asinh.3:72 build/C/man3/atan.3:62 build/C/man3/atan2.3:60
#: build/C/man3/atanh.3:72 build/C/man3/ceil.3:55 build/C/man3/cos.3:61
#: build/C/man3/cosh.3:63 build/C/man3/erf.3:69 build/C/man3/exp.3:63
#: build/C/man3/expm1.3:67 build/C/man3/fabs.3:59 build/C/man3/floor.3:54
#: build/C/man3/fmod.3:62 build/C/man3/fpclassify.3:61 build/C/man3/frexp.3:61
#: build/C/man3/hypot.3:69 build/C/man3/ilogb.3:65 build/C/man3/ldexp.3:61
#: build/C/man3/lgamma.3:56 build/C/man3/log.3:63 build/C/man3/log10.3:63
#: build/C/man3/log1p.3:66 build/C/man3/logb.3:64 build/C/man3/modf.3:61
#: build/C/man3/nextafter.3:54 build/C/man3/pow.3:62
#: build/C/man3/remainder.3:80 build/C/man3/rint.3:81
#: build/C/man3/scalbln.3:71 build/C/man3/sin.3:62 build/C/man3/sinh.3:63
#: build/C/man3/sqrt.3:61 build/C/man3/tan.3:62 build/C/man3/tanh.3:62
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/acos.3:70
msgid ""
"The B<acos>()  function calculates the arc cosine of I<x>; that is the value "
"whose cosine is I<x>."
msgstr ""
"B<acos>()  関数は I<x> の逆余弦（arc cosine) を計算する。 すなわち、その余弦 "
"(cosine) が I<x> となる値である。"

#. type: Plain text
#: build/C/man3/acos.3:74
msgid ""
"On success, these functions return the arc cosine of I<x> in radians; the "
"return value is in the range [0,\\ pi]."
msgstr ""
"成功すると、これらの関数は I<x> の逆余弦をラジアン単位で返す。 返り値は [0,"
"\\ pi] の範囲となる。"

#. type: Plain text
#: build/C/man3/acos.3:78 build/C/man3/acosh.3:89 build/C/man3/asin.3:80
#: build/C/man3/asinh.3:89 build/C/man3/atan.3:80 build/C/man3/atanh.3:89
#: build/C/man3/cos.3:78 build/C/man3/cosh.3:84 build/C/man3/erf.3:89
#: build/C/man3/erfc.3:79 build/C/man3/exp.3:81 build/C/man3/expm1.3:94
#: build/C/man3/fabs.3:76 build/C/man3/j0.3:118 build/C/man3/ldexp.3:87
#: build/C/man3/lgamma.3:98 build/C/man3/log.3:80 build/C/man3/log1p.3:89
#: build/C/man3/logb.3:102 build/C/man3/scalbln.3:101 build/C/man3/sin.3:79
#: build/C/man3/sinh.3:84 build/C/man3/sqrt.3:77 build/C/man3/tan.3:79
#: build/C/man3/tanh.3:83 build/C/man3/tgamma.3:69 build/C/man3/y0.3:121
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "I<x> が NaN の場合、NaN が返される。"

#. type: Plain text
#: build/C/man3/acos.3:83 build/C/man3/acosh.3:93
msgid "If I<x> is +1, +0 is returned."
msgstr "I<x> が +1 の場合、+0 が返される。"

#. type: Plain text
#: build/C/man3/acos.3:89 build/C/man3/cos.3:84 build/C/man3/sin.3:88
#: build/C/man3/tan.3:85
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned."
msgstr ""
"I<x> が正の無限大か負の無限大の場合、 領域エラー (domain error) が発生し、"
"NaN が返される。"

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: build/C/man3/acos.3:95 build/C/man3/asin.3:94
msgid ""
"If I<x> is outside the range [-1,\\ 1], a domain error occurs, and a NaN is "
"returned."
msgstr ""
"I<x> が [-1,\\ 1] の範囲に入っていない場合、 領域エラー (domain error) が発生"
"し、NaN が返される。"

#. type: SH
#: build/C/man3/acos.3:95 build/C/man3/acosh.3:103 build/C/man3/asin.3:94
#: build/C/man3/asinh.3:101 build/C/man3/atan.3:92 build/C/man3/atan2.3:162
#: build/C/man3/atanh.3:113 build/C/man3/cbrt.3:87 build/C/man3/ceil.3:75
#: build/C/man3/copysign.3:83 build/C/man3/cos.3:84 build/C/man3/cosh.3:102
#: build/C/man3/erf.3:104 build/C/man3/erfc.3:102 build/C/man3/exp.3:104
#: build/C/man3/exp10.3:64 build/C/man3/exp2.3:80 build/C/man3/expm1.3:115
#: build/C/man3/fabs.3:84 build/C/man3/fdim.3:59 build/C/man3/floor.3:74
#: build/C/man3/fma.3:117 build/C/man3/fmax.3:54 build/C/man3/fmin.3:54
#: build/C/man3/fmod.3:106 build/C/man3/frexp.3:96 build/C/man3/gamma.3:62
#: build/C/man3/hypot.3:128 build/C/man3/ilogb.3:110 build/C/man3/infnan.3:64
#: build/C/man3/isgreater.3:93 build/C/man3/j0.3:125 build/C/man3/ldexp.3:106
#: build/C/man3/lgamma.3:128 build/C/man3/log.3:104 build/C/man3/log10.3:80
#: build/C/man3/log1p.3:111 build/C/man3/log2.3:80 build/C/man3/logb.3:116
#: build/C/man3/lrint.3:87 build/C/man3/lround.3:90 build/C/man3/modf.3:88
#: build/C/man3/nextafter.3:138 build/C/man3/pow.3:253
#: build/C/man3/remainder.3:150 build/C/man3/remquo.3:101
#: build/C/man3/rint.3:110 build/C/man3/round.3:78 build/C/man3/scalb.3:133
#: build/C/man3/scalbln.3:125 build/C/man3/signbit.3:59 build/C/man3/sin.3:88
#: build/C/man3/sincos.3:52 build/C/man3/sinh.3:107 build/C/man3/sqrt.3:91
#: build/C/man3/tan.3:103 build/C/man3/tanh.3:96 build/C/man3/tgamma.3:103
#: build/C/man3/trunc.3:65 build/C/man3/y0.3:158
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/acos.3:100 build/C/man3/acosh.3:108 build/C/man3/asin.3:99
#: build/C/man3/atanh.3:118 build/C/man3/cos.3:89 build/C/man3/cosh.3:107
#: build/C/man3/erf.3:109 build/C/man3/erfc.3:107 build/C/man3/exp.3:109
#: build/C/man3/exp10.3:69 build/C/man3/exp2.3:85 build/C/man3/expm1.3:120
#: build/C/man3/fdim.3:64 build/C/man3/fma.3:122 build/C/man3/fmod.3:111
#: build/C/man3/hypot.3:133 build/C/man3/ilogb.3:115 build/C/man3/j0.3:130
#: build/C/man3/ldexp.3:111 build/C/man3/lgamma.3:133 build/C/man3/log.3:109
#: build/C/man3/log10.3:85 build/C/man3/log1p.3:116 build/C/man3/log2.3:85
#: build/C/man3/logb.3:121 build/C/man3/lrint.3:92 build/C/man3/lround.3:95
#: build/C/man3/nextafter.3:143 build/C/man3/pow.3:278
#: build/C/man3/remainder.3:155 build/C/man3/remquo.3:106
#: build/C/man3/scalb.3:138 build/C/man3/scalbln.3:130 build/C/man3/sin.3:93
#: build/C/man3/sincos.3:57 build/C/man3/sinh.3:112 build/C/man3/sqrt.3:96
#: build/C/man3/tan.3:108 build/C/man3/tgamma.3:108 build/C/man3/y0.3:163
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"これらの関数を呼び出した際にエラーが発生したかの判定方法についての情報は "
"B<math_error>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man3/acos.3:102 build/C/man3/acosh.3:110 build/C/man3/asin.3:101
#: build/C/man3/atanh.3:120 build/C/man3/cos.3:91 build/C/man3/cosh.3:109
#: build/C/man3/erf.3:111 build/C/man3/erfc.3:109 build/C/man3/exp.3:111
#: build/C/man3/expm1.3:122 build/C/man3/fdim.3:66 build/C/man3/fma.3:124
#: build/C/man3/fmod.3:113 build/C/man3/hypot.3:135 build/C/man3/ilogb.3:117
#: build/C/man3/j0.3:132 build/C/man3/ldexp.3:113 build/C/man3/lgamma.3:135
#: build/C/man3/log.3:111 build/C/man3/log1p.3:118 build/C/man3/logb.3:123
#: build/C/man3/lrint.3:94 build/C/man3/lround.3:97
#: build/C/man3/nextafter.3:145 build/C/man3/pow.3:280
#: build/C/man3/remainder.3:157 build/C/man3/remquo.3:108
#: build/C/man3/scalb.3:140 build/C/man3/scalbln.3:132 build/C/man3/sin.3:95
#: build/C/man3/sincos.3:59 build/C/man3/sinh.3:114 build/C/man3/sqrt.3:98
#: build/C/man3/tan.3:110 build/C/man3/tgamma.3:110 build/C/man3/y0.3:165
msgid "The following errors can occur:"
msgstr "以下のエラーが発生する可能性がある。"

#. type: TP
#: build/C/man3/acos.3:102 build/C/man3/asin.3:101
#, no-wrap
msgid "Domain error: I<x> is outside the range [-1,\\ 1]"
msgstr "領域エラー (domain error): I<x> が [-1,\\ 1] の範囲に入っていない"

#. type: Plain text
#: build/C/man3/acos.3:110 build/C/man3/acosh.3:118 build/C/man3/asin.3:109
#: build/C/man3/atanh.3:128 build/C/man3/fmod.3:132 build/C/man3/log.3:119
#: build/C/man3/pow.3:288 build/C/man3/remainder.3:180 build/C/man3/sqrt.3:106
#: build/C/man3/y0.3:173
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> に B<EDOM> が設定される。 不正 (invalid) 浮動小数点例外 "
"(B<FE_INVALID>)  が上がる。"

#. type: Plain text
#: build/C/man3/acos.3:116 build/C/man3/acosh.3:124 build/C/man3/asin.3:115
#: build/C/man3/asinh.3:109 build/C/man3/atan.3:100 build/C/man3/atan2.3:172
#: build/C/man3/atanh.3:143 build/C/man3/ceil.3:84 build/C/man3/exp.3:133
#: build/C/man3/exp2.3:96 build/C/man3/fabs.3:92 build/C/man3/floor.3:83
#: build/C/man3/fmod.3:138 build/C/man3/frexp.3:104 build/C/man3/ldexp.3:135
#: build/C/man3/log.3:133 build/C/man3/log10.3:94 build/C/man3/modf.3:96
#: build/C/man3/pow.3:319 build/C/man3/sin.3:110 build/C/man3/sinh.3:128
#: build/C/man3/sqrt.3:112 build/C/man3/tan.3:135 build/C/man3/tanh.3:104
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD, C89."
msgstr ""
"C99, POSIX.1-2001.  I<double> 版の関数は SVr4, 4.3BSD, C89 にも準拠している。"

#. type: Plain text
#: build/C/man3/acos.3:124
msgid ""
"B<asin>(3), B<atan>(3), B<atan2>(3), B<cacos>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"
msgstr ""
"B<asin>(3), B<atan>(3), B<atan2>(3), B<cacos>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"

#. type: TH
#: build/C/man3/acosh.3:35
#, no-wrap
msgid "ACOSH"
msgstr "ACOSH"

#. type: Plain text
#: build/C/man3/acosh.3:38
msgid "acosh, acoshf, acoshl - inverse hyperbolic cosine function"
msgstr "acosh, acoshf, acoshl - 逆双曲線余弦（inverse hyperbolic cosine）関数"

#. type: Plain text
#: build/C/man3/acosh.3:43
#, no-wrap
msgid "B<double acosh(double >I<x>B<);>\n"
msgstr "B<double acosh(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/acosh.3:45
#, no-wrap
msgid "B<float acoshf(float >I<x>B<);>\n"
msgstr "B<float acoshf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/acosh.3:47
#, no-wrap
msgid "B<long double acoshl(long double >I<x>B<);>\n"
msgstr "B<long double acoshl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/acosh.3:58
msgid "B<acosh>():"
msgstr "B<acosh>():"

#. type: Plain text
#: build/C/man3/acosh.3:62 build/C/man3/asinh.3:62 build/C/man3/atanh.3:62
#: build/C/man3/cbrt.3:58 build/C/man3/expm1.3:57 build/C/man3/ilogb.3:55
#: build/C/man3/log1p.3:56 build/C/man3/logb.3:54 build/C/man3/nextafter.3:44
#: build/C/man3/rint.3:71
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>="
"\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>="
"\\ 200112L;"

#. type: Plain text
#: build/C/man3/acosh.3:69
msgid "B<acoshf>(), B<acoshl>():"
msgstr "B<acoshf>(), B<acoshl>():"

#. type: Plain text
#: build/C/man3/acosh.3:82
msgid ""
"The B<acosh>()  function calculates the inverse hyperbolic cosine of I<x>; "
"that is the value whose hyperbolic cosine is I<x>."
msgstr ""
"B<acosh>()  関数は I<x> の逆双曲線余弦（inverse hyperbolic cosine）を 計算す"
"る。 すなわち、その双曲線余弦（hyperbolic cosine）が I<x> に なるような値であ"
"る。"

#. type: Plain text
#: build/C/man3/acosh.3:85
msgid ""
"On success, these functions return the inverse hyperbolic cosine of I<x>."
msgstr "成功すると、これらの関数は I<x> の逆双曲線余弦を返す。"

#. type: Plain text
#: build/C/man3/acosh.3:97 build/C/man3/exp.3:86 build/C/man3/expm1.3:103
#: build/C/man3/log.3:89 build/C/man3/log1p.3:93 build/C/man3/sqrt.3:85
#: build/C/man3/tgamma.3:73
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr "I<x> が正の無限大の場合、正の無限大が返される。"

#. type: Plain text
#: build/C/man3/acosh.3:103
msgid ""
"If I<x> is less than 1, a domain error occurs, and the functions return a "
"NaN."
msgstr ""
"I<x> が 1 より小さい場合、 領域エラー (domain error) が発生し、NaN が返され"
"る。"

#. type: TP
#: build/C/man3/acosh.3:110
#, no-wrap
msgid "Domain error: I<x> is less than 1"
msgstr "領域エラー (domain error): I<x> が 1 より小さい"

#. type: Plain text
#: build/C/man3/acosh.3:131
msgid ""
"B<asinh>(3), B<atanh>(3), B<cacosh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<asinh>(3), B<atanh>(3), B<cacosh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: build/C/man3/asin.3:35
#, no-wrap
msgid "ASIN"
msgstr "ASIN"

#. type: Plain text
#: build/C/man3/asin.3:38
msgid "asin, asinf, asinl - arc sine function"
msgstr "asin, asinf, asinl - 逆正弦（arc sine）関数"

#. type: Plain text
#: build/C/man3/asin.3:43
#, no-wrap
msgid "B<double asin(double >I<x>B<);>\n"
msgstr "B<double asin(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/asin.3:45
#, no-wrap
msgid "B<float asinf(float >I<x>B<);>\n"
msgstr "B<float asinf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/asin.3:47
#, no-wrap
msgid "B<long double asinl(long double >I<x>B<);>\n"
msgstr "B<long double asinl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/asin.3:59
msgid "B<asinf>(), B<asinl>():"
msgstr "B<asinf>(), B<asinl>():"

#. type: Plain text
#: build/C/man3/asin.3:72
msgid ""
"The B<asin>()  function calculates the principal value of the arc sine of "
"I<x>; that is the value whose sine is I<x>."
msgstr ""
"B<asin>()  関数は I<x> の逆正弦（arc sine) の主値を計算する。 すなわち、その"
"正弦（sine）が I<x> となるような値である。"

#. type: Plain text
#: build/C/man3/asin.3:76
msgid ""
"On success, these functions return the principal value of the arc sine of "
"I<x> in radians; the return value is in the range [-pi/2,\\ pi/2]."
msgstr ""
"成功すると、これらの関数は I<x> の逆正弦の主値をラジアン単位で返す。 返り値"
"は [-pi/2,\\ pi/2] の範囲となる。"

#. type: Plain text
#: build/C/man3/asin.3:85 build/C/man3/asinh.3:93 build/C/man3/atan.3:85
#: build/C/man3/atanh.3:93 build/C/man3/erf.3:93 build/C/man3/expm1.3:99
#: build/C/man3/scalbln.3:110 build/C/man3/sinh.3:88 build/C/man3/sqrt.3:81
#: build/C/man3/tanh.3:87
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr "I<x> が +0 (-0) の場合、+0 (-0) が返される。"

#. type: Plain text
#: build/C/man3/asin.3:123
msgid ""
"B<acos>(3), B<atan>(3), B<atan2>(3), B<casin>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"
msgstr ""
"B<acos>(3), B<atan>(3), B<atan2>(3), B<casin>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"

#. type: TH
#: build/C/man3/asinh.3:35
#, no-wrap
msgid "ASINH"
msgstr "ASINH"

#. type: Plain text
#: build/C/man3/asinh.3:38
msgid "asinh, asinhf, asinhl - inverse hyperbolic sine function"
msgstr "asinh, asinhf, asinhl - 逆双曲線正弦（inverse hyperbolic sine）関数"

#. type: Plain text
#: build/C/man3/asinh.3:43
#, no-wrap
msgid "B<double asinh(double >I<x>B<);>\n"
msgstr "B<double asinh(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/asinh.3:45
#, no-wrap
msgid "B<float asinhf(float >I<x>B<);>\n"
msgstr "B<float asinhf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/asinh.3:47
#, no-wrap
msgid "B<long double asinhl(long double >I<x>B<);>\n"
msgstr "B<long double asinhl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/asinh.3:58
msgid "B<asinh>():"
msgstr "B<asinh>():"

#. type: Plain text
#: build/C/man3/asinh.3:69
msgid "B<asinhf>(), B<asinhl>():"
msgstr "B<asinhf>(), B<asinhl>():"

#. type: Plain text
#: build/C/man3/asinh.3:82
msgid ""
"The B<asinh>()  function calculates the inverse hyperbolic sine of I<x>; "
"that is the value whose hyperbolic sine is I<x>."
msgstr ""
"B<asinh>()  関数は I<x> 逆双曲線正弦（inverse hyperbolic sine）を 計算する。"
"すなわち、その双曲線正弦（hyperbolic sine）が I<x> に なるような値である。"

#. type: Plain text
#: build/C/man3/asinh.3:85
msgid "On success, these functions return the inverse hyperbolic sine of I<x>."
msgstr "成功すると、これらの関数は I<x> の逆双曲線正弦を返す。"

#. type: Plain text
#: build/C/man3/asinh.3:101 build/C/man3/ldexp.3:92 build/C/man3/scalbln.3:106
#: build/C/man3/sinh.3:93
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned."
msgstr ""
"I<x> が正の無限大 (負の無限大) の場合、正の無限大 (負の無限大) が返される。"

#. type: Plain text
#: build/C/man3/asinh.3:103 build/C/man3/atan.3:94 build/C/man3/atan2.3:166
#: build/C/man3/cbrt.3:89 build/C/man3/copysign.3:85 build/C/man3/fabs.3:86
#: build/C/man3/fmax.3:56 build/C/man3/fmin.3:56 build/C/man3/frexp.3:98
#: build/C/man3/isgreater.3:95 build/C/man3/modf.3:90
#: build/C/man3/signbit.3:61 build/C/man3/tanh.3:98 build/C/man3/trunc.3:67
msgid "No errors occur."
msgstr "エラーは発生しない。"

#. type: Plain text
#: build/C/man3/asinh.3:116
msgid ""
"B<acosh>(3), B<atanh>(3), B<casinh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<atanh>(3), B<casinh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: build/C/man3/atan.3:35
#, no-wrap
msgid "ATAN"
msgstr "ATAN"

#. type: Plain text
#: build/C/man3/atan.3:38
msgid "atan, atanf, atanl - arc tangent function"
msgstr "atan, atanf, atanl - 逆正接（arc tangent）関数"

#. type: Plain text
#: build/C/man3/atan.3:43
#, no-wrap
msgid "B<double atan(double >I<x>B<);>\n"
msgstr "B<double atan(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atan.3:45
#, no-wrap
msgid "B<float atanf(float >I<x>B<);>\n"
msgstr "B<float atanf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atan.3:47
#, no-wrap
msgid "B<long double atanl( long double >I<x>B<);>\n"
msgstr "B<long double atanl( long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atan.3:59
msgid "B<atanf>(), B<atanl>():"
msgstr "B<atanf>(), B<atanl>():"

#. type: Plain text
#: build/C/man3/atan.3:72
msgid ""
"The B<atan>()  function calculates the principal value of the arc tangent of "
"I<x>; that is the value whose tangent is I<x>."
msgstr ""
"B<atan>()  I<x> の逆正接（arc tangent）の主値を計算する。 すなわち、 その正接"
"（tangent）が I<x> となるような値である。"

#. type: Plain text
#: build/C/man3/atan.3:76
msgid ""
"On success, these functions return the principal value of the arc tangent of "
"I<x> in radians; the return value is in the range [-pi/2,\\ pi/2]."
msgstr ""
"成功すると、これらの関数は I<x> の逆正接の主値をラジアン単位で返す。 返り値"
"は [-pi/2,\\ pi/2] の範囲となる。"

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: build/C/man3/atan.3:92
msgid ""
"If I<x> is positive infinity (negative infinity), +pi/2 (-pi/2) is returned."
msgstr "I<x> が正の無限大 (負の無限大) の場合、+pi/2 (-pi/2) が返される。"

#. type: Plain text
#: build/C/man3/atan.3:109
msgid ""
"B<acos>(3), B<asin>(3), B<atan2>(3), B<carg>(3), B<catan>(3), B<cos>(3), "
"B<sin>(3), B<tan>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan2>(3), B<carg>(3), B<catan>(3), B<cos>(3), "
"B<sin>(3), B<tan>(3)"

#. type: TH
#: build/C/man3/atan2.3:35
#, no-wrap
msgid "ATAN2"
msgstr "ATAN2"

#. type: Plain text
#: build/C/man3/atan2.3:38
msgid "atan2, atan2f, atan2l - arc tangent function of two variables"
msgstr "atan2, atan2f, atan2l - 二つの変数に対する逆正接（arc tangent）関数"

#. type: Plain text
#: build/C/man3/atan2.3:45
#, no-wrap
msgid ""
"B<double atan2(double >I<y>B<, double >I<x>B<);>\n"
"B<float atan2f(float >I<y>B<, float >I<x>B<);>\n"
"B<long double atan2l(long double >I<y>B<, long double >I<x>B<);>\n"
msgstr ""
"B<double atan2(double >I<y>B<, double >I<x>B<);>\n"
"B<float atan2f(float >I<y>B<, float >I<x>B<);>\n"
"B<long double atan2l(long double >I<y>B<, long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atan2.3:57
msgid "B<atan2f>(), B<atan2l>():"
msgstr "B<atan2f>(), B<atan2l>():"

#. type: Plain text
#: build/C/man3/atan2.3:72
msgid ""
"The B<atan2>()  function calculates the principal value of the arc tangent "
"of I<y/x>, using the signs of the two arguments to determine the quadrant of "
"the result."
msgstr ""
"B<atan2>()  関数は I<y/x> の逆正接 (arg tangent) の主値を計算する。 二つの引"
"き数の符号は結果の象限を決定するために使われる。"

#. type: Plain text
#: build/C/man3/atan2.3:76
msgid ""
"On success, these functions return the principal value of the arc tangent of "
"I<y/x> in radians; the return value is in the range [-pi,\\ pi]."
msgstr ""
"成功すると、これらの関数は I<y/x> の逆正接の主値をラジアン単位で返す。 返り値"
"は [-pi,\\ pi] の範囲となる。"

#. type: Plain text
#: build/C/man3/atan2.3:82
msgid "If I<y> is +0 (-0) and I<x> is less than 0, +pi (-pi) is returned."
msgstr "I<y> が +0 (-0) で I<x> が 0 未満の場合、+pi (-pi) が返される。"

#. type: Plain text
#: build/C/man3/atan2.3:88
msgid "If I<y> is +0 (-0) and I<x> is greater than 0, +0 (-0) is returned."
msgstr "I<y> が +0 (-0) で I<x> が 0 より大きい場合、+0 (-0) が返される。"

#. type: Plain text
#: build/C/man3/atan2.3:94
msgid "If I<y> is less than 0 and I<x> is +0 or -0, -pi/2 is returned."
msgstr "I<y> が 0 未満で I<x> が +0 か -0 の場合、-pi/2 が返される。"

#. type: Plain text
#: build/C/man3/atan2.3:100
msgid "If I<y> is greater than 0 and I<x> is +0 or -0, pi/2 is returned."
msgstr "I<y> が 0 より大きく I<x> が +0 か -0 の場合、pi/2 が返される。"

#.  POSIX.1 says:
#.  If
#.  .I x
#.  is 0, a pole error shall not occur.
#. type: Plain text
#: build/C/man3/atan2.3:111
msgid "If either I<x> or I<y> is NaN, a NaN is returned."
msgstr "I<x> か I<y> のいずかが NaN の場合、NaN が返される。"

#.  POSIX.1 says:
#.  If the result underflows, a range error may occur and
#.  .I y/x
#.  should be returned.
#. type: Plain text
#: build/C/man3/atan2.3:122
msgid "If I<y> is +0 (-0) and I<x> is -0, +pi (-pi) is returned."
msgstr "I<y> が +0 (-0) で I<x> が -0 の場合、+pi (-pi) が返される。"

#. type: Plain text
#: build/C/man3/atan2.3:128
msgid "If I<y> is +0 (-0) and I<x> is +0, +0 (-0) is returned."
msgstr "I<y> が +0 (-0) で I<x> が +0 の場合、+0 (-0) が返される。"

#. type: Plain text
#: build/C/man3/atan2.3:134
msgid ""
"If I<y> is a finite value greater (less) than 0, and I<x> is negative "
"infinity, +pi (-pi) is returned."
msgstr ""
"I<y> が 0 より大きい (小さい) 有限値で I<x> が負の無限大の場合、+pi (-pi) が"
"返される。"

#. type: Plain text
#: build/C/man3/atan2.3:140
msgid ""
"If I<y> is a finite value greater (less) than 0, and I<x> is positive "
"infinity, +0 (-0) is returned."
msgstr ""
"I<y> が 0 より大きい (小さい) 有限値で I<x> が正の無限大の場合、+0 (-0) が返"
"される。"

#. type: Plain text
#: build/C/man3/atan2.3:147
msgid ""
"If I<y> is positive infinity (negative infinity), and I<x> is finite, pi/2 (-"
"pi/2) is returned."
msgstr ""
"I<y> が正の無限大 (負の無限大) で I<x> が有限値の場合、pi/2 (-pi/2) が返され"
"る。"

#. type: Plain text
#: build/C/man3/atan2.3:153
msgid ""
"If I<y> is positive infinity (negative infinity) and I<x> is negative "
"infinity, +3*pi/4 (-3*pi/4) is returned."
msgstr ""
"I<y> が正の無限大 (負の無限大) で I<x> が負の無限大の場合、+3*pi/4 (-3*pi/4) "
"が返される。"

#.  POSIX.1 says:
#.  If both arguments are 0, a domain error shall not occur.
#. type: Plain text
#: build/C/man3/atan2.3:162
msgid ""
"If I<y> is positive infinity (negative infinity) and I<x> is positive "
"infinity, +pi/4 (-pi/4) is returned."
msgstr ""
"I<y> が正の無限大 (負の無限大) で I<x> が正の無限大の場合、+pi/4 (-pi/4) が返"
"される。"

#. type: Plain text
#: build/C/man3/atan2.3:180
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<carg>(3), B<cos>(3), B<sin>(3), B<tan>"
"(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<carg>(3), B<cos>(3), B<sin>(3), B<tan>"
"(3)"

#. type: TH
#: build/C/man3/atanh.3:35
#, no-wrap
msgid "ATANH"
msgstr "ATANH"

#. type: TH
#: build/C/man3/atanh.3:35 build/C/man3/cos.3:34 build/C/man3/lgamma.3:11
#: build/C/man3/sin.3:35 build/C/man3/tan.3:35
#, no-wrap
msgid "2010-09-11"
msgstr "2010-09-11"

#. type: Plain text
#: build/C/man3/atanh.3:38
msgid "atanh, atanhf, atanhl - inverse hyperbolic tangent function"
msgstr "atanh, atanhf, atanhl - 逆双曲線正接（inverse hyperbolic tangent）関数"

#. type: Plain text
#: build/C/man3/atanh.3:43
#, no-wrap
msgid "B<double atanh(double >I<x>B<);>\n"
msgstr "B<double atanh(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atanh.3:45
#, no-wrap
msgid "B<float atanhf(float >I<x>B<);>\n"
msgstr "B<float atanhf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atanh.3:47
#, no-wrap
msgid "B<long double atanhl(long double >I<x>B<);>\n"
msgstr "B<long double atanhl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/atanh.3:58
msgid "B<atanh>():"
msgstr "B<atanh>():"

#. type: Plain text
#: build/C/man3/atanh.3:69
msgid "B<atanhf>(), B<atanhl>():"
msgstr "B<atanhf>(), B<atanhl>():"

#. type: Plain text
#: build/C/man3/atanh.3:82
msgid ""
"The B<atanh>()  function calculates the inverse hyperbolic tangent of I<x>; "
"that is the value whose hyperbolic tangent is I<x>."
msgstr ""
"B<atanh>()  関数は I<x> の逆双曲線正接 (inverse hyperbolic tangent) を計算す"
"る。 すなわち、その双曲線正接 (hyperbolic tangent) が I<x> になる ような値で"
"ある。"

#. type: Plain text
#: build/C/man3/atanh.3:85
msgid ""
"On success, these functions return the inverse hyperbolic tangent of I<x>."
msgstr "成功すると、これらの関数は I<x> の逆双曲線正接を返す。"

#. type: Plain text
#: build/C/man3/atanh.3:104
msgid ""
"If I<x> is +1 or -1, a pole error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the "
"mathematically correct sign."
msgstr ""
"I<x> が +1 か -1 の場合、 極エラー (pole error) が発生し、 関数の種類に応じ"
"て、数学的に正しい符号の B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> がそれぞれ返"
"される。"

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: build/C/man3/atanh.3:113
msgid ""
"If the absolute value of I<x> is greater than 1, a domain error occurs, and "
"a NaN is returned."
msgstr ""
"I<x> の絶対値が 1 より大きい場合、 領域エラー (domain error) が発生し、 NaN "
"が返される。"

#. type: TP
#: build/C/man3/atanh.3:120
#, no-wrap
msgid "Domain error: I<x> less than -1 or greater than +1"
msgstr "領域エラー (domain error): I<x> が -1 より小さいか +1 より大きい"

#. type: TP
#: build/C/man3/atanh.3:128
#, no-wrap
msgid "Pole error: I<x> is +1 or -1"
msgstr "極エラー (pole error): I<x> が +1 か -1"

#. type: Plain text
#: build/C/man3/atanh.3:137 build/C/man3/lgamma.3:144 build/C/man3/pow.3:297
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  A divide-by-zero floating-"
"point exception (B<FE_DIVBYZERO>)  is raised."
msgstr ""
"I<errno> に B<ERANGE> が設定される (「バグ」の節も参照)。 0 による除算 "
"(divide-by-zero) 浮動小数点例外 (B<FE_DIVBYZERO>)  が上がる。"

#. type: SH
#: build/C/man3/atanh.3:143 build/C/man3/cos.3:106 build/C/man3/cosh.3:123
#: build/C/man3/expm1.3:137 build/C/man3/fenv.3:312 build/C/man3/fmod.3:138
#: build/C/man3/j0.3:152 build/C/man3/lgamma.3:163 build/C/man3/log.3:133
#: build/C/man3/nextafter.3:172 build/C/man3/pow.3:319
#: build/C/man3/remainder.3:204 build/C/man3/sin.3:110 build/C/man3/tan.3:135
#: build/C/man3/tgamma.3:167 build/C/man3/y0.3:223
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  Bug: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6759
#.  This can be seen in sysdeps/ieee754/k_standard.c
#. type: Plain text
#: build/C/man3/atanh.3:154
msgid ""
"In glibc 2.9 and earlier, when a pole error occurs, I<errno> as set to "
"B<EDOM> instead of the POSIX-mandated B<ERANGE>.  Since version 2.10, glibc "
"does the right thing."
msgstr ""
"glibc 2.9 とそれ以前のバージョンでは、 極エラーが発生した場合、POSIX で要求さ"
"れている B<ERANGE> ではなく B<EDOM> が I<errno> に設定される。 バージョン "
"2.10 以降の glibc では、正しい動作をする。"

#. type: Plain text
#: build/C/man3/atanh.3:161
msgid ""
"B<acosh>(3), B<asinh>(3), B<catanh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<asinh>(3), B<catanh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: build/C/man3/cbrt.3:30
#, no-wrap
msgid "CBRT"
msgstr "CBRT"

#. type: Plain text
#: build/C/man3/cbrt.3:33
msgid "cbrt, cbrtf, cbrtl - cube root function"
msgstr "cbrt, cbrtf, cbrtl - 立方根を計算する関数"

#. type: Plain text
#: build/C/man3/cbrt.3:38
#, no-wrap
msgid "B<double cbrt(double >I<x>B<);>\n"
msgstr "B<double cbrt(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cbrt.3:40
#, no-wrap
msgid "B<float cbrtf(float >I<x>B<);>\n"
msgstr "B<float cbrtf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cbrt.3:42
#, no-wrap
msgid "B<long double cbrtl(long double >I<x>B<);>\n"
msgstr "B<long double cbrtl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cbrt.3:53
msgid "B<cbrt>():"
msgstr "B<cbrt>():"

#. type: Plain text
#: build/C/man3/cbrt.3:64
msgid "B<cbrtf>(), B<cbrtl>():"
msgstr "B<cbrtf>(), B<cbrtl>():"

#. type: Plain text
#: build/C/man3/cbrt.3:67
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOUCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOUCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/cbrt.3:78
msgid ""
"The B<cbrt>()  function returns the (real) cube root of I<x>.  This function "
"cannot fail; every representable real value has a representable real cube "
"root."
msgstr ""
"B<cbrt>()  関数は I<x> の (実数)立方根を返す。 この関数が失敗することはない。"
"なぜなら、 すべての内部表現可能な (representable) 実数は 必ず内部表現可能な立"
"方根を持つためである。"

#. type: Plain text
#: build/C/man3/cbrt.3:81
msgid "These functions return the cube root of I<x>."
msgstr "これらの関数は I<x> の立方根を返す。"

#. type: Plain text
#: build/C/man3/cbrt.3:87
msgid ""
"If I<x> is +0, -0, positive infinity, negative infinity, or NaN, I<x> is "
"returned."
msgstr ""
"I<x> が +0、-0、正の無限大、負の無限大、NaN のいずれかの場合、 I<x> が返され"
"る。"

#. type: Plain text
#: build/C/man3/cbrt.3:93 build/C/man3/expm1.3:137 build/C/man3/fdim.3:83
#: build/C/man3/fma.3:158 build/C/man3/fmax.3:60 build/C/man3/fmin.3:60
#: build/C/man3/ilogb.3:148 build/C/man3/isgreater.3:97
#: build/C/man3/log1p.3:143 build/C/man3/logb.3:145 build/C/man3/lrint.3:111
#: build/C/man3/lround.3:114 build/C/man3/remquo.3:126 build/C/man3/rint.3:115
#: build/C/man3/round.3:85 build/C/man3/scalbln.3:157
#: build/C/man3/tgamma.3:160 build/C/man3/trunc.3:71
msgid "C99, POSIX.1-2001."
msgstr "C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/cbrt.3:96
msgid "B<pow>(3), B<sqrt>(3)"
msgstr "B<pow>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/ceil.3:27
#, no-wrap
msgid "CEIL"
msgstr "CEIL"

#. type: Plain text
#: build/C/man3/ceil.3:31
msgid ""
"ceil, ceilf, ceill - ceiling function: smallest integral value not less than "
"argument"
msgstr "ceil, ceilf, ceill - 引き数を下回らない最小の整数値"

#. type: Plain text
#: build/C/man3/ceil.3:36
#, no-wrap
msgid "B<double ceil(double >I<x>B<);>\n"
msgstr "B<double ceil(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/ceil.3:38
#, no-wrap
msgid "B<float ceilf(float >I<x>B<);>\n"
msgstr "B<float ceilf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/ceil.3:40
#, no-wrap
msgid "B<long double ceill(long double >I<x>B<);>\n"
msgstr "B<long double ceill(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/ceil.3:52
msgid "B<ceilf>(), B<ceill>():"
msgstr "B<ceilf>(), B<ceill>():"

#. type: Plain text
#: build/C/man3/ceil.3:63
msgid ""
"These functions return the smallest integral value that is not less than "
"I<x>."
msgstr "これらの関数は I<x> より小さくない最小の整数値を返す。"

#. type: Plain text
#: build/C/man3/ceil.3:69
msgid "For example, I<ceil(0.5)> is 1.0, and I<ceil(-0.5)> is 0.0."
msgstr "例えば、 I<ceil(0.5)> は 1.0 であり、 I<ceil(-0.5)> は 0.0 である。"

#. type: Plain text
#: build/C/man3/ceil.3:72
msgid "These functions return the ceiling of I<x>."
msgstr "これらの関数は I<x> を下回らない整数値を返す。"

#. type: Plain text
#: build/C/man3/ceil.3:75 build/C/man3/rint.3:110 build/C/man3/round.3:78
msgid "If I<x> is integral, +0, -0, NaN, or infinite, I<x> itself is returned."
msgstr ""
"I<x> が整数、+0、-0、NaN、無限のいずれかの場合、 I<x> そのものが返される。"

#. type: Plain text
#: build/C/man3/ceil.3:78 build/C/man3/floor.3:77 build/C/man3/rint.3:113
#: build/C/man3/round.3:81
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""
"エラーは発生しない。 POSIX.1-2001 にはオーバーフローでの範囲エラー (range "
"error) の 記載がある。「注意」の節を参照のこと。"

#. type: Plain text
#: build/C/man3/ceil.3:100 build/C/man3/floor.3:99 build/C/man3/rint.3:130
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno> "
"to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of "
"mantissa bits is 24 (respectively, 53).)"
msgstr ""
"SUSv2 と POSIX.1-2001 にはオーバーフローに関する記述があり、 オーバーフローの"
"場合には、 I<errno> を B<ERANGE> に設定するか、 B<FE_OVERFLOW> 例外を発生する"
"こととされている。 実際のところ、どの現行のマシンでも結果がオーバーフローを起"
"こすことはないので、 このエラー処理は意味がない。 (より正確に言うと、オーバー"
"フローは指数部の最大値が 仮数部を表すビットの数より小さい場合にしか起こらな"
"い。 IEEE-754 規格の 32 ビットと 64 ビットの浮動小数では、 指数部の最大値はそ"
"れぞれ 128 と 1024 であり、 仮数部のビット数はそれぞれ 24 と 53 である。)"

#. type: Plain text
#: build/C/man3/ceil.3:109 build/C/man3/trunc.3:80
msgid ""
"The integral value returned by these functions may be too large to store in "
"an integer type (I<int>, I<long>, etc.).  To avoid an overflow, which will "
"produce undefined results, an application should perform a range check on "
"the returned value before assigning it to an integer type."
msgstr ""
"これらの関数が返す整数値は整数型 (I<int>, I<long> など) に格納するには大き過"
"ぎるかもしれない。 オーバーフローが起こった場合の結果は分からないので、 オー"
"バーフローを避けるため、アプリケーションでは整数型に代入する前に 返された値の"
"範囲確認を実行すべきである。"

#. type: Plain text
#: build/C/man3/ceil.3:116
msgid ""
"B<floor>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), B<trunc>"
"(3)"
msgstr ""
"B<floor>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), B<trunc>"
"(3)"

#. type: TH
#: build/C/man3/copysign.3:31
#, no-wrap
msgid "COPYSIGN"
msgstr "COPYSIGN"

#. type: TH
#: build/C/man3/copysign.3:31
#, no-wrap
msgid "2012-03-25"
msgstr "2012-03-25"

#. type: Plain text
#: build/C/man3/copysign.3:34
msgid "copysign, copysignf, copysignl - copy sign of a number"
msgstr "copysign, copysignf, copysignl - 数の符号をコピーする"

#. type: Plain text
#: build/C/man3/copysign.3:39
#, no-wrap
msgid "B<double copysign(double >I<x>B<, double >I<y>B<);>\n"
msgstr "B<double copysign(double >I<x>B<, double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/copysign.3:41
#, no-wrap
msgid "B<float copysignf(float >I<x>B<, float >I<y>B<);>\n"
msgstr "B<float copysignf(float >I<x>B<, float >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/copysign.3:43
#, no-wrap
msgid "B<long double copysignl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr "B<long double copysignl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/copysign.3:56
msgid "B<copysign>(), B<copysignf>(), B<copysignl>():"
msgstr "B<copysign>(), B<copysignf>(), B<copysignl>():"

#. type: Plain text
#: build/C/man3/copysign.3:59
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/copysign.3:69
msgid ""
"The B<copysign>()  functions return a value whose absolute value matches "
"that of I<x>, but whose sign bit matches that of I<y>."
msgstr ""
"関数 B<copysign>()  は絶対値が I<x> に等しく、符号ビットが I<y> に等しい値を"
"返す。"

#. type: Plain text
#: build/C/man3/copysign.3:75
msgid ""
"For example, I<copysign(42.0,\\ -1.0)> and I<copysign(-42.0, -1.0)> both "
"return -42.0."
msgstr ""
"例えば、\n"
"I<copysign(42.0,\\ -1.0)> と I<copysign(-42.0, -1.0)> はどちらも -42.0 を返"
"す。"

#. type: Plain text
#: build/C/man3/copysign.3:80
msgid ""
"On success, these functions return a value whose magnitude is taken from "
"I<x> and whose sign is taken from I<y>."
msgstr ""
"成功すると、これらの関数は、その絶対値は I<x> に等しく、符号は I<y> に等しい"
"値を返す。"

#. type: Plain text
#: build/C/man3/copysign.3:83
msgid "If I<x> is a NaN, a NaN with the sign bit of I<y> is returned."
msgstr "I<x> が NaN の場合、NaN に I<y> の符号ビットをつけて返す。"

#. type: Plain text
#: build/C/man3/copysign.3:90 build/C/man3/nextafter.3:172
#: build/C/man3/signbit.3:65
msgid ""
"C99, POSIX.1-2001.  This function is defined in IEC 559 (and the appendix "
"with recommended functions in IEEE 754/IEEE 854)."
msgstr ""
"C99, POSIX.1-2001.  この関数は IEC 559 で定義されている (また IEEE 754/IEEE "
"854 では付録で推奨関数として定義されている)。"

#. type: Plain text
#: build/C/man3/copysign.3:95
msgid ""
"On architectures where the floating-point formats are not IEEE 754 "
"compliant, the B<copysign>()  functions may treat a negative zero as "
"positive."
msgstr ""
"浮動小数点形式が IEEE 754 準拠でないアーキテクチャでは、 B<copysign>()  は負"
"の 0 を正として扱うことがある。"

#. type: Plain text
#: build/C/man3/copysign.3:97
msgid "B<signbit>(3)"
msgstr "B<signbit>(3)"

#. type: TH
#: build/C/man3/cos.3:34
#, no-wrap
msgid "COS"
msgstr "COS"

#. type: Plain text
#: build/C/man3/cos.3:37
msgid "cos, cosf, cosl - cosine function"
msgstr "cos, cosf, cosl - 余弦 (コサイン) 関数"

#. type: Plain text
#: build/C/man3/cos.3:42
#, no-wrap
msgid "B<double cos(double >I<x>B<);>\n"
msgstr "B<double cos(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cos.3:44
#, no-wrap
msgid "B<float cosf(float >I<x>B<);>\n"
msgstr "B<float cosf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cos.3:46
#, no-wrap
msgid "B<long double cosl(long double >I<x>B<);>\n"
msgstr "B<long double cosl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cos.3:58
msgid "B<cosf>(), B<cosl>():"
msgstr "B<cosf>(), B<cosl>():"

#. type: Plain text
#: build/C/man3/cos.3:71
msgid ""
"The B<cos>()  function returns the cosine of I<x>, where I<x> is given in "
"radians."
msgstr ""
"B<cos>()  関数は I<x> の余弦 (コサイン) の値を返す。 I<x> はラジアン単位で指"
"定する。"

#. type: Plain text
#: build/C/man3/cos.3:74
msgid "On success, these functions return the cosine of I<x>."
msgstr "成功すると、これらの関数は I<x> の余弦を返す。"

#. type: TP
#: build/C/man3/cos.3:91 build/C/man3/fmod.3:113 build/C/man3/ilogb.3:130
#: build/C/man3/sin.3:95 build/C/man3/sincos.3:59 build/C/man3/tan.3:110
#, no-wrap
msgid "Domain error: I<x> is an infinity"
msgstr "領域エラー (domain error): I<x> が無限大である"

#. type: Plain text
#: build/C/man3/cos.3:100 build/C/man3/fmod.3:122 build/C/man3/sin.3:104
#: build/C/man3/tan.3:119
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> に B<EDOM> が設定される (「バグ」の節も参照)。 不正 (invalid) 浮動小"
"数点例外 (B<FE_INVALID>) が上がる。"

#. type: Plain text
#: build/C/man3/cos.3:106 build/C/man3/cosh.3:123 build/C/man3/erf.3:130
#: build/C/man3/erfc.3:128 build/C/man3/hypot.3:164 build/C/man3/log2.3:96
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD."
msgstr ""
"C99, POSIX.1-2001.  I<double> 版の関数は SVr4, 4.3BSD にも準拠している。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6782
#. type: Plain text
#: build/C/man3/cos.3:113 build/C/man3/sin.3:117 build/C/man3/tan.3:142
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred."
msgstr ""
"バージョン 2.10 より前の glibc の実装では、 領域エラーが発生した際に、 "
"I<error> に B<EDOM> が設定されなかった。"

#. type: Plain text
#: build/C/man3/cos.3:122
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<ccos>(3), B<sin>(3), "
"B<sincos>(3), B<tan>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<ccos>(3), B<sin>(3), "
"B<sincos>(3), B<tan>(3)"

#. type: TH
#: build/C/man3/cosh.3:36
#, no-wrap
msgid "COSH"
msgstr "COSH"

#. type: Plain text
#: build/C/man3/cosh.3:39
msgid "cosh, coshf, coshl - hyperbolic cosine function"
msgstr "cosh, coshf, coshl - 双曲線余弦 (ハイパボリックコサイン) 関数"

#. type: Plain text
#: build/C/man3/cosh.3:44
#, no-wrap
msgid "B<double cosh(double >I<x>B<);>\n"
msgstr "B<double cosh(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cosh.3:46
#, no-wrap
msgid "B<float coshf(float >I<x>B<);>\n"
msgstr "B<float coshf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cosh.3:48
#, no-wrap
msgid "B<long double coshl(long double >I<x>B<);>\n"
msgstr "B<long double coshl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/cosh.3:60
msgid "B<coshf>(), B<coshl>():"
msgstr "B<coshf>(), B<coshl>():"

#. type: Plain text
#: build/C/man3/cosh.3:73
msgid ""
"The B<cosh>()  function returns the hyperbolic cosine of I<x>, which is "
"defined mathematically as:"
msgstr ""
"B<cosh>()  関数は双曲線余弦 (ハイパボリックコサイン) の値を返す。 数学的には"
"以下のように定義される."

#. type: Plain text
#: build/C/man3/cosh.3:76
#, no-wrap
msgid "    cosh(x) = (exp(x) + exp(-x)) / 2\n"
msgstr "    cosh(x) = (exp(x) + exp(-x)) / 2\n"

#. type: Plain text
#: build/C/man3/cosh.3:80
msgid "On success, these functions return the hyperbolic cosine of I<x>."
msgstr "成功すると、これらの関数は I<x> の双曲線余弦を返す。"

#. type: Plain text
#: build/C/man3/cosh.3:88 build/C/man3/erfc.3:83
msgid "If I<x> is +0 or -0, 1 is returned."
msgstr "I<x> が +0 か -0 の場合、1 が返される。"

#. type: Plain text
#: build/C/man3/cosh.3:93 build/C/man3/lgamma.3:107
msgid ""
"If I<x> is positive infinity or negative infinity, positive infinity is "
"returned."
msgstr "I<x> が正の無限大か負の無限大の場合、正の無限大が返される。"

#. type: Plain text
#: build/C/man3/cosh.3:102 build/C/man3/exp.3:104
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"+B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, respectively."
msgstr ""
"結果がオーバーフローする場合、範囲エラーが発生し、 各関数はそれぞれ "
"+B<HUGE_VAL>, +B<HUGE_VALF>, +B<HUGE_VALL> を返す。"

#. type: TP
#: build/C/man3/cosh.3:109 build/C/man3/fdim.3:66 build/C/man3/fma.3:133
#: build/C/man3/hypot.3:135 build/C/man3/lgamma.3:144
#: build/C/man3/nextafter.3:145 build/C/man3/sinh.3:114 build/C/man3/tan.3:119
#: build/C/man3/tgamma.3:128 build/C/man3/y0.3:204
#, no-wrap
msgid "Range error: result overflow"
msgstr "範囲エラー (range error): 結果のオーバーフロー"

#. type: Plain text
#: build/C/man3/cosh.3:117 build/C/man3/exp.3:119 build/C/man3/hypot.3:143
#: build/C/man3/ldexp.3:121 build/C/man3/lgamma.3:154 build/C/man3/pow.3:305
#: build/C/man3/sinh.3:122 build/C/man3/tgamma.3:136
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""
"I<errno> に B<ERANGE> が設定される。 オーバーフロー浮動小数点例外 "
"(B<FE_OVERFLOW>)  が上がる。"

#. type: Plain text
#: build/C/man3/cosh.3:128
msgid ""
"In glibc version 2.3.4 and earlier, an overflow floating-point "
"(B<FE_OVERFLOW>)  exception is not raised when an overflow occurs."
msgstr ""
"glibc バージョン 2.3.4 以前では、オーバーフローが発生したときに、 オーバーフ"
"ロー浮動小数点例外 (B<FE_OVERFLOW>)  が上がらなかった。"

#. type: Plain text
#: build/C/man3/cosh.3:135
msgid ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<ccos>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<ccos>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: build/C/man3/div.3:34
#, no-wrap
msgid "DIV"
msgstr "DIV"

#. type: TH
#: build/C/man3/div.3:34
#, no-wrap
msgid "2012-04-17"
msgstr "2012-04-17"

#. type: Plain text
#: build/C/man3/div.3:38
msgid ""
"div, ldiv, lldiv, imaxdiv - compute quotient and remainder of an integer "
"division"
msgstr "div, ldiv, lldiv, imaxdiv - integer 型の割算の商と余りを計算する"

#. type: Plain text
#: build/C/man3/div.3:43
#, no-wrap
msgid "B<div_t div(int >I<numerator>B<, int >I<denominator>B<);>\n"
msgstr "B<div_t div(int >I<numerator>B<, int >I<denominator>B<);>\n"

#. type: Plain text
#: build/C/man3/div.3:45
#, no-wrap
msgid "B<ldiv_t ldiv(long >I<numerator>B<, long >I<denominator>B<);>\n"
msgstr "B<ldiv_t ldiv(long >I<numerator>B<, long >I<denominator>B<);>\n"

#. type: Plain text
#: build/C/man3/div.3:47
#, no-wrap
msgid "B<lldiv_t lldiv(long long >I<numerator>B<, long long >I<denominator>B<);>\n"
msgstr "B<lldiv_t lldiv(long long >I<numerator>B<, long long >I<denominator>B<);>\n"

#. type: Plain text
#: build/C/man3/div.3:51
#, no-wrap
msgid "B<imaxdiv_t imaxdiv(intmax_t >I<numerator>B<, intmax_t >I<denominator>B<);>\n"
msgstr "B<imaxdiv_t imaxdiv(intmax_t >I<numerator>B<, intmax_t >I<denominator>B<);>\n"

#. type: Plain text
#: build/C/man3/div.3:60
msgid "B<lldiv>():"
msgstr "B<lldiv>():"

#. type: Plain text
#: build/C/man3/div.3:78
msgid ""
"The B<div>()  function computes the value I<numerator>/I<denominator> and "
"returns the quotient and remainder in a structure named I<div_t> that "
"contains two integer members (in unspecified order) named I<quot> and "
"I<rem>.  The quotient is rounded toward zero.  The result satisfies "
"I<quot>*I<denominator>+I<rem> = I<numerator>."
msgstr ""
"B<div>()  関数は I<numerator>/I<denominator> の値を計算する。 商と余りは、 "
"I<quot> (商) と I<rem> (余り) という名前の 2 つの integer 型メンバを含む "
"I<div_t> という構造体の中に返される (メンバの順番は不定である)。 商は 0 に近"
"い方に丸められる。 結果は I<quot>*I<denominator>+I<rem> = I<numerator> を満た"
"す。"

#. type: Plain text
#: build/C/man3/div.3:89
msgid ""
"The B<ldiv>(), B<lldiv>(), and B<imaxdiv>()  functions do the same, dividing "
"numbers of the indicated type and returning the result in a structure of the "
"indicated name, in all cases with fields I<quot> and I<rem> of the same type "
"as the function arguments."
msgstr ""
"B<ldiv>(), B<lldiv>(), B<imaxdiv>()  関数は同様な動作をし、 上に示した型の数"
"値を割算して、上に示した名前の構造体に結果を返す。 どの場合でもフィールド "
"I<quot> と I<rem> は、 関数の引き数と同じ型である。"

#. type: Plain text
#: build/C/man3/div.3:91
msgid "The I<div_t> (etc.) structure."
msgstr "I<div_t> (などの) 構造体。"

#. type: Plain text
#: build/C/man3/div.3:98
msgid ""
"SVr4, 4.3BSD, C89. C99.  The functions B<lldiv>()  and B<imaxdiv>()  were "
"added in C99."
msgstr ""
"SVr4, 4.3BSD, C89, C99.\n"
"関数 B<lldiv>() と B<imaxdiv>() は C99 に追加された。"

#. type: SH
#: build/C/man3/div.3:98 build/C/man3/frexp.3:104 build/C/man3/matherr.3:275
#: build/C/man3/remainder.3:213
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/div.3:100
msgid "After"
msgstr "以下の式を計算すると、"

#. type: Plain text
#: build/C/man3/div.3:103
#, no-wrap
msgid "        div_t q = div(-5, 3);\n"
msgstr "        div_t q = div(-5, 3);\n"

#. type: Plain text
#: build/C/man3/div.3:106
msgid "the values I<q.quot> and I<q.rem> are -1 and -2, respectively."
msgstr "I<q.quot> と I<q.rem> はそれぞれ -1 と -2 になる。"

#. type: Plain text
#: build/C/man3/div.3:109
msgid "B<abs>(3), B<remainder>(3)"
msgstr "B<abs>(3), B<remainder>(3)"

#. type: TH
#: build/C/man3/erf.3:35
#, no-wrap
msgid "ERF"
msgstr "ERF"

#. type: Plain text
#: build/C/man3/erf.3:38
msgid "erf, erff, erfl, - error function"
msgstr "erf, erff, erfl - 誤差関数"

#. type: Plain text
#: build/C/man3/erf.3:45
#, no-wrap
msgid ""
"B<double erf(double >I<x>B<);>\n"
"B<float erff(float >I<x>B<);>\n"
"B<long double erfl(long double >I<x>B<);>\n"
msgstr ""
"B<double erf(double >I<x>B<);>\n"
"B<float erff(float >I<x>B<);>\n"
"B<long double erfl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/erf.3:56
msgid "B<erf>():"
msgstr "B<erf>():"

#. type: Plain text
#: build/C/man3/erf.3:59 build/C/man3/erfc.3:50 build/C/man3/fpclassify.3:53
#: build/C/man3/hypot.3:59 build/C/man3/lgamma.3:46
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/erf.3:66
msgid "B<erff>(), B<erfl>():"
msgstr "B<erff>(), B<erfl>():"

#. type: Plain text
#: build/C/man3/erf.3:79
msgid "The B<erf>()  function returns the error function of I<x>, defined as"
msgstr "B<erf>()  は I<x> の誤差関数を返す関数で、以下のように定義されている。"

#. type: TP
#: build/C/man3/erf.3:79
#, no-wrap
msgid "    erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt"
msgstr "    erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt"

#. type: Plain text
#: build/C/man3/erf.3:85
msgid ""
"On success, these functions return the error function of I<x>, a value in "
"the range [-1,\\ 1]."
msgstr ""
"成功すると、これらの関数は I<x> の誤差関数を返す。 返り値は [-1,\\ 1] の範囲"
"となる。"

#.  POSIX.1-2001 documents an optional range error (underflow)
#.  for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: build/C/man3/erf.3:98 build/C/man3/tanh.3:96
msgid "If I<x> is positive infinity (negative infinity), +1 (-1) is returned."
msgstr "I<x> が正の無限大 (負の無限大) の場合、+1 (-1) が返される。"

#. type: Plain text
#: build/C/man3/erf.3:104
msgid ""
"If I<x> is subnormal, a range error occurs, and the return value is 2*x/sqrt"
"(pi)."
msgstr ""
"I<x> が非正規化数の場合、範囲エラー (range error) が発生し、 返り値は 2*x/"
"sqrt(pi) となる。"

#. type: TP
#: build/C/man3/erf.3:111
#, no-wrap
msgid "Range error: result underflow (I<x> is subnormal)"
msgstr "範囲エラー (range error): 結果がアンダーフローする (I<x> が非正規化数)"

#.  e.g., tgamma(-172.5) on glibc 2.8/x86-32
#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: build/C/man3/erf.3:119 build/C/man3/erfc.3:117 build/C/man3/fma.3:149
#: build/C/man3/hypot.3:151 build/C/man3/nextafter.3:163
#: build/C/man3/scalb.3:166 build/C/man3/scalbln.3:148
#: build/C/man3/tgamma.3:148
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr "アンダーフロー浮動小数点例外 (B<FE_UNDERFLOW>)  が上がる。"

#.  FIXME . Is it intentional that these functions do not set errno?
#.  sin() and cos() also don't set errno; bugs have been raised for
#.  those functions.
#. type: Plain text
#: build/C/man3/erf.3:124 build/C/man3/erfc.3:122 build/C/man3/fdim.3:79
#: build/C/man3/fma.3:154 build/C/man3/log1p.3:140 build/C/man3/logb.3:143
#: build/C/man3/lrint.3:107 build/C/man3/lround.3:110
#: build/C/man3/nextafter.3:168 build/C/man3/remquo.3:122
#: build/C/man3/scalb.3:172 build/C/man3/scalbln.3:153
#: build/C/man3/sincos.3:73
msgid "These functions do not set I<errno>."
msgstr "これらの関数は I<errno> を設定しない。"

#. type: Plain text
#: build/C/man3/erf.3:134
msgid "B<cerf>(3), B<erfc>(3), B<exp>(3)"
msgstr "B<cerf>(3), B<erfc>(3), B<exp>(3)"

#. type: TH
#: build/C/man3/erfc.3:26
#, no-wrap
msgid "ERFC"
msgstr "ERFC"

#. type: Plain text
#: build/C/man3/erfc.3:29
msgid "erfc, erfcf, erfcl - complementary error function"
msgstr "erfc, erfcf, erfcl - 相補誤差関数"

#. type: Plain text
#: build/C/man3/erfc.3:36
#, no-wrap
msgid ""
"B<double erfc(double >I<x>B<);>\n"
"B<float erfcf(float >I<x>B<);>\n"
"B<long double erfcl(long double >I<x>B<);>\n"
msgstr ""
"B<double erfc(double >I<x>B<);>\n"
"B<float erfcf(float >I<x>B<);>\n"
"B<long double erfcl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/erfc.3:47
msgid "B<erfc>():"
msgstr "B<erfc>():"

#. type: Plain text
#: build/C/man3/erfc.3:57
msgid "B<erfcf>(), B<erfcl>():"
msgstr "B<erfcf>(), B<erfcl>():"

#. type: Plain text
#: build/C/man3/erfc.3:60
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600|| _ISOC99_SOURCE "
"|| _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/erfc.3:71
msgid ""
"The B<erfc>()  function returns the complementary error function of I<x>, "
"that is, 1.0 - erf(x)."
msgstr "B<erfc>()  関数は I<x> の相補誤差関数、つまり 1.0 - erf(x) を返す。"

#. type: Plain text
#: build/C/man3/erfc.3:75
msgid ""
"On success, these functions return the complementary error function of I<x>, "
"a value in the range [0,2]."
msgstr ""
"成功すると、これらの関数は I<x> の相補誤差関数を返す。 返り値は [0,2] の範囲"
"となる。"

#. type: Plain text
#: build/C/man3/erfc.3:88
msgid "If I<x> is positive infinity, +0 is returned."
msgstr "I<x> が正の無限大の場合、+0 が返される。"

#. type: Plain text
#: build/C/man3/erfc.3:93
msgid "If I<x> is negative infinity, +2 is returned."
msgstr "I<x> が負の無限大の場合、+2 が返される。"

#. type: Plain text
#: build/C/man3/erfc.3:96
msgid ""
"If the function result underflows and produces an unrepresentable value, the "
"return value is 0.0."
msgstr ""
"関数の結果がアンダーフローし、表現できない値となる場合は、 返り値は 0.0 とな"
"る。"

#.  e.g., erfc(27) on x86-32
#. type: Plain text
#: build/C/man3/erfc.3:102
msgid ""
"If the function result underflows but produces a representable (i.e., "
"subnormal) value, that value is returned, and a range error occurs."
msgstr ""
"関数の結果がアンダーフローするが、 表現できる値 (つまり非正規化数 "
"(subnormal)) となる場合は、 その値が返され、範囲エラー (range error) が発生す"
"る。"

#. type: TP
#: build/C/man3/erfc.3:109
#, no-wrap
msgid "Range error: result underflow (result is subnormal)"
msgstr "範囲エラー: 結果のアンダーフロー (結果が非正規化数)"

#. type: Plain text
#: build/C/man3/erfc.3:135
msgid ""
"The B<erfc>()  functions are provided to avoid the loss accuracy that would "
"occur for the calculation 1-erf(x) for large values of I<x> (for which the "
"value of erf(x) approaches 1)."
msgstr ""
"B<erfc>()  関数が提供されているのは、 I<x> が大きな値の場合に (erf(x) の値は "
"1 に近付いていくことで)  1-erf(x) の計算において精度が失われるのを避けるため"
"である。"

#. type: Plain text
#: build/C/man3/erfc.3:139
msgid "B<cerf>(3), B<erf>(3), B<exp>(3)"
msgstr "B<cerf>(3), B<erf>(3), B<exp>(3)"

#. type: TH
#: build/C/man3/exp.3:36
#, no-wrap
msgid "EXP"
msgstr "EXP"

#. type: Plain text
#: build/C/man3/exp.3:39
msgid "exp, expf, expl - base-e exponential function"
msgstr "exp, expf, expl - 底が e の指数関数"

#. type: Plain text
#: build/C/man3/exp.3:44
#, no-wrap
msgid "B<double exp(double >I<x>B<);>\n"
msgstr "B<double exp(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp.3:46
#, no-wrap
msgid "B<float expf(float >I<x>B<);>\n"
msgstr "B<float expf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp.3:48
#, no-wrap
msgid "B<long double expl(long double >I<x>B<);>\n"
msgstr "B<long double expl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp.3:60
msgid "B<expf>(), B<expl>():"
msgstr "B<expf>(), B<expl>():"

#. type: Plain text
#: build/C/man3/exp.3:73
msgid ""
"The B<exp>()  function returns the value of e (the base of natural "
"logarithms) raised to the power of I<x>."
msgstr "B<exp>()  関数は e の I<x> 乗の値を返す (e は自然対数の底)。"

#. type: Plain text
#: build/C/man3/exp.3:76
msgid "On success, these functions return the exponential value of I<x>."
msgstr "成功すると、これらの関数は e の I<x> 乗を返す。"

#. type: Plain text
#: build/C/man3/exp.3:91
msgid "If I<x> is negative infinity, +0 is returned."
msgstr "I<x> が負の無限大の場合、+0 が返される。"

#. type: Plain text
#: build/C/man3/exp.3:95 build/C/man3/ldexp.3:96
msgid "If the result underflows, a range error occurs, and zero is returned."
msgstr ""
"結果がアンダーフローする場合、 範囲エラー (range error) が発生し、0 が返され"
"る。"

#. type: TP
#: build/C/man3/exp.3:111 build/C/man3/expm1.3:122 build/C/man3/ldexp.3:113
#: build/C/man3/scalb.3:150 build/C/man3/scalbln.3:132
#, no-wrap
msgid "Range error, overflow"
msgstr "範囲エラー (range error)、オーバーフローの場合"

#. type: TP
#: build/C/man3/exp.3:119 build/C/man3/ldexp.3:121 build/C/man3/scalb.3:158
#: build/C/man3/scalbln.3:140
#, no-wrap
msgid "Range error, underflow"
msgstr "範囲エラー (range error)、アンダーフローの場合"

#. type: Plain text
#: build/C/man3/exp.3:127 build/C/man3/ldexp.3:129 build/C/man3/pow.3:313
msgid ""
"I<errno> is set to B<ERANGE>.  An underflow floating-point exception "
"(B<FE_UNDERFLOW>)  is raised."
msgstr ""
"I<errno> に B<ERANGE> が設定される。 アンダーフロー浮動小数点例外 "
"(B<FE_UNDERFLOW>)  が上がる。"

#. type: Plain text
#: build/C/man3/exp.3:139
msgid "B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/exp10.3:35
#, no-wrap
msgid "EXP10"
msgstr "EXP10"

#. type: TH
#: build/C/man3/exp10.3:35 build/C/man7/math_error.7:26
#: build/C/man3/pow10.3:25 build/C/man3/sincos.3:9
#, no-wrap
msgid "2008-08-11"
msgstr "2008-08-11"

#. type: Plain text
#: build/C/man3/exp10.3:38
msgid "exp10, exp10f, exp10l - base-10 exponential function"
msgstr "exp10, exp10f, exp10l - 基数が 10 の指数関数"

#. type: Plain text
#: build/C/man3/exp10.3:41 build/C/man3/fenv.3:290
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/exp10.3:45
#, no-wrap
msgid "B<double exp10(double >I<x>B<);>\n"
msgstr "B<double exp10(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp10.3:47
#, no-wrap
msgid "B<float exp10f(float >I<x>B<);>\n"
msgstr "B<float exp10f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp10.3:49
#, no-wrap
msgid "B<long double exp10l(long double >I<x>B<);>\n"
msgstr "B<long double exp10l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp10.3:57
msgid ""
"The B<exp10>()  function returns the value of 10 raised to the power of I<x>."
msgstr "B<exp10>()  関数は 10 の I<x> 乗の値を返す。"

#. type: Plain text
#: build/C/man3/exp10.3:60
msgid ""
"On success, these functions return the base-10 exponential value of I<x>."
msgstr "成功すると、これらの関数は 10 の I<x> 乗を返す。"

#. type: Plain text
#: build/C/man3/exp10.3:64 build/C/man3/exp2.3:80
msgid ""
"For various special cases, including the handling of infinity and NaN, as "
"well as overflows and underflows, see B<exp>(3)."
msgstr ""
"無限大や NaN の扱いや、オーバーフローとアンダーフローなどの さまざまな特別な"
"状況については、 B<exp>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/exp10.3:74 build/C/man3/exp2.3:88
msgid ""
"For a discussion of the errors that can occur for these functions, see B<exp>"
"(3)."
msgstr "これらの関数で発生するエラーについては、 B<exp>(3)  を参照のこと。"

#. type: SH
#: build/C/man3/exp10.3:74 build/C/man3/exp2.3:88 build/C/man3/fdim.3:79
#: build/C/man3/fenv.3:263 build/C/man3/fma.3:154 build/C/man3/fmax.3:56
#: build/C/man3/fmin.3:56 build/C/man3/log2.3:88 build/C/man3/lrint.3:107
#: build/C/man3/lround.3:110 build/C/man3/nan.3:73 build/C/man3/pow10.3:46
#: build/C/man3/remquo.3:122 build/C/man3/round.3:81
#: build/C/man3/scalbln.3:153 build/C/man3/sincos.3:73
#: build/C/man3/tgamma.3:156 build/C/man3/trunc.3:67
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/exp10.3:76 build/C/man3/exp2.3:90 build/C/man3/fdim.3:81
#: build/C/man3/fenv.3:265 build/C/man3/fma.3:156 build/C/man3/fmax.3:58
#: build/C/man3/fmin.3:58 build/C/man3/log2.3:90 build/C/man3/lrint.3:109
#: build/C/man3/lround.3:112 build/C/man3/nan.3:75 build/C/man3/pow10.3:48
#: build/C/man3/remquo.3:124 build/C/man3/round.3:83
#: build/C/man3/scalbln.3:155 build/C/man3/sincos.3:75
#: build/C/man3/tgamma.3:158 build/C/man3/trunc.3:69
msgid "These functions first appeared in glibc in version 2.1."
msgstr "これらの関数は glibc バージョン 2.1 で初めて登場した。"

#. type: Plain text
#: build/C/man3/exp10.3:78
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/exp10.3:84
msgid "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/exp2.3:36
#, no-wrap
msgid "EXP2"
msgstr "EXP2"

#. type: Plain text
#: build/C/man3/exp2.3:39
msgid "exp2, exp2f, exp2l - base-2 exponential function"
msgstr "exp2, exp2f, exp2l - 底が 2 の指数関数"

#. type: Plain text
#: build/C/man3/exp2.3:44
#, no-wrap
msgid "B<double exp2(double >I<x>B<);>\n"
msgstr "B<double exp2(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp2.3:46
#, no-wrap
msgid "B<float exp2f(float >I<x>B<);>\n"
msgstr "B<float exp2f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp2.3:48
#, no-wrap
msgid "B<long double exp2l(long double >I<x>B<);>\n"
msgstr "B<long double exp2l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/exp2.3:61
msgid "B<exp2>(), B<exp2f>(), B<exp2l>():"
msgstr "B<exp2>(), B<exp2f>(), B<exp2l>():"

#. type: Plain text
#: build/C/man3/exp2.3:73
msgid ""
"The B<exp2>()  function returns the value of 2 raised to the power of I<x>."
msgstr "B<exp2>()  関数は 2 の I<x> 乗の値を返す。"

#. type: Plain text
#: build/C/man3/exp2.3:76
msgid ""
"On success, these functions return the base-2 exponential value of I<x>."
msgstr "成功すると、これらの関数は 2 の I<x> 乗を返す。"

#. type: Plain text
#: build/C/man3/exp2.3:102
msgid "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/expm1.3:30
#, no-wrap
msgid "EXPM1"
msgstr "EXPM1"

#. type: TH
#: build/C/man3/expm1.3:30 build/C/man3/log2.3:36 build/C/man3/pow.3:35
#, no-wrap
msgid "2010-09-12"
msgstr "2010-09-12"

#. type: Plain text
#: build/C/man3/expm1.3:33
msgid "expm1, expm1f, expm1l - exponential minus 1"
msgstr "expm1, expm1f, expm1l - 引き数の指数から 1 を引いた値"

#. type: Plain text
#: build/C/man3/expm1.3:38
#, no-wrap
msgid "B<double expm1(double >I<x>B<);>\n"
msgstr "B<double expm1(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/expm1.3:40
#, no-wrap
msgid "B<float expm1f(float >I<x>B<);>\n"
msgstr "B<float expm1f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/expm1.3:42
#, no-wrap
msgid "B<long double expm1l(long double >I<x>B<);>\n"
msgstr "B<long double expm1l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/expm1.3:53
msgid "B<expm1>():"
msgstr "B<expm1>():"

#. type: Plain text
#: build/C/man3/expm1.3:64
msgid "B<expm1f>(), B<expm1l>():"
msgstr "B<expm1f>(), B<expm1l>():"

#. type: Plain text
#: build/C/man3/expm1.3:75
msgid "I<expm1(x)> returns a value equivalent to"
msgstr "B<expm1(>I<x>B<)> は以下と等しい値を返す。"

#. type: Plain text
#: build/C/man3/expm1.3:78
#, no-wrap
msgid "    exp(x) - 1\n"
msgstr "    exp(x) - 1\n"

#. type: Plain text
#: build/C/man3/expm1.3:86
msgid ""
"It is computed in a way that is accurate even if the value of I<x> is near "
"zero\\(ema case where I<exp(x) - 1> would be inaccurate due to subtraction "
"of two numbers that are nearly equal."
msgstr ""
"I<exp(x) - 1> の計算には、I<x> が 0 の近傍で引き算時の桁落ちのために 不正確と"
"なるような場合でも正確な値が計算できる方法が用いられる。"

#. type: Plain text
#: build/C/man3/expm1.3:89
msgid "On success, these functions return I<exp(x)\\ -\\ 1>."
msgstr "成功すると、これらの関数は I<exp(x)\\ -\\ 1> を返す。"

#. type: Plain text
#: build/C/man3/expm1.3:107
msgid "If I<x> is negative infinity, -1 is returned."
msgstr "I<x> が負の無限大の場合、-1 が返される。"

#. type: Plain text
#: build/C/man3/expm1.3:115
msgid ""
"If the result overflows, a range error occurs, and the functions return -"
"B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""
"結果がオーバーフローする場合、範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ -B<HUGE_VAL>, -B<HUGE_VALF>, -B<HUGE_VALL> を返す。"

#.  POSIX.1 specifies an optional range error (underflow) if
#.  x is subnormal.  Glibc does not implement this.
#. type: Plain text
#: build/C/man3/expm1.3:134
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  An overflow floating-point "
"exception (B<FE_OVERFLOW>)  is raised."
msgstr ""
"I<errno> に B<ERANGE> が設定される (「バグ」の節も参照)。 オーバーフロー浮動"
"小数点例外 (B<FE_OVERFLOW>)  が上がる。"

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6778
#. type: Plain text
#: build/C/man3/expm1.3:145
msgid ""
"For some large negative I<x> values (where the function result approaches "
"-1), B<expm1>()  raises a bogus underflow floating-point exception."
msgstr ""
"I<x> が負の大きな値の場合 (この場合には関数の結果は -1 に近付いていく)、 "
"B<expm1>()  は間違ってアンダーフロー浮動小数点例外を上げることがある。"

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6814
#.  e.g., expm1(1e5) through expm1(1.00199970127e5),
#.  but not expm1(1.00199970128e5) and beyond.
#. type: Plain text
#: build/C/man3/expm1.3:156
msgid ""
"For some large positive I<x> values, B<expm1>()  raises a bogus invalid "
"floating-point exception in addition to the expected overflow exception, and "
"returns a NaN instead of positive infinity."
msgstr ""
"I<x> が正の大きな値の場合、 B<expm1>()  は期待通りのオーバーフロー例外だけで"
"なく 間違って不正 (invalid) 浮動小数点例外を上げ、 正の無限大ではなく NaN を"
"返すことがある。"

#.  It looks like the fix was in 2.11, or possibly 2.12.
#.  I have no test system for 2.11, but 2.12 passes.
#.  From the source (sysdeps/i386/fpu/s_expm1.S) it looks
#.  like the changes were in 2.11.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6788
#. type: Plain text
#: build/C/man3/expm1.3:168
msgid ""
"Before version 2.11, the glibc implementation did not set I<errno> to "
"B<ERANGE> when a range error occurred."
msgstr ""
"バージョン 2.11 より前の glibc の実装では、 範囲エラーが発生した場合に、 "
"I<errno> に B<ERANGE> が設定されなかった。"

#. type: Plain text
#: build/C/man3/expm1.3:172
msgid "B<exp>(3), B<log>(3), B<log1p>(3)"
msgstr "B<exp>(3), B<log>(3), B<log1p>(3)"

#. type: TH
#: build/C/man3/fabs.3:32
#, no-wrap
msgid "FABS"
msgstr "FABS"

#. type: Plain text
#: build/C/man3/fabs.3:35
msgid "fabs, fabsf, fabsl - absolute value of floating-point number"
msgstr "fabs, fabsf, fabsl - 浮動小数点実数の絶対値"

#. type: Plain text
#: build/C/man3/fabs.3:40
#, no-wrap
msgid "B<double fabs(double >I<x>B<);>\n"
msgstr "B<double fabs(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fabs.3:42
#, no-wrap
msgid "B<float fabsf(float >I<x>B<);>\n"
msgstr "B<float fabsf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fabs.3:44
#, no-wrap
msgid "B<long double fabsl(long double >I<x>B<);>\n"
msgstr "B<long double fabsl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fabs.3:56
msgid "B<fabsf>(), B<fabsl>():"
msgstr "B<fabsf>(), B<fabsl>():"

#. type: Plain text
#: build/C/man3/fabs.3:69
msgid ""
"The B<fabs>()  functions return the absolute value of the floating-point "
"number I<x>."
msgstr "B<fabs>()  関数群は浮動小数点実数 I<x> の絶対値を返す。"

#. type: Plain text
#: build/C/man3/fabs.3:72
msgid "These functions return the absolute value of I<x>."
msgstr "これらの関数は I<x> の絶対値を返す。"

#. type: Plain text
#: build/C/man3/fabs.3:80
msgid "If I<x> is -0, +0 is returned."
msgstr "I<x> が -0 の場合、+0 が返される。"

#. type: Plain text
#: build/C/man3/fabs.3:84
msgid ""
"If I<x> is negative infinity or positive infinity, positive infinity is "
"returned."
msgstr "I<x> が負の無限大か正の無限大の場合、正の無限大が返される。"

#. type: Plain text
#: build/C/man3/fabs.3:99
msgid "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"
msgstr "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"

#. type: TH
#: build/C/man3/fdim.3:9
#, no-wrap
msgid "FDIM"
msgstr "FDIM"

#. type: Plain text
#: build/C/man3/fdim.3:12
msgid "fdim, fdimf, fdiml - positive difference"
msgstr "fdim, fdimf, fdiml - 正の差分を計算する"

#. type: Plain text
#: build/C/man3/fdim.3:14 build/C/man3/fmax.3:14 build/C/man3/fmin.3:14
#: build/C/man3/gamma.3:14 build/C/man3/ilogb.3:34 build/C/man3/logb.3:34
#: build/C/man3/nan.3:16 build/C/man3/nextafter.3:17 build/C/man3/scalb.3:33
#: build/C/man3/scalbln.3:33 build/C/man3/signbit.3:16
#: build/C/man3/significand.3:15 build/C/man3/tgamma.3:18
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: build/C/man3/fdim.3:16
msgid "B<double fdim(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fdim(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fdim.3:18
msgid "B<float fdimf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fdimf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fdim.3:20
msgid "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fdim.3:31
msgid "B<fdimf>(), B<fdiml>():"
msgstr "B<fdimf>(), B<fdiml>():"

#. type: Plain text
#: build/C/man3/fdim.3:42
msgid ""
"These functions return the positive difference, max(I<x>-I<y>,0), between "
"their arguments."
msgstr "これらの関数は、二つの引き数間の正の差分 max(I<x>-I<y>,0) を返す。"

#. type: Plain text
#: build/C/man3/fdim.3:44
msgid "On success, these functions return the positive difference."
msgstr "成功すると、これらの関数は正の差分を返す。"

#. type: Plain text
#: build/C/man3/fdim.3:50 build/C/man3/fma.3:63 build/C/man3/fmod.3:88
#: build/C/man3/nextafter.3:116 build/C/man3/remainder.3:130
#: build/C/man3/remquo.3:83
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr "I<x> か I<y> が NaN の場合、NaN が返される。"

#. type: Plain text
#: build/C/man3/fdim.3:59 build/C/man3/hypot.3:122
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively."
msgstr ""
"結果がオーバーフローする場合、範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> を返す。"

#.  Unable to test this case, since the best approximation of
#.  pi/2 in double precision only yields a tan() value of 1.633e16.
#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: build/C/man3/fdim.3:74 build/C/man3/fma.3:141 build/C/man3/nextafter.3:154
#: build/C/man3/scalb.3:158 build/C/man3/scalbln.3:140 build/C/man3/tan.3:129
msgid "An overflow floating-point exception (B<FE_OVERFLOW>)  is raised."
msgstr "オーバーフロー浮動小数点例外 (B<FE_OVERFLOW>)  が上がる。"

#. type: Plain text
#: build/C/man3/fdim.3:85 build/C/man3/fmin.3:62
msgid "B<fmax>(3)"
msgstr "B<fmax>(3)"

#. type: TH
#: build/C/man3/fenv.3:27
#, no-wrap
msgid "FENV"
msgstr "FENV"

#. type: TH
#: build/C/man3/fenv.3:27
#, no-wrap
msgid "2010-10-31"
msgstr "2010-10-31"

#. type: TH
#: build/C/man3/fenv.3:27 build/C/man7/math_error.7:26
#: build/C/man3/matherr.3:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/fenv.3:33
msgid ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, "
"fetestexcept, fegetenv, fegetround, feholdexcept, fesetround, fesetenv, "
"feupdateenv, feenableexcept, fedisableexcept, fegetexcept - floating-point "
"rounding and exception handling"
msgstr ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, "
"fetestexcept, fegetenv, fegetround, feholdexcept, fesetround, fesetenv, "
"feupdateenv, feenableexcept, fedisableexcept, fegetexcept - 浮動小数点の丸め"
"と例外の取り扱い"

#. type: Plain text
#: build/C/man3/fenv.3:36 build/C/man3/fenv.3:292
#, no-wrap
msgid "B<#include E<lt>fenv.hE<gt>>\n"
msgstr "B<#include E<lt>fenv.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fenv.3:38
#, no-wrap
msgid "B<int feclearexcept(int >I<excepts>B<);>\n"
msgstr "B<int feclearexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:40
#, no-wrap
msgid "B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
msgstr "B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:42
#, no-wrap
msgid "B<int feraiseexcept(int >I<excepts>B<);>\n"
msgstr "B<int feraiseexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:44
#, no-wrap
msgid "B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
msgstr "B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:46
#, no-wrap
msgid "B<int fetestexcept(int >I<excepts>B<);>\n"
msgstr "B<int fetestexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:48
#, no-wrap
msgid "B<int fegetround(void);>\n"
msgstr "B<int fegetround(void);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:50
#, no-wrap
msgid "B<int fesetround(int >I<rounding_mode>B<);>\n"
msgstr "B<int fesetround(int >I<rounding_mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:52
#, no-wrap
msgid "B<int fegetenv(fenv_t *>I<envp>B<);>\n"
msgstr "B<int fegetenv(fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:54
#, no-wrap
msgid "B<int feholdexcept(fenv_t *>I<envp>B<);>\n"
msgstr "B<int feholdexcept(fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:56
#, no-wrap
msgid "B<int fesetenv(const fenv_t *>I<envp>B<);>\n"
msgstr "B<int fesetenv(const fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:58
#, no-wrap
msgid "B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"
msgstr "B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:64
msgid ""
"These eleven functions were defined in C99, and describe the handling of "
"floating-point rounding and exceptions (overflow, zero-divide, etc.)."
msgstr ""
"これらの 11 個の関数は C99 で定義されており、 浮動小数点の丸めと例外 (オー"
"バーフロー、ゼロによる除算など)  の取り扱いを規定する。"

#. type: SS
#: build/C/man3/fenv.3:64
#, no-wrap
msgid "Exceptions"
msgstr "例外"

#. type: Plain text
#: build/C/man3/fenv.3:69
msgid ""
"The I<divide-by-zero> exception occurs when an operation on finite numbers "
"produces infinity as exact answer."
msgstr ""
"I<divide-by-zero> 例外は、有限の数値に対する演算が、 無限大の答えを生成するよ"
"うな場合に起こる。"

#. type: Plain text
#: build/C/man3/fenv.3:75
msgid ""
"The I<overflow> exception occurs when a result has to be represented as a "
"floating-point number, but has (much) larger absolute value than the largest "
"(finite) floating-point number that is representable."
msgstr ""
"I<overflow> 例外は、結果が浮動小数点数値で表記されなければならないのに、 その"
"絶対値が表現可能な浮動小数点数の (有限の) 最大値よりも (ずっと) 大きくなって"
"しまうような場合に起こる。"

#. type: Plain text
#: build/C/man3/fenv.3:82
msgid ""
"The I<underflow> exception occurs when a result has to be represented as a "
"floating-point number, but has smaller absolute value than the smallest "
"positive normalized floating-point number (and would lose much accuracy when "
"represented as a denormalized number)."
msgstr ""
"I<underflow> 例外は、結果が浮動小数点数値で表記されなければならないのに、 そ"
"の絶対値が正の正規化浮動小数点数の最小値よりも 小さくなってしまう (そして 非"
"正規化数で表現した場合に非常に精度を失ってしまう)  ような場合に起こる。"

#. type: Plain text
#: build/C/man3/fenv.3:92
msgid ""
"The I<inexact> exception occurs when the rounded result of an operation is "
"not equal to the infinite precision result.  It may occur whenever "
"I<overflow> or I<underflow> occurs."
msgstr ""
"I<inexact> 例外は、丸め後の演算結果が、 無限精度の結果と異なるような場合に起"
"こる。 I<overflow> 例外か I<underflow> 例外が起きたときには、常にこの例外も起"
"こる。"

#. type: Plain text
#: build/C/man3/fenv.3:97
msgid ""
"The I<invalid> exception occurs when there is no well-defined result for an "
"operation, as for 0/0 or infinity - infinity or sqrt(-1)."
msgstr ""
"I<invalid> 例外は、演算結果がうまく定義できない結果を生じるような場合に起こ"
"る。 例えば 0/0、無限大 - 無限大、sqrt(-1) など。"

#. type: SS
#: build/C/man3/fenv.3:97
#, no-wrap
msgid "Exception handling"
msgstr "例外処理"

#. type: Plain text
#: build/C/man3/fenv.3:103
msgid ""
"Exceptions are represented in two ways: as a single bit (exception present/"
"absent), and these bits correspond in some implementation-defined way with "
"bit positions in an integer, and also as an opaque structure that may "
"contain more information about the exception (perhaps the code address where "
"it occurred)."
msgstr ""
"例外の表し方には 2 つの方法がある。 ひとつは、単一のビットで (例外があったか"
"なかったかを) 表す方法で、 これらのビットは整数のあるビット位置に対応し、ビッ"
"トの対応付けは 実装依存である。もう一つは、内部構造体を使って表す方法で、 こ"
"の方法の方が例外に関するより多くの情報 (例えば例外が起こったコードのアドレス"
"など) が含まれる。"

#. type: Plain text
#: build/C/man3/fenv.3:119
msgid ""
"Each of the macros B<FE_DIVBYZERO>, B<FE_INEXACT>, B<FE_INVALID>, "
"B<FE_OVERFLOW>, B<FE_UNDERFLOW> is defined when the implementation supports "
"handling of the corresponding exception, and if so then defines the "
"corresponding bit(s), so that one can call exception handling functions, for "
"example, using the integer argument B<FE_OVERFLOW>|B<FE_UNDERFLOW>.  Other "
"exceptions may be supported.  The macro B<FE_ALL_EXCEPT> is the bitwise OR "
"of all bits corresponding to supported exceptions."
msgstr ""
"B<FE_DIVBYZERO>, B<FE_INEXACT>, B<FE_INVALID>, B<FE_OVERFLOW>, "
"B<FE_UNDERFLOW> の各マクロは、それぞれ対応する例外の処理を 実装がサポートして"
"いる場合に定義される。 このとき対応するビットをそれぞれ定義することになるの"
"で、 例外処理関数の呼び出しを、例えば B<FE_OVERFLOW>|B<FE_UNDERFLOW> という整"
"数の引き数を用いて行うことができる。 他の例外もサポートされているかもしれな"
"い。 B<FE_ALL_EXCEPT> マクロは、サポートされている例外に対応するビットが全て"
"セットされている (サポートされている例外全ての論理和である)。"

#. type: Plain text
#: build/C/man3/fenv.3:124
msgid ""
"The B<feclearexcept>()  function clears the supported exceptions represented "
"by the bits in its argument."
msgstr ""
"B<feclearexcept>()  関数は、引き数 I<excepts> のビット列で指定された例外をク"
"リアする (処理は実装でサポートされている例外についてのみ行われる)。"

#. type: Plain text
#: build/C/man3/fenv.3:132
msgid ""
"The B<fegetexceptflag>()  function stores a representation of the state of "
"the exception flags represented by the argument I<excepts> in the opaque "
"object I<*flagp>."
msgstr ""
"B<fegetexceptflag>()  関数は、引き数 I<excepts> で指定された例外フラグの状態"
"を I<*flagp> が指す内部オブジェクトに保存する。"

#. type: Plain text
#: build/C/man3/fenv.3:137
msgid ""
"The B<feraiseexcept>()  function raises the supported exceptions represented "
"by the bits in I<excepts>."
msgstr ""
"B<feraiseexcept>()  関数は、 I<excepts> のビット列で指定された例外のうち、 実"
"装がサポートしているものを発生させる。"

#. type: Plain text
#: build/C/man3/fenv.3:148
msgid ""
"The B<fesetexceptflag>()  function sets the complete status for the "
"exceptions represented by I<excepts> to the value I<*flagp>.  This value "
"must have been obtained by an earlier call of B<fegetexceptflag>()  with a "
"last argument that contained all bits in I<excepts>."
msgstr ""
"B<fesetexceptflag>()  関数は、 I<excepts> で指定された例外に対応するフラグの"
"状態を I<*flagp> の値に設定する。 I<*flagp> の値は、この関数を呼ぶ前に "
"B<fegetexceptflag>()  関数を呼び出して取得しておかなければならない (このと"
"き、 B<fegetexceptflag>()  の最後の引き数には、 B<fesetexceptflag>()  に渡す "
"I<excepts> のすべてのビットを含む値を指定すること)。"

#. type: Plain text
#: build/C/man3/fenv.3:155
msgid ""
"The B<fetestexcept>()  function returns a word in which the bits are set "
"that were set in the argument I<excepts> and for which the corresponding "
"exception is currently set."
msgstr ""
"B<fetestexcept>()  関数は、 I<excepts> 引き数でセットされているビットのう"
"ち、 現在設定されている例外に対応するビットが 1 になったワードを返す。"

#. type: SS
#: build/C/man3/fenv.3:155
#, no-wrap
msgid "Rounding mode"
msgstr "丸めモード"

#. type: Plain text
#: build/C/man3/fenv.3:163
msgid ""
"The rounding mode determines how the result of floating-point operations is "
"treated when the result cannot be exactly represented in the significand.  "
"Various rounding modes may be provided: round to nearest (the default), "
"round up (toward positive infinity), round down (toward negative infinity), "
"and round toward zero."
msgstr ""
"丸めモードは、結果が仮数部だけで正確に表現できない際に、 浮動小数点操作の結果"
"をどのように扱うかを決めるものである。 さまざまな丸めモードを提供することがで"
"きる: 最も近い値に丸める (デフォルト)、 (正の無限大に向かって) 大きくなる方向"
"に丸める、 (負の無限大に向かって) 小さくなる方向に丸める、 0 に向けて丸める、"
"である。"

#. type: Plain text
#: build/C/man3/fenv.3:172
msgid ""
"Each of the macros B<FE_TONEAREST>, B<FE_UPWARD>, B<FE_DOWNWARD>, and "
"B<FE_TOWARDZERO> is defined when the implementation supports getting and "
"setting the corresponding rounding direction."
msgstr ""
"B<FE_TONEAREST>, B<FE_UPWARD>, B<FE_DOWNWARD>, B<FE_TOWARDZERO> の各マクロ"
"は、それぞれ対応する丸めの方向を 実装がサポートしている場合に定義される。"

#. type: Plain text
#: build/C/man3/fenv.3:177
msgid ""
"The B<fegetround>()  function returns the macro corresponding to the current "
"rounding mode."
msgstr "B<fegetround>()  関数は現在の丸めモードに対応するマクロを返す。"

#. type: Plain text
#: build/C/man3/fenv.3:182
msgid ""
"The B<fesetround>()  function sets the rounding mode as specified by its "
"argument and returns zero when it was successful."
msgstr ""
"B<fesetround>()  関数は丸めモードを引き数に与えられた値にし、 成功したらゼロ"
"を返す。"

#. type: Plain text
#: build/C/man3/fenv.3:190
msgid ""
"C99 and POSIX.1-2008 specify an identifier, B<FLT_ROUNDS>, defined in "
"I<E<lt>float.hE<gt>>, which indicates the implementation-defined rounding "
"behavior for floating-point addition.  This identifier has one of the "
"following values:"
msgstr ""
"C99 と POSIX.1-2008 では B<FLT_ROUNDS> という識別子が規定されており、 "
"I<E<lt>float.hE<gt>> で定義されている。この識別子は 浮動小数点数の加算につい"
"ての実装定義された丸め動作を表し、 以下のいずれかの値を持つ。"

#. type: IP
#: build/C/man3/fenv.3:190
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: build/C/man3/fenv.3:192
msgid "The rounding mode is not determinable."
msgstr "丸めモードは決められていない。"

#. type: IP
#: build/C/man3/fenv.3:192
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man3/fenv.3:194
msgid "Rounding is toward 0."
msgstr "0 に向けて丸める。"

#. type: IP
#: build/C/man3/fenv.3:194
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man3/fenv.3:196
msgid "Rounding is toward nearest number."
msgstr "最も近い数に丸める。"

#. type: IP
#: build/C/man3/fenv.3:196
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man3/fenv.3:198
msgid "Rounding is toward positive infinity."
msgstr "正の無限大に向けて丸める。"

#. type: IP
#: build/C/man3/fenv.3:198
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: build/C/man3/fenv.3:200
msgid "Rounding is toward negative infinity."
msgstr "負の無限大に向けて丸める。"

#. type: Plain text
#: build/C/man3/fenv.3:202
msgid "Other values represent machine-dependent, nonstandard rounding modes."
msgstr "他の値はマシン依存であり、標準的ではない丸めモードである。"

#. type: Plain text
#: build/C/man3/fenv.3:208
msgid ""
"The value of B<FLT_ROUNDS> should reflect the current rounding mode as set "
"by B<fesetround>()  (but see BUGS)."
msgstr ""
"B<FLT_ROUNDS> の値には、 B<fesetround>()  で設定された現在の丸めモードが反映"
"されるべきである (但し、「バグ」の節を参照)。"

#. type: SS
#: build/C/man3/fenv.3:208
#, no-wrap
msgid "Floating-point environment"
msgstr "浮動小数点関連の環境"

#. type: Plain text
#: build/C/man3/fenv.3:220
msgid ""
"The entire floating-point environment, including control modes and status "
"flags, can be handled as one opaque object, of type I<fenv_t>.  The default "
"environment is denoted by B<FE_DFL_ENV> (of type I<const fenv_t *>).  This "
"is the environment setup at program start and it is defined by ISO C to have "
"round to nearest, all exceptions cleared and a nonstop (continue on "
"exceptions) mode."
msgstr ""
"浮動小数点関連の環境の全体は、 制御モードや状態フラグも含め、 I<fenv_t> 型の"
"内部オブジェクト一つで取り扱うことができる。 デフォルトの環境は、 (I<const "
"fenv_t *> 型の)  B<FE_DFL_ENV> で示されるものである。 これはプログラムの開始"
"時に構築される環境であり、 ISO C では、丸めモードを最も近い値への丸め "
"(B<FE_TONEAREST>)  に設定し、すべての例外をクリアし、不停止 (nonstop)  (例外"
"が起きても継続する) モードとするように規定されている。"

#. type: Plain text
#: build/C/man3/fenv.3:225
msgid ""
"The B<fegetenv>()  function saves the current floating-point environment in "
"the object I<*envp>."
msgstr ""
"B<fegetenv>()  関数は、現在の浮動小数点環境を、オブジェクト I<*envp> に保存す"
"る。"

#. type: Plain text
#: build/C/man3/fenv.3:232
msgid ""
"The B<feholdexcept>()  function does the same, then clears all exception "
"flags, and sets a nonstop (continue on exceptions) mode, if available.  It "
"returns zero when successful."
msgstr ""
"B<feholdexcept>()  関数も同じ動作を行い、 さらに可能であれば、全ての例外フラ"
"グをクリアし、 nonstop (例外時にも実行を継続) モードに設定する。"

#. type: Plain text
#: build/C/man3/fenv.3:245
msgid ""
"The B<fesetenv>()  function restores the floating-point environment from the "
"object I<*envp>.  This object must be known to be valid, for example, the "
"result of a call to B<fegetenv>()  or B<feholdexcept>()  or equal to "
"B<FE_DFL_ENV>.  This call does not raise exceptions."
msgstr ""
"B<fesetenv>()  関数は、浮動小数点環境を、オブジェクト I<*envp> から取り出した"
"値に戻す。 このオブジェクトは、有効であることが事前に分かっていなければならな"
"い。 例えば、 B<fegetenv>()  や B<feholdexcept>()  を呼び出した結果であると"
"か、 B<FE_DFL_ENV> に等しいとかでなければならない。 この関数の呼び出しは例外"
"を発生しない。"

#. type: Plain text
#: build/C/man3/fenv.3:258
msgid ""
"The B<feupdateenv>()  function installs the floating-point environment "
"represented by the object I<*envp>, except that currently raised exceptions "
"are not cleared.  After calling this function, the raised exceptions will be "
"a bitwise OR of those previously set with those in I<*envp>.  As before, the "
"object I<*envp> must be known to be valid."
msgstr ""
"B<feupdateenv>()  関数は、オブジェクト I<*envp> が表現する浮動小数点環境をイ"
"ンストールする。 ただし、現在発生している例外はクリアされない。 この関数を呼"
"んだ後に立っている例外は、 関数を呼ぶ前の値と I<*envp> の値とのビットごとの "
"OR を取ったものになる。 上記と同様に、オブジェクト I<*envp> は、事前に有効で"
"あることが分かっていなければならない。"

#.  Earlier seven of these functions were listed as returning void.
#.  This was corrected in Corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001(E))
#.  of the C99 Standard.
#. type: Plain text
#: build/C/man3/fenv.3:263
msgid ""
"These functions return zero on success and nonzero if an error occurred."
msgstr "これらの関数は、成功の場合 0 を返し、エラーが発生すると 0 以外を返す。"

#. type: Plain text
#: build/C/man3/fenv.3:267
msgid "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."
msgstr "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."

#. type: SS
#: build/C/man3/fenv.3:268
#, no-wrap
msgid "Glibc notes"
msgstr "glibc での注意"

#. type: Plain text
#: build/C/man3/fenv.3:287
msgid ""
"If possible, the GNU C Library defines a macro B<FE_NOMASK_ENV> which "
"represents an environment where every exception raised causes a trap to "
"occur.  You can test for this macro using B<#ifdef>.  It is only defined if "
"B<_GNU_SOURCE> is defined.  The C99 standard does not define a way to set "
"individual bits in the floating-point mask, for example, to trap on specific "
"flags.  Since version 2.2, glibc supports the functions B<feenableexcept>()  "
"and B<fedisableexcept>()  to set individual floating-point traps, and "
"B<fegetexcept>()  to query the state."
msgstr ""
"可能な場合には、GNU C Library はマクロ B<FE_NOMASK_ENV> を定義する。このマク"
"ロはすべての例外でトラップが生じるような環境を表す。 B<#ifdef> を使ってこのマ"
"クロをテストできる。これは B<_GNU_SOURCE> が定義されている場合に限って定義さ"
"れる。 C99 標準は浮動小数点マスク (例えば特定のフラグでのトラップなど)  の各"
"ビットの設定方法については定義していない。 バージョン 2.2 以降の glibc は、 "
"B<feenableexcept>()  関数と B<fedisableexcept>()  関数をサポートしており、 "
"各々の浮動小数点トラップを設定できるようになっている。 また B<fegetexcept>"
"()  によって状態の問い合わせもできるようになっている。"

#. type: Plain text
#: build/C/man3/fenv.3:294
#, no-wrap
msgid "B<int feenableexcept(int >I<excepts>B<);>\n"
msgstr "B<int feenableexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:296
#, no-wrap
msgid "B<int fedisableexcept(int >I<excepts>B<);>\n"
msgstr "B<int fedisableexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:298
#, no-wrap
msgid "B<int fegetexcept(void);>\n"
msgstr "B<int fegetexcept(void);>\n"

#. type: Plain text
#: build/C/man3/fenv.3:312
msgid ""
"The B<feenableexcept>()  and B<fedisableexcept>()  functions enable "
"(disable) traps for each of the exceptions represented by I<excepts> and "
"return the previous set of enabled exceptions when successful, and -1 "
"otherwise.  The B<fegetexcept>()  function returns the set of all currently "
"enabled exceptions."
msgstr ""
"B<feenableexcept>()  関数と B<fedisableexcept>()  関数は I<excepts> によって"
"表現される各例外のトラップを有効 (無効) にする。 成功した場合は直前に有効に"
"なっていた例外のセットを返す。 失敗した場合は -1 を返す。 B<fegetexcept>()  "
"関数は現在有効になっている例外全てからなるセットを返す。"

#.  Aug 08, glibc 2.8
#.  See http://gcc.gnu.org/ml/gcc/2002-02/msg01535.html
#. type: Plain text
#: build/C/man3/fenv.3:323
msgid ""
"C99 specifies that the value of B<FLT_ROUNDS> should reflect changes to the "
"current rounding mode, as set by B<fesetround>().  Currently, this does not "
"occur: B<FLT_ROUNDS> always has the value 1."
msgstr ""
"C99 の規定では、 B<FLT_ROUNDS> の値には B<fesetround>()  で設定された現在の丸"
"めモードが反映されるべきであるとされている。 現在のところ、 このようになって"
"おらず、 B<FLT_ROUNDS> は常に値 1 となる。"

#. type: Plain text
#: build/C/man3/fenv.3:325
msgid "B<math_error>(7)"
msgstr "B<math_error>(7)"

#. type: TH
#: build/C/man3/finite.3:25
#, no-wrap
msgid "FINITE"
msgstr "FINITE"

#. type: TH
#: build/C/man3/finite.3:25 build/C/man3/gamma.3:9
#, no-wrap
msgid "2008-08-05"
msgstr "2008-08-05"

#. type: Plain text
#: build/C/man3/finite.3:29
msgid ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - BSD "
"floating-point classification functions"
msgstr ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - BSD "
"の浮動小数点分類関数"

#. type: Plain text
#: build/C/man3/finite.3:34
#, no-wrap
msgid "B<int finite(double >I<x>B<);>\n"
msgstr "B<int finite(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:36
#, no-wrap
msgid "B<int finitef(float >I<x>B<);>\n"
msgstr "B<int finitef(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:38
#, no-wrap
msgid "B<int finitel(long double >I<x>B<);>\n"
msgstr "B<int finitel(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:40
#, no-wrap
msgid "B<int isinf(double >I<x>B<);>\n"
msgstr "B<int isinf(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:42
#, no-wrap
msgid "B<int isinff(float >I<x>B<);>\n"
msgstr "B<int isinff(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:44
#, no-wrap
msgid "B<int isinfl(long double >I<x>B<);>\n"
msgstr "B<int isinfl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:46
#, no-wrap
msgid "B<int isnan(double >I<x>B<);>\n"
msgstr "B<int isnan(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:48
#, no-wrap
msgid "B<int isnanf(float >I<x>B<);>\n"
msgstr "B<int isnanf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:50
#, no-wrap
msgid "B<int isnanl(long double >I<x>B<);>\n"
msgstr "B<int isnanl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/finite.3:61
msgid "B<finite>(), B<finitef>(), B<finitel>():"
msgstr "B<finite>(), B<finitef>(), B<finitel>():"

#. type: Plain text
#: build/C/man3/finite.3:63 build/C/man3/finite.3:76 build/C/man3/lgamma.3:65
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/finite.3:65 build/C/man3/fpclassify.3:58
msgid "B<isinf>():"
msgstr "B<isinf>():"

#. type: Plain text
#: build/C/man3/finite.3:67
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE;"

#. type: Plain text
#: build/C/man3/finite.3:74
msgid "B<isinff>(), B<isinfl>():"
msgstr "B<isinff>(), B<isinfl>():"

#. type: Plain text
#: build/C/man3/finite.3:78 build/C/man3/fpclassify.3:50
msgid "B<isnan>():"
msgstr "B<isnan>():"

#. type: Plain text
#: build/C/man3/finite.3:80
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE;"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE;"

#. type: Plain text
#: build/C/man3/finite.3:86
msgid "B<isnanf>(), B<isnanl>():"
msgstr "B<isnanf>(), B<isnanl>():"

#. type: Plain text
#: build/C/man3/finite.3:88 build/C/man3/gamma.3:38 build/C/man3/scalb.3:58
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: build/C/man3/finite.3:95
msgid ""
"The B<finite>()  functions return a nonzero value if I<x> is neither "
"infinite nor a \"not-a-number\" (NaN) value, and 0 otherwise."
msgstr ""
"B<finite>()  関数は、 I<x> が無限大や無効値 (NaN) のいずれでもない 場合に 0 "
"以外の値を返し、それ以外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/finite.3:100
msgid ""
"The B<isnan>()  functions return a nonzero value if I<x> is a NaN value, and "
"0 otherwise."
msgstr ""
"B<isnan>()  関数は、 I<x> が NaN の場合 0 以外の値を返し、 それ以外の場合は "
"0 を返す。"

#. type: Plain text
#: build/C/man3/finite.3:105
msgid ""
"The B<isinf>()  functions return 1 if I<x> is positive infinity, -1 if I<x> "
"is negative infinity, and 0 otherwise."
msgstr ""
"B<isinf>()  関数は、 I<x> が正の無限大であれば 1 を返し、I<x> が負の無限大で "
"あれば -1 を返す。それ以外の場合は 0 を返す。"

#.  finite* not on HP-UX; they exist on Tru64.
#.  .SH HISTORY
#.  The
#.  .BR finite ()
#.  function occurs in 4.3BSD.
#.  see IEEE.3 in the 4.3BSD manual
#. type: Plain text
#: build/C/man3/finite.3:125
msgid ""
"Note that these functions are obsolete.  C99 defines macros B<isfinite>(), "
"B<isinf>(), and B<isnan>()  (for all types) replacing them.  Further note "
"that the C99 B<isinf>()  has weaker guarantees on the return value.  See "
"B<fpclassify>(3)."
msgstr ""
"これらの関数は廃止された点に注意すること。 C99 では、これらの置き換えとして "
"(どんな型にも適用できる)  B<isfinite>(), B<isinf>(), B<isnan>()  というマクロ"
"が定義されている。 さらに C99 の B<isinf>()  は返り値に関して弱い意味での保証"
"しかないことにも 注意すること。詳細は B<fpclassify>(3)  を参照。"

#. type: Plain text
#: build/C/man3/finite.3:127
msgid "B<fpclassify>(3)"
msgstr "B<fpclassify>(3)"

#. type: TH
#: build/C/man3/floor.3:27
#, no-wrap
msgid "FLOOR"
msgstr "FLOOR"

#. type: Plain text
#: build/C/man3/floor.3:30
msgid ""
"floor, floorf, floorl - largest integral value not greater than argument"
msgstr "floor, floorf, floorl - 引き数を越えない最大の整数値"

#. type: Plain text
#: build/C/man3/floor.3:35
#, no-wrap
msgid "B<double floor(double >I<x>B<);>\n"
msgstr "B<double floor(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/floor.3:37
#, no-wrap
msgid "B<float floorf(float >I<x>B<);>\n"
msgstr "B<float floorf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/floor.3:39
#, no-wrap
msgid "B<long double floorl(long double >I<x>B<);>\n"
msgstr "B<long double floorl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/floor.3:51
msgid "B<floorf>(), B<floorl>():"
msgstr "B<floorf>(), B<floorl>():"

#. type: Plain text
#: build/C/man3/floor.3:62
msgid ""
"These functions return the largest integral value that is not greater than "
"I<x>."
msgstr "これらの関数は I<x> より大きくない最大の整数値を返す。"

#. type: Plain text
#: build/C/man3/floor.3:68
msgid "For example, I<floor(0.5)> is 0.0, and I<floor(-0.5)> is -1.0."
msgstr "例えば、 I<floor(0.5)> は 0.0 で、 I<floor(-0.5)> は -1.0 である。"

#. type: Plain text
#: build/C/man3/floor.3:71
msgid "These functions return the floor of I<x>."
msgstr "これらの関数は I<x> を越えない最小の整数値を返す。"

#. type: Plain text
#: build/C/man3/floor.3:74
msgid ""
"If I<x> is integral, +0, -0, NaN, or an infinity, I<x> itself is returned."
msgstr ""
"I<x> が整数、+0、-0、NaN、無限大のいずれかの場合、 I<x> そのものが返される。"

#. type: Plain text
#: build/C/man3/floor.3:106
msgid ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), B<trunc>"
"(3)"
msgstr ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), B<trunc>"
"(3)"

#. type: TH
#: build/C/man3/fma.3:12
#, no-wrap
msgid "FMA"
msgstr "FMA"

#. type: Plain text
#: build/C/man3/fma.3:15
msgid "fma, fmaf, fmal - floating-point multiply and add"
msgstr "fma, fmaf, fmal - 浮動小数点数の積と和を計算する"

#. type: Plain text
#: build/C/man3/fma.3:20
#, no-wrap
msgid "B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"
msgstr "B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"

#. type: Plain text
#: build/C/man3/fma.3:22
#, no-wrap
msgid "B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"
msgstr "B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"

#. type: Plain text
#: build/C/man3/fma.3:24
#, no-wrap
msgid "B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double >I<z>B<);>\n"
msgstr "B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double >I<z>B<);>\n"

#. type: Plain text
#: build/C/man3/fma.3:37
msgid "B<fma>(), B<fmaf>(), B<fmal>():"
msgstr "B<fma>(), B<fmaf>(), B<fmal>():"

#. type: Plain text
#: build/C/man3/fma.3:53
msgid ""
"The B<fma>()  function computes I<x> * I<y> + I<z>.  The result is rounded "
"as one ternary operation according to the current rounding mode (see B<fenv>"
"(3))."
msgstr ""
"B<fma>()  関数は I<x> * I<y> + I<z> を計算する。 結果は、一つの三項演算として"
"現在の丸めモードにしたがって丸められる (B<fenv>(3)  参照)。"

#. type: Plain text
#: build/C/man3/fma.3:57
msgid ""
"These functions return the value of I<x> * I<y> + I<z>, rounded as one "
"ternary operation."
msgstr ""
"これらの関数は I<x> * I<y> + I<z> の、一つの三項演算として丸められた値を返"
"す。"

#. type: Plain text
#: build/C/man3/fma.3:73
msgid ""
"If I<x> times I<y> is an exact infinity, and I<z> is an infinity with the "
"opposite sign, a domain error occurs, and a NaN is returned."
msgstr ""
"I<y> の I<x> 倍がちょうど無限大で、 I<z> がそれとは反対の符号の無限大の場"
"合、 領域エラー (domain error) が発生し、NaN が返される。"

#.  POSIX.1-2008 allows some possible differences for the following two
#.  domain error cases, but on Linux they are treated the same (AFAICS).
#.  Nevertheless, we'll mirror POSIX.1 and describe the two cases
#.  separately.
#.  POSIX.1 says that a NaN or an implementation-defined value shall
#.  be returned for this case.
#. type: Plain text
#: build/C/man3/fma.3:89
msgid ""
"If one of I<x> or I<y> is an infinity, the other is 0, and I<z> is not a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""
"I<x> と I<y> のうち一方が無限大で、もう一方が 0 で、 I<z> が NaN でない場合、"
"領域エラーが発生し、NaN が返される。"

#.  POSIX.1 makes the domain error optional for this case.
#. type: Plain text
#: build/C/man3/fma.3:100
msgid ""
"If one of I<x> or I<y> is an infinity, and the other is 0, and I<z> is a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""
"I<x> と I<y> のうち一方が無限大で、もう一方が 0 で、 I<z> が NaN の場合、領域"
"エラーが発生し、NaN が返される。"

#. type: Plain text
#: build/C/man3/fma.3:109
msgid ""
"If I<x> times I<y> is not an infinity times zero (or vice versa), and I<z> "
"is a NaN, a NaN is returned."
msgstr ""
"I<y> の I<x> 倍が 0 の無限大倍 (もしくはその逆) ではなく、 I<z> が NaN の場"
"合、NaN が返される。"

#. type: Plain text
#: build/C/man3/fma.3:113
msgid ""
"If the result overflows, a range error occurs, and an infinity with the "
"correct sign is returned."
msgstr ""
"結果がオーバーフローする場合、範囲エラー (range error) が発生し、 正しい符号"
"の無限大が返される。"

#. type: Plain text
#: build/C/man3/fma.3:117
msgid ""
"If the result underflows, a range error occurs, and a signed 0 is returned."
msgstr ""
"結果がアンダーフローする場合、 範囲エラーが発生し、符号付きの 0 が返される。"

#. type: TP
#: build/C/man3/fma.3:124
#, no-wrap
msgid "Domain error: I<x> * I<y> + I<z>, or I<x> * I<y> is invalid and I<z> is not a NaN"
msgstr "領域エラー: I<x> * I<y> + I<z> か I<x> * I<y> が無効で、I<z> が NaN ではない"

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: build/C/man3/fma.3:133 build/C/man3/ilogb.3:125 build/C/man3/log1p.3:126
#: build/C/man3/lrint.3:102 build/C/man3/lround.3:105
#: build/C/man3/remainder.3:165 build/C/man3/remquo.3:117
#: build/C/man3/scalb.3:150 build/C/man3/sincos.3:67
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "不正 (invalid) 浮動小数点例外 (B<FE_INVALID>)  が上がる。"

#. type: TP
#: build/C/man3/fma.3:141 build/C/man3/hypot.3:143 build/C/man3/tgamma.3:139
#: build/C/man3/y0.3:188
#, no-wrap
msgid "Range error: result underflow"
msgstr "範囲エラー (range error): 結果のアンダーフロー"

#. type: Plain text
#: build/C/man3/fma.3:161
msgid "B<remainder>(3), B<remquo>(3)"
msgstr "B<remainder>(3), B<remquo>(3)"

#. type: TH
#: build/C/man3/fmax.3:9
#, no-wrap
msgid "FMAX"
msgstr "FMAX"

#. type: Plain text
#: build/C/man3/fmax.3:12
msgid "fmax, fmaxf, fmaxl - determine maximum of two floating-point numbers"
msgstr "fmax, fmaxf, fmaxl - 二つの浮動小数点数の最大値を求める"

#. type: Plain text
#: build/C/man3/fmax.3:16
msgid "B<double fmax(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fmax(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fmax.3:18
msgid "B<float fmaxf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fmaxf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fmax.3:20
msgid "B<long double fmaxl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fmaxl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fmax.3:32
msgid "B<fmax>(), B<fmaxf>(), B<fmaxl>():"
msgstr "B<fmax>(), B<fmaxf>(), B<fmaxl>():"

#. type: Plain text
#: build/C/man3/fmax.3:45
msgid "These functions return the larger value of I<x> and I<y>."
msgstr "これらの関数は I<x> と I<y> のうち大きい方の値を返す。"

#. type: Plain text
#: build/C/man3/fmax.3:50
msgid "These functions return the maximum of I<x> and I<y>."
msgstr "これらの関数は I<x> と I<y> の最大値を返す。"

#. type: Plain text
#: build/C/man3/fmax.3:52 build/C/man3/fmin.3:52
msgid "If one argument is a NaN, the other argument is returned."
msgstr "一方の引き数が NaN の場合、もう一方の値が返される。"

#. type: Plain text
#: build/C/man3/fmax.3:54 build/C/man3/fmin.3:54
msgid "If both arguments are NaN, a NaN is returned."
msgstr "両方の引き数が NaN の場合、NaN が返される。"

#. type: Plain text
#: build/C/man3/fmax.3:62
msgid "B<fmin>(3)"
msgstr "B<fmin>(3)"

#. type: TH
#: build/C/man3/fmin.3:9
#, no-wrap
msgid "FMIN"
msgstr "FMIN"

#. type: Plain text
#: build/C/man3/fmin.3:12
msgid "fmin, fminf, fminl - determine minimum of two floating-point numbers"
msgstr "fmin, fminf, fminl - 二つの浮動小数点数の最小値を求める"

#. type: Plain text
#: build/C/man3/fmin.3:16
msgid "B<double fmin(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fmin(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fmin.3:18
msgid "B<float fminf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fminf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fmin.3:20
msgid "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/fmin.3:32
msgid "B<fmin>(), B<fminf>(), B<fminl>():"
msgstr "B<fmin>(), B<fminf>(), B<fminl>():"

#. type: Plain text
#: build/C/man3/fmin.3:45
msgid "These functions the lesser value of I<x> and I<y>."
msgstr "これらの関数は I<x> と I<y> のうち小さい方の値を返す。"

#. type: Plain text
#: build/C/man3/fmin.3:50
msgid "These functions return the minimum of I<x> and I<y>."
msgstr "これらの関数は I<x> と I<y> の最小値を返す。"

#. type: TH
#: build/C/man3/fmod.3:35
#, no-wrap
msgid "FMOD"
msgstr "FMOD"

#. type: TH
#: build/C/man3/fmod.3:35
#, no-wrap
msgid "2012-03-15"
msgstr "2012-03-15"

#. type: Plain text
#: build/C/man3/fmod.3:38
msgid "fmod, fmodf, fmodl - floating-point remainder function"
msgstr "fmod, fmodf, fmodl - 浮動小数点剰余関数"

#. type: Plain text
#: build/C/man3/fmod.3:43
#, no-wrap
msgid "B<double fmod(double >I<x>B<, double >I<y>B<);>\n"
msgstr "B<double fmod(double >I<x>B<, double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/fmod.3:45
#, no-wrap
msgid "B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"
msgstr "B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/fmod.3:47
#, no-wrap
msgid "B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr "B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/fmod.3:59
msgid "B<fmodf>(), B<fmodl>():"
msgstr "B<fmodf>(), B<fmodl>():"

#. type: Plain text
#: build/C/man3/fmod.3:74
msgid ""
"The B<fmod>()  function computes the floating-point remainder of dividing "
"I<x> by I<y>.  The return value is I<x> - I<n> * I<y>, where I<n> is the "
"quotient of I<x> / I<y>, rounded toward zero to an integer."
msgstr ""
"B<fmod>()  関数は I<x> を I<y> で割った浮動小数点剰余を計算する。 返り値は "
"I<x> - I<n> * I<y> である。 ここで、I<n> は I<x> / I<y> の商を ゼロに向かう方"
"向で整数値に丸めたものである。"

#. type: Plain text
#: build/C/man3/fmod.3:82
msgid ""
"On success, these functions return the value I<x>\\ -\\ I<n>*I<y>, for some "
"integer I<n>, such that the returned value has the same sign as I<x> and a "
"magnitude less than the magnitude of I<y>."
msgstr ""
"成功すると、これらの関数は I<x>\\ -\\ I<n>*I<y> を返す。 I<n> は、返り値が "
"I<x> と同じ符号で、その絶対値が I<y> の絶対値よりも小さくなるような整数であ"
"る。"

#. type: Plain text
#: build/C/man3/fmod.3:94
msgid "If I<x> is an infinity, a domain error occurs, and a NaN is returned."
msgstr ""
"I<x> が無限大の場合、領域エラー (domain error) が発生し、 NaN が返される。"

#. type: Plain text
#: build/C/man3/fmod.3:100
msgid "If I<y> is zero, a domain error occurs, and a NaN is returned."
msgstr "I<y> が 0 の場合、領域エラーが発生し、 NaN が返される。"

#. type: Plain text
#: build/C/man3/fmod.3:106
msgid "If I<x> is +0 (-0), and I<y> is not zero, +0 (-0) is returned."
msgstr "I<x> が +0 (-0) で I<y> が 0 でない場合、+0 (-0) が返される。"

#.  [XXX see bug above] and \fIx\fP is not a NaN
#. type: TP
#: build/C/man3/fmod.3:122 build/C/man3/remainder.3:172
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr "領域エラー: I<y> がゼロ"

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6784
#. type: Plain text
#: build/C/man3/fmod.3:146
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred for an infinite I<x>."
msgstr ""
"バージョン 2.10 より前の glibc の実装では、 無限大で領域エラーが発生した際"
"に、 I<error> に B<EDOM> が設定されなかった。"

#. type: Plain text
#: build/C/man3/fmod.3:148
msgid "B<remainder>(3)"
msgstr "B<remainder>(3)"

#. type: TH
#: build/C/man3/fpclassify.3:10
#, no-wrap
msgid "FPCLASSIFY"
msgstr "FPCLASSIFY"

#. type: Plain text
#: build/C/man3/fpclassify.3:14
msgid ""
"fpclassify, isfinite, isnormal, isnan, isinf - floating-point classification "
"macros"
msgstr ""
"fpclassify, isfinite, isnormal, isnan, isinf - 浮動小数点数の分類マクロ"

#. type: Plain text
#: build/C/man3/fpclassify.3:19
#, no-wrap
msgid "B<int fpclassify(>I<x>B<);>\n"
msgstr "B<int fpclassify(>I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fpclassify.3:21
#, no-wrap
msgid "B<int isfinite(>I<x>B<);>\n"
msgstr "B<int isfinite(>I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fpclassify.3:23
#, no-wrap
msgid "B<int isnormal(>I<x>B<);>\n"
msgstr "B<int isnormal(>I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fpclassify.3:25
#, no-wrap
msgid "B<int isnan(>I<x>B<);>\n"
msgstr "B<int isnan(>I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fpclassify.3:27
#, no-wrap
msgid "B<int isinf(>I<x>B<);>\n"
msgstr "B<int isinf(>I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/fpclassify.3:42
msgid "B<fpclassify>(), B<isfinite>(), B<isnormal>():"
msgstr "B<fpclassify>(), B<isfinite>(), B<isnormal>():"

#. type: Plain text
#: build/C/man3/fpclassify.3:76
msgid ""
"Floating point numbers can have special values, such as infinite or NaN.  "
"With the macro B<fpclassify(>I<x>B<)> you can find out what type I<x> is.  "
"The macro takes any floating-point expression as argument.  The result is "
"one of the following values:"
msgstr ""
"浮動小数点数は無限大や NaN のような特別な値を持つことができる。 マクロ "
"B<fpclassify(>I<x>B<)> で I<x> がどのような種別かを知ることができる。 マクロ"
"は任意の浮動小数点数表現を引き数としてとることができる。 結果は以下の値のいず"
"れか一つである:"

#. type: TP
#: build/C/man3/fpclassify.3:76
#, no-wrap
msgid "B<FP_NAN>"
msgstr "B<FP_NAN>"

#. type: Plain text
#: build/C/man3/fpclassify.3:80
msgid "I<x> is \"Not a Number\"."
msgstr "I<x> が \"Not a Number\" である (数値ではない)。"

#. type: TP
#: build/C/man3/fpclassify.3:80
#, no-wrap
msgid "B<FP_INFINITE>"
msgstr "B<FP_INFINITE>"

#. type: Plain text
#: build/C/man3/fpclassify.3:84
msgid "I<x> is either positive infinity or negative infinity."
msgstr "I<x> が正の無限大または負の無限大である。"

#. type: TP
#: build/C/man3/fpclassify.3:84
#, no-wrap
msgid "B<FP_ZERO>"
msgstr "B<FP_ZERO>"

#. type: Plain text
#: build/C/man3/fpclassify.3:88
msgid "I<x> is zero."
msgstr "I<x> が 0 である。"

#. type: TP
#: build/C/man3/fpclassify.3:88
#, no-wrap
msgid "B<FP_SUBNORMAL>"
msgstr "B<FP_SUBNORMAL>"

#. type: Plain text
#: build/C/man3/fpclassify.3:92
msgid "I<x> is too small to be represented in normalized format."
msgstr "I<x> を正規化形式で表現するには小さすぎる。"

#. type: TP
#: build/C/man3/fpclassify.3:92
#, no-wrap
msgid "B<FP_NORMAL>"
msgstr "B<FP_NORMAL>"

#. type: Plain text
#: build/C/man3/fpclassify.3:96
msgid ""
"if nothing of the above is correct then it must be a normal floating-point "
"number."
msgstr ""
"上記のどれにも当てはまらない場合であり、 値は通常の浮動小数点数であるはずだ。"

#. type: Plain text
#: build/C/man3/fpclassify.3:98
msgid "The other macros provide a short answer to some standard questions."
msgstr "他のマクロは、いくつかの標準的な問いに対して、簡単な答えを提供する。"

#. type: TP
#: build/C/man3/fpclassify.3:98
#, no-wrap
msgid "B<isfinite(>I<x>B<)>"
msgstr "B<isfinite(>I<x>B<)>"

#. type: Plain text
#: build/C/man3/fpclassify.3:101
msgid "returns a nonzero value if"
msgstr "以下の場合に 0 以外の値を返す。"

#. type: Plain text
#: build/C/man3/fpclassify.3:103
msgid "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"
msgstr "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"

#. type: TP
#: build/C/man3/fpclassify.3:103
#, no-wrap
msgid "B<isnormal(>I<x>B<)>"
msgstr "B<isnormal(>I<x>B<)>"

#. type: Plain text
#: build/C/man3/fpclassify.3:107
msgid "returns a nonzero value if (fpclassify(x) == FP_NORMAL)"
msgstr "(fpclassify(x) == FP_NORMAL)  の場合に 0 以外の値を返す。"

#. type: TP
#: build/C/man3/fpclassify.3:107
#, no-wrap
msgid "B<isnan(>I<x>B<)>"
msgstr "B<isnan(>I<x>B<)>"

#. type: Plain text
#: build/C/man3/fpclassify.3:111
msgid "returns a nonzero value if (fpclassify(x) == FP_NAN)"
msgstr "(fpclassify(x) == FP_NAN)  の場合に 0 以外の値を返す。"

#. type: TP
#: build/C/man3/fpclassify.3:111
#, no-wrap
msgid "B<isinf(>I<x>B<)>"
msgstr "B<isinf(>I<x>B<)>"

#. type: Plain text
#: build/C/man3/fpclassify.3:118
msgid ""
"returns 1 if I<x> is positive infinity, and -1 if I<x> is negative infinity."
msgstr "I<x> が正の無限大の場合は 1 を、 負の無限大の場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/fpclassify.3:120
msgid "C99, POSIX.1."
msgstr "C99, POSIX.1."

#. type: Plain text
#: build/C/man3/fpclassify.3:125
msgid ""
"For B<isinf>(), the standards merely say that the return value is nonzero if "
"and only if the argument has an infinite value."
msgstr ""
"B<isinf>()  に関して、標準規格で定められているのは、 返り値が 0 以外になるの"
"は引き数が無限大の場合だけということだけである。"

#. type: Plain text
#: build/C/man3/fpclassify.3:132
msgid ""
"In glibc 2.01 and earlier, B<isinf>()  returns a nonzero value (actually: 1) "
"if I<x> is positive infinity or negative infinity.  (This is all that C99 "
"requires.)"
msgstr ""
"glibc 2.01 以前では、 B<isinf>()  は I<x> が正の無限大か負の無限大の場合、 0 "
"以外の値 (実際には 1) を返す (C99 の要求仕様で決まっているのは 0 以外の値を返"
"すということだけである)。"

#. type: Plain text
#: build/C/man3/fpclassify.3:137
msgid "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"
msgstr "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"

#. type: TH
#: build/C/man3/frexp.3:33
#, no-wrap
msgid "FREXP"
msgstr "FREXP"

#. type: Plain text
#: build/C/man3/frexp.3:37
msgid ""
"frexp, frexpf, frexpl - convert floating-point number to fractional and "
"integral components"
msgstr "frexp, frexpf, frexpl - 浮動小数点実数を小数成分と整数成分に変換する"

#. type: Plain text
#: build/C/man3/frexp.3:42
#, no-wrap
msgid "B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"
msgstr "B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: build/C/man3/frexp.3:44
#, no-wrap
msgid "B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"
msgstr "B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: build/C/man3/frexp.3:46
#, no-wrap
msgid "B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"
msgstr "B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: build/C/man3/frexp.3:58
msgid "B<frexpf>(), B<frexpl>():"
msgstr "B<frexpf>(), B<frexpl>():"

#. type: Plain text
#: build/C/man3/frexp.3:71
msgid ""
"The B<frexp>()  function is used to split the number I<x> into a normalized "
"fraction and an exponent which is stored in I<exp>."
msgstr ""
"B<frexp>()  関数は浮動小数点実数 I<x> を正規化小数と指数に分解し、 指数を "
"*I<exp> に格納する。"

#. type: Plain text
#: build/C/man3/frexp.3:79
msgid ""
"The B<frexp>()  function returns the normalized fraction.  If the argument "
"I<x> is not zero, the normalized fraction is I<x> times a power of two, and "
"its absolute value is always in the range 1/2 (inclusive) to 1 (exclusive), "
"that is, [0.5,1)."
msgstr ""
"B<frexp>()  関数は正規化小数を返す。 引数 I<x> がゼロでない場合、この正規化小"
"数は I<x> に 2 の累乗を乗じたものであり、その絶対値は 常に 1/2 以上 1 未満、"
"つまり [0.5,1) となる。"

#. type: Plain text
#: build/C/man3/frexp.3:82
msgid ""
"If I<x> is zero, then the normalized fraction is zero and zero is stored in "
"I<exp>."
msgstr ""
"I<x> がゼロの場合、正規化小数はゼロになり *I<exp> にはゼロが格納される。"

#. type: Plain text
#: build/C/man3/frexp.3:89
msgid ""
"If I<x> is a NaN, a NaN is returned, and the value of I<*exp> is unspecified."
msgstr "I<x> が NaN の場合、NaN が返される。 I<*exp> の値は不定である。"

#. type: Plain text
#: build/C/man3/frexp.3:96
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned, and the value of I<*exp> is unspecified."
msgstr ""
"I<x> が正の無限大 (負の無限大) の場合、 正の無限大 (負の無限大) が返される。 "
"I<*exp> の値は不定である。"

#. type: Plain text
#: build/C/man3/frexp.3:106
msgid "The program below produces results such as the following:"
msgstr "このプログラムを実行すると以下のような結果となる:"

#. type: Plain text
#: build/C/man3/frexp.3:113
#, no-wrap
msgid ""
"$B< ./a.out 2560>\n"
"frexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n"
"$B< ./a.out -4>\n"
"frexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"
msgstr ""
"$B< ./a.out 2560>\n"
"frexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n"
"$B< ./a.out -4>\n"
"frexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"

#. type: SS
#: build/C/man3/frexp.3:115 build/C/man3/matherr.3:360
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/frexp.3:122
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>float.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>float.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/frexp.3:128
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x, r;\n"
"    int exp;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x, r;\n"
"    int exp;\n"

#. type: Plain text
#: build/C/man3/frexp.3:131
#, no-wrap
msgid ""
"    x = strtod(argv[1], NULL);\n"
"    r = frexp(x, &exp);\n"
msgstr ""
"    x = strtod(argv[1], NULL);\n"
"    r = frexp(x, &exp);\n"

#. type: Plain text
#: build/C/man3/frexp.3:136
#, no-wrap
msgid ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n"
"           x, r, r, FLT_RADIX, exp, x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n"
"           x, r, r, FLT_RADIX, exp, x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/frexp.3:140
msgid "B<ldexp>(3), B<modf>(3)"
msgstr "B<ldexp>(3), B<modf>(3)"

#. type: TH
#: build/C/man3/gamma.3:9
#, no-wrap
msgid "GAMMA"
msgstr "GAMMA"

#. type: Plain text
#: build/C/man3/gamma.3:12
msgid "gamma, gammaf, gammal - (logarithm of the) gamma function"
msgstr "gamma, gammaf, gammal - ガンマ関数 (の自然対数)"

#. type: Plain text
#: build/C/man3/gamma.3:16
msgid "B<double gamma(double >I<x>B<);>"
msgstr "B<double gamma(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/gamma.3:18
msgid "B<float gammaf(float >I<x>B<);>"
msgstr "B<float gammaf(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/gamma.3:20
msgid "B<long double gammal(long double >I<x>B<);>"
msgstr "B<long double gammal(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/gamma.3:30
msgid "B<gamma>():"
msgstr "B<gamma>():"

#. type: Plain text
#: build/C/man3/gamma.3:32 build/C/man3/lgamma.3:69
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/gamma.3:35
msgid "B<gammaf>(), B<gammal>():"
msgstr "B<gammaf>(), B<gammal>():"

#. type: Plain text
#: build/C/man3/gamma.3:46
msgid ""
"These functions are deprecated: instead, use either the B<tgamma>(3)  or the "
"B<lgamma>(3)  functions, as appropriate."
msgstr ""
"これらの関数は非推奨である。その代わり、場面に応じて B<tgamma>(3)  か "
"B<lgamma>(3)  を使うこと。"

#. type: Plain text
#: build/C/man3/gamma.3:49 build/C/man3/lgamma.3:74
msgid "For the definition of the Gamma function, see B<tgamma>(3)."
msgstr "ガンマ関数の定義については、 B<tgamma>(3)  を参照のこと。"

#. type: SS
#: build/C/man3/gamma.3:49
#, no-wrap
msgid "*BSD version"
msgstr "*BSD版"

#. type: Plain text
#: build/C/man3/gamma.3:53
msgid ""
"The libm in 4.4BSD and some versions of FreeBSD had a B<gamma>()  function "
"that computes the Gamma function, as one would expect."
msgstr ""
"4.4BSD の libm と FreeBSD のいくつかのバージョンには、関数 B<gamma>()  が含ま"
"れており、期待通りガンマ関数を計算できる。"

#. type: SS
#: build/C/man3/gamma.3:53
#, no-wrap
msgid "glibc version"
msgstr "glibc版"

#. type: Plain text
#: build/C/man3/gamma.3:59
msgid ""
"Glibc has a B<gamma>()  function that is equivalent to B<lgamma>(3)  and "
"computes the natural logarithm of the Gamma function."
msgstr ""
"Glibcは、関数 B<gamma>()  を含んでいるが、これは B<lgamma>(3)  と等価であり、"
"ガンマ関数の自然対数を計算する。"

#. type: Plain text
#: build/C/man3/gamma.3:62 build/C/man3/gamma.3:65
msgid "See B<lgamma>(3)."
msgstr "B<lgamma>(3)  を参照。"

#. type: Plain text
#: build/C/man3/gamma.3:68
msgid ""
"Because of historical variations in behavior across systems, this function "
"is not specified in any standard."
msgstr ""
"システムによって振舞いが異なるという歴史的な経緯のため、 この関数はどの標準規"
"格でも規定されていない。"

#. type: SS
#: build/C/man3/gamma.3:69
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man3/gamma.3:81
msgid ""
"4.2BSD had a B<gamma>()  that computed ln(|Gamma(|I<x>|)|), leaving the sign "
"of Gamma(|I<x>|)  in the external integer I<signgam>.  In 4.3BSD the name "
"was changed to B<lgamma>(3), and the man page promises"
msgstr ""
"4.2BSDにおいては、関数 B<gamma>()  が実際に計算するのは ln(|Gamma(|I<x>|)|)  "
"であり、 Gamma(|I<x>|)  の符号が extern int I<signgam> に格納されていた。 "
"4.3BSDになって関数名が変更され、 B<lgamma>(3)  となり、そのマニュアルページで"
"は"

#. type: Plain text
#: build/C/man3/gamma.3:85
msgid ""
"At some time in the future the name gamma will be rehabilitated and used for "
"the Gamma function"
msgstr "「いつの日か gamma の名は復活し、ガンマ関数に冠されるであろう」"

#.  The FreeBSD man page says about gamma() that it is like lgamma()
#.  except that is does not set signgam.
#.  Also, that 4.4BSD has a gamma() that computes the true gamma function.
#. type: Plain text
#: build/C/man3/gamma.3:97
msgid ""
"This did indeed happen in 4.4BSD, where B<gamma>()  computes the Gamma "
"function (with no effect on I<signgam>).  However, this came too late, and "
"we now have B<tgamma>(3), the \"true gamma\" function."
msgstr ""
"という誓いが述べられていた。 これは4.4BSDになって実現され、 B<gamma>()  はま"
"さにガンマ関数を計算するようになった。 (もう I<signgam> には作用しない。)  と"
"ころが、これが登場する時期が遅すぎたため、 B<tgamma>(3)  という「本当のガンマ"
"関数」がすでに存在しているのである。"

#. type: Plain text
#: build/C/man3/gamma.3:101
msgid "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"
msgstr "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"

#. type: TH
#: build/C/man3/hypot.3:33
#, no-wrap
msgid "HYPOT"
msgstr "HYPOT"

#. type: Plain text
#: build/C/man3/hypot.3:36
msgid "hypot, hypotf, hypotl - Euclidean distance function"
msgstr "hypot, hypotf, hypotl - ユークリッド距離関数"

#. type: Plain text
#: build/C/man3/hypot.3:41
#, no-wrap
msgid "B<double hypot(double >I<x>B<, double >I<y>B<);>\n"
msgstr "B<double hypot(double >I<x>B<, double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/hypot.3:43
#, no-wrap
msgid "B<float hypotf(float >I<x>B<, float >I<y>B<);>\n"
msgstr "B<float hypotf(float >I<x>B<, float >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/hypot.3:45
#, no-wrap
msgid "B<long double hypotl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr "B<long double hypotl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/hypot.3:56
msgid "B<hypot>():"
msgstr "B<hypot>():"

#. type: Plain text
#: build/C/man3/hypot.3:66
msgid "B<hypotf>(), B<hypotl>():"
msgstr "B<hypotf>(), B<hypotl>():"

#. type: Plain text
#: build/C/man3/hypot.3:87
msgid ""
"The B<hypot>()  function returns sqrt(I<x>*I<x>+I<y>*I<y>).  This is the "
"length of the hypotenuse of a right-angled triangle with sides of length "
"I<x> and I<y>, or the distance of the point (I<x>,I<y>)  from the origin."
msgstr ""
"B<hypot>()  関数は sqrt(I<x>*I<x>+I<y>*I<y>)  の値を返す。 これは 直角を挟む "
"2 辺の長さが I<x> と I<y> である直角三角形の斜辺の長さ、 すなわち、原点と点 "
"(I<x>,I<y>)  との距離である。"

#.  e.g., hypot(DBL_MIN, DBL_MIN) does the right thing, as does, say
#.  hypot(DBL_MAX/2.0, DBL_MAX/2.0).
#. type: Plain text
#: build/C/man3/hypot.3:92
msgid ""
"The calculation is performed without undue overflow or underflow during the "
"intermediate steps of the calculation."
msgstr ""
"計算の中間ステップでは、必要以上のオーバーフローやアンダーフローが 起きないよ"
"うにして計算が実行される。"

#. type: Plain text
#: build/C/man3/hypot.3:98
msgid ""
"On success, these functions return the length of a right-angled triangle "
"with sides of length I<x> and I<y>."
msgstr ""
"成功すると、これらの関数は、 直角を挟む 2 辺の長さが I<x> と I<y> である直角"
"三角形の斜辺の長さを返す。"

#. type: Plain text
#: build/C/man3/hypot.3:105
msgid "If I<x> or I<y> is an infinity, positive infinity is returned."
msgstr "I<x> か I<y> が無限大の場合、正の無限大が返される。"

#. type: Plain text
#: build/C/man3/hypot.3:113
msgid ""
"If I<x> or I<y> is a NaN, and the other argument is not an infinity, a NaN "
"is returned."
msgstr ""
"I<x> か I<y> の一方が NaN で、もう一方が無限大でない場合、 NaN が返される。"

#.  Actually, could the result not be subnormal if both arguments
#.  are subnormal?  I think not -- mtk, Jul 2008
#. type: Plain text
#: build/C/man3/hypot.3:128
msgid ""
"If both arguments are subnormal, and the result is subnormal, a range error "
"occurs, and the correct result is returned."
msgstr ""
"両方の引き数が非正規化数 (subnormal) で、結果も非正規化数 (subnormal) の場"
"合、 範囲エラーが発生し、正しい結果が返される。"

#.  FIXME . Is it intentional that these functions do not set errno?
#.  They do set errno for the y == 0 case, below.
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6783
#. type: Plain text
#: build/C/man3/hypot.3:158 build/C/man3/ilogb.3:130
#: build/C/man3/remainder.3:172
msgid "These functions do not set I<errno> for this case."
msgstr "これらの関数は、この場合に I<errno> を設定しない。"

#. type: Plain text
#: build/C/man3/hypot.3:167
msgid "B<cabs>(3), B<sqrt>(3)"
msgstr "B<cabs>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/ilogb.3:29
#, no-wrap
msgid "ILOGB"
msgstr "ILOGB"

#. type: Plain text
#: build/C/man3/ilogb.3:32
msgid "ilogb, ilogbf, ilogbl - get integer exponent of a floating-point value"
msgstr "ilogb, ilogbf, ilogbl - 浮動小数点数の指数部を整数として取得する"

#. type: Plain text
#: build/C/man3/ilogb.3:36
msgid "B<int ilogb(double >I<x>B<);>"
msgstr "B<int ilogb(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/ilogb.3:38
msgid "B<int ilogbf(float >I<x>B<);>"
msgstr "B<int ilogbf(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/ilogb.3:40
msgid "B<int ilogbl(long double >I<x>B<);>"
msgstr "B<int ilogbl(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/ilogb.3:50
msgid "B<ilogb>():"
msgstr "B<ilogb>():"

#. type: Plain text
#: build/C/man3/ilogb.3:62
msgid "B<ilogbf>(), B<ilogbl>():"
msgstr "B<ilogbf>(), B<ilogbl>():"

#. type: Plain text
#: build/C/man3/ilogb.3:78
msgid ""
"These functions return the exponent part of their argument as a signed "
"integer.  When no error occurs, these functions are equivalent to the "
"corresponding B<logb>(3)  functions, cast to I<int>."
msgstr ""
"これらの関数は引き数の指数部を符号付き整数として返す。 エラーが起らなかった場"
"合、これらの関数は、対応する B<logb>(3)  関数を I<int> でキャストしたものと等"
"価である。"

#. type: Plain text
#: build/C/man3/ilogb.3:82
msgid ""
"On success, these functions return the exponent of I<x>, as a signed integer."
msgstr "成功すると、これらの関数は I<x> の指数部を符号付き整数として返す。"

#.  the POSIX.1 spec for logb() says logb() gives pole error for this
#.  case, but for ilogb() it says domain error.
#.  glibc: The numeric value is either `INT_MIN' or `-INT_MAX'.
#. type: Plain text
#: build/C/man3/ilogb.3:90
msgid ""
"If I<x> is zero, then a domain error occurs, and the functions return "
"B<FP_ILOGB0>."
msgstr ""
"I<x> がゼロの場合、領域エラー (domain error) が発生し、 B<FP_ILOGB0> が返され"
"る。"

#.  glibc: The numeric value is either `INT_MIN' or `INT_MAX'.
#.  On i386, FP_ILOGB0 and FP_ILOGBNAN have the same value.
#. type: Plain text
#: build/C/man3/ilogb.3:97
msgid ""
"If I<x> is a NaN, then a domain error occurs, and the functions return "
"B<FP_ILOGBNAN>."
msgstr ""
"I<x> が NaN の場合、領域エラー (domain error) が発生し、 B<FP_ILOGBNAN> が返"
"される。"

#.  POSIX.1-2001 also says:
#.  If the correct value is greater than {INT_MAX}, {INT_MAX}
#.  shall be returned and a domain error shall occur.
#.  If the correct value is less than {INT_MIN}, {INT_MIN}
#.  shall be returned and a domain error shall occur.
#. type: Plain text
#: build/C/man3/ilogb.3:110
msgid ""
"If I<x> is negative infinity or positive infinity, then a domain error "
"occurs, and the functions return B<INT_MAX>."
msgstr ""
"I<x> が負の無限大か正の無限大の場合、 領域エラー (domain error) が発生し、 "
"B<INT_MAX> が返される。"

#. type: TP
#: build/C/man3/ilogb.3:117
#, no-wrap
msgid "Domain error: I<x> is 0 or a NaN"
msgstr "領域エラー: I<x> が 0 か NaN"

#.  FIXME . Is it intentional that these functions do not set errno,
#.  or raise an exception?
#.  log(), log2(), log10() do set errno
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6794
#. type: Plain text
#: build/C/man3/ilogb.3:146
msgid ""
"These functions do not set I<errno> or raise an exception for this case."
msgstr "これらの関数は、この状況で I<errno> を設定せず、例外も上げない。"

#. type: Plain text
#: build/C/man3/ilogb.3:152
msgid "B<log>(3), B<logb>(3), B<significand>(3)"
msgstr "B<log>(3), B<logb>(3), B<significand>(3)"

#. type: TH
#: build/C/man3/infnan.3:33
#, no-wrap
msgid "INFNAN"
msgstr "INFNAN"

#. type: TH
#: build/C/man3/infnan.3:33
#, no-wrap
msgid "1993-06-02"
msgstr "1993-06-02"

#. type: Plain text
#: build/C/man3/infnan.3:36
msgid "infnan - deal with infinite or not-a-number (NaN) result"
msgstr "infnan - 無限大と無効値 (NaN) を取扱う"

#. type: Plain text
#: build/C/man3/infnan.3:41
#, no-wrap
msgid "B<double infnan(int >I<error>B<);>\n"
msgstr "B<double infnan(int >I<error>B<);>\n"

#. type: Plain text
#: build/C/man3/infnan.3:54
msgid ""
"The B<infnan>()  function returns a suitable value for infinity and \"not-a-"
"number\" (NaN) results.  The value of I<error> can be B<ERANGE> to represent "
"infinity or anything else to represent NaN.  I<errno> is also set."
msgstr ""
"関数 B<infnan>()  は無限大と無効値 (NaN) の結果に対する適切な値を返す。 "
"I<error> の値は、無限大を表す B<ERANGE> か NaN を表すそれ以外の値である。 "
"I<errno> も同様に設定される。"

#. type: Plain text
#: build/C/man3/infnan.3:60
msgid "If I<error> is B<ERANGE> (Infinity), B<HUGE_VAL> is returned."
msgstr "I<error> が B<ERANGE> (無限大) の場合、 B<HUGE_VAL> が返される。"

#. type: Plain text
#: build/C/man3/infnan.3:62
msgid "If I<error> is -B<ERANGE> (-Infinity), -B<HUGE_VAL> is returned."
msgstr "I<error> が -B<ERANGE> (負の無限大) の場合、 -B<HUGE_VAL> が返される。"

#. type: Plain text
#: build/C/man3/infnan.3:64
msgid "If I<error> is anything else, NAN is returned."
msgstr "I<error> がそれ以外の値の場合、NaN が返される。"

#. type: TP
#: build/C/man3/infnan.3:65
#, no-wrap
msgid "B<EDOM>"
msgstr "B<EDOM>"

#. type: Plain text
#: build/C/man3/infnan.3:68
msgid "The value of I<error> is \"not-a-number\" (NaN)."
msgstr "I<error> の値が無効値 (NaN) である。"

#. type: TP
#: build/C/man3/infnan.3:68
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/infnan.3:71
msgid "The value of I<error> is positive infinity or negative infinity."
msgstr "I<error> の値が正の無限大もしくは負の無限大である。"

#. type: Plain text
#: build/C/man3/infnan.3:73
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man3/infnan.3:76
msgid ""
"This obsolete function was provided in libc4 and libc5, but is not available "
"in glibc2."
msgstr ""
"この廃止された (obsolete) 関数は、 libc4 と libc5 で提供されていたが、 "
"glibc2 では提供されていない。"

#. type: TH
#: build/C/man3/isgreater.3:10
#, no-wrap
msgid "ISGREATER"
msgstr "ISGREATER"

#. type: TH
#: build/C/man3/isgreater.3:10
#, no-wrap
msgid "2012-05-06"
msgstr "2012-05-06"

#. type: Plain text
#: build/C/man3/isgreater.3:14
msgid ""
"isgreater, isgreaterequal, isless, islessequal, islessgreater, isunordered - "
"floating-point relational tests without exception for NaN"
msgstr ""
"isgreater, isgreaterequal, isless, islessequal, islessgreater, isunordered - "
"NaN に対して例外を発生せずに、浮動小数点数の大小関係の判定を行う"

#. type: Plain text
#: build/C/man3/isgreater.3:19
#, no-wrap
msgid "B<int isgreater(>I<x>B<, >I<y>B<);>\n"
msgstr "B<int isgreater(>I<x>B<, >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/isgreater.3:21
#, no-wrap
msgid "B<int isgreaterequal(>I<x>B<, >I<y>B<);>\n"
msgstr "B<int isgreaterequal(>I<x>B<, >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/isgreater.3:23
#, no-wrap
msgid "B<int isless(>I<x>B<, >I<y>B<);>\n"
msgstr "B<int isless(>I<x>B<, >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/isgreater.3:25
#, no-wrap
msgid "B<int islessequal(>I<x>B<, >I<y>B<);>\n"
msgstr "B<int islessequal(>I<x>B<, >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/isgreater.3:27
#, no-wrap
msgid "B<int islessgreater(>I<x>B<, >I<y>B<);>\n"
msgstr "B<int islessgreater(>I<x>B<, >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/isgreater.3:29
#, no-wrap
msgid "B<int isunordered(>I<x>B<, >I<y>B<);>\n"
msgstr "B<int isunordered(>I<x>B<, >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/isgreater.3:40
msgid "All functions described here:"
msgstr "ここで説明する全ての関数:"

#. type: Plain text
#: build/C/man3/isgreater.3:53
msgid ""
"The normal relation operations (like B<E<lt>>, \"less than\")  will fail if "
"one of the operands is NaN.  This will cause an exception.  To avoid this, "
"C99 defines the macros listed below."
msgstr ""
"(B<E<lt>>、「小なり」のような) 通常の関係操作 (relation operations) は、\n"
"オペランドの一方が NaN の場合には失敗する。 これは例外の原因になる。\n"
"これを避けるため、C99 では以下のリストに示すマクロを定義している。"

#. type: Plain text
#: build/C/man3/isgreater.3:59
msgid ""
"These macros are guaranteed to evaluate their arguments only once.  The "
"arguments must be of real floating-point type (note: do not pass integer "
"values as arguments to these macros, since the arguments will I<not> be "
"promoted to real-floating types)."
msgstr ""
"これらのマクロでは、引き数を 1 回だけ評価することが保証されている。\n"
"引き数には実数の浮動小数点数型を指定しなければならない。\n"
"(注意: これらのマクロの引き数に整数値を渡さないこと。なぜなら\n"
"整数値の引き数は実数の浮動小数点型に変換されないからである。)"

#. type: TP
#: build/C/man3/isgreater.3:59
#, no-wrap
msgid "B<isgreater>()"
msgstr "B<isgreater>()"

#. type: Plain text
#: build/C/man3/isgreater.3:63
msgid ""
"determines I<(x)\\ E<gt>\\ (y)> without an exception if I<x> or I<y> is NaN."
msgstr ""
"I<(x)\\ E<gt>\\ (y)> を決定する。 I<x> または I<y> が NaN でも例外を発生しな"
"い。"

#. type: TP
#: build/C/man3/isgreater.3:63
#, no-wrap
msgid "B<isgreaterequal>()"
msgstr "B<isgreaterequal>()"

#. type: Plain text
#: build/C/man3/isgreater.3:67
msgid ""
"determines I<(x)\\ E<gt>=\\ (y)> without an exception if I<x> or I<y> is NaN."
msgstr ""
"I<(x)\\ E<gt>=\\ (y)> を決定する。 I<x> または I<y> が NaN でも例外を発生しな"
"い。"

#. type: TP
#: build/C/man3/isgreater.3:67
#, no-wrap
msgid "B<isless>()"
msgstr "B<isless>()"

#. type: Plain text
#: build/C/man3/isgreater.3:71
msgid ""
"determines I<(x)\\ E<lt>\\ (y)> without an exception if I<x> or I<y> is NaN."
msgstr ""
"I<(x)\\ E<lt>\\ (y)> を決定する。 I<x> または I<y> が NaN でも例外を発生しな"
"い。"

#. type: TP
#: build/C/man3/isgreater.3:71
#, no-wrap
msgid "B<islessequal>()"
msgstr "B<islessequal>()"

#. type: Plain text
#: build/C/man3/isgreater.3:75
msgid ""
"determines I<(x)\\ E<lt>=\\ (y)> without an exception if I<x> or I<y> is NaN."
msgstr ""
"I<(x)\\ E<lt>=\\ (y)> を決定する。 I<x> または I<y> が NaN でも例外を発生しな"
"い。"

#. type: TP
#: build/C/man3/isgreater.3:75
#, no-wrap
msgid "B<islessgreater>()"
msgstr "B<islessgreater>()"

#. type: Plain text
#: build/C/man3/isgreater.3:81
msgid ""
"determines I<(x)\\ E<lt> (y) || (x) E<gt>\\ (y)> without an exception if "
"I<x> or I<y> is NaN.  This macro is not equivalent to I<x\\ !=\\ y> because "
"that expression is true if I<x> or I<y> is NaN."
msgstr ""
"I<(x)\\ E<lt> (y) || (x) E<gt>\\ (y)> を決定する。 I<x> または I<y> が NaN で"
"も例外を発生しない。 このマクロは I<x\\ !=\\ y> と等価ではない。 なぜなら、こ"
"の評価式は I<x> または I<y> が NaN の場合に true となるためである。"

#. type: TP
#: build/C/man3/isgreater.3:81
#, no-wrap
msgid "B<isunordered>()"
msgstr "B<isunordered>()"

#. type: Plain text
#: build/C/man3/isgreater.3:85
msgid ""
"determines whether its arguments are unordered, that is, whether at least "
"one of the arguments is a NaN."
msgstr ""
"引き数が unordered かどうか、つまり引き数の少なくとも一方が NaN かどうか を判"
"定する。"

#. type: Plain text
#: build/C/man3/isgreater.3:90
msgid ""
"The macros other than B<isunordered>()  return the result of the relational "
"comparison; these macros return 0 if either argument is a NaN."
msgstr ""
"B<isunordered>()  以外のマクロは関係操作の結果を返す。 一方の引き数が NaN の"
"場合、これらのマクロは 0 を返す。"

#. type: Plain text
#: build/C/man3/isgreater.3:93
msgid "B<isunordered>()  returns 1 if I<x> or I<y> is NaN and 0 otherwise."
msgstr ""
"B<isunordered>()  は I<x> か I<y> が NaN の場合 1 を、 それ以外の場合 0 を返"
"す。"

#. type: Plain text
#: build/C/man3/isgreater.3:102
msgid ""
"Not all hardware supports these functions, and where hardware support isn't "
"provided, they will be emulated by macros.  This will result in a "
"performance penalty.  Don't use these functions if NaN is of no concern for "
"you."
msgstr ""
"これらの関数は全てのハードウェアでサポートされているわけではない。 サポートさ"
"れていない場合は、マクロでエミュレートされる。 エミュレートされる場合は、性能"
"上での不利となる。 NaN について心配しなくて構わない場合は、 これらの関数を使"
"わないこと。"

#. type: Plain text
#: build/C/man3/isgreater.3:105
msgid "B<fpclassify>(3), B<isnan>(3)"
msgstr "B<fpclassify>(3), B<isnan>(3)"

#. type: TH
#: build/C/man3/j0.3:36
#, no-wrap
msgid "J0"
msgstr "J0"

#. type: Plain text
#: build/C/man3/j0.3:40
msgid ""
"j0, j0f, j0l, j1, j1f, j1l, jn, jnf, jnl - Bessel functions of the first kind"
msgstr "j0, j0f, j0l, j1, j1f, j1l, jn, jnf, jnl - 第一種ベッセル関数"

#. type: Plain text
#: build/C/man3/j0.3:46
msgid "B<double j0(double >I<x>B<);>"
msgstr "B<double j0(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:48
msgid "B<double j1(double >I<x>B<);>"
msgstr "B<double j1(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:50
msgid "B<double jn(int >I<n>B<, double >I<x>B<);>"
msgstr "B<double jn(int >I<n>B<, double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:52
msgid "B<float j0f(float >I<x>B<);>"
msgstr "B<float j0f(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:54
msgid "B<float j1f(float >I<x>B<);>"
msgstr "B<float j1f(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:56
msgid "B<float jnf(int >I<n>B<, float >I<x>B<);>"
msgstr "B<float jnf(int >I<n>B<, float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:58
msgid "B<long double j0l(long double >I<x>B<);>"
msgstr "B<long double j0l(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:60
msgid "B<long double j1l(long double >I<x>B<);>"
msgstr "B<long double j1l(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:62
msgid "B<long double jnl(int >I<n>B<, long double >I<x>B<);>"
msgstr "B<long double jnl(int >I<n>B<, long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/j0.3:74
msgid "B<j0>(), B<j1>(), B<jn>():"
msgstr "B<j0>(), B<j1>(), B<jn>():"

#. type: Plain text
#: build/C/man3/j0.3:76 build/C/man3/y0.3:76
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/j0.3:84
msgid "B<j0f>(), B<j0l>(), B<j1f>(), B<j1l>(), B<jnf>(), B<jnl>():"
msgstr "B<j0f>(), B<j0l>(), B<j1f>(), B<j1l>(), B<jnf>(), B<jnl>():"

#.  Also seems to work: -std=c99 -D_XOPEN_SOURCE
#. type: Plain text
#: build/C/man3/j0.3:87 build/C/man3/y0.3:87
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: build/C/man3/j0.3:100
msgid ""
"The B<j0>()  and B<j1>()  functions return Bessel functions of I<x> of the "
"first kind of orders 0 and 1, respectively.  The B<jn>()  function returns "
"the Bessel function of I<x> of the first kind of order I<n>."
msgstr ""
"関数 B<j0>(), B<j1>()  はそれぞれ I<x> の0次、1次の 第一種ベッセル関数の値を"
"返す。 関数 B<jn>()  は I<x> の I<n> 次の 第一種ベッセル関数の値を返す。"

#. type: Plain text
#: build/C/man3/j0.3:110
msgid ""
"The B<j0f>()  etc. and B<j0l>()  etc. functions are versions that take and "
"return I<float> and I<long double> values, respectively."
msgstr ""
"B<j0f>()  群の関数、 B<j0l>()  群の関数は、それぞれ I<float> 型、 I<long "
"double> 型の返り値を返す。"

#. type: Plain text
#: build/C/man3/j0.3:114
msgid ""
"On success, these functions return the appropriate Bessel value of the first "
"kind for I<x>."
msgstr "成功すると、これらの関数は I<x> に対する第一種ベッセル関数の値を返す。"

#. type: Plain text
#: build/C/man3/j0.3:125
msgid ""
"If I<x> is too large in magnitude, or the result underflows, a range error "
"occurs, and the return value is 0."
msgstr ""
"I<x> の絶対値が大き過ぎる場合や結果がアンダーフローする場合、 範囲エラー "
"(range error) が発生し、返り値が 0 となる。"

#. type: TP
#: build/C/man3/j0.3:132
#, no-wrap
msgid "Range error: result underflow, or I<x> is too large in magnitude"
msgstr "範囲エラー: 結果のアンダーフローや、I<x> の絶対値が大き過ぎる"

#.  An underflow floating-point exception
#.  .RB ( FE_UNDERFLOW )
#.  is raised.
#. type: Plain text
#: build/C/man3/j0.3:140
msgid "I<errno> is set to B<ERANGE>."
msgstr "I<errno> に B<ERANGE> が設定される。"

#.  FIXME . Is it intentional that these functions do not raise exceptions?
#.  e.g., j0(1.5e16)
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6805
#. type: Plain text
#: build/C/man3/j0.3:146
msgid "These functions do not raise exceptions for B<fetestexcept>(3)."
msgstr "これらの関数は、 B<fetestexcept>(3)  でチェックできる例外を上げない。"

#. type: Plain text
#: build/C/man3/j0.3:152 build/C/man3/y0.3:223
msgid ""
"The functions returning I<double> conform to SVr4, 4.3BSD, POSIX.1-2001.  "
"The others are nonstandard functions that also exist on the BSDs."
msgstr ""
"I<double> 型の値を返す関数は、SVr4, 4.3BSD, POSIX.1-2001 に準拠する。 それ以"
"外は非標準の関数で、BSD にも存在する。"

#. type: Plain text
#: build/C/man3/j0.3:159
msgid ""
"There are errors of up to 2e-16 in the values returned by B<j0>(), B<j1>()  "
"and B<jn>()  for values of I<x> between -8 and 8."
msgstr ""
"-8 から 8 までの I<x> の値について B<j0>(), B<j1>(), B<jn>()  が返す値には、"
"最大で 2e-16 の誤差がある。"

#. type: Plain text
#: build/C/man3/j0.3:161
msgid "B<y0>(3)"
msgstr "B<y0>(3)"

#. type: TH
#: build/C/man3/ldexp.3:34
#, no-wrap
msgid "LDEXP"
msgstr "LDEXP"

#. type: Plain text
#: build/C/man3/ldexp.3:37
msgid ""
"ldexp, ldexpf, ldexpl - multiply floating-point number by integral power of 2"
msgstr "ldexp, ldexpf, ldexpl - 浮動小数点実数と 2 の整数乗との積を計算する"

#. type: Plain text
#: build/C/man3/ldexp.3:42
#, no-wrap
msgid "B<double ldexp(double >I<x>B<, int >I<exp>B<);>\n"
msgstr "B<double ldexp(double >I<x>B<, int >I<exp>B<);>\n"

#. type: Plain text
#: build/C/man3/ldexp.3:44
#, no-wrap
msgid "B<float ldexpf(float >I<x>B<, int >I<exp>B<);>\n"
msgstr "B<float ldexpf(float >I<x>B<, int >I<exp>B<);>\n"

#. type: Plain text
#: build/C/man3/ldexp.3:46
#, no-wrap
msgid "B<long double ldexpl(long double >I<x>B<, int >I<exp>B<);>\n"
msgstr "B<long double ldexpl(long double >I<x>B<, int >I<exp>B<);>\n"

#. type: Plain text
#: build/C/man3/ldexp.3:58
msgid "B<ldexpf>(), B<ldexpl>():"
msgstr "B<ldexpf>(), B<ldexpl>():"

#. type: Plain text
#: build/C/man3/ldexp.3:73
msgid ""
"The B<ldexp>()  function returns the result of multiplying the floating-"
"point number I<x> by 2 raised to the power I<exp>."
msgstr ""
"B<ldexp>()  関数は、浮動小数点実数 I<x> と 2 の I<exp> 乗との積を返す。"

#. type: Plain text
#: build/C/man3/ldexp.3:76
msgid "On success, these functions return I<x * (2^exp)>."
msgstr "成功すると、これらの関数は I<x * (2^exp)> を返す。"

#. type: Plain text
#: build/C/man3/ldexp.3:82
msgid "If I<exp> is zero, then I<x> is returned."
msgstr "I<exp> がゼロの場合、 I<x> が返される。"

#. type: Plain text
#: build/C/man3/ldexp.3:106 build/C/man3/scalb.3:128
#: build/C/man3/scalbln.3:120
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with a sign the "
"same as I<x>."
msgstr ""
"結果がオーバーフローする場合、 範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> を返す。符号は I<x> と同じにな"
"る。"

#. type: Plain text
#: build/C/man3/ldexp.3:139
msgid "B<frexp>(3), B<modf>(3), B<scalbln>(3)"
msgstr "B<frexp>(3), B<modf>(3), B<scalbln>(3)"

#. type: TH
#: build/C/man3/lgamma.3:11
#, no-wrap
msgid "LGAMMA"
msgstr "LGAMMA"

#. type: Plain text
#: build/C/man3/lgamma.3:15
msgid ""
"lgamma, lgammaf, lgammal, lgamma_r, lgammaf_r, lgammal_r, signgam - log "
"gamma function"
msgstr ""
"lgamma, lgammaf, lgammal, lgamma_r, lgammaf_r, lgammal_r, signgam - ガンマ関"
"数の対数を計算する"

#. type: Plain text
#: build/C/man3/lgamma.3:20
#, no-wrap
msgid "B<double lgamma(double >I<x>B<);>\n"
msgstr "B<double lgamma(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:22
#, no-wrap
msgid "B<float lgammaf(float >I<x>B<);>\n"
msgstr "B<float lgammaf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:24
#, no-wrap
msgid "B<long double lgammal(long double >I<x>B<);>\n"
msgstr "B<long double lgammal(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:26
#, no-wrap
msgid "B<double lgamma_r(double >I<x>B<, int *>I<signp>B<);>\n"
msgstr "B<double lgamma_r(double >I<x>B<, int *>I<signp>B<);>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:28
#, no-wrap
msgid "B<float lgammaf_r(float >I<x>B<, int *>I<signp>B<);>\n"
msgstr "B<float lgammaf_r(float >I<x>B<, int *>I<signp>B<);>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:30
#, no-wrap
msgid "B<long double lgammal_r(long double >I<x>B<, int *>I<signp>B<);>\n"
msgstr "B<long double lgammal_r(long double >I<x>B<, int *>I<signp>B<);>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:32
#, no-wrap
msgid "B<extern int >I<signgam>B<;>\n"
msgstr "B<extern int >I<signgam>B<;>\n"

#. type: Plain text
#: build/C/man3/lgamma.3:43
msgid "B<lgamma>():"
msgstr "B<lgamma>():"

#. type: Plain text
#: build/C/man3/lgamma.3:53
msgid "B<lgammaf>(), B<lgammal>():"
msgstr "B<lgammaf>(), B<lgammal>():"

#. type: Plain text
#: build/C/man3/lgamma.3:63
msgid "B<lgamma_r>(), B<lgammaf_r>(), B<lgammal_r>():"
msgstr "B<lgamma_r>(), B<lgammaf_r>(), B<lgammal_r>():"

#. type: Plain text
#: build/C/man3/lgamma.3:67
msgid "I<signgam>:"
msgstr "I<signgam>:"

#. type: Plain text
#: build/C/man3/lgamma.3:84
msgid ""
"The B<lgamma>()  function returns the natural logarithm of the absolute "
"value of the Gamma function.  The sign of the Gamma function is returned in "
"the external integer I<signgam> declared in I<E<lt>math.hE<gt>>.  It is 1 "
"when the Gamma function is positive or zero, -1 when it is negative."
msgstr ""
"関数 B<lgamma>()  は、ガンマ関数の絶対値の自然対数を返す。 ガンマ関数の符号"
"は、 I<E<lt>math.hE<gt>> で宣言されている extern int I<signgam> に格納され"
"る。 格納される値は、ガンマ関数が正または 0 の場合 1、 負の場合 -1 である。"

#. type: Plain text
#: build/C/man3/lgamma.3:92
msgid ""
"Since using a constant location I<signgam> is not thread-safe, the functions "
"B<lgamma_r>()  etc. have been introduced; they return the sign via the "
"argument I<signp>."
msgstr ""
"I<signgam> という固定された場所を使うことはスレッドセーフではないので、 関数 "
"B<lgamma_r>()  などが導入されている。 これらの関数では、符号は引き数 "
"I<signp> 経由で返される。"

#. type: Plain text
#: build/C/man3/lgamma.3:94
msgid "On success, these functions return the natural logarithm of Gamma(x)."
msgstr "成功すると、これらの関数は Gamma(x) の自然対数を返す。"

#. type: Plain text
#: build/C/man3/lgamma.3:102
msgid "If I<x> is 1 or 2, +0 is returned."
msgstr "I<x> が 1 か 2 の場合、+0 が返される。"

#. type: Plain text
#: build/C/man3/lgamma.3:118
msgid ""
"If I<x> is a nonpositive integer, a pole error occurs, and the functions "
"return +B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, respectively."
msgstr ""
"I<x> が正でない整数の場合、極エラー (pole error) が発生し、 各関数はそれぞれ "
"+B<HUGE_VAL>, +B<HUGE_VALF>, +B<HUGE_VALL> を返す。"

#. type: Plain text
#: build/C/man3/lgamma.3:128 build/C/man3/tgamma.3:88
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the correct "
"mathematical sign."
msgstr ""
"結果がオーバーフローする場合、範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL>, を返す。この際、数学的に正し"
"い符号が付与される。"

#. type: TP
#: build/C/man3/lgamma.3:135
#, no-wrap
msgid "Pole error: I<x> is a nonpositive integer"
msgstr "極エラー: I<x> が正でない整数"

#. type: Plain text
#: build/C/man3/lgamma.3:163
msgid ""
"The B<lgamma>()  functions are specified in C99 and POSIX.1-2001.  "
"I<signgam> is specified in POSIX.1-2001, but not in C99.  The B<lgamma_r>()  "
"functions are nonstandard, but present on several other systems."
msgstr ""
"関数 B<lgamma>()  は C99 と POSIX.1-2001 で規定されている。 I<signgam> は "
"POSIX.1-2001 で規定されているが、C99 にはない。 関数 B<lgamma_r>()  は非標準"
"だが、いくつかの他のシステムにも存在する。"

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6777
#. type: Plain text
#: build/C/man3/lgamma.3:173
msgid ""
"In glibc 2.9 and earlier, when a pole error occurs, I<errno> is set to "
"B<EDOM>; instead of the POSIX-mandated B<ERANGE>.  Since version 2.10, glibc "
"does the right thing."
msgstr ""
"glibc 2.9 とそれ以前のバージョンでは、 極エラーが発生した場合、POSIX で要求さ"
"れている B<ERANGE> ではなく B<EDOM> が I<errno> に設定される。 POSIX.1 で"
"は、 B<ERANGE> が設定されるべきとされている。 バージョン 2.10 以降の glibc で"
"は、正しい動作をする。"

#. type: Plain text
#: build/C/man3/lgamma.3:175
msgid "B<tgamma>(3)"
msgstr "B<tgamma>(3)"

#. type: TH
#: build/C/man3/log.3:36
#, no-wrap
msgid "LOG"
msgstr "LOG"

#. type: Plain text
#: build/C/man3/log.3:39
msgid "log, logf, logl - natural logarithmic function"
msgstr "log, logf, logl - 自然対数関数"

#. type: Plain text
#: build/C/man3/log.3:44
#, no-wrap
msgid "B<double log(double >I<x>B<);>\n"
msgstr "B<double log(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log.3:46
#, no-wrap
msgid "B<float logf(float >I<x>B<);>\n"
msgstr "B<float logf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log.3:48
#, no-wrap
msgid "B<long double logl(long double >I<x>B<);>\n"
msgstr "B<long double logl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log.3:60
msgid "B<logf>(), B<logl>():"
msgstr "B<logf>(), B<logl>():"

#. type: Plain text
#: build/C/man3/log.3:72
msgid "The B<log>()  function returns the natural logarithm of I<x>."
msgstr "B<log>()  関数は I<x> の自然対数を返す。"

#. type: Plain text
#: build/C/man3/log.3:75
msgid "On success, these functions return the natural logarithm of I<x>."
msgstr "成功すると、これらの関数は I<x> の自然対数を返す。"

#. type: Plain text
#: build/C/man3/log.3:84
msgid "If I<x> is 1, the result is +0."
msgstr "I<x> が 1 の場合、+0 が返される。"

#. type: Plain text
#: build/C/man3/log.3:99 build/C/man3/logb.3:111
msgid ""
"If I<x> is zero, then a pole error occurs, and the functions return -"
"B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""
"I<x> が 0 の場合、極エラー (pole error) が発生し、 各関数はそれぞれ -"
"B<HUGE_VAL>, -B<HUGE_VALF>, -B<HUGE_VALL> を返す。"

#. type: Plain text
#: build/C/man3/log.3:104
msgid ""
"If I<x> is negative (including negative infinity), then a domain error "
"occurs, and a NaN (not a number) is returned."
msgstr ""
"I<x> が負の場合 (負の無限大も含む)、領域エラー (domain error) が発生し、 NaN "
"(not a number) が返される。"

#. type: TP
#: build/C/man3/log.3:111 build/C/man3/y0.3:165
#, no-wrap
msgid "Domain error: I<x> is negative"
msgstr "領域エラー (domain error): I<x> が負である"

#. type: TP
#: build/C/man3/log.3:119
#, no-wrap
msgid "Pole error: I<x> is zero"
msgstr "極エラー (pole error): I<x> が 0 である"

#. type: Plain text
#: build/C/man3/log.3:127 build/C/man3/tgamma.3:128
msgid ""
"I<errno> is set to B<ERANGE>.  A divide-by-zero floating-point exception "
"(B<FE_DIVBYZERO>)  is raised."
msgstr ""
"I<errno> に B<ERANGE> が設定される。 0 による除算 (divide-by-zero) 浮動小数点"
"例外 (B<FE_DIVBYZERO>)  が上がる。"

#. type: Plain text
#: build/C/man3/log.3:140
msgid ""
"In glibc 2.5 and earlier, taking the B<log>()  of a NaN produces a bogus "
"invalid floating-point (B<FE_INVALID>)  exception."
msgstr ""
"glibc 2.5 以前では、 NaN に対して B<log>()  をとると、間違って不正浮動小数点"
"例外 (B<FE_INVALID>)  が発生していた。"

#. type: Plain text
#: build/C/man3/log.3:147
msgid ""
"B<cbrt>(3), B<clog>(3), B<log10>(3), B<log1p>(3), B<log2>(3), B<sqrt>(3)"
msgstr ""
"B<cbrt>(3), B<clog>(3), B<log10>(3), B<log1p>(3), B<log2>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/log10.3:36
#, no-wrap
msgid "LOG10"
msgstr "LOG10"

#. type: Plain text
#: build/C/man3/log10.3:39
msgid "log10, log10f, log10l - base-10 logarithmic function"
msgstr "log10, log10f, log10l - 底が 10 の対数関数"

#. type: Plain text
#: build/C/man3/log10.3:44
#, no-wrap
msgid "B<double log10(double >I<x>B<);>\n"
msgstr "B<double log10(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log10.3:46
#, no-wrap
msgid "B<float log10f(float >I<x>B<);>\n"
msgstr "B<float log10f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log10.3:48
#, no-wrap
msgid "B<long double log10l(long double >I<x>B<);>\n"
msgstr "B<long double log10l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log10.3:60
msgid "B<log10f>(), B<log10l>():"
msgstr "B<log10f>(), B<log10l>():"

#. type: Plain text
#: build/C/man3/log10.3:72
msgid "The B<log10>()  function returns the base 10 logarithm of I<x>."
msgstr "B<log10>()  関数は I<x> の常用対数 (底が 10 の対数) を返す。"

#. type: Plain text
#: build/C/man3/log10.3:75
msgid "On success, these functions return the base 10 logarithm of I<x>."
msgstr "成功すると、これらの関数は I<x> の常用対数 (底が 10 の対数) を返す。"

#. type: Plain text
#: build/C/man3/log10.3:80 build/C/man3/log2.3:80
msgid ""
"For special cases, including where I<x> is 0, 1, negative, infinity, or NaN, "
"see B<log>(3)."
msgstr ""
"I<x> が 0、1、負、無限大、NaN などのさまざまな特別な状況については、 B<log>"
"(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/log10.3:88 build/C/man3/log2.3:88
msgid ""
"For a discussion of the errors that can occur for these functions, see B<log>"
"(3)."
msgstr "これらの関数で発生するエラーについては、 B<log>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/log10.3:101
msgid ""
"B<cbrt>(3), B<clog10>(3), B<exp10>(3), B<log>(3), B<log2>(3), B<sqrt>(3)"
msgstr ""
"B<cbrt>(3), B<clog10>(3), B<exp10>(3), B<log>(3), B<log2>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/log1p.3:29
#, no-wrap
msgid "LOG1P"
msgstr "LOG1P"

#. type: Plain text
#: build/C/man3/log1p.3:32
msgid "log1p, log1pf, log1pl - logarithm of 1 plus argument"
msgstr "log1p, log1pf, log1pl - 引き数に 1 を加えた値の対数"

#. type: Plain text
#: build/C/man3/log1p.3:37
#, no-wrap
msgid "B<double log1p(double >I<x>B<);>\n"
msgstr "B<double log1p(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log1p.3:39
#, no-wrap
msgid "B<float log1pf(float >I<x>B<);>\n"
msgstr "B<float log1pf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log1p.3:41
#, no-wrap
msgid "B<long double log1pl(long double >I<x>B<);>\n"
msgstr "B<long double log1pl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log1p.3:52
msgid "B<log1p>():"
msgstr "B<log1p>():"

#. type: Plain text
#: build/C/man3/log1p.3:63
msgid "B<log1pf>(), B<log1pl>():"
msgstr "B<log1pf>(), B<log1pl>():"

#. type: Plain text
#: build/C/man3/log1p.3:74
msgid "I<log1p(x)> returns a value equivalent to"
msgstr "I<log1p(x)> は以下と等価な値を返す。"

#. type: Plain text
#: build/C/man3/log1p.3:77
#, no-wrap
msgid "    log (1 + I<x>)\n"
msgstr "    log (1 + I<x>)\n"

#. type: Plain text
#: build/C/man3/log1p.3:81
msgid ""
"It is computed in a way that is accurate even if the value of I<x> is near "
"zero."
msgstr "I<x> の値が 0 に近い場合でも正確に計算できる方法が用いられる。"

#. type: Plain text
#: build/C/man3/log1p.3:84
msgid ""
"On success, these functions return the natural logarithm of I<(1\\ +\\ x)>."
msgstr "成功すると、これらの関数は I<(1\\ +\\ x)> の自然対数を返す。"

#. type: Plain text
#: build/C/man3/log1p.3:103
msgid ""
"If I<x> is -1, a pole error occurs, and the functions return -B<HUGE_VAL>, -"
"B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""
"I<x> が -1 の場合、極エラー (pole error) が発生し、 各関数はそれぞれ -"
"B<HUGE_VAL>, -B<HUGE_VALF>, -B<HUGE_VALL> を返す。"

#.  POSIX.1 specifies a possible range error if x is subnormal
#.  glibc 2.8 doesn't do this
#. type: Plain text
#: build/C/man3/log1p.3:111
msgid ""
"If I<x> is less than -1 (including negative infinity), a domain error "
"occurs, and a NaN (not a number) is returned."
msgstr ""
"I<x> が -1 より小さい場合 (負の無限大も含む)、 領域エラー (domain error) が発"
"生し、 NaN (not a number) が返される。"

#. type: TP
#: build/C/man3/log1p.3:118
#, no-wrap
msgid "Domain error: I<x> is less than -1"
msgstr "領域エラー (domain error): I<x> が -1 より小さい"

#. type: TP
#: build/C/man3/log1p.3:126
#, no-wrap
msgid "Pole error: I<x> is -1"
msgstr "極エラー (pole error): I<x> が -1 である"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: build/C/man3/log1p.3:134 build/C/man3/logb.3:131
msgid "A divide-by-zero floating-point exception (B<FE_DIVBYZERO>)  is raised."
msgstr ""
"0 による除算 (divide-by-zero) 浮動小数点例外 (B<FE_DIVBYZERO>)  が上がる。"

#. type: Plain text
#: build/C/man3/log1p.3:147
msgid "B<exp>(3), B<expm1>(3), B<log>(3)"
msgstr "B<exp>(3), B<expm1>(3), B<log>(3)"

#. type: TH
#: build/C/man3/log2.3:36
#, no-wrap
msgid "LOG2"
msgstr "LOG2"

#. type: Plain text
#: build/C/man3/log2.3:39
msgid "log2, log2f, log2l - base-2 logarithmic function"
msgstr "log2, log2f, log2l - 底が 2 の対数関数"

#. type: Plain text
#: build/C/man3/log2.3:44
#, no-wrap
msgid "B<double log2(double >I<x>B<);>\n"
msgstr "B<double log2(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log2.3:46
#, no-wrap
msgid "B<float log2f(float >I<x>B<);>\n"
msgstr "B<float log2f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log2.3:48
#, no-wrap
msgid "B<long double log2l(long double >I<x>B<);>\n"
msgstr "B<long double log2l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/log2.3:61
msgid "B<log2>(), B<log2f>(), B<log2l>():"
msgstr "B<log2>(), B<log2f>(), B<log2l>():"

#. type: Plain text
#: build/C/man3/log2.3:72
msgid "The B<log2>()  function returns the base 2 logarithm of I<x>."
msgstr "B<log2>()  関数は底を 2 とする I<x> の対数を返す。"

#. type: Plain text
#: build/C/man3/log2.3:75
msgid "On success, these functions return the base 2 logarithm of I<x>."
msgstr "成功すると、これらの関数は I<x> の底を 2 とする対数を返す。"

#. type: Plain text
#: build/C/man3/log2.3:102
msgid "B<cbrt>(3), B<clog2>(3), B<log>(3), B<log10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<clog2>(3), B<log>(3), B<log10>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/logb.3:29
#, no-wrap
msgid "LOGB"
msgstr "LOGB"

#. type: Plain text
#: build/C/man3/logb.3:32
msgid "logb, logbf, logbl - get exponent of a floating-point value"
msgstr "logb, logbf, logbl - 浮動小数点数の指数を取得する"

#. type: Plain text
#: build/C/man3/logb.3:36
msgid "B<double logb(double >I<x>B<);>"
msgstr "B<double logb(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/logb.3:38
msgid "B<float logbf(float >I<x>B<);>"
msgstr "B<float logbf(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/logb.3:40
msgid "B<long double logbl(long double >I<x>B<);>"
msgstr "B<long double logbl(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/logb.3:50
msgid "B<logb>():"
msgstr "B<logb>():"

#. type: Plain text
#: build/C/man3/logb.3:61
msgid "B<logbf>(), B<logbl>():"
msgstr "B<logbf>(), B<logbl>():"

#. type: Plain text
#: build/C/man3/logb.3:86
msgid ""
"These functions extract the exponent from the internal floating-point "
"representation of I<x> and return it as a floating-point value.  The integer "
"constant B<FLT_RADIX>, defined in I<E<lt>float.hE<gt>>, indicates the radix "
"used for the system's floating-point representation.  If B<FLT_RADIX> is 2, "
"B<logb(>I<x>B<)> is equal to B<floor(log2(>I<x>B<))>, except that it is "
"probably faster."
msgstr ""
"これらの関数は、 I<x> の浮動小数点の内部表現から指数部を抽出し、浮動小数点数"
"値として返す。 I<E<lt>float.hE<gt>> で定義されている整数定数 B<FLT_RADIX> "
"は、システムの浮動小数点表現で使用されている基数を表す。 B<FLT_RADIX> が 2 の"
"場合、 B<logb(>I<x>B<)> は B<floor(log2(>I<x>B<))> と等しいが、後者の方がたぶ"
"ん高速である。"

#. type: Plain text
#: build/C/man3/logb.3:94
msgid ""
"If I<x> is subnormal, B<logb>()  returns the exponent I<x> would have if it "
"were normalized."
msgstr ""
"I<x> が非正規化数の場合、 B<logb>()  は I<x> が正規化された場合の指数を返す。"

#. type: Plain text
#: build/C/man3/logb.3:97
msgid "On success, these functions return the exponent of I<x>."
msgstr "成功すると、これらの関数は I<x> の指数部を返す。"

#. type: Plain text
#: build/C/man3/logb.3:116
msgid ""
"If I<x> is negative infinity or positive infinity, then positive infinity is "
"returned."
msgstr "I<x> が負の無限大か正の無限大の場合、正の無限大が返される。"

#. type: TP
#: build/C/man3/logb.3:123
#, no-wrap
msgid "Pole error: I<x> is 0"
msgstr "極エラー (pole error): I<x> が 0 である"

#. type: Plain text
#: build/C/man3/logb.3:148
msgid "B<ilogb>(3), B<log>(3)"
msgstr "B<ilogb>(3), B<log>(3)"

#. type: TH
#: build/C/man3/lrint.3:27
#, no-wrap
msgid "LRINT"
msgstr "LRINT"

#. type: Plain text
#: build/C/man3/lrint.3:30
msgid ""
"lrint, lrintf, lrintl, llrint, llrintf, llrintl - round to nearest integer"
msgstr ""
"lrint, lrintf, lrintl, llrint, llrintf, llrintl - 最も近い整数値に丸める"

#. type: Plain text
#: build/C/man3/lrint.3:35
#, no-wrap
msgid "B<long int lrint(double >I<x>B<);>\n"
msgstr "B<long int lrint(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lrint.3:37
#, no-wrap
msgid "B<long int lrintf(float >I<x>B<);>\n"
msgstr "B<long int lrintf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lrint.3:39
#, no-wrap
msgid "B<long int lrintl(long double >I<x>B<);>\n"
msgstr "B<long int lrintl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lrint.3:41
#, no-wrap
msgid "B<long long int llrint(double >I<x>B<);>\n"
msgstr "B<long long int llrint(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lrint.3:43
#, no-wrap
msgid "B<long long int llrintf(float >I<x>B<);>\n"
msgstr "B<long long int llrintf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lrint.3:45
#, no-wrap
msgid "B<long long int llrintl(long double >I<x>B<);>\n"
msgstr "B<long long int llrintl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lrint.3:56 build/C/man3/lround.3:57
msgid "All functions shown above:"
msgstr "上記の全ての関数:"

#. type: Plain text
#: build/C/man3/lrint.3:68
msgid ""
"These functions round their argument to the nearest integer value, using the "
"current rounding direction (see B<fesetround>(3))."
msgstr ""
"これらの関数は、現在の丸め方向に基づき、最も近い整数に引き数を丸める (現在の"
"丸め方向については B<fesetround>(3)  を参照)。"

#. type: Plain text
#: build/C/man3/lrint.3:73
msgid ""
"Note that unlike B<rint>(3), etc., the return type of these functions "
"differs from that of their arguments."
msgstr ""
"B<rint>(3)  と違い、これらの関数の返り値の型は引き数の型と異なる点に注意する"
"こと。"

#. type: Plain text
#: build/C/man3/lrint.3:75 build/C/man3/lround.3:78 build/C/man3/rint.3:107
#: build/C/man3/round.3:75 build/C/man3/trunc.3:63
msgid "These functions return the rounded integer value."
msgstr "これらの関数は丸めた整数値を返す。"

#.  The return value is -(LONG_MAX - 1) or -(LLONG_MAX -1)
#. type: Plain text
#: build/C/man3/lrint.3:87 build/C/man3/lround.3:90
msgid ""
"If I<x> is a NaN or an infinity, or the rounded value is too large to be "
"stored in a I<long> (I<long long> in the case of the B<ll*> functions)  then "
"a domain error occurs, and the return value is unspecified."
msgstr ""
"I<x> が NaN か無限大の場合、もしくは丸めた値が大き過ぎて I<long> (B<ll*> 関数"
"の場合には I<long long>)  に格納できない場合、 領域エラー (domain error) が発"
"生し、返り値は不定となる。"

#. type: TP
#: build/C/man3/lrint.3:94 build/C/man3/lround.3:97
#, no-wrap
msgid "Domain error: I<x> is a NaN or infinite, or the rounded value is too large"
msgstr "領域エラー (domain error): I<x> が NaN か無限大、もしくは丸めた値が大き過ぎる"

#. type: Plain text
#: build/C/man3/lrint.3:118
msgid ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), B<round>"
"(3)"
msgstr ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), B<round>"
"(3)"

#. type: TH
#: build/C/man3/lround.3:27
#, no-wrap
msgid "LROUND"
msgstr "LROUND"

#. type: Plain text
#: build/C/man3/lround.3:31
msgid ""
"lround, lroundf, lroundl, llround, llroundf, llroundl - round to nearest "
"integer, away from zero"
msgstr ""
"lround, lroundf, lroundl, llround, llroundf, llroundl - (0 から遠い方の) 最も"
"近い整数値に丸める"

#. type: Plain text
#: build/C/man3/lround.3:36
#, no-wrap
msgid "B<long int lround(double >I<x>B<);>\n"
msgstr "B<long int lround(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lround.3:38
#, no-wrap
msgid "B<long int lroundf(float >I<x>B<);>\n"
msgstr "B<long int lroundf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lround.3:40
#, no-wrap
msgid "B<long int lroundl(long double >I<x>B<);>\n"
msgstr "B<long int lroundl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lround.3:42
#, no-wrap
msgid "B<long long int llround(double >I<x>B<);>\n"
msgstr "B<long long int llround(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lround.3:44
#, no-wrap
msgid "B<long long int llroundf(float >I<x>B<);>\n"
msgstr "B<long long int llroundf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lround.3:46
#, no-wrap
msgid "B<long long int llroundl(long double >I<x>B<);>\n"
msgstr "B<long long int llroundl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/lround.3:70
msgid ""
"These functions round their argument to the nearest integer value, rounding "
"away from zero, regardless of the current rounding direction (see B<fenv>"
"(3))."
msgstr ""
"これらの関数は最も近い整数に引き数を丸める。 現在の丸め方向に関係なく、 0 か"
"ら遠い方の最も近い整数に引き数は丸められる (現在の丸め方向については B<fenv>"
"(3)  参照)。"

#. type: Plain text
#: build/C/man3/lround.3:76
msgid ""
"Note that unlike B<round>(3), B<ceil>(3), etc., the return type of these "
"functions differs from that of their arguments."
msgstr ""
"B<round>(3), B<ceil>(3)  などと違い、これらの関数の返り値の型は引き数の型と異"
"なる点に注意すること。"

#. type: Plain text
#: build/C/man3/lround.3:121 build/C/man3/trunc.3:87
msgid ""
"B<ceil>(3), B<floor>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>"
"(3)"
msgstr ""
"B<ceil>(3), B<floor>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>"
"(3)"

#. type: TH
#: build/C/man7/math_error.7:26
#, no-wrap
msgid "MATH_ERROR"
msgstr "MATH_ERROR"

#. type: Plain text
#: build/C/man7/math_error.7:29
msgid "math_error - detecting errors from mathematical functions"
msgstr "math_error - 数学関数からのエラーの検出"

#. type: Plain text
#: build/C/man7/math_error.7:34
#, no-wrap
msgid ""
"B<#include E<lt>math.hE<gt>>\n"
"B<#include E<lt>errno.hE<gt>>\n"
"B<#include E<lt>fenv.hE<gt>>\n"
msgstr ""
"B<#include E<lt>math.hE<gt>>\n"
"B<#include E<lt>errno.hE<gt>>\n"
"B<#include E<lt>fenv.hE<gt>>\n"

#. type: Plain text
#: build/C/man7/math_error.7:53
msgid ""
"When an error occurs, most library functions indicate this fact by returning "
"a special value (e.g., -1 or NULL).  Because they typically return a "
"floating-point number, the mathematical functions declared in I<E<lt>math."
"hE<gt>> indicate an error using other mechanisms.  There are two error-"
"reporting mechanisms: the older one sets I<errno>; the newer one uses the "
"floating-point exception mechanism (the use of B<feclearexcept>(3)  and "
"B<fetestexcept>(3), as outlined below)  described in B<fenv>(3)."
msgstr ""
"エラーが発生すると、ほとんどのライブラリ関数は (-1 や NULL などの)  特別な値"
"を返すことでエラーを通知する。 I<E<lt>math.hE<gt>> で宣言されている数学関数"
"は、通常は浮動小数点値を返すので、 他の機構を使ってエラーを通知する。 エラー"
"通知機構は 2 種類あり、 古いものが I<errno> を設定するやり方であり、新しいも"
"のが B<fenv>(3)  で説明されている浮動小数点例外機構である。 (B<feclearexcept>"
"(3)  と B<fetestexcept>(3)  を使用する。これらについては以下で概要を説明して"
"いる。)"

#. type: Plain text
#: build/C/man7/math_error.7:58
msgid ""
"A portable program that needs to check for an error from a mathematical "
"function should set I<errno> to zero, and make the following call"
msgstr ""
"移植性が必要なプログラムで、数学関数からのエラーを確認する必要がある場合に"
"は、 数学関数を呼び出す前に I<errno> を 0 に設定し、"

#. type: Plain text
#: build/C/man7/math_error.7:62
#, no-wrap
msgid "feclearexcept(FE_ALL_EXCEPT);\n"
msgstr "feclearexcept(FE_ALL_EXCEPT);\n"

#. type: Plain text
#: build/C/man7/math_error.7:66
msgid "before calling a mathematical function."
msgstr "を呼び出すべきである。"

#. type: Plain text
#: build/C/man7/math_error.7:72
msgid ""
"Upon return from the mathematical function, if I<errno> is nonzero, or the "
"following call (see B<fenv>(3))  returns nonzero"
msgstr "数学関数から返ってきた際に、 I<errno> が 0 以外か、"

#. type: Plain text
#: build/C/man7/math_error.7:77
#, no-wrap
msgid ""
"fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW |\n"
"             FE_UNDERFLOW);\n"
msgstr ""
"fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW |\n"
"             FE_UNDERFLOW);\n"

#.  enum
#.  {
#.  FE_INVALID = 0x01,
#.  __FE_DENORM = 0x02,
#.  FE_DIVBYZERO = 0x04,
#.  FE_OVERFLOW = 0x08,
#.  FE_UNDERFLOW = 0x10,
#.  FE_INEXACT = 0x20
#.  };
#. type: Plain text
#: build/C/man7/math_error.7:90
msgid "then an error occurred in the mathematical function."
msgstr ""
"の呼び出しが 0 以外を返した場合 (B<fenv>(3)  参照)、数学関数でエラーが発生し"
"ている。"

#. type: Plain text
#: build/C/man7/math_error.7:93
msgid ""
"The error conditions that can occur for mathematical functions are described "
"below."
msgstr "数学関数で発生するエラー条件については以下で説明する。"

#. type: SS
#: build/C/man7/math_error.7:93
#, fuzzy, no-wrap
#| msgid "Domain Error"
msgid "Domain error"
msgstr "領域エラー (domain error)"

#. type: Plain text
#: build/C/man7/math_error.7:109
msgid ""
"A I<domain error> occurs when a mathematical function is supplied with an "
"argument whose value falls outside the domain for which the function is "
"defined (e.g., giving a negative argument to B<log>(3)).  When a domain "
"error occurs, math functions commonly return a NaN (though some functions "
"return a different value in this case); I<errno> is set to B<EDOM>, and an "
"\"invalid\" (B<FE_INVALID>)  floating-point exception is raised."
msgstr ""
"I<領域エラー> が発生するのは、数学関数に渡された引き数の値がその関数が定義さ"
"れている 領域に入っていない場合である (例えば B<log>(3)  に負の引き数を渡した"
"場合)。 領域エラーが発生すると、 数学関数は普通は NaN を返し (同じ状況で違う"
"値を返す関数もある)、 I<errno> に B<EDOM> を設定し、「無効 (invalid)」 浮動小"
"数点例外 (B<FE_INVALID>)  を上げる。"

#. type: SS
#: build/C/man7/math_error.7:109
#, fuzzy, no-wrap
#| msgid "Pole Error"
msgid "Pole error"
msgstr "極エラー (pole error)"

#. type: Plain text
#: build/C/man7/math_error.7:133
msgid ""
"A I<pole error> occurs when the mathematical result of a function is an "
"exact infinity (e.g., the logarithm of 0 is negative infinity).  When a pole "
"error occurs, the function returns the (signed) value B<HUGE_VAL>, "
"B<HUGE_VALF>, or B<HUGE_VALL>, depending on whether the function result type "
"is I<double>, I<float>, or I<long double>.  The sign of the result is that "
"which is mathematically correct for the function.  I<errno> is set to "
"B<ERANGE>, and a \"divide-by-zero\" (B<FE_DIVBYZERO>)  floating-point "
"exception is raised."
msgstr ""
"I<極エラー> が発生するのは、関数の数学的な結果が無限大そのものとなる場合であ"
"る (例えば 0 の対数は負の無限大である)。 極エラーが発生すると、その関数の返り"
"値は (符号付きの)  B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> のいずれかとなる "
"(前記の値のうちどれが返るかは関数の返り値の型により決まり、 それぞれ "
"I<double>, I<float>, I<long double> に対応する)。 結果の符号は、その関数の数"
"学的な定義から決定される。 I<errno> は B<ERANGE> に設定され、「0 による除算 "
"(divide-by-zero)」 浮動小数点例外 (B<FE_DIVBYZERO>)  が上がる。"

#. type: SS
#: build/C/man7/math_error.7:133
#, fuzzy, no-wrap
#| msgid "Range Error"
msgid "Range error"
msgstr "範囲エラー (range エラー)"

#. type: Plain text
#: build/C/man7/math_error.7:140
msgid ""
"A I<range error> occurs when the magnitude of the function result means that "
"it cannot be represented in the result type of the function.  The return "
"value of the function depends on whether the range error was an overflow or "
"an underflow."
msgstr ""
"I<範囲エラー> が発生するのは、関数の結果の値がその関数の返り値の型では表現で"
"きない場合 である。関数の返り値は、範囲エラーがオーバーフローであったかアン"
"ダーフロー であったかによって異なる。"

#. type: Plain text
#: build/C/man7/math_error.7:162
msgid ""
"A floating result I<overflows> if the result is finite, but is too large to "
"represented in the result type.  When an overflow occurs, the function "
"returns the value B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, depending on "
"whether the function result type is I<double>, I<float>, or I<long double>.  "
"I<errno> is set to B<ERANGE>, and an \"overflow\" (B<FE_OVERFLOW>)  floating-"
"point exception is raised."
msgstr ""
"浮動小数点のオーバーフローは、結果が有限だが、大き過ぎて 結果を返す型では表現"
"できない場合に発生する。 オーバーフローが発生すると、 その関数は "
"B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> のいずれかを返す (前記の値のうちどれ"
"が返るかは関数の返り値の型により決まり、 それぞれ I<double>, I<float>, "
"I<long double> に対応する)。 I<errno> は B<ERANGE> に設定され、「オーバーフ"
"ロー (overflow)」 浮動小数点例外 (B<FE_OVERFLOW>)  が上がる。"

#. type: Plain text
#: build/C/man7/math_error.7:177
msgid ""
"A floating result I<underflows> if the result is too small to be represented "
"in the result type.  If an underflow occurs, a mathematical function "
"typically returns 0.0 (C99 says a function shall return \"an implementation-"
"defined value whose magnitude is no greater than the smallest normalized "
"positive number in the specified type\").  I<errno> may be set to B<ERANGE>, "
"and an \"overflow\" (B<FE_UNDERFLOW>)  floating-point exception may be "
"raised."
msgstr ""
"浮動小数点のアンダーフローは、 結果が小さ過ぎて、結果を返す型では表現できない"
"場合に発生する。 アンダーフローが発生すると、数学関数は通常は 0.0 を返す "
"(C99 では、指定された型において最小の正規化された正の値より大きくない 値を持"
"つ実装定義 (implementation-defined) の値を返す、となっている)。 I<errno> は "
"B<ERANGE> に設定され、「アンダーフロー」浮動小数点例外 (B<FE_UNDERFLOW>)  が"
"上がる。"

#. type: Plain text
#: build/C/man7/math_error.7:187
msgid ""
"Some functions deliver a range error if the supplied argument value, or the "
"correct function result, would be I<subnormal>.  A subnormal value is one "
"that is nonzero, but with a magnitude that is so small that it can't be "
"presented in normalized form (i.e., with a 1 in the most significant bit of "
"the significand).  The representation of a subnormal number will contain one "
"or more leading zeros in the significand."
msgstr ""
"いくつかの関数では、渡された引き数の値や、正しい関数の結果が I<subnormal (非"
"正規化数)> になる場合に範囲エラーを上げる。 subnormal な値とは、0 ではない"
"が、その値が小さすぎて (仮数部の最上位ビットが 1 となる) 標準形では表現できな"
"いような値である。 subnormal な値の表現では、仮数部の上位側のビットに 1 個以"
"上の 0 が 含まれることになる。"

#.  See CONFORMANCE in the glibc 2.8 (and earlier) source.
#. type: Plain text
#: build/C/man7/math_error.7:209
msgid ""
"The I<math_errhandling> identifier specified by C99 and POSIX.1-2001 is not "
"supported by glibc.  This identifier is supposed to indicate which of the "
"two error-notification mechanisms (I<errno>, exceptions retrievable via "
"B<fettestexcept>(3))  is in use.  The standards require that at least one be "
"in use, but permit both to be available.  The current (version 2.8) "
"situation under glibc is messy.  Most (but not all) functions raise "
"exceptions on errors.  Some also set I<errno>.  A few functions set "
"I<errno>, but don't raise an exception.  A very few functions do neither.  "
"See the individual manual pages for details."
msgstr ""
"C99 と POSIX.1-2001 で規定されている I<math_errhandling> 識別子は glibc では"
"サポートされていない。 この識別子は、2 つのエラー通知機構 (I<errno> と "
"B<fetestexcept>(3)  経由で取得できる例外) のうちどちらが使用されているかを通"
"知 することになっている。 標準では、少なくとも一つは使用されることが要求され"
"ているが、 両方とも利用可能であってもよいとされている。 glibc での現在の "
"(バージョン 2.8 での) 状況はかなり混乱している。 ほとんどの関数 (ただし全部で"
"はない) はエラー時に例外を上げる。 いくつかの関数は I<errno> も設定する。 "
"I<errno> を設定するが、例外を上げない関数も少しだけ存在する。 どちらも行わな"
"い関数もごく少数だが存在する。 詳細については個々のマニュアルページを参照のこ"
"と。"

#.  http://www.securecoding.cert.org/confluence/display/seccode/FLP32-C.+Prevent+or+detect+domain+and+range+errors+in+math+functions
#. type: Plain text
#: build/C/man7/math_error.7:222
msgid ""
"To avoid the complexities of using I<errno> and B<fetestexcept>(3)  for "
"error checking, it is often advised that one should instead check for bad "
"argument values before each call.  For example, the following code ensures "
"that B<log>(3)'s argument is not a NaN and is not zero (a pole error) or "
"less than zero (a domain error):"
msgstr ""
"I<errno> と B<fetestexcept>(3)  の両方を使ってエラーチェックを行うことで複雑"
"になるのを避けるため、 多くの場合、関数呼び出しを行う前に不正な引き数かの"
"チェックを行う 方法が推奨されている。 例えば、以下のコードは、 B<log>(3)  の"
"引き数が NaN でも (極エラーとなる) 0 でも (領域エラーとなる) 0 未満 でもない"
"ことを保証するものである。"

#. type: Plain text
#: build/C/man7/math_error.7:226
#, no-wrap
msgid "double x, r;\n"
msgstr "double x, r;\n"

#. type: Plain text
#: build/C/man7/math_error.7:230
#, no-wrap
msgid ""
"if (isnan(x) || islessequal(x, 0)) {\n"
"    /* Deal with NaN / pole error / domain error */\n"
"}\n"
msgstr ""
"if (isnan(x) || islessequal(x, 0)) {\n"
"    /* Deal with NaN / pole error / domain error */\n"
"}\n"

#. type: Plain text
#: build/C/man7/math_error.7:232
#, no-wrap
msgid "r = log(x);\n"
msgstr "r = log(x);\n"

#. type: Plain text
#: build/C/man7/math_error.7:240
msgid ""
"The discussion on this page does not apply to the complex mathematical "
"functions (i.e., those declared by I<E<lt>complex.hE<gt>>), which in general "
"are not required to return errors by C99 and POSIX.1-2001."
msgstr ""
"このページに書かれていることは、 (I<E<lt>complex.hE<gt>> で宣言されている) 複"
"素数関数にはあてはまらない。 一般に、C99 や POSIX.1-2001 ではこれらの関数がエ"
"ラーを返すことを 要求してない。"

#. type: Plain text
#: build/C/man7/math_error.7:256
msgid ""
"The B<gcc>(1)  I<-fno-math-errno> option causes the executable to employ "
"implementations of some mathematical functions that are faster than the "
"standard implementations, but do not set I<errno> on error.  (The B<gcc>(1)  "
"I<-ffast-math> option also enables I<-fno-math-errno>.)  An error can still "
"be tested for using B<fetestexcept>(3)."
msgstr ""
"B<gcc>(1)  の I<-fno-math-errno> オプションを使うと、実行ファイルで、標準の実"
"装よりも高速な数学関数の 実装が使用されるようになるが、 エラー時に I<errno> "
"が設定されない (B<gcc>(1)  の I<-ffast-math> オプションを指定した場合にも I<-"
"fno-math-errno> は有効になる)。 このオプションを指定した場合でも、 "
"B<fetestexcept>(3)  を使ったエラーの検査は可能である。"

#. type: Plain text
#: build/C/man7/math_error.7:265
msgid ""
"B<gcc>(1), B<errno>(3), B<fenv>(3), B<fpclassify>(3), B<INFINITY>(3), "
"B<isgreater>(3), B<matherr>(3), B<nan>(3)"
msgstr ""
"B<gcc>(1), B<errno>(3), B<fenv>(3), B<fpclassify>(3), B<INFINITY>(3), "
"B<isgreater>(3), B<matherr>(3), B<nan>(3)"

#. type: Plain text
#: build/C/man7/math_error.7:267
msgid "I<info libc>"
msgstr "I<info libc>"

#. type: TH
#: build/C/man3/matherr.3:27
#, no-wrap
msgid "MATHERR"
msgstr "MATHERR"

#. type: TH
#: build/C/man3/matherr.3:27
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/matherr.3:30
msgid "matherr - SVID math library exception handling"
msgstr "matherr - SVID 数学ライブラリの例外処理"

#. type: Plain text
#: build/C/man3/matherr.3:34
#, no-wrap
msgid ""
"B<#define _SVID_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr ""
"B<#define _SVID_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/matherr.3:36
#, no-wrap
msgid "B<int matherr(struct exception *>I<exc>B<);>\n"
msgstr "B<int matherr(struct exception *>I<exc>B<);>\n"

#. type: Plain text
#: build/C/man3/matherr.3:38
#, no-wrap
msgid "B<extern _LIB_VERSION_TYPE _LIB_VERSION;>\n"
msgstr "B<extern _LIB_VERSION_TYPE _LIB_VERSION;>\n"

#. type: Plain text
#: build/C/man3/matherr.3:51
msgid ""
"The System V Interface Definition (SVID) specifies that various math "
"functions should invoke a function called B<matherr>()  if a math exception "
"is detected.  This function is called before the math function returns; "
"after B<matherr>()  returns, the system then returns to the math function, "
"which in turn returns to the caller."
msgstr ""
"System V Interface Definition (SVID) では、各種の数学関数は数学的な\n"
"例外を検出した場合に B<matherr>() を呼ばれる関数を起動すべきである、\n"
"と規定されている。この関数は数学関数が返る前に呼び出される。\n"
"B<matherr>() が返った後に、システムは数学関数に戻り、\n"
"それから呼び出し元に返る。"

#. type: Plain text
#: build/C/man3/matherr.3:62
msgid ""
"The B<matherr>()  mechanism is supported by glibc, but is now obsolete: new "
"applications should use the techniques described in B<math_error>(7)  and "
"B<fenv>(3).  This page documents the glibc B<matherr>()  mechanism as an aid "
"for maintaining and porting older applications."
msgstr ""
"B<matherr>() の仕組みは glibc によりサポートされているが、\n"
"現在は廃止予定の扱いである。\n"
"新しくアプリケーションを作成する際には、\n"
"B<math_error>(7) と B<fenv>(3) で説明されている手法を使用すべきである。\n"
"このマニュアルページでは、古いアプリケーションを保守したり移植する際の\n"
"助けとなるよう、 glibc の B<matherr>() の仕組みについて説明する。"

#. type: Plain text
#: build/C/man3/matherr.3:75
msgid ""
"To employ B<matherr>(), the programmer must define the B<_SVID_SOURCE> "
"feature test macro (before including I<any> header files), and assign the "
"value B<_SVID_> to the external variable B<_LIB_VERSION>."
msgstr ""
"B<matherr>() を使用するためには、\n"
"プログラマは (I<どの>ヘッダファイルをインクルードするよりも前に)\n"
"B<_SVID_SOURCE> 機能検査マクロを定義し、値 B<_SVID_> をグローバル変数\n"
"B<_LIB_VERSION> に代入しなければならない。"

#. type: Plain text
#: build/C/man3/matherr.3:87
msgid ""
"The system provides a default version of B<matherr>().  This version does "
"nothing, and returns zero (see below for the significance of this).  The "
"default B<matherr>()  can be overridden by a programmer-defined version, "
"which will be invoked when an exception occurs.  The function is invoked "
"with one argument, a pointer to an I<exception> structure, defined as "
"follows:"
msgstr ""
"デフォルト版の B<matherr>() がシステムによって提供されている。\n"
"デフォルト版は何も行わず、0 を返す (このことの重要性については\n"
"下記を参照)。プログラマが B<matherr>() を定義することで、\n"
"デフォルト版を上書きすることができる。\n"
"プログラマが定義した関数は例外が発生した際に起動される。\n"
"この関数は引き数 1 個で起動され、その引き数は以下に示す\n"
"I<exception> 構造体へのポインタである。"

#. type: Plain text
#: build/C/man3/matherr.3:97
#, no-wrap
msgid ""
"struct exception {\n"
"    int    type;      /* Exception type */\n"
"    char  *name;      /* Name of function causing exception */\n"
"    double arg1;      /* 1st argument to function */\n"
"    double arg2;      /* 2nd argument to function */\n"
"    double retval;    /* Function return value */\n"
"}\n"
msgstr ""
"struct exception {\n"
"    int    type;      /* Exception type */\n"
"    char  *name;      /* Name of function causing exception */\n"
"    double arg1;      /* 1st argument to function */\n"
"    double arg2;      /* 2nd argument to function */\n"
"    double retval;    /* Function return value */\n"
"}\n"

#. type: Plain text
#: build/C/man3/matherr.3:103
msgid "The I<type> field has one of the following values:"
msgstr "I<type> フィールドは以下の値のいずれかである。"

#. type: TP
#: build/C/man3/matherr.3:103
#, no-wrap
msgid "B<DOMAIN>"
msgstr "B<DOMAIN>"

#. type: Plain text
#: build/C/man3/matherr.3:111
msgid ""
"A domain error occurred (the function argument was outside the range for "
"which the function is defined).  The return value depends on the function; "
"I<errno> is set to B<EDOM>."
msgstr ""
"領域エラー (domain error) が発生した\n"
"(関数の引き数が関数が定義された範囲外であった)。\n"
"返り値は関数によって異なり、 I<error> には B<EDOM> が設定される。"

#. type: TP
#: build/C/man3/matherr.3:111
#, no-wrap
msgid "B<SING>"
msgstr "B<SING>"

#. type: Plain text
#: build/C/man3/matherr.3:122
msgid ""
"A pole error occurred (the function result is an infinity).  The return "
"value in most cases is B<HUGE> (the largest single precision floating-point "
"number), appropriately signed.  In most cases, I<errno> is set to B<EDOM>."
msgstr ""
"極エラー (pole error) が発生した (関数の結果が無限大である)。\n"
"返り値はほとんどの場合 B<HUGE> (最大の単精度浮動小数点数) となり、\n"
"たいていは符号付きである。\n"
"ほとんどの場合、I<errno> には B<EDOM> が設定される。"

#. type: TP
#: build/C/man3/matherr.3:122
#, no-wrap
msgid "B<OVERFLOW>"
msgstr "B<OVERFLOW>"

#. type: Plain text
#: build/C/man3/matherr.3:131
msgid ""
"An overflow occurred.  In most cases, the value B<HUGE> is returned, and "
"I<errno> is set to B<ERANGE>."
msgstr ""
"オーバーフローが発生した。\n"
"ほとんどの場合、値 B<HUGE> が返され、\n"
"I<errno> には B<ERANGE> が設定される。"

#. type: TP
#: build/C/man3/matherr.3:131
#, no-wrap
msgid "B<UNDERFLOW>"
msgstr "B<UNDERFLOW>"

#. type: Plain text
#: build/C/man3/matherr.3:138
msgid ""
"An underflow occurred.  0.0 is returned, and I<errno> is set to B<ERANGE>."
msgstr ""
"アンダーフローが発生した。\n"
"0.0 が返され、 I<errno> に B<ERANGE> が設定される。"

#. type: TP
#: build/C/man3/matherr.3:138
#, no-wrap
msgid "B<TLOSS>"
msgstr "B<TLOSS>"

#. type: Plain text
#: build/C/man3/matherr.3:145
msgid ""
"Total loss of significance.  0.0 is returned, and I<errno> is set to "
"B<ERANGE>."
msgstr ""
"Total loss of significance が発生した。\n"
"0.0 が返され、 I<errno> に B<ERANGE> が設定される。"

#. type: TP
#: build/C/man3/matherr.3:145
#, no-wrap
msgid "B<PLOSS>"
msgstr "B<PLOSS>"

#. type: Plain text
#: build/C/man3/matherr.3:150
msgid ""
"Partial loss of significance.  This value is unused on glibc (and many other "
"systems)."
msgstr ""
"Partial loss of significance が発生した。\n"
"この値は glibc (や他の多くのシステム) で使用されていない。"

#. type: Plain text
#: build/C/man3/matherr.3:158
msgid ""
"The I<arg1> and I<arg2> fields are the arguments supplied to the function "
"(I<arg2> is undefined for functions that take only one argument)."
msgstr ""
"フィールド I<arg1> と I<arg2> は関数に渡された引き数である\n"
"(引き数を一つしか取らない関数の場合は I<arg2> は不定となる)。"

#. type: Plain text
#: build/C/man3/matherr.3:166
msgid ""
"The I<retval> field specifies the return value that the math function will "
"return to its caller.  The programmer-defined B<matherr>()  can modify this "
"field to change the return value of the math function."
msgstr ""
"I<retval> フィールドはその数学関数が呼び出し元に返そうとしている返り値\n"
"を示す。プログラマが定義した B<matherr>() でこのフィールドを変更する\n"
"ことで、その数学関数の返り値を変更することができる。"

#. type: Plain text
#: build/C/man3/matherr.3:173
msgid ""
"If the B<matherr>()  function returns zero, then the system sets I<errno> as "
"described above, and may print an error message on standard error (see "
"below)."
msgstr ""
"B<matherr>() 関数が 0 を返した場合、\n"
"システムは I<errno> を上記の通り設定し、標準エラー出力に\n"
"エラーメッセージを表示することがある (下記参照)。"

#. type: Plain text
#: build/C/man3/matherr.3:179
msgid ""
"If the B<matherr>()  function returns a nonzero value, then the system does "
"not set I<errno>, and doesn't print an error message."
msgstr ""
"B<matherr>() 関数が 0 以外の値を返した場合、\n"
"システムは I<errno> を設定せず、エラーメッセージの表示も行わない。"

#. type: SS
#: build/C/man3/matherr.3:179
#, no-wrap
msgid "Math functions that employ matherr()"
msgstr "matherr() を利用している数学関数"

#. type: Plain text
#: build/C/man3/matherr.3:189
msgid ""
"The table below lists the functions and circumstances in which B<matherr>()  "
"is called.  The \"Type\" column indicates the value assigned to I<exc-"
"E<gt>type> when calling B<matherr>().  The \"Result\" column is the default "
"return value assigned to I<exc-E<gt>retval>."
msgstr ""
"下記の表は、関数と B<matherr>() が呼び出される状況の一覧である。\n"
"\"Type\" 列 は B<matherr>() が呼び出される際に I<exc-E<gt>type> に\n"
"設定される値を示す。 \"Result\" 列は I<exc-E<gt>retval> に\n"
"設定されるデフォルトの返り値を示す。"

#. type: Plain text
#: build/C/man3/matherr.3:195
msgid ""
"The \"Msg?\" and \"errno\" columns describe the default behavior if "
"B<matherr>()  returns zero.  If the \"Msg?\" columns contains \"y\", then "
"the system prints an error message on standard error."
msgstr ""
"\"Msg?\" 列と \"errno\" 列は B<matherr>() が 0 を返した場合のデフォルトの\n"
"動作を示す。 \"Msg?\" 列に \"y\" が入っている場合、システムは標準エラー\n"
"出力にエラーメッセージを表示する。"

#. type: Plain text
#: build/C/man3/matherr.3:197
msgid "The table uses the following notations and abbreviations:"
msgstr "以下の表では、下記の記法と省略形を使用している。"

#. type: Plain text
#: build/C/man3/matherr.3:209
#, no-wrap
msgid ""
"x        first argument to function\n"
"y        second argument to function\n"
"fin      finite value for argument\n"
"neg      negative value for argument\n"
"int      integral value for argument\n"
"o/f      result overflowed\n"
"u/f      result underflowed\n"
"|x|      absolute value of x\n"
"X_TLOSS  is a constant defined in I<E<lt>math.hE<gt>>\n"
msgstr ""
"x        関数の最初の引き数\n"
"y        関数の二番目の引き数\n"
"fin      引き数の値が無限大\n"
"neg      引き数が負の値\n"
"int      引き数が整数値\n"
"o/f      結果のオーバーフロー\n"
"u/f      結果のアンダーフロー\n"
"|x|      x の絶対値\n"
"X_TLOSS  I<E<lt>math.hE<gt>> で定義される定数\n"

#. type: tbl table
#: build/C/man3/matherr.3:216
#, no-wrap
msgid "Function\tType\tResult\tMsg?\terrno\n"
msgstr "Function\tType\tResult\tMsg?\terrno\n"

#. type: tbl table
#: build/C/man3/matherr.3:217
#, no-wrap
msgid "acos(|x|E<gt>1)\tDOMAIN\tHUGE\ty\tEDOM\n"
msgstr "acos(|x|E<gt>1)\tDOMAIN\tHUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:218
#, no-wrap
msgid "asin(|x|E<gt>1)\tDOMAIN\tHUGE\ty\tEDOM\n"
msgstr "asin(|x|E<gt>1)\tDOMAIN\tHUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:219
#, no-wrap
msgid "atan2(0,0)\tDOMAIN\tHUGE\ty\tEDOM\n"
msgstr "atan2(0,0)\tDOMAIN\tHUGE\ty\tEDOM\n"

#.  retval is 0.0/0.0
#. type: tbl table
#: build/C/man3/matherr.3:220
#, no-wrap
msgid "acosh(xE<lt>1)\tDOMAIN\tNAN\ty\tEDOM\t\n"
msgstr "acosh(xE<lt>1)\tDOMAIN\tNAN\ty\tEDOM\t\n"

#.  retval is 0.0/0.0
#. type: tbl table
#: build/C/man3/matherr.3:221
#, no-wrap
msgid "atanh(|x|E<gt>1)\tDOMAIN\tNAN\ty\tEDOM\t\n"
msgstr "atanh(|x|E<gt>1)\tDOMAIN\tNAN\ty\tEDOM\t\n"

#.  retval is x/0.0
#. type: tbl table
#: build/C/man3/matherr.3:222
#, no-wrap
msgid "atanh(|x|==1)\tSING\t(xE<gt>0.0)?\ty\tEDOM\t\n"
msgstr "atanh(|x|==1)\tSING\t(xE<gt>0.0)?\ty\tEDOM\t\n"

#. type: tbl table
#: build/C/man3/matherr.3:223 build/C/man3/matherr.3:268
#, no-wrap
msgid "\\ \t\\ \tHUGE_VAL :\n"
msgstr "\\ \t\\ \tHUGE_VAL :\n"

#. type: tbl table
#: build/C/man3/matherr.3:224 build/C/man3/matherr.3:269
#, no-wrap
msgid "\\ \t\\ \t-HUGE_VAL\n"
msgstr "\\ \t\\ \t-HUGE_VAL\n"

#. type: tbl table
#: build/C/man3/matherr.3:225
#, no-wrap
msgid "cosh(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "cosh(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:226
#, no-wrap
msgid "sinh(fin) o/f\tOVERFLOW\t(xE<gt>0.0) ?\tn\tERANGE\n"
msgstr "sinh(fin) o/f\tOVERFLOW\t(xE<gt>0.0) ?\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:227
#, no-wrap
msgid "\\ \t\\ \tHUGE : -HUGE\n"
msgstr "\\ \t\\ \tHUGE : -HUGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:228
#, no-wrap
msgid "sqrt(xE<lt>0)\tDOMAIN\t0.0\ty\tEDOM\n"
msgstr "sqrt(xE<lt>0)\tDOMAIN\t0.0\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:229
#, no-wrap
msgid "hypot(fin,fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "hypot(fin,fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:230
#, no-wrap
msgid "exp(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "exp(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:231
#, no-wrap
msgid "exp(fin) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"
msgstr "exp(fin) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:232
#, no-wrap
msgid "exp2(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "exp2(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:233
#, no-wrap
msgid "exp2(fin) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"
msgstr "exp2(fin) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:234
#, no-wrap
msgid "exp10(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "exp10(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:235
#, no-wrap
msgid "exp10(fin) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"
msgstr "exp10(fin) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:236
#, no-wrap
msgid "j0(|x|E<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"
msgstr "j0(|x|E<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:237
#, no-wrap
msgid "j1(|x|E<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"
msgstr "j1(|x|E<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:238
#, no-wrap
msgid "jn(|x|E<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"
msgstr "jn(|x|E<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:239
#, no-wrap
msgid "y0(xE<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"
msgstr "y0(xE<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:240
#, no-wrap
msgid "y1(xE<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"
msgstr "y1(xE<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:241
#, no-wrap
msgid "yn(xE<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"
msgstr "yn(xE<gt>X_TLOSS)\tTLOSS\t0.0\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:242
#, no-wrap
msgid "y0(0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "y0(0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:243
#, no-wrap
msgid "y0(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "y0(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:244
#, no-wrap
msgid "y1(0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "y1(0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:245
#, no-wrap
msgid "y1(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "y1(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:246
#, no-wrap
msgid "yn(n,0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "yn(n,0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:247
#, no-wrap
msgid "yn(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "yn(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:248
#, no-wrap
msgid "lgamma(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "lgamma(fin) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:249
#, no-wrap
msgid "lgamma(-int) or\tSING\tHUGE\ty\tEDOM\n"
msgstr "lgamma(-int) or\tSING\tHUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:250
#, no-wrap
msgid "\\ \\ lgamma(0)\n"
msgstr "\\ \\ lgamma(0)\n"

#. type: tbl table
#: build/C/man3/matherr.3:251
#, no-wrap
msgid "tgamma(fin) o/f\tOVERFLOW\tHUGE_VAL\tn\tERANGE\n"
msgstr "tgamma(fin) o/f\tOVERFLOW\tHUGE_VAL\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:252
#, no-wrap
msgid "tgamma(-int)\tSING\tNAN\ty\tEDOM\n"
msgstr "tgamma(-int)\tSING\tNAN\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:253
#, no-wrap
msgid "tgamma(0)\tSING\tcopysign(\ty\tERANGE\n"
msgstr "tgamma(0)\tSING\tcopysign(\ty\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:254
#, no-wrap
msgid "\\ \t\\ \tHUGE_VAL,x)\n"
msgstr "\\ \t\\ \tHUGE_VAL,x)\n"

#. type: tbl table
#: build/C/man3/matherr.3:255
#, no-wrap
msgid "log(0)\tSING\t-HUGE\ty\tEDOM\n"
msgstr "log(0)\tSING\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:256
#, no-wrap
msgid "log(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "log(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#.  different from log()
#. type: tbl table
#: build/C/man3/matherr.3:257
#, no-wrap
msgid "log2(0)\tSING\t-HUGE\tn\tEDOM\t\n"
msgstr "log2(0)\tSING\t-HUGE\tn\tEDOM\t\n"

#.  different from log()
#. type: tbl table
#: build/C/man3/matherr.3:258
#, no-wrap
msgid "log2(xE<lt>0)\tDOMAIN\t-HUGE\tn\tEDOM\t\n"
msgstr "log2(xE<lt>0)\tDOMAIN\t-HUGE\tn\tEDOM\t\n"

#. type: tbl table
#: build/C/man3/matherr.3:259
#, no-wrap
msgid "log10(0)\tSING\t-HUGE\ty\tEDOM\n"
msgstr "log10(0)\tSING\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:260
#, no-wrap
msgid "log10(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"
msgstr "log10(xE<lt>0)\tDOMAIN\t-HUGE\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:261
#, no-wrap
msgid "pow(0.0,0.0)\tDOMAIN\t0.0\ty\tEDOM\n"
msgstr "pow(0.0,0.0)\tDOMAIN\t0.0\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:262
#, no-wrap
msgid "pow(x,y) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"
msgstr "pow(x,y) o/f\tOVERFLOW\tHUGE\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:263
#, no-wrap
msgid "pow(x,y) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"
msgstr "pow(x,y) u/f\tUNDERFLOW\t0.0\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:264
#, no-wrap
msgid "pow(NaN,0.0)\tDOMAIN\tx\tn\tEDOM\n"
msgstr "pow(NaN,0.0)\tDOMAIN\tx\tn\tEDOM\n"

#.  +0 and -0
#. type: tbl table
#: build/C/man3/matherr.3:265
#, no-wrap
msgid "0**neg\tDOMAIN\t0.0\ty\tEDOM\t\n"
msgstr "0**neg\tDOMAIN\t0.0\ty\tEDOM\t\n"

#. type: tbl table
#: build/C/man3/matherr.3:266
#, no-wrap
msgid "neg**non-int\tDOMAIN\t0.0\ty\tEDOM\n"
msgstr "neg**non-int\tDOMAIN\t0.0\ty\tEDOM\n"

#. type: tbl table
#: build/C/man3/matherr.3:267
#, no-wrap
msgid "scalb() o/f\tOVERFLOW\t(xE<gt>0.0) ?\tn\tERANGE\n"
msgstr "scalb() o/f\tOVERFLOW\t(xE<gt>0.0) ?\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:270
#, no-wrap
msgid "scalb() u/f\tUNDERFLOW\tcopysign(\tn\tERANGE\n"
msgstr "scalb() u/f\tUNDERFLOW\tcopysign(\tn\tERANGE\n"

#. type: tbl table
#: build/C/man3/matherr.3:271
#, no-wrap
msgid "\\ \t\\ \t\\ \\ 0.0,x)\n"
msgstr "\\ \t\\ \t\\ \\ 0.0,x)\n"

#. type: tbl table
#: build/C/man3/matherr.3:272
#, no-wrap
msgid "fmod(x,0)\tDOMAIN\tx\ty\tEDOM\n"
msgstr "fmod(x,0)\tDOMAIN\tx\ty\tEDOM\n"

#.  retval is 0.0/0.0
#. type: tbl table
#: build/C/man3/matherr.3:273
#, no-wrap
msgid "remainder(x,0)\tDOMAIN\tNAN\ty\tEDOM\t\n"
msgstr "remainder(x,0)\tDOMAIN\tNAN\ty\tEDOM\t\n"

#. type: Plain text
#: build/C/man3/matherr.3:296
msgid ""
"The example program demonstrates the use of B<matherr>()  when calling B<log>"
"(3).  The program takes up to three command-line arguments.  The first "
"argument is the floating-point number to be given to B<log>(3).  If the "
"optional second argument is provided, then B<_LIB_VERSION> is set to "
"B<_SVID_> so that B<matherr>()  is called, and the integer supplied in the "
"command-line argument is used as the return value from B<matherr>().  If the "
"optional third command-line argument is supplied, then it specifies an "
"alternative return value that B<matherr>()  should assign as the return "
"value of the math function."
msgstr ""
"以下のサンプルプログラムは B<log>(3) を呼び出した際の\n"
"B<matherr>() の使用法を示したものである。\n"
"最初の引き数は B<log>(3) に渡す浮動小数点数である。\n"
"省略可能な第二引き数を指定した場合、\n"
"B<_LIB_VERSION> に B<_SVID_> が設定され、\n"
"B<matherr>() が呼ばれるようになる。\n"
"このコマンドライン引き数で指定した整数は、\n"
"B<matherr>() からの返り値として使用される。\n"
"省略可能な第三引き数を指定した場合、 B<matherr>() は\n"
"数学関数の返り値として代わりに引き数で指定した値を割り当てる。"

#. type: Plain text
#: build/C/man3/matherr.3:301
msgid ""
"The following example run, where B<log>(3)  is given an argument of 0.0, "
"does not use B<matherr>():"
msgstr ""
"以下の実行例では、\n"
"B<log>(3) に引き数 0.0 が渡しているが、\n"
"B<matherr>() は使用しない。"

#. type: Plain text
#: build/C/man3/matherr.3:307
#, no-wrap
msgid ""
"$B< ./a.out 0.0>\n"
"errno: Numerical result out of range\n"
"x=-inf\n"
msgstr ""
"$B< ./a.out 0.0>\n"
"errno: Numerical result out of range\n"
"x=-inf\n"

#. type: Plain text
#: build/C/man3/matherr.3:313
msgid "In the following run, B<matherr>()  is called, and returns 0:"
msgstr ""
"以下の実行例では、\n"
"B<matherr>() が呼び出され、返り値 0 が返される。"

#. type: Plain text
#: build/C/man3/matherr.3:323
#, no-wrap
msgid ""
"$B< ./a.out 0.0 0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"log: SING error\n"
"errno: Numerical argument out of domain\n"
"x=-340282346638528859811704183484516925440.000000\n"
msgstr ""
"$B< ./a.out 0.0 0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"log: SING error\n"
"errno: Numerical argument out of domain\n"
"x=-340282346638528859811704183484516925440.000000\n"

#. type: Plain text
#: build/C/man3/matherr.3:327
msgid "The message \"log: SING error\" was printed by the C library."
msgstr "メッセージ \"log: SING error\" は C ライブラリによって出力されている。"

#. type: Plain text
#: build/C/man3/matherr.3:331
msgid ""
"In the following run, B<matherr>()  is called, and returns a nonzero value:"
msgstr "次の実行例では、 B<matherr>() が呼び出され、0 以外の返り値が返される。"

#. type: Plain text
#: build/C/man3/matherr.3:339
#, no-wrap
msgid ""
"$B< ./a.out 0.0 1>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=-340282346638528859811704183484516925440.000000\n"
msgstr ""
"$B< ./a.out 0.0 1>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=-340282346638528859811704183484516925440.000000\n"

#. type: Plain text
#: build/C/man3/matherr.3:345
msgid ""
"In this case, the C library did not print a message, and I<errno> was not "
"set."
msgstr ""
"この場合は、C ライブラリはメッセージを出力しておらず、\n"
"I<errno> は設定されていない。"

#. type: Plain text
#: build/C/man3/matherr.3:350
msgid ""
"In the following run, B<matherr>()  is called, changes the return value of "
"the math function, and returns a nonzero value:"
msgstr ""
"次の実行例では、 B<matherr>() が呼び出され、\n"
"数学関数の返り値が変更され、0 以外の返り値が返されている。"

#. type: Plain text
#: build/C/man3/matherr.3:358
#, no-wrap
msgid ""
"$B< ./a.out 0.0 1 12345.0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=12345.000000\n"
msgstr ""
"$B< ./a.out 0.0 1 12345.0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=12345.000000\n"

#. type: Plain text
#: build/C/man3/matherr.3:368
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _SVID_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/matherr.3:374
#, no-wrap
msgid ""
"static int matherr_ret = 0;     /* Value that matherr()\n"
"                                   should return */\n"
"static int change_retval = 0;   /* Should matherr() change\n"
"                                   function\\(aqs return value? */\n"
"static double new_retval;       /* New function return value */\n"
msgstr ""
"static int matherr_ret = 0;     /* Value that matherr()\n"
"                                   should return */\n"
"static int change_retval = 0;   /* Should matherr() change\n"
"                                   function\\(aqs return value? */\n"
"static double new_retval;       /* New function return value */\n"

#. type: Plain text
#: build/C/man3/matherr.3:389
#, no-wrap
msgid ""
"int\n"
"matherr(struct exception *exc)\n"
"{\n"
"    fprintf(stderr, \"matherr %s exception in %s() function\\en\",\n"
"           (exc-E<gt>type == DOMAIN) ?    \"DOMAIN\" :\n"
"           (exc-E<gt>type == OVERFLOW) ?  \"OVERFLOW\" :\n"
"           (exc-E<gt>type == UNDERFLOW) ? \"UNDERFLOW\" :\n"
"           (exc-E<gt>type == SING) ?      \"SING\" :\n"
"           (exc-E<gt>type == TLOSS) ?     \"TLOSS\" :\n"
"           (exc-E<gt>type == PLOSS) ?     \"PLOSS\" : \"???\",\n"
"            exc-E<gt>name);\n"
"    fprintf(stderr, \"        args:   %f, %f\\en\",\n"
"            exc-E<gt>arg1, exc-E<gt>arg2);\n"
"    fprintf(stderr, \"        retval: %f\\en\", exc-E<gt>retval);\n"
msgstr ""
"int\n"
"matherr(struct exception *exc)\n"
"{\n"
"    fprintf(stderr, \"matherr %s exception in %s() function\\en\",\n"
"           (exc-E<gt>type == DOMAIN) ?    \"DOMAIN\" :\n"
"           (exc-E<gt>type == OVERFLOW) ?  \"OVERFLOW\" :\n"
"           (exc-E<gt>type == UNDERFLOW) ? \"UNDERFLOW\" :\n"
"           (exc-E<gt>type == SING) ?      \"SING\" :\n"
"           (exc-E<gt>type == TLOSS) ?     \"TLOSS\" :\n"
"           (exc-E<gt>type == PLOSS) ?     \"PLOSS\" : \"???\",\n"
"            exc-E<gt>name);\n"
"    fprintf(stderr, \"        args:   %f, %f\\en\",\n"
"            exc-E<gt>arg1, exc-E<gt>arg2);\n"
"    fprintf(stderr, \"        retval: %f\\en\", exc-E<gt>retval);\n"

#. type: Plain text
#: build/C/man3/matherr.3:392
#, no-wrap
msgid ""
"    if (change_retval)\n"
"        exc-E<gt>retval = new_retval;\n"
msgstr ""
"    if (change_retval)\n"
"        exc-E<gt>retval = new_retval;\n"

#. type: Plain text
#: build/C/man3/matherr.3:395
#, no-wrap
msgid ""
"    return matherr_ret;\n"
"}\n"
msgstr ""
"    return matherr_ret;\n"
"}\n"

#. type: Plain text
#: build/C/man3/matherr.3:400
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x;\n"

#. type: Plain text
#: build/C/man3/matherr.3:406
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>argvalE<gt>\"\n"
"                \" [E<lt>matherr-retE<gt> [E<lt>new-func-retvalE<gt>]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>argvalE<gt>\"\n"
"                \" [E<lt>matherr-retE<gt> [E<lt>new-func-retvalE<gt>]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/matherr.3:411
#, no-wrap
msgid ""
"    if (argc E<gt> 2) {\n"
"        _LIB_VERSION = _SVID_;\n"
"        matherr_ret = atoi(argv[2]);\n"
"    }\n"
msgstr ""
"    if (argc E<gt> 2) {\n"
"        _LIB_VERSION = _SVID_;\n"
"        matherr_ret = atoi(argv[2]);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/matherr.3:416
#, no-wrap
msgid ""
"    if (argc E<gt> 3) {\n"
"        change_retval = 1;\n"
"        new_retval = atof(argv[3]);\n"
"    }\n"
msgstr ""
"    if (argc E<gt> 3) {\n"
"        change_retval = 1;\n"
"        new_retval = atof(argv[3]);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/matherr.3:420
#, no-wrap
msgid ""
"    x = log(atof(argv[1]));\n"
"    if (errno != 0)\n"
"        perror(\"errno\");\n"
msgstr ""
"    x = log(atof(argv[1]));\n"
"    if (errno != 0)\n"
"        perror(\"errno\");\n"

#. type: Plain text
#: build/C/man3/matherr.3:424
#, no-wrap
msgid ""
"    printf(\"x=%f\\en\", x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"x=%f\\en\", x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/matherr.3:429
msgid "B<fenv>(3), B<math_error>(7), B<standards>(7)"
msgstr "B<fenv>(3), B<math_error>(7), B<standards>(7)"

#. type: TH
#: build/C/man3/modf.3:33
#, no-wrap
msgid "MODF"
msgstr "MODF"

#. type: Plain text
#: build/C/man3/modf.3:37
msgid ""
"modf, modff, modfl - extract signed integral and fractional values from "
"floating-point number"
msgstr ""
"modf, modff, modfl - 浮動小数点実数から、符号付き整数と小数部分を取り出す関数"

#. type: Plain text
#: build/C/man3/modf.3:42
#, no-wrap
msgid "B<double modf(double >I<x>B<, double *>I<iptr>B<);>\n"
msgstr "B<double modf(double >I<x>B<, double *>I<iptr>B<);>\n"

#. type: Plain text
#: build/C/man3/modf.3:44
#, no-wrap
msgid "B<float modff(float >I<x>B<, float *>I<iptr>B<);>\n"
msgstr "B<float modff(float >I<x>B<, float *>I<iptr>B<);>\n"

#. type: Plain text
#: build/C/man3/modf.3:46
#, no-wrap
msgid "B<long double modfl(long double >I<x>B<, long double *>I<iptr>B<);>\n"
msgstr "B<long double modfl(long double >I<x>B<, long double *>I<iptr>B<);>\n"

#. type: Plain text
#: build/C/man3/modf.3:58
msgid "B<modf>(), B<modfl>():"
msgstr "B<modf>(), B<modfl>():"

#. type: Plain text
#: build/C/man3/modf.3:72
msgid ""
"The B<modf>()  function breaks the argument I<x> into an integral part and a "
"fractional part, each of which has the same sign as I<x>.  The integral part "
"is stored in the location pointed to by I<iptr>."
msgstr ""
"B<modf>()  関数は、引数 I<x> を整数部分と小数部分に分割する。 このとき、ふた"
"つの値はともに I<x> と同じ符号を持つ。 整数部分は I<iptr> が指す場所に格納さ"
"れる。"

#. type: Plain text
#: build/C/man3/modf.3:76
msgid "The B<modf>()  function returns the fractional part of I<x>."
msgstr "B<modf>()  関数は I<x> の小数部分を返す。"

#. type: Plain text
#: build/C/man3/modf.3:82
msgid "If I<x> is a NaN, a NaN is returned, and I<*iptr> is set to a NaN."
msgstr "I<x> が NaN の場合、NaN が返され、 I<*iptr> に NaN が設定される。"

#. type: Plain text
#: build/C/man3/modf.3:88
msgid ""
"If I<x> is positive infinity (negative infinity), +0 (-0) is returned, and "
"I<*iptr> is set to positive infinity (negative infinity)."
msgstr ""
"I<x> が正の無限大 (負の無限大) の場合、 +0 (-0) が返され、 I<*iptr> に正の無"
"限大 (負の無限大) が設定される。"

#. type: Plain text
#: build/C/man3/modf.3:99
msgid "B<frexp>(3), B<ldexp>(3)"
msgstr "B<frexp>(3), B<ldexp>(3)"

#. type: TH
#: build/C/man3/nan.3:11
#, no-wrap
msgid "NAN"
msgstr "NAN"

#. type: Plain text
#: build/C/man3/nan.3:14
msgid "nan, nanf, nanl - return 'Not a Number'"
msgstr "nan, nanf, nanl - 無効値 ('Not a Number') を返す"

#. type: Plain text
#: build/C/man3/nan.3:18
msgid "B<double nan(const char *>I<tagp>B<);>"
msgstr "B<double nan(const char *>I<tagp>B<);>"

#. type: Plain text
#: build/C/man3/nan.3:20
msgid "B<float nanf(const char *>I<tagp>B<);>"
msgstr "B<float nanf(const char *>I<tagp>B<);>"

#. type: Plain text
#: build/C/man3/nan.3:22
msgid "B<long double nanl(const char *>I<tagp>B<);>"
msgstr "B<long double nanl(const char *>I<tagp>B<);>"

#. type: Plain text
#: build/C/man3/nan.3:34
msgid "B<nan>(), B<nanf>(), B<nanl>():"
msgstr "B<nan>(), B<nanf>(), B<nanl>():"

#. type: Plain text
#: build/C/man3/nan.3:48
msgid ""
"These functions return a representation (determined by I<tagp>)  of a quiet "
"NaN.  If the implementation does not support quiet NaNs, these functions "
"return zero."
msgstr ""
"これらの関数は、SIGFPE シグナルなしの無効値 (NaN) を示す表現を返す (どの表現"
"を使用するかは I<tagp> で指定する)。SIGFPE シグナルなしの NaN をサポートして"
"いない実装では 0 を返す。"

#. type: Plain text
#: build/C/man3/nan.3:52
msgid "The call I<nan(\"char-sequence\")> is equivalent to:"
msgstr "I<nan(\"char-sequence\")> を呼び出すのは、以下と等価である。"

#. type: Plain text
#: build/C/man3/nan.3:55
#, no-wrap
msgid "    strtod(\"NAN(char-sequence)\", NULL);\n"
msgstr "    strtod(\"NAN(char-sequence)\", NULL);\n"

#. type: Plain text
#: build/C/man3/nan.3:65
msgid ""
"Similarly, calls to B<nanf>()  and B<nanl>()  are equivalent to analogous "
"calls to B<strtof>(3)  and B<strtold>(3)."
msgstr ""
"同様に、 B<nanf>()  や B<nanl>()  を呼び出すのは、 B<strtof>()  や B<strtold>"
"()  を呼ぶのと同じである。"

#. type: Plain text
#: build/C/man3/nan.3:73
msgid ""
"The argument I<tagp> is used in an unspecified manner.  On IEEE 754 systems, "
"there are many representations of NaN, and I<tagp> selects one.  On other "
"systems it may do nothing."
msgstr ""
"引き数 I<tagp> の使い方は規定されていない。 IEEE 754 準拠のシステムでは、NaN "
"にも複数の表現が存在し、 I<tagp> はその選択に使用される。 他のシステムでは、"
"何の意味もないかもしれない。"

#. type: Plain text
#: build/C/man3/nan.3:79
msgid ""
"C99, POSIX.1-2001.  See also IEC 559 and the appendix with recommended "
"functions in IEEE 754/IEEE 854."
msgstr ""
"C99, POSIX.1-2001.  IEC 559 や推奨関数になっている IEEE 754/IEEE 854 の付録も"
"参照すること。"

#. type: Plain text
#: build/C/man3/nan.3:83
msgid "B<isnan>(3), B<strtod>(3), B<math_error>(7)"
msgstr "B<isnan>(3), B<strtod>(3), B<math_error>(7)"

#. type: TH
#: build/C/man3/nextafter.3:11
#, no-wrap
msgid "NEXTAFTER"
msgstr "NEXTAFTER"

#. type: Plain text
#: build/C/man3/nextafter.3:15
msgid ""
"nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl - "
"floating-point number manipulation"
msgstr ""
"nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl - 浮"
"動小数点数の操作"

#. type: Plain text
#: build/C/man3/nextafter.3:19
msgid "B<double nextafter(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double nextafter(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/nextafter.3:21
msgid "B<float nextafterf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float nextafterf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: build/C/man3/nextafter.3:23
msgid "B<long double nextafterl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double nextafterl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/nextafter.3:25
msgid "B<double nexttoward(double >I<x>B<, long double >I<y>B<);>"
msgstr "B<double nexttoward(double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/nextafter.3:27
msgid "B<float nexttowardf(float >I<x>B<, long double >I<y>B<);>"
msgstr "B<float nexttowardf(float >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/nextafter.3:29
msgid "B<long double nexttowardl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double nexttowardl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: build/C/man3/nextafter.3:39
msgid "B<nextafter>():"
msgstr "B<nextafter>():"

#. type: Plain text
#: build/C/man3/nextafter.3:51
msgid "B<nextafterf>(), B<nextafterl>():"
msgstr "B<nextafterf>(), B<nextafterl>():"

#. type: Plain text
#: build/C/man3/nextafter.3:62
msgid "B<nexttoward>(), B<nexttowardf>(), B<nexttowardl>():"
msgstr "B<nexttoward>(), B<nexttowardf>(), B<nexttowardl>():"

#. type: Plain text
#: build/C/man3/nextafter.3:83
msgid ""
"The B<nextafter>()  functions return the next representable floating-point "
"value following I<x> in the direction of I<y>.  If I<y> is less than I<x>, "
"these functions will return the largest representable number less than I<x>."
msgstr ""
"B<nextafter>()  関数群は、I<y> に向かう方向で I<x> のすぐ次の浮動小数点数表現"
"を返す。 I<y> が I<x> より小さい場合、 I<x> より小さい最大の浮動小数点表現の"
"値を返す。"

#. type: Plain text
#: build/C/man3/nextafter.3:85
msgid "If I<x> equals I<y>, the functions return I<y>."
msgstr "I<x> が I<y> と等しい場合、I<y> が返される。"

#. type: Plain text
#: build/C/man3/nextafter.3:93
msgid ""
"The B<nexttoward>()  functions do the same as the B<nextafter>()  functions, "
"except that they have a I<long double> second argument."
msgstr ""
"B<nexttoward>()  関数群は、2 番目の引き数が I<long double> 型である点以外、 "
"B<nextafter>()  関数群と同じはたらきをする。"

#. type: Plain text
#: build/C/man3/nextafter.3:99
msgid ""
"On success, these functions return the next representable floating-point "
"value after I<x> in the direction of I<y>."
msgstr ""
"成功すると、これらの関数は I<y> に向かう方向で I<x> の すぐ次の浮動小数点数表"
"現を返す。"

#. type: Plain text
#: build/C/man3/nextafter.3:109
msgid ""
"If I<x> equals I<y>, then I<y> (cast to the same type as I<x>)  is returned."
msgstr ""
"I<x> が I<y> と等しい場合、 (I<x> と同じ型にキャストされた)  I<y> が返され"
"る。"

#.  e.g., DBL_MAX
#. type: Plain text
#: build/C/man3/nextafter.3:129
msgid ""
"If I<x> is finite, and the result would overflow, a range error occurs, and "
"the functions return B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, "
"respectively, with the correct mathematical sign."
msgstr ""
"I<x> が有限値で 結果がオーバーフローする場合、 範囲エラー (range error) が発"
"生し、 各関数はそれぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> を返す。返り"
"値には数学的に正しい符号が付与される。"

#. type: Plain text
#: build/C/man3/nextafter.3:138
msgid ""
"If I<x> is not equal to I<y>, and the correct function result would be "
"subnormal, zero, or underflow, a range error occurs, and either the correct "
"value (if it can be represented), or 0.0, is returned."
msgstr ""
"I<x> が I<y> と同じではなく、正しい関数の結果が非正規化数かゼロかアンダーフ"
"ローの場合、 範囲エラーが発生し、 (表現可能な場合には) 正しい値が、(そうでな"
"い場合には) 0.0 が返される。"

#. type: TP
#: build/C/man3/nextafter.3:154
#, no-wrap
msgid "Range error: result is subnormal or underflows"
msgstr "範囲エラー: 結果が非正規化数かアンダーフロー"

#. type: Plain text
#: build/C/man3/nextafter.3:177
msgid ""
"In glibc version 2.5 and earlier, these functions do not raise an underflow "
"floating-point (B<FE_UNDERFLOW>)  exception when an underflow occurs."
msgstr ""
"glibc バージョン 2.5 以前では、アンダーフローが発生した際に、 これらの関数は"
"アンダーフロー浮動小数点例外 (B<FE_UNDERFLOW>)  を上がない。"

#. type: Plain text
#: build/C/man3/nextafter.3:179
msgid "B<nearbyint>(3)"
msgstr "B<nearbyint>(3)"

#. type: TH
#: build/C/man3/pow.3:35
#, no-wrap
msgid "POW"
msgstr "POW"

#. type: Plain text
#: build/C/man3/pow.3:38
msgid "pow, powf, powl - power functions"
msgstr "pow, powf, powl - 累乗関数"

#. type: Plain text
#: build/C/man3/pow.3:43
#, no-wrap
msgid "B<double pow(double >I<x>B<, double >I<y>B<);>\n"
msgstr "B<double pow(double >I<x>B<, double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/pow.3:45
#, no-wrap
msgid "B<float powf(float >I<x>B<, float >I<y>B<);>\n"
msgstr "B<float powf(float >I<x>B<, float >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/pow.3:47
#, no-wrap
msgid "B<long double powl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr "B<long double powl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/pow.3:59
msgid "B<powf>(), B<powl>():"
msgstr "B<powf>(), B<powl>():"

#. type: Plain text
#: build/C/man3/pow.3:72
msgid ""
"The B<pow>()  function returns the value of I<x> raised to the power of I<y>."
msgstr "B<pow>()  関数は I<x> の I<y> 乗の値を返す。"

#. type: Plain text
#: build/C/man3/pow.3:77
msgid ""
"On success, these functions return the value of I<x> to the power of I<y>."
msgstr "成功すると、これらの関数は I<x> の I<y> 乗の値を返す。"

#.  The domain error is generated at least as far back as glibc 2.4
#. type: Plain text
#: build/C/man3/pow.3:85
msgid ""
"If I<x> is a finite value less than 0, and I<y> is a finite noninteger, a "
"domain error occurs, and a NaN is returned."
msgstr ""
"I<x> が 0 未満の有限値で I<y> が整数でない有限値の場合、領域エラー (domain "
"error) が発生し、 NaN が返される。"

#.  The range error is generated at least as far back as glibc 2.4
#. type: Plain text
#: build/C/man3/pow.3:95
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the "
"mathematically correct sign."
msgstr ""
"結果がオーバーフローする場合、 範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> を返す。返り値には数学的に正し"
"い符号が付与される。"

#.  POSIX.1 does not specify the sign of the zero,
#.  but http://sources.redhat.com/bugzilla/show_bug.cgi?id=2678
#.  points out that the zero has the wrong sign in some cases.
#. type: Plain text
#: build/C/man3/pow.3:102
msgid ""
"If result underflows, and is not representable, a range error occurs, and "
"0.0 is returned."
msgstr ""
"結果がアンダーフローし、その値が表現可能でない場合、 範囲エラーが発生し、 "
"0.0 が返される。"

#. type: Plain text
#: build/C/man3/pow.3:108
msgid ""
"Except as specified below, if I<x> or I<y> is a NaN, the result is a NaN."
msgstr ""
"以下で規定されていない場合で、 I<x> か I<y> が NaN の場合、返り値は NaN とな"
"る。"

#. type: Plain text
#: build/C/man3/pow.3:114
msgid "If I<x> is +1, the result is 1.0 (even if I<y> is a NaN)."
msgstr ""
"I<x> が +1 の場合、 (I<y> が NaN であったとしても) 返り値は 1.0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:120
msgid "If I<y> is 0, the result is 1.0 (even if I<x> is a NaN)."
msgstr ""
"I<y> が 0 の場合、 (I<x> が NaN であったとしても) 返り値は 1.0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:128
msgid ""
"If I<x> is +0 (-0), and I<y> is an odd integer greater than 0, the result is "
"+0 (-0)."
msgstr ""
"I<x> が +0 (-0) で I<y> が 0 より大きな奇数の場合、返り値は +0 (-0) となる。"

#. type: Plain text
#: build/C/man3/pow.3:136
msgid ""
"If I<x> is 0, and I<y> greater than 0 and not an odd integer, the result is "
"+0."
msgstr ""
"I<x> が 0 で、 I<y> が 0 より大きく奇数でない場合、返り値は +0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:144
msgid ""
"If I<x> is -1, and I<y> is positive infinity or negative infinity, the "
"result is 1.0."
msgstr ""
"I<x> が -1 で、 I<y> が正の無限大か負の無限大の場合、返り値は 1.0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:152
msgid ""
"If the absolute value of I<x> is less than 1, and I<y> is negative infinity, "
"the result is positive infinity."
msgstr ""
"I<x> の絶対値が 1 未満で、 I<y> が負の無限大の場合、返り値は正の無限大とな"
"る。"

#. type: Plain text
#: build/C/man3/pow.3:160
msgid ""
"If the absolute value of I<x> is greater than 1, and I<y> is negative "
"infinity, the result is +0."
msgstr ""
"I<x> 絶対値が 1 より大きく、 I<y> が負の無限大の場合、返り値は +0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:168
msgid ""
"If the absolute value of I<x> is less than 1, and I<y> is positive infinity, "
"the result is +0."
msgstr ""
"I<x> の絶対値が 1 未満で、 I<y> が正の無限大の場合、返り値は +0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:176
msgid ""
"If the absolute value of I<x> is greater than 1, and I<y> is positive "
"infinity, the result is positive infinity."
msgstr ""
"I<x> の絶対値が 1 より大きく、 I<y> が正の無限大の場合、返り値は正の無限大と"
"なる。"

#. type: Plain text
#: build/C/man3/pow.3:184
msgid ""
"If I<x> is negative infinity, and I<y> is an odd integer less than 0, the "
"result is -0."
msgstr ""
"I<x> が負の無限大で、 I<y> が 0 より小さい奇数の場合、返り値は -0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:192
msgid ""
"If I<x> is negative infinity, and I<y> less than 0 and not an odd integer, "
"the result is +0."
msgstr ""
"I<x> が負の無限大で、 I<y> が 0 より小さく奇数でない場合、返り値は +0 とな"
"る。"

#. type: Plain text
#: build/C/man3/pow.3:200
msgid ""
"If I<x> is negative infinity, and I<y> is an odd integer greater than 0, the "
"result is negative infinity."
msgstr ""
"I<x> が負の無限大で、 I<y> が 0 より大きい奇数の場合、返り値は負の無限大とな"
"る。"

#. type: Plain text
#: build/C/man3/pow.3:208
msgid ""
"If I<x> is negative infinity, and I<y> greater than 0 and not an odd "
"integer, the result is positive infinity."
msgstr ""
"I<x> が負の無限大で、 I<y> が 0 より大きく奇数でない場合、返り値は正の無限大"
"となる。"

#. type: Plain text
#: build/C/man3/pow.3:216
msgid "If I<x> is positive infinity, and I<y> less than 0, the result is +0."
msgstr "I<x> が正の無限大で、 I<y> が 0 未満の場合、返り値は +0 となる。"

#. type: Plain text
#: build/C/man3/pow.3:224
msgid ""
"If I<x> is positive infinity, and I<y> greater than 0, the result is "
"positive infinity."
msgstr ""
"I<x> が正の無限大で、 I<y> が 0 より大きい場合、返り値は正の無限大となる。"

#. type: Plain text
#: build/C/man3/pow.3:239
msgid ""
"If I<x> is +0 or -0, and I<y> is an odd integer less than 0, a pole error "
"occurs and B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, is returned, with the "
"same sign as I<x>."
msgstr ""
"I<x> が +0 か -0 で、 I<y> が 0 より小さい奇数の場合、 極エラー (pole error) "
"が発生し、返り値は B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> となる。 I<x> と同"
"じ符号が付与される。"

#.  The pole error is generated at least as far back as glibc 2.4
#. type: Plain text
#: build/C/man3/pow.3:253
msgid ""
"If I<x> is +0 or -0, and I<y> is less than 0 and not an odd integer, a pole "
"error occurs and +B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, is returned."
msgstr ""
"I<x> が +0 か -0 で、 I<y> が 0 より小さく奇数でない場合、 極エラーが発生"
"し、 返り値は B<+>HUGE_VALB<,> B<+>HUGE_VALFB<,> B<+>HUGE_VALL となる。"

#. type: TP
#: build/C/man3/pow.3:280
#, no-wrap
msgid "Domain error: I<x> is negative, and I<y> is a finite noninteger"
msgstr "領域エラー: I<x> が負で、I<y> が整数でない有限値"

#. type: TP
#: build/C/man3/pow.3:288
#, no-wrap
msgid "Pole error: I<x> is zero, and I<y> is negative"
msgstr "極エラー: I<x> がゼロで、I<y> が負"

#. type: TP
#: build/C/man3/pow.3:297
#, no-wrap
msgid "Range error: the result overflows"
msgstr "範囲エラー: 結果がオーバーフロー"

#. type: TP
#: build/C/man3/pow.3:305
#, no-wrap
msgid "Range error: the result underflows"
msgstr "範囲エラー: 結果がアンダーフロー"

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6776
#.  or possibly 2.9, I haven't found the source code change
#.  and I don't have a 2.9 system to test
#. type: Plain text
#: build/C/man3/pow.3:333
msgid ""
"In glibc 2.9 and earlier, when a pole error occurs, I<errno> is set to "
"B<EDOM> instead of the POSIX-mandated B<ERANGE>.  Since version 2.10, glibc "
"does the right thing."
msgstr ""
"glibc 2.9 とそれ以前のバージョンでは、 極エラーが発生した場合、POSIX で要求さ"
"れている B<ERANGE> ではなく B<EDOM> が I<errno> に設定される。 バージョン "
"2.10 以降の glibc では、正しい動作をする。"

#.  see bug http://sources.redhat.com/bugzilla/show_bug.cgi?id=3866
#.  and http://sources.redhat.com/bugzilla/show_bug.cgi?id=369
#. type: Plain text
#: build/C/man3/pow.3:353
msgid ""
"If I<x> is negative, then large negative or positive I<y> values yield a NaN "
"as the function result, with I<errno> set to B<EDOM>, and an invalid "
"(B<FE_INVALID>)  floating-point exception.  For example, with B<pow>(), one "
"sees this behavior when the absolute value of I<y> is greater than about "
"9.223373e18."
msgstr ""
"I<x> が負の場合、大きな正負の値の I<y> が与えられると、関数の結果が NaN とな"
"り、 I<errno> に B<EDOM> が設定され、 不正浮動小数点例外 (B<FE_INVALID>)  が"
"発生する。 例えば、 B<pow>()  では、 I<y> の絶対値が約 9.223373e18 より大きい"
"場合にこの状況となる。"

#.  FIXME . Actually, 2.3.2 is the earliest test result I have; so yet
#.  to confirm if this error occurs only in 2.3.2.
#. type: Plain text
#: build/C/man3/pow.3:362
msgid ""
"In version 2.3.2 and earlier, when an overflow or underflow error occurs, "
"glibc's B<pow>()  generates a bogus invalid floating-point exception "
"(B<FE_INVALID>)  in addition to the overflow or underflow exception."
msgstr ""
"glibc バージョン 2.3.2 以前では、 アンダーフローやアンダーフローのエラーが発"
"生する場合、 glibc の B<pow>()  は、オーバーフロー例外やアンダーフロー例外を"
"上げるだけでなく、 不正浮動小数点例外 (B<FE_INVALID>)  を間違って発生する。"

#. type: Plain text
#: build/C/man3/pow.3:366
msgid "B<cbrt>(3), B<cpow>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cpow>(3), B<sqrt>(3)"

#. type: TH
#: build/C/man3/pow10.3:25
#, no-wrap
msgid "POW10"
msgstr "POW10"

#. type: Plain text
#: build/C/man3/pow10.3:28
msgid "pow10, pow10f, pow10l - base-10 power functions"
msgstr "pow10, pow10f, pow10l - 底が 10 の累乗関数"

#. type: Plain text
#: build/C/man3/pow10.3:32 build/C/man3/sincos.3:16
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pow10.3:34
#, no-wrap
msgid "B<double pow10(double >I<x>B<);>\n"
msgstr "B<double pow10(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/pow10.3:36
#, no-wrap
msgid "B<float pow10f(float >I<x>B<);>\n"
msgstr "B<float pow10f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/pow10.3:38
#, no-wrap
msgid "B<long double pow10l(long double >I<x>B<);>\n"
msgstr "B<long double pow10l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/pow10.3:46
msgid ""
"The B<pow10>()  function returns the value of 10 raised to the power I<x>."
msgstr "B<pow10>()  関数は 10 の I<x> 乗の値を返す。"

#. type: Plain text
#: build/C/man3/pow10.3:50
msgid "This is a GNU extension."
msgstr "これは GNU による拡張である。"

#. type: Plain text
#: build/C/man3/pow10.3:53
msgid ""
"These functions are identical to the functions listed under B<exp10>(3)."
msgstr "これらの関数は B<exp10>(3)  でリストされている関数と同一である。"

#. type: Plain text
#: build/C/man3/pow10.3:56
msgid "B<exp10>(3), B<pow>(3)"
msgstr "B<exp10>(3), B<pow>(3)"

#. type: TH
#: build/C/man3/remainder.3:37
#, no-wrap
msgid "REMAINDER"
msgstr "REMAINDER"

#. type: Plain text
#: build/C/man3/remainder.3:41
msgid ""
"drem, dremf, dreml, remainder, remainderf, remainderl - floating-point "
"remainder function"
msgstr ""
"drem, dremf, dreml, remainder, remainderf, remainderl - 浮動小数点剰余関数"

#. type: Plain text
#: build/C/man3/remainder.3:49
#, no-wrap
msgid ""
"/* The C99 versions */\n"
"B<double remainder(double >I<x>B<, double >I<y>B<);>\n"
"B<float remainderf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double remainderl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"/* C99 版 */\n"
"B<double remainder(double >I<x>B<, double >I<y>B<);>\n"
"B<float remainderf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double remainderl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/remainder.3:54
#, no-wrap
msgid ""
"/* Obsolete synonyms */\n"
"B<double drem(double >I<x>B<, double >I<y>B<);>\n"
"B<float dremf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double dreml(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"/* 廃止された別名 */\n"
"B<double drem(double >I<x>B<, double >I<y>B<);>\n"
"B<float dremf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double dreml(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: build/C/man3/remainder.3:65
msgid "B<remainder>():"
msgstr "B<remainder>():"

#. type: Plain text
#: build/C/man3/remainder.3:70
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>="
"\\ 200112L;"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>="
"\\ 200112L;"

#. type: Plain text
#: build/C/man3/remainder.3:77
msgid "B<remainderf>(), B<remainderl>():"
msgstr "B<remainderf>(), B<remainderl>():"

#. type: Plain text
#: build/C/man3/remainder.3:88
msgid "B<drem>(), B<dremf>(), B<dreml>():"
msgstr "B<drem>(), B<dremf>(), B<dreml>():"

#. type: Plain text
#: build/C/man3/remainder.3:90 build/C/man3/significand.3:35
msgid "_SVID_SOURCE || _BSD_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/remainder.3:111
msgid ""
"The B<remainder>()  function computes the remainder of dividing I<x> by "
"I<y>.  The return value is I<x>-I<n>*I<y>, where I<n> is the value I<x\\ /\\ "
"y>, rounded to the nearest integer.  If the absolute value of I<x>-I<n>*I<y> "
"is 0.5, I<n> is chosen to be even."
msgstr ""
"B<remainder>()  関数は I<x> を I<y> で割った余りを計算する。 返り値は I<x>-"
"I<n>*I<y> である。 ここで I<n> は I<x\\ /\\ y> の値を最も近い整数に丸めたもの"
"である。 I<x>-I<n>*I<y> の絶対値が 0.5 の場合、偶数になるように I<n> が選ばれ"
"る。"

#. type: Plain text
#: build/C/man3/remainder.3:114
msgid ""
"These functions are unaffected by the current rounding mode (see B<fenv>(3))."
msgstr ""
"これらの関数は、現在の丸めモードの影響を受けない (丸めモードについては "
"B<fenv>(3)  を参照)。"

#. type: Plain text
#: build/C/man3/remainder.3:118
msgid "The B<drem>()  function does precisely the same thing."
msgstr "B<drem>()  関数はこれと全く同じ動作をする。"

#. type: Plain text
#: build/C/man3/remainder.3:124
msgid ""
"On success, these functions return the floating-point remainder, I<x>-"
"I<n>*I<y>.  If the return value is 0, it has the sign of I<x>."
msgstr ""
"成功すると、これらの関数は浮動小数点の剰余 I<x>-I<n>*I<y> を返す。 返り値が "
"0 の場合、その符号は I<x> と同じになる。"

#. type: Plain text
#: build/C/man3/remainder.3:139 build/C/man3/remquo.3:92
msgid ""
"If I<x> is an infinity, and I<y> is not a NaN, a domain error occurs, and a "
"NaN is returned."
msgstr ""
"I<x> が無限大で I<y> が NaN でない場合、 領域エラー (domain error) が発生し、"
"NaN が返される。"

#. type: Plain text
#: build/C/man3/remainder.3:150 build/C/man3/remquo.3:101
msgid ""
"If I<y> is zero, and I<x> is not a NaN, a domain error occurs, and a NaN is "
"returned."
msgstr ""
"I<y> がゼロで I<x> が NaN でない場合、 領域エラー (domain error) が発生し、"
"NaN が返される。"

#. type: TP
#: build/C/man3/remainder.3:157
#, no-wrap
msgid "Domain error: I<x> is an infinity and I<y> is not a NaN"
msgstr "領域エラー (domain error): I<x> が無限大で I<y> が NaN ではない"

#.  IEC 60559.
#. type: Plain text
#: build/C/man3/remainder.3:188
msgid ""
"The functions B<remainder>(), B<remainderf>(), and B<remainderl>()  are "
"specified in C99 and POSIX.1-2001."
msgstr ""
"関数 B<remainder>(), B<remainderf>(), B<remainderl>()  は C99 と "
"POSIX.1-2001 で規定されている。"

#. type: Plain text
#: build/C/man3/remainder.3:204
msgid ""
"The function B<drem>()  is from 4.3BSD.  The I<float> and I<long double> "
"variants B<dremf>()  and B<dreml>()  exist on some systems, such as Tru64 "
"and glibc2.  Avoid the use of these functions in favor of B<remainder>()  "
"etc."
msgstr ""
"関数 B<drem>()  は 4.3BSD に由来する。 I<float> と I<long double> 版の "
"B<dremf>()  と B<dreml>()  は、Tru64 や glibc2 のようないくつかのシステムに存"
"在する。 これらの関数の使用は避けて、 B<remainder>()  などを使用すること。"

#. type: Plain text
#: build/C/man3/remainder.3:206
msgid "The call"
msgstr "呼び出し"

#. type: Plain text
#: build/C/man3/remainder.3:208
#, no-wrap
msgid "    remainder(nan(\"\"), 0);\n"
msgstr "    remainder(nan(\"\"), 0);\n"

#.  FIXME . this bug occurs as at glibc 2.8.
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6779
#. type: Plain text
#: build/C/man3/remainder.3:213
msgid ""
"returns a NaN, as expected, but wrongly causes a domain error; it should "
"yield a silent NaN."
msgstr ""
"を行うと、期待通り Nan が返るが、誤って領域エラーが発生する。 正しくはエラー"
"なしの Nan となるべきである。"

#. type: Plain text
#: build/C/man3/remainder.3:215
msgid "The call \"remainder(29.0, 3.0)\" returns -1."
msgstr "\"remainder(29.0, 3.0)\" を呼び出すと -1 を返す。"

#. type: Plain text
#: build/C/man3/remainder.3:219
msgid "B<div>(3), B<fmod>(3), B<remquo>(3)"
msgstr "B<div>(3), B<fmod>(3), B<remquo>(3)"

#. type: TH
#: build/C/man3/remquo.3:12
#, no-wrap
msgid "REMQUO"
msgstr "REMQUO"

#. type: Plain text
#: build/C/man3/remquo.3:15
msgid "remquo, remquof, remquol - remainder and part of quotient"
msgstr "remquo, remquof, remquol - 商の一部と剰余を求める"

#. type: Plain text
#: build/C/man3/remquo.3:20
#, no-wrap
msgid "B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"
msgstr "B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"

#. type: Plain text
#: build/C/man3/remquo.3:22
#, no-wrap
msgid "B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"
msgstr "B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"

#. type: Plain text
#: build/C/man3/remquo.3:24
#, no-wrap
msgid "B<long double remquol(long double >I<x>B<, long double >I<y>B<, int *>I<quo>B<);>\n"
msgstr "B<long double remquol(long double >I<x>B<, long double >I<y>B<, int *>I<quo>B<);>\n"

#. type: Plain text
#: build/C/man3/remquo.3:37
msgid "B<remquo>(), B<remquof>(), B<remquol>():"
msgstr "B<remquo>(), B<remquof>(), B<remquol>():"

#. type: Plain text
#: build/C/man3/remquo.3:55
msgid ""
"These functions compute the remainder and part of the quotient upon division "
"of I<x> by I<y>.  A few bits of the quotient are stored via the I<quo> "
"pointer.  The remainder is returned as the function result."
msgstr ""
"これらの関数は I<x> を I<y> で割ったときの商の一部と剰余を計算する。 商のいく"
"つかのビットが I<quo> ポインタを使って格納される。 剰余は関数の結果として返さ"
"れる。"

#. type: Plain text
#: build/C/man3/remquo.3:59
msgid ""
"The value of the remainder is the same as that computed by the B<remainder>"
"(3)  function."
msgstr "剰余の値は B<remainder>(3)  関数で計算されるものと同じである。"

#. type: Plain text
#: build/C/man3/remquo.3:65
msgid ""
"The value stored via the I<quo> pointer has the sign of I<x\\ /\\ y> and "
"agrees with the quotient in at least the low order 3 bits."
msgstr ""
"I<quo> ポインタを使って格納される値には、 I<x\\ /\\ y> の符号と最低でも商の下"
"位 3 ビットが含まれる。"

#.  A possible application of this function might be the computation
#.  of sin(x). Compute remquo(x, pi/2, &quo) or so.
#.  glibc, UnixWare: return 3 bits
#.  MacOS 10: return 7 bits
#. type: Plain text
#: build/C/man3/remquo.3:73
msgid ""
"For example, I<remquo(29.0,\\ 3.0)> returns -1.0 and might store 2.  Note "
"that the actual quotient might not fit in an integer."
msgstr ""
"たとえば I<remquo(29.0,\\ 3.0)> は -1.0 を返し、 (訳注: quo の指しているもの"
"には) 2 が格納される。 実際の商が整数値にならない点に注意すること。"

#. type: Plain text
#: build/C/man3/remquo.3:77
msgid ""
"On success, these functions return the same value as the analogous functions "
"described in B<remainder>(3)."
msgstr ""
"成功すると、これらの関数は B<remainder>(3)  に書かれている同様の関数と同じ値"
"を返す。"

#. type: TP
#: build/C/man3/remquo.3:108
#, no-wrap
msgid "Domain error: I<x> is an infinity or I<y> is 0, and the other argument is not a NaN"
msgstr "領域エラー (domain error): I<x> が無限大か I<y> が 0 で、 他の引き数が NaN でない"

#. type: Plain text
#: build/C/man3/remquo.3:130
msgid "B<fmod>(3), B<logb>(3), B<remainder>(3)"
msgstr "B<fmod>(3), B<logb>(3), B<remainder>(3)"

#. type: TH
#: build/C/man3/rint.3:27
#, no-wrap
msgid "RINT"
msgstr "RINT"

#. type: Plain text
#: build/C/man3/rint.3:31
msgid ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - round to nearest "
"integer"
msgstr ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - 最も近い整数に丸める"

#. type: Plain text
#: build/C/man3/rint.3:36
#, no-wrap
msgid "B<double nearbyint(double >I<x>B<);>\n"
msgstr "B<double nearbyint(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/rint.3:38
#, no-wrap
msgid "B<float nearbyintf(float >I<x>B<);>\n"
msgstr "B<float nearbyintf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/rint.3:40
#, no-wrap
msgid "B<long double nearbyintl(long double >I<x>B<);>\n"
msgstr "B<long double nearbyintl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/rint.3:42
#, no-wrap
msgid "B<double rint(double >I<x>B<);>\n"
msgstr "B<double rint(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/rint.3:44
#, no-wrap
msgid "B<float rintf(float >I<x>B<);>\n"
msgstr "B<float rintf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/rint.3:46
#, no-wrap
msgid "B<long double rintl(long double >I<x>B<);>\n"
msgstr "B<long double rintl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/rint.3:59
msgid "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"
msgstr "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"

#. type: Plain text
#: build/C/man3/rint.3:61
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || "
"_ISOC99_SOURCE;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || "
"_ISOC99_SOURCE;"

#. type: Plain text
#: build/C/man3/rint.3:67
msgid "B<rint>():"
msgstr "B<rint>():"

#. type: Plain text
#: build/C/man3/rint.3:78
msgid "B<rintf>(), B<rintl>():"
msgstr "B<rintf>(), B<rintl>():"

#. type: Plain text
#: build/C/man3/rint.3:95
msgid ""
"The B<nearbyint>()  functions round their argument to an integer value in "
"floating-point format, using the current rounding direction (see "
"B<fesetround>(3))  and without raising the I<inexact> exception."
msgstr ""
"B<nearbyint>()  関数群は、現在の丸め方向 (B<fesetround>(3)  参照) で引き数を"
"浮動小数点形式の整数に丸める。 I<inexact> 例外を出さない。"

#. type: Plain text
#: build/C/man3/rint.3:105
msgid ""
"The B<rint>()  functions do the same, but will raise the I<inexact> "
"exception (B<FE_INEXACT>, checkable via B<fetestexcept>(3))  when the result "
"differs in value from the argument."
msgstr ""
"B<rint>()  関数群も同じような動作をするが、 結果が引き数と異なる場合に "
"I<inexact> 例外 (B<FE_INEXACT>)  を出す (この例外は B<fetestexcept>(3)  経由"
"で確認可能)。"

#. type: Plain text
#: build/C/man3/rint.3:135
msgid ""
"If you want to store the rounded value in an integer type, you probably want "
"to use one of the functions described in B<lrint>(3)  instead."
msgstr ""
"丸めた値を整数型に格納した場合には、おそらくこの関数ではなく B<lrint>(3)  に"
"載っている関数のどれかを使いたいのだろう。"

#. type: Plain text
#: build/C/man3/rint.3:141
msgid "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"
msgstr "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"

#. type: TH
#: build/C/man3/round.3:27
#, no-wrap
msgid "ROUND"
msgstr "ROUND"

#. type: Plain text
#: build/C/man3/round.3:30
msgid "round, roundf, roundl - round to nearest integer, away from zero"
msgstr ""
"round, roundf, roundl - 最も近い整数値に丸める (2 つの整数の中間値の場合は 0 "
"から遠い方に丸める)"

#. type: Plain text
#: build/C/man3/round.3:35
#, no-wrap
msgid "B<double round(double >I<x>B<);>\n"
msgstr "B<double round(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/round.3:37
#, no-wrap
msgid "B<float roundf(float >I<x>B<);>\n"
msgstr "B<float roundf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/round.3:39
#, no-wrap
msgid "B<long double roundl(long double >I<x>B<);>\n"
msgstr "B<long double roundl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/round.3:52
msgid "B<round>(), B<roundf>(), B<roundl>():"
msgstr "B<round>(), B<roundf>(), B<roundl>():"

#. type: Plain text
#: build/C/man3/round.3:67
msgid ""
"These functions round I<x> to the nearest integer, but round halfway cases "
"away from zero (regardless of the current rounding direction, see B<fenv>"
"(3)), instead of to the nearest even integer like B<rint>(3)."
msgstr ""
"これらの関数は I<x> を最も近い整数値に丸める。 2 つの整数の中間値の場合は、 "
"B<rint>(3)  のように最も近い偶数に丸めたりせずに、 (現在の丸め方向に関係な"
"く) 0 から遠い方に丸める (丸め方向については B<fenv>(3)  を参照)。"

#. type: Plain text
#: build/C/man3/round.3:73
msgid "For example, I<round(0.5)> is 1.0, and I<round(-0.5)> is -1.0."
msgstr "例えば、 I<round(0.5)> は 1.0 で、 I<round(-0.5)> は -1.0 である。"

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: build/C/man3/round.3:101
msgid ""
"POSIX.1-2001 contains text about overflow (which might set I<errno> to "
"B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the result "
"cannot overflow on any current machine, so this error-handling stuff is just "
"nonsense.  (More precisely, overflow can happen only when the maximum value "
"of the exponent is smaller than the number of mantissa bits.  For the "
"IEEE-754 standard 32-bit and 64-bit floating-point numbers the maximum value "
"of the exponent is 128 (respectively, 1024), and the number of mantissa bits "
"is 24 (respectively, 53).)"
msgstr ""
"POSIX.1-2001 にはオーバーフローに関する記述があり、 オーバーフローの場合に"
"は、 I<errno> を B<ERANGE> に設定するか、 B<FE_OVERFLOW> 例外を発生することと"
"されている。 実際のところ、どの現行のマシンでは結果がオーバーフローを起こすこ"
"とはないので、 このエラー処理は意味がない。 (より正確に言うと、オーバーフロー"
"は指数部の最大値が 仮数部を表すビットの数より小さい場合にしか起こらない。 "
"IEEE-754 規格の 32 ビットと 64 ビットの浮動小数では、 指数部の最大値はそれぞ"
"れ 128 と 1024 であり、 仮数部のビット数はそれぞれ 24 と 53 である。)"

#. type: Plain text
#: build/C/man3/round.3:106
msgid ""
"If you want to store the rounded value in an integer type, you probably want "
"to use one of the functions described in B<lround>(3)  instead."
msgstr ""
"丸めた値を整数型に格納した場合には、おそらくこの関数ではなく B<lround>(3)  に"
"載っている関数のどれかを使いたいのだろう。"

#. type: Plain text
#: build/C/man3/round.3:113
msgid ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), B<trunc>"
"(3)"
msgstr ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), B<trunc>"
"(3)"

#. type: TH
#: build/C/man3/scalb.3:27
#, no-wrap
msgid "SCALB"
msgstr "SCALB"

#. type: Plain text
#: build/C/man3/scalb.3:31
msgid ""
"scalb, scalbf, scalbl - multiply floating-point number by integral power of "
"radix (OBSOLETE)"
msgstr ""
"scalb, scalbf, scalbl - 浮動小数点数に整数である基数の累乗を掛ける (廃止予定)"

#. type: Plain text
#: build/C/man3/scalb.3:35
msgid "B<double scalb(double >I<x>B<, double >I<exp>B<);>"
msgstr "B<double scalb(double >I<x>B<, double >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalb.3:37
msgid "B<float scalbf(float >I<x>B<, double >I<exp>B<);>"
msgstr "B<float scalbf(float >I<x>B<, double >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalb.3:39
msgid "B<long double scalbl(long double >I<x>B<, double >I<exp>B<);>"
msgstr "B<long double scalbl(long double >I<x>B<, double >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalb.3:49
msgid "B<scalb>():"
msgstr "B<scalb>():"

#. type: Plain text
#: build/C/man3/scalb.3:52
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/scalb.3:56
msgid "B<scalbf>(), B<scalbl>():"
msgstr "B<scalbf>(), B<scalbl>():"

#. type: Plain text
#: build/C/man3/scalb.3:69 build/C/man3/scalbln.3:85
msgid ""
"These functions multiply their first argument I<x> by B<FLT_RADIX> (probably "
"2)  to the power of I<exp>, that is:"
msgstr ""
"これらの関数は最初の引き数 I<x> に B<FLT_RADIX> の I<exp> 乗を掛ける "
"(B<FLT_RADIX> はおそらく 2 である)。つまり、以下の式の値を返す。"

#. type: Plain text
#: build/C/man3/scalb.3:72 build/C/man3/scalbln.3:88
#, no-wrap
msgid "    x * FLT_RADIX ** exp\n"
msgstr "    x * FLT_RADIX ** exp\n"

#.  not in /usr/include but in a gcc lib
#. type: Plain text
#: build/C/man3/scalb.3:79 build/C/man3/scalbln.3:95
msgid ""
"The definition of B<FLT_RADIX> can be obtained by including I<E<lt>float."
"hE<gt>>."
msgstr ""
"B<FLT_RADIX> の定義は I<E<lt>float.hE<gt>> をインクルードすることで得られる。"

#. type: Plain text
#: build/C/man3/scalb.3:81 build/C/man3/scalbln.3:97
msgid "On success, these functions return I<x> * B<FLT_RADIX> ** I<exp>."
msgstr "成功すると、これらの関数は I<x> * B<FLT_RADIX> ** I<exp> を返す。"

#. type: Plain text
#: build/C/man3/scalb.3:87
msgid "If I<x> or I<exp> is a NaN, a NaN is returned."
msgstr "I<x> か I<exp> が NaN の場合、NaN が返される。"

#. type: Plain text
#: build/C/man3/scalb.3:95
msgid ""
"If I<x> is positive infinity (negative infinity), and I<exp> is not negative "
"infinity, positive infinity (negative infinity) is returned."
msgstr ""
"I<x> が正の無限大 (負の無限大) で I<exp> が負の無限大でない場合、正の無限大 "
"(負の無限大) が返される。"

#. type: Plain text
#: build/C/man3/scalb.3:101
msgid ""
"If I<x> is +0 (-0), and I<exp> is not positive infinity, +0 (-0) is returned."
msgstr "I<x> が +0 (-0) で I<exp> が正の無限大でない場合、+0 (-0) が返される。"

#. type: Plain text
#: build/C/man3/scalb.3:109
msgid ""
"If I<x> is zero, and I<exp> is positive infinity, a domain error occurs, and "
"a NaN is returned."
msgstr ""
"I<x> がゼロで I<exp> が正の無限大の場合、領域エラー (domain error) が発生"
"し、 NaN が返される。"

#. type: Plain text
#: build/C/man3/scalb.3:118
msgid ""
"If I<x> is an infinity, and I<exp> is negative infinity, a domain error "
"occurs, and a NaN is returned."
msgstr ""
"I<x> が無限大で I<exp> が負の無限大の場合、領域エラー (domain error) が発生"
"し、 NaN が返される。"

#. type: Plain text
#: build/C/man3/scalb.3:133 build/C/man3/scalbln.3:125
msgid ""
"If the result underflows, a range error occurs, and the functions return "
"zero, with a sign the same as I<x>."
msgstr ""
"結果がアンダーフローする場合、範囲エラーが発生し、 各関数は 0 を返す。符号は "
"I<x> と同じになる。"

#. type: TP
#: build/C/man3/scalb.3:140
#, no-wrap
msgid "Domain error: I<x> is 0, and I<exp> is positive infinity, or I<x> is positive infinity and I<exp> is negative infinity and the other argument is not a NaN"
msgstr "領域エラー (domain error): I<x> が 0 で I<exp> が正の無限大、または I<x> が正の無限大で I<exp> が負の無限大"

#. type: Plain text
#: build/C/man3/scalb.3:186
msgid ""
"B<scalb>()  is specified in POSIX.1-2001, but marked obsolescent.  "
"POSIX.1-2008 removes the specification of B<scalb>(), recommending the use "
"of B<scalbln>(3), B<scalblnf>(3), or B<scalblnl>(3)  instead.  The B<scalb>"
"()  function is from 4.3BSD."
msgstr ""
"B<scalb>()  は POSIX.1-2001 で規定されているが、廃止予定とされている。 "
"POSIX.1-2008 では B<scalb>()  の仕様は削除されており、代わりに B<scalbln>"
"(3), B<scalblnf>(3), B<scalblnl>(3)  の使用が推奨されている。 B<scalb>()  関"
"数は 4.3BSD に由来する。"

#.  Looking at header files: scalbf() is present on the
#.  BSDs, Tru64, HP-UX 11, Irix 6.5; scalbl() is on HP-UX 11 and Tru64.
#. type: Plain text
#: build/C/man3/scalb.3:195
msgid ""
"B<scalbf>()  and B<scalbl>()  are unstandardized; B<scalbf>()  is "
"nevertheless present on several other systems"
msgstr ""
"B<scalbf>()  と B<scalbl>()  は標準化されていない。 それにも関わらず、 "
"B<scalbf>()  はいくつかの他のシステムに存在する。"

#. type: Plain text
#: build/C/man3/scalb.3:198
msgid "B<ldexp>(3), B<scalbln>(3)"
msgstr "B<ldexp>(3), B<scalbln>(3)"

#. type: TH
#: build/C/man3/scalbln.3:27
#, no-wrap
msgid "SCALBLN"
msgstr "SCALBLN"

#. type: Plain text
#: build/C/man3/scalbln.3:31
msgid ""
"scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl - multiply floating-"
"point number by integral power of radix"
msgstr ""
"scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl - \n"
"浮動小数点数に基数の整数乗を掛ける"

#. type: Plain text
#: build/C/man3/scalbln.3:35
msgid "B<double scalbln(double >I<x>B<, long int >I<exp>B<);>"
msgstr "B<double scalbln(double >I<x>B<, long int >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalbln.3:37
msgid "B<float scalblnf(float >I<x>B<, long int >I<exp>B<);>"
msgstr "B<float scalblnf(float >I<x>B<, long int >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalbln.3:39
msgid "B<long double scalblnl(long double >I<x>B<, long int >I<exp>B<);>"
msgstr "B<long double scalblnl(long double >I<x>B<, long int >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalbln.3:41
msgid "B<double scalbn(double >I<x>B<, int >I<exp>B<);>"
msgstr "B<double scalbn(double >I<x>B<, int >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalbln.3:43
msgid "B<float scalbnf(float >I<x>B<, int >I<exp>B<);>"
msgstr "B<float scalbnf(float >I<x>B<, int >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalbln.3:45
msgid "B<long double scalbnl(long double >I<x>B<, int >I<exp>B<);>"
msgstr "B<long double scalbnl(long double >I<x>B<, int >I<exp>B<);>"

#. type: Plain text
#: build/C/man3/scalbln.3:57
msgid "B<scalbln>(), B<scalblnf>(), B<scalblnl>():"
msgstr "B<scalbln>(), B<scalblnf>(), B<scalblnl>():"

#. type: Plain text
#: build/C/man3/scalbln.3:68
msgid "B<scalbn>(), B<scalbnf>(), B<scalbnl>():"
msgstr "B<scalbn>(), B<scalbnf>(), B<scalbnl>():"

#. type: Plain text
#: build/C/man3/scalbln.3:166
msgid ""
"These functions differ from the obsolete functions described in B<scalb>(3)  "
"in the type of their second argument.  The functions described on this page "
"have a second argument of an integral type, while those in B<scalb>(3)  have "
"a second argument of type I<double>."
msgstr ""
"これらの関数は、 B<scalb>(3) に説明がある廃止予定の関数群とは二番目の\n"
"引き数の型が異なる。このページで説明する関数群は、二番目の引き数の型が\n"
"整数である。これに対して B<scalb>(3) に説明がある関数群は、二番目の\n"
"引き数の型が I<double> である。"

#. type: Plain text
#: build/C/man3/scalbln.3:173
msgid ""
"If B<FLT_RADIX> equals 2 (which is usual), then B<scalbn>()  is equivalent "
"to B<ldexp>(3)."
msgstr ""
"B<FLT_RADIX> が 2 の場合 (これが普通だが)、\n"
"その場合は B<scalbn>() は B<ldexp>(3) と等価である。"

#. type: Plain text
#: build/C/man3/scalbln.3:176
msgid "B<ldexp>(3), B<scalb>(3)"
msgstr "B<ldexp>(3), B<scalb>(3)"

#. type: TH
#: build/C/man3/signbit.3:11
#, no-wrap
msgid "SIGNBIT"
msgstr "SIGNBIT"

#. type: Plain text
#: build/C/man3/signbit.3:14
msgid "signbit - test sign of a real floating-point number"
msgstr "signbit - 浮動小数点実数の符号 (sign) を調べる"

#. type: Plain text
#: build/C/man3/signbit.3:18
msgid "B<int signbit(>I<x>B<);>"
msgstr "B<int signbit(>I<x>B<);>"

#. type: Plain text
#: build/C/man3/signbit.3:28
msgid "B<signbit>():"
msgstr "B<signbit>():"

#. type: Plain text
#: build/C/man3/signbit.3:42
msgid ""
"B<signbit>()  is a generic macro which can work on all real floating-point "
"types.  It returns a nonzero value if the value of I<x> has its sign bit set."
msgstr ""
"B<signbit>()  は、あらゆる種類の浮動小数点実数に対して 適用可能な汎用的なマク"
"ロである。 I<x> の値の符号ビットがセットされている場合、非 0 の値を返す。"

#. type: Plain text
#: build/C/man3/signbit.3:51
msgid ""
"This is not the same as I<x E<lt> 0.0>, because IEEE 754 floating point "
"allows zero to be signed.  The comparison I<-0.0 E<lt> 0.0> is false, but "
"I<signbit(-0.0)> will return a nonzero value."
msgstr ""
"このマクロは I<x E<lt> 0.0> と全く同じではない。 なぜなら、IEEE 754 の浮動小"
"数点表現では 0 も符号を持つからである。 I<-0.0 E<lt> 0.0> という比較結果は偽 "
"(false) だが、 I<signbit (-0.0)> は 非 0 の値を返す。"

#. type: Plain text
#: build/C/man3/signbit.3:53
msgid "NaNs and infinities have a sign bit."
msgstr "NaN と無限大には符号ビットがある。"

#. type: Plain text
#: build/C/man3/signbit.3:59
msgid ""
"The B<signbit>()  macro returns nonzero if the sign of I<x> is negative; "
"otherwise it returns zero."
msgstr ""
"B<signbit>()  マクロは I<x> の符号が負の場合 0 以外を返し、そうでない場合 0 "
"を返す。"

#. type: Plain text
#: build/C/man3/signbit.3:67
msgid "B<copysign>(3)"
msgstr "B<copysign>(3)"

#. type: TH
#: build/C/man3/significand.3:9
#, no-wrap
msgid "SIGNIFICAND"
msgstr "SIGNIFICAND"

#. type: TH
#: build/C/man3/significand.3:9
#, no-wrap
msgid "2009-02-04"
msgstr "2009-02-04"

#. type: Plain text
#: build/C/man3/significand.3:13
msgid ""
"significand, significandf, significandl - get mantissa of floating-point "
"number"
msgstr ""
"significand, significandf, significandl - 浮動小数点数の仮数 (mantissa) を取"
"得する"

#. type: Plain text
#: build/C/man3/significand.3:17
msgid "B<double significand(double >I<x>B<);>"
msgstr "B<double significand(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/significand.3:19
msgid "B<float significandf(float >I<x>B<);>"
msgstr "B<float significandf(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/significand.3:21
msgid "B<long double significandl(long double >I<x>B<);>"
msgstr "B<long double significandl(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/significand.3:33
msgid "B<significand>(), B<significandf>(), B<significandl>():"
msgstr "B<significand>(), B<significandf>(), B<significandl>():"

#. type: Plain text
#: build/C/man3/significand.3:44
msgid ""
"The B<significand>()  function returns the mantissa of I<x> scaled to the "
"range [1,2).  It is equivalent to"
msgstr ""
"B<significand>()  関数は I<x> の仮数を [1,2) の範囲にして返す。 これは、以下"
"と等しい。"

#. type: Plain text
#: build/C/man3/significand.3:47
msgid "scalb(x, (double) -ilogb(x))"
msgstr "scalb(x, (double) -ilogb(x))"

#. type: Plain text
#: build/C/man3/significand.3:51
msgid ""
"This function exists mainly for use in certain standardized tests for IEEE "
"754 conformance."
msgstr "この関数は主に IEEE 754 への準拠を調べる標準テストで使われる。"

#.  .SH HISTORY
#.  This function came from BSD.
#. type: Plain text
#: build/C/man3/significand.3:57
msgid ""
"These functions are nonstandard; the I<double> version is available on a "
"number of other systems."
msgstr ""
"これらの関数は非標準である。。 I<double> 版は他の多くのシステムでも利用可能で"
"ある。"

#. type: Plain text
#: build/C/man3/significand.3:60
msgid "B<ilogb>(3), B<scalb>(3)"
msgstr "B<ilogb>(3), B<scalb>(3)"

#. type: TH
#: build/C/man3/sin.3:35
#, no-wrap
msgid "SIN"
msgstr "SIN"

#. type: Plain text
#: build/C/man3/sin.3:38
msgid "sin, sinf, sinl - sine function"
msgstr "sin, sinf, sinl - 正弦 (サイン) 関数"

#. type: Plain text
#: build/C/man3/sin.3:43
#, no-wrap
msgid "B<double sin(double >I<x>B<);>\n"
msgstr "B<double sin(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sin.3:45
#, no-wrap
msgid "B<float sinf(float >I<x>B<);>\n"
msgstr "B<float sinf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sin.3:47
#, no-wrap
msgid "B<long double sinl(long double >I<x>B<);>\n"
msgstr "B<long double sinl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sin.3:59
msgid "B<sinf>(), B<sinl>():"
msgstr "B<sinf>(), B<sinl>():"

#. type: Plain text
#: build/C/man3/sin.3:72
msgid ""
"The B<sin>()  function returns the sine of I<x>, where I<x> is given in "
"radians."
msgstr ""
"B<sin>()  関数は I<x> の正弦 (サイン) の値を返す。 I<x> はラジアン単位で指定"
"する。"

#. type: Plain text
#: build/C/man3/sin.3:75
msgid "On success, these functions return the sine of I<x>."
msgstr "成功すると、これらの関数は I<x> の正弦を返す。"

#. type: Plain text
#: build/C/man3/sin.3:126
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<csin>(3), "
"B<sincos>(3), B<tan>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<csin>(3), "
"B<sincos>(3), B<tan>(3)"

#. type: TH
#: build/C/man3/sincos.3:9
#, no-wrap
msgid "SINCOS"
msgstr "SINCOS"

#. type: Plain text
#: build/C/man3/sincos.3:12
msgid "sincos, sincosf, sincosl - calculate sin and cos simultaneously"
msgstr "sincos, sincosf, sincosl - 正弦と余弦を同時に計算する"

#. type: Plain text
#: build/C/man3/sincos.3:18
#, no-wrap
msgid "B<void sincos(double >I<x>B<, double *>I<sin>B<, double *>I<cos>B<);>\n"
msgstr "B<void sincos(double >I<x>B<, double *>I<sin>B<, double *>I<cos>B<);>\n"

#. type: Plain text
#: build/C/man3/sincos.3:20
#, no-wrap
msgid "B<void sincosf(float >I<x>B<, float *>I<sin>B<, float *>I<cos>B<);>\n"
msgstr "B<void sincosf(float >I<x>B<, float *>I<sin>B<, float *>I<cos>B<);>\n"

#. type: Plain text
#: build/C/man3/sincos.3:22
#, no-wrap
msgid "B<void sincosl(long double >I<x>B<, long double *>I<sin>B<, long double *>I<cos>B<);>\n"
msgstr "B<void sincosl(long double >I<x>B<, long double *>I<sin>B<, long double *>I<cos>B<);>\n"

#. type: Plain text
#: build/C/man3/sincos.3:32
msgid ""
"Several applications need sine and cosine of the same angle I<x>.  This "
"function computes both at the same time, and stores the results in I<*sin> "
"and I<*cos>."
msgstr ""
"アプリケーションの中には、同じ角度 I<x> について正弦と余弦の両方の計算が必要"
"なものがある。 この関数は両者を同時に計算し、その結果を I<*sin> と I<*cos> に"
"格納する。"

#. type: Plain text
#: build/C/man3/sincos.3:40
msgid "If I<x> is a NaN, a NaN is returned in I<*sin> and I<*cos>."
msgstr "I<x> が NaN の場合、 I<*sin> と I<*cos> に NaN が返される。"

#. type: Plain text
#: build/C/man3/sincos.3:49
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned in I<*sin> and I<*cos>."
msgstr ""
"I<x> が正の無限大か負の無限大の場合、 領域エラー (domain error) が発生し、 "
"I<*sin> と I<*cos> に NaN が返される。"

#. type: Plain text
#: build/C/man3/sincos.3:52
msgid "These functions return I<void>."
msgstr "これらの関数は I<void> を返す。"

#. type: Plain text
#: build/C/man3/sincos.3:77
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/sincos.3:81
msgid "B<cos>(3), B<sin>(3), B<tan>(3)"
msgstr "B<cos>(3), B<sin>(3), B<tan>(3)"

#. type: TH
#: build/C/man3/sinh.3:36
#, no-wrap
msgid "SINH"
msgstr "SINH"

#. type: Plain text
#: build/C/man3/sinh.3:39
msgid "sinh, sinhf, sinhl - hyperbolic sine function"
msgstr "sinh, sinhf, sinhl - 双曲線正弦 (ハイパボリックサイン) 関数"

#. type: Plain text
#: build/C/man3/sinh.3:44
#, no-wrap
msgid "B<double sinh(double >I<x>B<);>\n"
msgstr "B<double sinh(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sinh.3:46
#, no-wrap
msgid "B<float sinhf(float >I<x>B<);>\n"
msgstr "B<float sinhf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sinh.3:48
#, no-wrap
msgid "B<long double sinhl(long double >I<x>B<);>\n"
msgstr "B<long double sinhl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sinh.3:60
msgid "B<sinhf>(), B<sinhl>():"
msgstr "B<sinhf>(), B<sinhl>():"

#. type: Plain text
#: build/C/man3/sinh.3:73
msgid ""
"The B<sinh>()  function returns the hyperbolic sine of I<x>, which is "
"defined mathematically as:"
msgstr ""
"B<sinh>()  関数は双曲線正弦 (ハイパボリックサイン) 関数の値を返す。 数学的に"
"は以下のように定義されている。"

#. type: Plain text
#: build/C/man3/sinh.3:76
#, no-wrap
msgid "    sinh(x) = (exp(x) - exp(-x)) / 2\n"
msgstr "    sinh(x) = (exp(x) - exp(-x)) / 2\n"

#. type: Plain text
#: build/C/man3/sinh.3:80
msgid "On success, these functions return the hyperbolic sine of I<x>."
msgstr "成功すると、これらの関数は I<x> の双曲線正弦を返す。"

#.  POSIX.1-2001 documents an optional range error (underflow)
#.  for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: build/C/man3/sinh.3:107
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the same sign "
"as I<x>."
msgstr ""
"結果がオーバーフローする場合、 範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> を返す。符号は I<x> と同じにな"
"る。"

#. type: Plain text
#: build/C/man3/sinh.3:135
msgid ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<csinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<csinh>(3), B<tanh>(3)"

#. type: TH
#: build/C/man3/sqrt.3:34
#, no-wrap
msgid "SQRT"
msgstr "SQRT"

#. type: Plain text
#: build/C/man3/sqrt.3:37
msgid "sqrt, sqrtf, sqrtl - square root function"
msgstr "sqrt, sqrtf, sqrtl - 平方根関数"

#. type: Plain text
#: build/C/man3/sqrt.3:42
#, no-wrap
msgid "B<double sqrt(double >I<x>B<);>\n"
msgstr "B<double sqrt(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sqrt.3:44
#, no-wrap
msgid "B<float sqrtf(float >I<x>B<);>\n"
msgstr "B<float sqrtf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sqrt.3:46
#, no-wrap
msgid "B<long double sqrtl(long double >I<x>B<);>\n"
msgstr "B<long double sqrtl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/sqrt.3:58
msgid "B<sqrtf>(), B<sqrtl>():"
msgstr "B<sqrtf>(), B<sqrtl>():"

#. type: Plain text
#: build/C/man3/sqrt.3:70
msgid "The B<sqrt>()  function returns the nonnegative square root of I<x>."
msgstr "B<sqrt>()  関数は I<x> の平方根のうち負でない方の値を返す。"

#. type: Plain text
#: build/C/man3/sqrt.3:73
msgid "On success, these functions return the square root of I<x>."
msgstr "成功すると、これらの関数は I<x> の平方根を返す。"

#. type: Plain text
#: build/C/man3/sqrt.3:91
msgid "If I<x> is less than -0, a domain error occurs, and a NaN is returned."
msgstr ""
"I<x> が 0 未満の場合、領域エラー (domain error) が発生し、 NaN が返される。"

#. type: TP
#: build/C/man3/sqrt.3:98
#, no-wrap
msgid "Domain error: I<x> less than -0"
msgstr "領域エラー (domain error): I<x> が 0 未満"

#. type: Plain text
#: build/C/man3/sqrt.3:116
msgid "B<cbrt>(3), B<csqrt>(3), B<hypot>(3)"
msgstr "B<cbrt>(3), B<csqrt>(3), B<hypot>(3)"

#. type: TH
#: build/C/man3/tan.3:35
#, no-wrap
msgid "TAN"
msgstr "TAN"

#. type: Plain text
#: build/C/man3/tan.3:38
msgid "tan, tanf, tanl - tangent function"
msgstr "tan, tanf, tanl - 正接（タンジェント）関数"

#. type: Plain text
#: build/C/man3/tan.3:43
#, no-wrap
msgid "B<double tan(double >I<x>B<);>\n"
msgstr "B<double tan(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/tan.3:45
#, no-wrap
msgid "B<float tanf(float >I<x>B<);>\n"
msgstr "B<float tanf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/tan.3:47
#, no-wrap
msgid "B<long double tanl(long double >I<x>B<);>\n"
msgstr "B<long double tanl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/tan.3:59
msgid "B<tanf>(), B<tanl>():"
msgstr "B<tanf>(), B<tanl>():"

#. type: Plain text
#: build/C/man3/tan.3:72
msgid ""
"The B<tan>()  function returns the tangent of I<x>, where I<x> is given in "
"radians."
msgstr ""
"B<tan>()  関数は I<x> の正接（タンジェント）の値を返す。 I<x> はラジアン単位"
"で指定する。"

#. type: Plain text
#: build/C/man3/tan.3:75
msgid "On success, these functions return the tangent of I<x>."
msgstr "成功すると、これらの関数は I<x> の正接 (タンジェント) を返す。"

#.  I think overflow can't occur, because the closest floating-point
#.  representation of pi/2 is still not close enough to pi/2 to
#.  produce a large enough value to overflow.
#.  Testing certainly seems to bear this out.  -- mtk, Jul 08
#.  POSIX.1 allows an optional underflow error;
#.  glibc 2.8 doesn't do this
#.  POSIX.1 an optional range error for subnormal x;
#.  glibc 2.8 doesn't do this
#. type: Plain text
#: build/C/man3/tan.3:103
msgid ""
"If the correct result would overflow, a range error occurs, and the "
"functions return B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, "
"with the mathematically correct sign."
msgstr ""
"結果がオーバーフローする場合、範囲エラー (range error) が発生し、 各関数はそ"
"れぞれ B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL> を返す。"

#. type: Plain text
#: build/C/man3/tan.3:150
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<ctan>(3), "
"B<sin>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<ctan>(3), "
"B<sin>(3)"

#. type: TH
#: build/C/man3/tanh.3:35
#, no-wrap
msgid "TANH"
msgstr "TANH"

#. type: Plain text
#: build/C/man3/tanh.3:38
msgid "tanh, tanhf, tanhl - hyperbolic tangent function"
msgstr "tanh, tanhf, tanhl - 双曲線正接 (hyperbolic tangent) 関数"

#. type: Plain text
#: build/C/man3/tanh.3:43
#, no-wrap
msgid "B<double tanh(double >I<x>B<);>\n"
msgstr "B<double tanh(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/tanh.3:45
#, no-wrap
msgid "B<float tanhf(float >I<x>B<);>\n"
msgstr "B<float tanhf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/tanh.3:47
#, no-wrap
msgid "B<long double tanhl(long double >I<x>B<);>\n"
msgstr "B<long double tanhl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/tanh.3:59
msgid "B<tanhf>(), B<tanhl>():"
msgstr "B<tanhf>(), B<tanhl>():"

#. type: Plain text
#: build/C/man3/tanh.3:72
msgid ""
"The B<tanh>()  function returns the hyperbolic tangent of I<x>, which is "
"defined mathematically as:"
msgstr ""
"B<tanh>()  関数は I<x> の双曲線正接 (hyperbolic tangent) 関数を返す。 数学的"
"には以下のように定義されている．"

#. type: Plain text
#: build/C/man3/tanh.3:75
#, no-wrap
msgid "    tanh(x) = sinh(x) / cosh(x)\n"
msgstr "    tanh(x) = sinh(x) / cosh(x)\n"

#. type: Plain text
#: build/C/man3/tanh.3:79
msgid "On success, these functions return the hyperbolic tangent of I<x>."
msgstr "成功すると、これらの関数は I<x> の双曲線正接を返す。"

#. type: Plain text
#: build/C/man3/tanh.3:111
msgid ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<ctanh>(3), B<sinh>(3)"
msgstr ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<ctanh>(3), B<sinh>(3)"

#. type: TH
#: build/C/man3/tgamma.3:13
#, no-wrap
msgid "TGAMMA"
msgstr "TGAMMA"

#. type: Plain text
#: build/C/man3/tgamma.3:16
msgid "tgamma, tgammaf, tgammal - true gamma function"
msgstr "tgamma, tgammaf, tgammal - 本当のガンマ関数"

#. type: Plain text
#: build/C/man3/tgamma.3:20
msgid "B<double tgamma(double >I<x>B<);>"
msgstr "B<double tgamma(double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/tgamma.3:22
msgid "B<float tgammaf(float >I<x>B<);>"
msgstr "B<float tgammaf(float >I<x>B<);>"

#. type: Plain text
#: build/C/man3/tgamma.3:24
msgid "B<long double tgammal(long double >I<x>B<);>"
msgstr "B<long double tgammal(long double >I<x>B<);>"

#. type: Plain text
#: build/C/man3/tgamma.3:36
msgid "B<tgamma>(), B<tgammaf>(), B<tgammal>():"
msgstr "B<tgamma>(), B<tgammaf>(), B<tgammal>():"

#. type: Plain text
#: build/C/man3/tgamma.3:46
msgid "The Gamma function is defined by"
msgstr "ガンマ関数は以下のように定義される:"

#. type: Plain text
#: build/C/man3/tgamma.3:48
#, no-wrap
msgid "    Gamma(x) = integral from 0 to infinity of t^(x-1) e^-t dt\n"
msgstr "     Gamma(x) = t^(x-1) e^-t dt の 0 から無限大までの積分\n"

#. type: Plain text
#: build/C/man3/tgamma.3:51
msgid ""
"It is defined for every real number except for nonpositive integers.  For "
"nonnegative integral I<m> one has"
msgstr ""
"この関数は正でない整数を除くすべての実数に対して定義されている。 非負の整数 "
"I<m> に関して、以下が成立する:"

#. type: Plain text
#: build/C/man3/tgamma.3:53
#, no-wrap
msgid "    Gamma(m+1) = m!\n"
msgstr "    Gamma(m+1) = m!\n"

#. type: Plain text
#: build/C/man3/tgamma.3:55
msgid "and, more generally, for all I<x>:"
msgstr "より一般的には、すべての I<x> に関して以下が成立する:"

#. type: Plain text
#: build/C/man3/tgamma.3:57
#, no-wrap
msgid "    Gamma(x+1) = x * Gamma(x)\n"
msgstr "    Gamma(x+1) = x * Gamma(x)\n"

#. type: Plain text
#: build/C/man3/tgamma.3:60
msgid ""
"Furthermore, the following is valid for all values of I<x> outside the poles:"
msgstr "さらに、極を除くすべての I<x> で次式も成立する:"

#. type: Plain text
#: build/C/man3/tgamma.3:62
#, no-wrap
msgid "    Gamma(x) * Gamma(1 - x) = PI / sin(PI * x)\n"
msgstr "    Gamma(x) * Gamma(1 - x) = PI / sin(PI * x)\n"

#. type: Plain text
#: build/C/man3/tgamma.3:65
msgid "On success, these functions return Gamma(x)."
msgstr "成功すると、これらの関数は Gamma(x) を返す。"

#. type: Plain text
#: build/C/man3/tgamma.3:79
msgid ""
"If I<x> is a negative integer, or is negative infinity, a domain error "
"occurs, and a NaN is returned."
msgstr ""
"I<x> が負の整数か負の無限大の場合、領域エラー (domain error) が発生し、 NaN "
"が返される。"

#. type: Plain text
#: build/C/man3/tgamma.3:92
msgid ""
"If the result underflows, a range error occurs, and the functions return 0, "
"with the correct mathematical sign."
msgstr ""
"結果がアンダーフローする場合、範囲エラー (range error) が発生し、 関数は 0 を"
"を返す。この際、数学的に正しい符号が付与される。"

#. type: Plain text
#: build/C/man3/tgamma.3:103
msgid ""
"If I<x> is -0 or +0, a pole error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the same sign "
"as the 0."
msgstr ""
"I<x> が -0 か +0 の場合、極エラー (pole error) が発生し、 各関数はそれぞれ "
"B<HUGE_VAL>, B<HUGE_VALF>, B<HUGE_VALL>, を返す。 0 と同じ符号が付与される。"

#. type: TP
#: build/C/man3/tgamma.3:110
#, no-wrap
msgid "Domain error: I<x> is a negative integer, or negative infinity"
msgstr "領域エラー: I<x> が負の整数か負の無限大"

#.  FIXME . errno is not set to EDOM for x == -inf
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6809
#. type: Plain text
#: build/C/man3/tgamma.3:120
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised (but see BUGS)."
msgstr ""
"I<errno> に B<EDOM> が設定される。 不正 (invalid) 浮動小数点例外 "
"(B<FE_INVALID>)  が上がる (「バグ」の節を参照)。"

#. type: TP
#: build/C/man3/tgamma.3:120
#, no-wrap
msgid "Pole error: I<x> is +0 or -0"
msgstr "極エラー (pole error): I<x> が +0 か -0"

#. type: Plain text
#: build/C/man3/tgamma.3:139
msgid ""
"glibc also gives the following error which is not specified in C99 or "
"POSIX.1-2001."
msgstr ""
"glibc では、C99 や POSIX.1-2001 で規定されていない以下のエラーも 起こり得る。"

#.  FIXME . Is it intentional that errno is not set:
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6810
#.  glibc (as at 2.8) also supports and an inexact
#.  exception for various cases.
#. type: Plain text
#: build/C/man3/tgamma.3:156
msgid "I<errno> is not set for this case."
msgstr "この場合は I<errno> は設定されない。"

#. type: Plain text
#: build/C/man3/tgamma.3:167
msgid ""
"This function had to be called \"true gamma function\" since there is "
"already a function B<gamma>(3)  that returns something else (see B<gamma>"
"(3)  for details)."
msgstr ""
"この関数を「本当の (true) ガンマ関数」と呼ばなければならなかった。 なぜなら、"
"他の値を返す B<gamma>(3)  という関数がすでに存在するからである (詳細について"
"は B<gamma>(3)  を参照)。"

#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6809
#. type: Plain text
#: build/C/man3/tgamma.3:175
msgid ""
"If I<x> is negative infinity, I<errno> is not set (it should be set to "
"B<EDOM>)."
msgstr ""
"I<x> が負の無限大の場合、 I<errno> は設定されない (B<EDOM> が設定されるべきで"
"ある)。"

#. type: Plain text
#: build/C/man3/tgamma.3:184
msgid ""
"In glibc versions 2.3.3 and earlier, an argument of +0 or -0 incorrectly "
"produced a domain error (I<errno> set to B<EDOM> and an B<FE_INVALID> "
"exception raised), rather than a pole error."
msgstr ""
"glibc バージョン 2.3.3 以前では、 引き数に +0 や -0 を渡すと、極エラーではな"
"く、 領域エラーを間違って発生していた (領域エラーの場合、 I<errno> に "
"B<EDOM> を設定され、 B<FE_INVALID> 例外が発生する)。"

#. type: Plain text
#: build/C/man3/tgamma.3:187
msgid "B<gamma>(3), B<lgamma>(3)"
msgstr "B<gamma>(3), B<lgamma>(3)"

#. type: TH
#: build/C/man3/trunc.3:25
#, no-wrap
msgid "TRUNC"
msgstr "TRUNC"

#. type: Plain text
#: build/C/man3/trunc.3:28
msgid "trunc, truncf, truncl - round to integer, toward zero"
msgstr "trunc, truncf, truncl - 0 に近い方の整数値に丸める"

#. type: Plain text
#: build/C/man3/trunc.3:33
#, no-wrap
msgid "B<double trunc(double >I<x>B<);>\n"
msgstr "B<double trunc(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/trunc.3:35
#, no-wrap
msgid "B<float truncf(float >I<x>B<);>\n"
msgstr "B<float truncf(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/trunc.3:37
#, no-wrap
msgid "B<long double truncl(long double >I<x>B<);>\n"
msgstr "B<long double truncl(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/trunc.3:50
msgid "B<trunc>(), B<truncf>(), B<truncl>():"
msgstr "B<trunc>(), B<truncf>(), B<truncl>():"

#. type: Plain text
#: build/C/man3/trunc.3:61
msgid ""
"These functions round I<x> to the nearest integer not larger in absolute "
"value."
msgstr ""
"これらの関数は絶対値が I<x> より小さい 一番近い整数値に I<x> を丸める。"

#. type: Plain text
#: build/C/man3/trunc.3:65
msgid "If I<x> is integral, infinite, or NaN, I<x> itself is returned."
msgstr "I<x> が整数、無限大、NaN の場合、I<x> 自身が返される。"

#. type: TH
#: build/C/man3/y0.3:36
#, no-wrap
msgid "Y0"
msgstr "Y0"

#. type: TH
#: build/C/man3/y0.3:36
#, no-wrap
msgid "2008-08-10"
msgstr "2008-08-10"

#. type: Plain text
#: build/C/man3/y0.3:40
msgid ""
"y0, y0f, y0l, y1, y1f, y1l, yn, ynf, ynl - Bessel functions of the second "
"kind"
msgstr "y0, y0f, y0l, y1, y1f, y1l, yn, ynf, ynl - 第二種ベッセル関数"

#. type: Plain text
#: build/C/man3/y0.3:45
#, no-wrap
msgid "B<double y0(double >I<x>B<);>\n"
msgstr "B<double y0(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:47
#, no-wrap
msgid "B<double y1(double >I<x>B<);>\n"
msgstr "B<double y1(double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:49
#, no-wrap
msgid "B<double yn(int >I<n>B<, double >I<x>B<);>\n"
msgstr "B<double yn(int >I<n>B<, double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:51
#, no-wrap
msgid "B<float y0f(float >I<x>B<);>\n"
msgstr "B<float y0f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:53
#, no-wrap
msgid "B<float y1f(float >I<x>B<);>\n"
msgstr "B<float y1f(float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:55
#, no-wrap
msgid "B<float ynf(int >I<n>B<, float >I<x>B<);>\n"
msgstr "B<float ynf(int >I<n>B<, float >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:57
#, no-wrap
msgid "B<long double y0l(long double >I<x>B<);>\n"
msgstr "B<long double y0l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:59
#, no-wrap
msgid "B<long double y1l(long double >I<x>B<);>\n"
msgstr "B<long double y1l(long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:61
#, no-wrap
msgid "B<long double ynl(int >I<n>B<, long double >I<x>B<);>\n"
msgstr "B<long double ynl(int >I<n>B<, long double >I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/y0.3:74
msgid "B<y0>(), B<y1>(), B<yn>():"
msgstr "B<y0>(), B<y1>(), B<yn>():"

#. type: Plain text
#: build/C/man3/y0.3:84
msgid "B<y0f>(), B<y0l>(), B<y1f>(), B<y1l>(), B<ynf>(), B<ynl>():"
msgstr "B<y0f>(), B<y0l>(), B<y1f>(), B<y1l>(), B<ynf>(), B<ynl>():"

#. type: Plain text
#: build/C/man3/y0.3:101
msgid ""
"The B<y0>()  and B<y1>()  functions return Bessel functions of I<x> of the "
"second kind of orders 0 and 1, respectively.  The B<yn>()  function returns "
"the Bessel function of I<x> of the second kind of order I<n>."
msgstr ""
"関数 B<y0>()  と B<y1>()  はそれぞれ I<x> の 0 次、1 次の 第二種ベッセル関数"
"の値を返す。 関数 B<yn>()  は I<x> の I<n> 次の 第二種ベッセル関数の値を返"
"す。"

#. type: Plain text
#: build/C/man3/y0.3:103
msgid "The value of I<x> must be positive."
msgstr "I<x> は正の値でなければならない。"

#. type: Plain text
#: build/C/man3/y0.3:113
msgid ""
"The B<y0f>()  etc. and B<y0l>()  etc. functions are versions that take and "
"return I<float> and I<long double> values, respectively."
msgstr ""
"B<y0f>()  群の関数、 B<y0l>()  群の関数は、それぞれ I<float> 型、 I<long "
"double> 型の返り値を返す。"

#. type: Plain text
#: build/C/man3/y0.3:117
msgid ""
"On success, these functions return the appropriate Bessel value of the "
"second kind for I<x>."
msgstr "成功すると、これらの関数は I<x> に対する第二種ベッセル関数の値を返す。"

#. type: Plain text
#: build/C/man3/y0.3:133
msgid ""
"If I<x> is negative, a domain error occurs, and the functions return -"
"B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively.  (POSIX.1-2001 "
"also allows a NaN return for this case.)"
msgstr ""
"I<x> が負の場合、領域エラー (domain error) が発生し、 各関数はそれぞれ -"
"B<HUGE_VAL>, -B<HUGE_VALF>, -B<HUGE_VALL> を返す (POSIX.1-2001 ではこの場合"
"に NaN を返すことも認めている)。"

#. type: Plain text
#: build/C/man3/y0.3:144
msgid ""
"If I<x> is 0.0, a pole error occurs, and the functions return -B<HUGE_VAL>, -"
"B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""
"I<x> が 0.0 の場合、極エラー (pole error) が発生し、 各関数はそれぞれ -"
"B<HUGE_VAL>, -B<HUGE_VALF>, -B<HUGE_VALL> を返す。"

#. type: Plain text
#: build/C/man3/y0.3:148
msgid ""
"If the result underflows, a range error occurs, and the functions return 0.0"
msgstr ""
"結果がアンダーフローする場合、 範囲エラー (range error) が発生し、 各関数は "
"0.0 を返す。"

#. type: Plain text
#: build/C/man3/y0.3:158
msgid ""
"If the result overflows, a range error occurs, and the functions return -"
"B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively.  (POSIX.1-2001 "
"also allows a 0.0 return for this case.)"
msgstr ""
"結果がオーバーフローする場合、範囲エラーが発生し、 各関数はそれぞれ -"
"B<HUGE_VAL>, -B<HUGE_VALF>, -B<HUGE_VALL> を返す (POSIX.1-2001 ではこの場合"
"に 0.0 を返すことも認めている)。"

#. type: TP
#: build/C/man3/y0.3:173
#, no-wrap
msgid "Pole error: I<x> is 0.0"
msgstr "極エラー: I<x> が 0.0"

#.  Before POSIX.1-2001 TC2, this was (inconsistently) specified
#.  as a range error.
#.  FIXME . y0(0.0) gives EDOM
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6808
#. type: Plain text
#: build/C/man3/y0.3:188
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  No B<FE_DIVBYZERO> exception "
"is returned by B<fetestexcept>(3)  for this case."
msgstr ""
"I<errno> に B<ERANGE> が設定される (「バグ」の節を参照のこと)。 このエラーの"
"場合、 B<fetestexcept>(3)  は B<FE_DIVBYZERO> 例外を返さない。"

#.  e.g., y0(1e33) on glibc 2.8/x86-32
#.  An underflow floating-point exception
#.  .RB ( FE_UNDERFLOW )
#.  is raised.
#.  FIXME . Is it intentional that these functions do not use FE_*?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6806
#. type: Plain text
#: build/C/man3/y0.3:204
msgid ""
"I<errno> is set to B<ERANGE>.  No B<FE_UNDERFLOW> exception is returned by "
"B<fetestexcept>(3)  for this case."
msgstr ""
"I<errno> に B<ERANGE> が設定される。 このエラーの場合、 B<fetestexcept>(3)  "
"は B<FE_UNDERFLOW> 例外を返さない。"

#.  e.g., yn(10, 1e-40) on glibc 2.8/x86-32
#.  .I errno
#.  is set to
#.  .BR ERANGE .
#.  FIXME . Is it intentional that errno is not set?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6808
#. type: Plain text
#: build/C/man3/y0.3:217
msgid ""
"I<errno> is not set for this case.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""
"この場合、 I<errno> は設定されない。 オーバーフロー浮動小数点例外 "
"(B<FE_OVERFLOW>)  が上がる。"

#.  FIXME .
#.  Bug raised: http://sourceware.org/bugzilla/show_bug.cgi?id=6807
#. type: Plain text
#: build/C/man3/y0.3:233
msgid ""
"On a pole error, these functions set I<errno> to B<EDOM>, instead of "
"B<ERANGE> as POSIX.1-2004 requires."
msgstr ""
"極エラーの場合、これらの関数は I<errno> に B<EDOM> を設定するが、 "
"POSIX.1-2004 では B<ERANGE> を設定することが要求されている。"

#.  FIXME . Actually, 2.3.2 is the earliest test result I have; so yet
#.  to confirm if this error occurs only in 2.3.2.
#. type: Plain text
#: build/C/man3/y0.3:240
msgid ""
"In glibc version 2.3.2 and earlier, these functions do not raise an invalid "
"floating-point exception (B<FE_INVALID>)  when a domain error occurs."
msgstr ""
"glibc バージョン 2.3.2 以前では、 領域エラーが発生した場合に、これらの関数は "
"不正浮動小数点例外 (B<FE_INVALID>)  を上げない。"

#. type: Plain text
#: build/C/man3/y0.3:242
msgid "B<j0>(3)"
msgstr "B<j0>(3)"
