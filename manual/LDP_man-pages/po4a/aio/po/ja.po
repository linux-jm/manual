# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: man-pages-ja\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2015-02-04 23:36+0900\n"
"Last-Translator: Akihiro MOTOKI <amotoki@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.net/projects/p/man-pages-ja/"
"language/ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0\n"

#. type: TH
#: build/C/man7/aio.7:25
#, no-wrap
msgid "AIO"
msgstr "AIO"

#. type: TH
#: build/C/man7/aio.7:25 build/C/man3/aio_init.3:25
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: TH
#: build/C/man7/aio.7:25 build/C/man3/aio_init.3:25 build/C/man2/io_cancel.2:7
#: build/C/man2/io_destroy.2:7 build/C/man2/io_getevents.2:7
#: build/C/man2/io_setup.2:7 build/C/man2/io_submit.2:8
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/aio.7:25 build/C/man3/aio_cancel.3:24
#: build/C/man3/aio_error.3:24 build/C/man3/aio_fsync.3:24
#: build/C/man3/aio_init.3:25 build/C/man3/aio_read.3:24
#: build/C/man3/aio_return.3:24 build/C/man3/aio_suspend.3:25
#: build/C/man3/aio_write.3:24 build/C/man2/io_cancel.2:7
#: build/C/man2/io_destroy.2:7 build/C/man2/io_getevents.2:7
#: build/C/man2/io_setup.2:7 build/C/man2/io_submit.2:8
#: build/C/man3/lio_listio.3:24
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/aio.7:26 build/C/man3/aio_cancel.3:25
#: build/C/man3/aio_error.3:25 build/C/man3/aio_fsync.3:25
#: build/C/man3/aio_init.3:26 build/C/man3/aio_read.3:25
#: build/C/man3/aio_return.3:25 build/C/man3/aio_suspend.3:26
#: build/C/man3/aio_write.3:25 build/C/man2/io_cancel.2:8
#: build/C/man2/io_destroy.2:8 build/C/man2/io_getevents.2:8
#: build/C/man2/io_setup.2:8 build/C/man2/io_submit.2:9
#: build/C/man3/lio_listio.3:25
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/aio.7:28
msgid "aio - POSIX asynchronous I/O overview"
msgstr "aio - POSIX 非同期 I/O の概要"

#. type: SH
#: build/C/man7/aio.7:28 build/C/man3/aio_cancel.3:33
#: build/C/man3/aio_error.3:33 build/C/man3/aio_fsync.3:33
#: build/C/man3/aio_init.3:37 build/C/man3/aio_read.3:33
#: build/C/man3/aio_return.3:33 build/C/man3/aio_suspend.3:38
#: build/C/man3/aio_write.3:33 build/C/man2/io_cancel.2:20
#: build/C/man2/io_destroy.2:19 build/C/man2/io_getevents.2:22
#: build/C/man2/io_setup.2:19 build/C/man2/io_submit.2:21
#: build/C/man3/lio_listio.3:36
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/aio.7:36
msgid ""
"The POSIX asynchronous I/O (AIO) interface allows applications to initiate "
"one or more I/O operations that are performed asynchronously (i.e., in the "
"background).  The application can elect to be notified of completion of the "
"I/O operation in a variety of ways: by delivery of a signal, by "
"instantiation of a thread, or no notification at all."
msgstr ""
"POSIX 非同期 (AIO) インターフェースを使うと、アプリケーションは、非同期\n"
"に (つまり、バックグラウンドで) 実行されるI/O 操作を一つ以上発行できる\n"
"ようになる。アプリケーションは I/O 操作の完了の通知方法を選択することが\n"
"できる。選択できる通知方法は、シグナルの配送、スレッドの起動、通知を行\n"
"わないである。"

#. type: Plain text
#: build/C/man7/aio.7:38
msgid "The POSIX AIO interface consists of the following functions:"
msgstr "POSIX AIO インターフェースは以下の関数で構成されている。"

#. type: TP
#: build/C/man7/aio.7:38
#, no-wrap
msgid "B<aio_read>(3)"
msgstr "B<aio_read>(3)"

#. type: Plain text
#: build/C/man7/aio.7:43
msgid "Enqueue a read request.  This is the asynchronous analog of B<read>(2)."
msgstr ""
"読み出しリクエストをキューに入れる。\n"
"B<read>(2) の非同期版である。"

#. type: TP
#: build/C/man7/aio.7:43
#, no-wrap
msgid "B<aio_write>(3)"
msgstr "B<aio_write>(3)"

#. type: Plain text
#: build/C/man7/aio.7:48
msgid ""
"Enqueue a write request.  This is the asynchronous analog of B<write>(2)."
msgstr ""
"書き込みリクエストをキューに入れる。\n"
"B<write>(2) の非同期版である。"

#. type: TP
#: build/C/man7/aio.7:48
#, no-wrap
msgid "B<aio_fsync>(3)"
msgstr "B<aio_fsync>(3)"

#. type: Plain text
#: build/C/man7/aio.7:55
msgid ""
"Enqueue a sync request for the I/O operations on a file descriptor.  This is "
"the asynchronous analog of B<fsync>(2)  and B<fdatasync>(2)."
msgstr ""
"ファイルディスクリプターに対して行われた I/O 操作の\n"
"同期 (sync) リクエストをキューに入れる。\n"
"B<fsync>(2) や B<fdatasync>(2) の非同期版である。"

#. type: TP
#: build/C/man7/aio.7:55
#, no-wrap
msgid "B<aio_error>(3)"
msgstr "B<aio_error>(3)"

#. type: Plain text
#: build/C/man7/aio.7:58
msgid "Obtain the error status of an enqueued I/O request."
msgstr "キューに入れられた I/O リクエストのエラー状態を取得する。"

#. type: TP
#: build/C/man7/aio.7:58
#, no-wrap
msgid "B<aio_return>(3)"
msgstr "B<aio_return>(3)"

#. type: Plain text
#: build/C/man7/aio.7:61
msgid "Obtain the return status of a completed I/O request."
msgstr "完了した I/O リクエストの終了ステータスを取得する。"

#. type: TP
#: build/C/man7/aio.7:61
#, no-wrap
msgid "B<aio_suspend>(3)"
msgstr "B<aio_suspend>(3)"

#. type: Plain text
#: build/C/man7/aio.7:65
msgid ""
"Suspend the caller until one or more of a specified set of I/O requests "
"completes."
msgstr ""
"指定された I/O リクエストの集合 (要素は一つ以上) が完了するまで、\n"
"呼び出し側の実行を停止 (suspend) する。"

#. type: TP
#: build/C/man7/aio.7:65
#, no-wrap
msgid "B<aio_cancel>(3)"
msgstr "B<aio_cancel>(3)"

#. type: Plain text
#: build/C/man7/aio.7:69
msgid ""
"Attempt to cancel outstanding I/O requests on a specified file descriptor."
msgstr ""
"指定されたファイルディスクリプターに関する\n"
"完了していない I/O リクエストのキャンセルを試みる。"

#. type: TP
#: build/C/man7/aio.7:69
#, no-wrap
msgid "B<lio_listio>(3)"
msgstr "B<lio_listio>(3)"

#. type: Plain text
#: build/C/man7/aio.7:72
msgid "Enqueue multiple I/O requests using a single function call."
msgstr "一回の関数呼び出しで複数の I/O リクエストをキューに入れる。"

#. type: Plain text
#: build/C/man7/aio.7:79
msgid ""
"The I<aiocb> (\"asynchronous I/O control block\") structure defines "
"parameters that control an I/O operation.  An argument of this type is "
"employed with all of the functions listed above.  This structure has the "
"following form:"
msgstr ""
"I<aiocb> (\"非同期 I/O 制御ブロック (asynchronous I/O control block)\")\n"
"構造体は、I/O 操作を制御するパラメーターを定義する。この型の引き数は上記\n"
"の全ての関数で使用されている。この構造体は以下の通りである。"

#. type: Plain text
#: build/C/man7/aio.7:83
#, no-wrap
msgid "#include E<lt>aiocb.hE<gt>\n"
msgstr "#include E<lt>aiocb.hE<gt>\n"

#. type: Plain text
#: build/C/man7/aio.7:86
#, no-wrap
msgid ""
"struct aiocb {\n"
"    /* The order of these fields is implementation-dependent */\n"
msgstr ""
"struct aiocb {\n"
"    /* The order of these fields is implementation-dependent */\n"

#. type: Plain text
#: build/C/man7/aio.7:95
#, no-wrap
msgid ""
"    int             aio_fildes;     /* File descriptor */\n"
"    off_t           aio_offset;     /* File offset */\n"
"    volatile void  *aio_buf;        /* Location of buffer */\n"
"    size_t          aio_nbytes;     /* Length of transfer */\n"
"    int             aio_reqprio;    /* Request priority */\n"
"    struct sigevent aio_sigevent;   /* Notification method */\n"
"    int             aio_lio_opcode; /* Operation to be performed;\n"
"                                       lio_listio() only */\n"
msgstr ""
"    int             aio_fildes;     /* File descriptor */\n"
"    off_t           aio_offset;     /* File offset */\n"
"    volatile void  *aio_buf;        /* Location of buffer */\n"
"    size_t          aio_nbytes;     /* Length of transfer */\n"
"    int             aio_reqprio;    /* Request priority */\n"
"    struct sigevent aio_sigevent;   /* Notification method */\n"
"    int             aio_lio_opcode; /* Operation to be performed;\n"
"                                       lio_listio() only */\n"

#. type: Plain text
#: build/C/man7/aio.7:98
#, no-wrap
msgid ""
"    /* Various implementation-internal fields not shown */\n"
"};\n"
msgstr ""
"    /* Various implementation-internal fields not shown */\n"
"};\n"

#. type: Plain text
#: build/C/man7/aio.7:100
#, no-wrap
msgid "/* Operation codes for \\(aqaio_lio_opcode\\(aq: */\n"
msgstr "/* Operation codes for \\(aqaio_lio_opcode\\(aq: */\n"

#. type: Plain text
#: build/C/man7/aio.7:102
#, no-wrap
msgid "enum { LIO_READ, LIO_WRITE, LIO_NOP };\n"
msgstr "enum { LIO_READ, LIO_WRITE, LIO_NOP };\n"

#. type: Plain text
#: build/C/man7/aio.7:106 build/C/man2/io_submit.2:68
msgid "The fields of this structure are as follows:"
msgstr "この構造体のフィールドは以下の通りである。"

#. type: TP
#: build/C/man7/aio.7:106 build/C/man2/io_submit.2:165
#, fuzzy, no-wrap
#| msgid "I<aio_filedes>"
msgid "I<aio_fildes>"
msgstr "I<aio_filedes>"

#. type: Plain text
#: build/C/man7/aio.7:109 build/C/man2/io_submit.2:168
msgid "The file descriptor on which the I/O operation is to be performed."
msgstr "I/O 操作の実行対象となるファイルディスクリプター。"

#. type: TP
#: build/C/man7/aio.7:109 build/C/man2/io_submit.2:175
#, no-wrap
msgid "I<aio_offset>"
msgstr "I<aio_offset>"

#. type: Plain text
#: build/C/man7/aio.7:112 build/C/man2/io_submit.2:178
msgid "This is the file offset at which the I/O operation is to be performed."
msgstr "I/O 操作を行うファイルオフセットを示す。"

#. type: TP
#: build/C/man7/aio.7:112 build/C/man2/io_submit.2:168
#, no-wrap
msgid "I<aio_buf>"
msgstr "I<aio_buf>"

#. type: Plain text
#: build/C/man7/aio.7:115 build/C/man2/io_submit.2:171
msgid "This is the buffer used to transfer data for a read or write operation."
msgstr "読み出し操作、書き込み操作でデータ転送に使用されるバッファー。"

#. type: TP
#: build/C/man7/aio.7:115 build/C/man2/io_submit.2:171
#, no-wrap
msgid "I<aio_nbytes>"
msgstr "I<aio_nbytes>"

#. type: Plain text
#: build/C/man7/aio.7:119 build/C/man2/io_submit.2:175
msgid "This is the size of the buffer pointed to by I<aio_buf>."
msgstr "I<aio_buf> が指すバッファーのサイズ。"

#. type: TP
#: build/C/man7/aio.7:119 build/C/man2/io_submit.2:162
#, no-wrap
msgid "I<aio_reqprio>"
msgstr "I<aio_reqprio>"

#. type: Plain text
#: build/C/man7/aio.7:128
msgid ""
"This field specifies a value that is subtracted from the calling thread's "
"real-time priority in order to determine the priority for execution of this "
"I/O request (see B<pthread_setschedparam>(3)).  The specified value must be "
"between 0 and the value returned by I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>.  "
"This field is ignored for file synchronization operations."
msgstr ""
"このフィールドでは、呼び出したスレッドのリアルタイム優先度から\n"
"減算する値を指定する。この I/O リクエストの実行の優先度を\n"
"決定するために使用される (B<pthread_setschedparam>(3) 参照)。\n"
"指定する値は 0 と I<sysconf(_SC_AIO_PRIO_DELTA_MAX)> が返す値の間で\n"
"なければならない。このフィールドは、ファイル同期操作では無視される。"

#. type: TP
#: build/C/man7/aio.7:128
#, no-wrap
msgid "I<aio_sigevent>"
msgstr "I<aio_sigevent>"

#. type: Plain text
#: build/C/man7/aio.7:142
msgid ""
"This field is a structure that specifies how the caller is to be notified "
"when the asynchronous I/O operation completes.  Possible values for "
"I<aio_sigevent.sigev_notify> are B<SIGEV_NONE>, B<SIGEV_SIGNAL>, and "
"B<SIGEV_THREAD>.  See B<sigevent>(7)  for further details."
msgstr ""
"このフィールドは、非同期 I/O 操作が完了した際に呼び出し側に\n"
"どのように通知を行うかを指定する構造体である。\n"
"I<aio_sigevent.sigev_notify> に指定できる値は、\n"
"B<SIGEV_NONE>, B<SIGEV_SIGNAL>, B<SIGEV_THREAD> である。\n"
"詳細は B<sigevent>(7) を参照。"

#. type: TP
#: build/C/man7/aio.7:142 build/C/man2/io_submit.2:139
#, no-wrap
msgid "I<aio_lio_opcode>"
msgstr "I<aio_lio_opcode>"

#. type: Plain text
#: build/C/man7/aio.7:146
msgid "The type of operation to be performed; used only for B<lio_listio>(3)."
msgstr ""
"実行される操作の種別。\n"
"B<lio_listio>(3) でのみ使用される。"

#. type: Plain text
#: build/C/man7/aio.7:149
msgid ""
"In addition to the standard functions listed above, the GNU C library "
"provides the following extension to the POSIX AIO API:"
msgstr ""
"上記のリストにある標準の関数に加えて、GNU C ライブラリでは\n"
"以下に示す POSIX AIO API に対する拡張が提供されている。"

#. type: TP
#: build/C/man7/aio.7:149
#, no-wrap
msgid "B<aio_init>(3)"
msgstr "B<aio_init>(3)"

#. type: Plain text
#: build/C/man7/aio.7:152
msgid ""
"Set parameters for tuning the behavior of the glibc POSIX AIO implementation."
msgstr "glibc の POSIX AIO 実装の動作を調整するパラメーターを設定する。"

#. type: SH
#: build/C/man7/aio.7:152 build/C/man3/aio_cancel.3:101
#: build/C/man3/aio_error.3:66 build/C/man3/aio_fsync.3:79
#: build/C/man3/aio_read.3:103 build/C/man3/aio_return.3:64
#: build/C/man3/aio_suspend.3:87 build/C/man3/aio_write.3:110
#: build/C/man2/io_cancel.2:50 build/C/man2/io_destroy.2:42
#: build/C/man2/io_getevents.2:73 build/C/man2/io_setup.2:45
#: build/C/man2/io_submit.2:210 build/C/man3/lio_listio.3:146
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man7/aio.7:153 build/C/man3/aio_error.3:67
#: build/C/man3/aio_fsync.3:87 build/C/man3/aio_read.3:111
#: build/C/man3/aio_return.3:65 build/C/man3/aio_write.3:122
#: build/C/man2/io_cancel.2:57 build/C/man2/io_destroy.2:46
#: build/C/man2/io_getevents.2:81 build/C/man2/io_setup.2:56
#: build/C/man2/io_submit.2:220 build/C/man3/lio_listio.3:171
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man7/aio.7:162
msgid ""
"The I<aio_reqprio> field of the I<aiocb> structure was less than 0, or was "
"greater than the limit returned by the call "
"I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>."
msgstr ""
"I<aiocb> 構造体の I<aio_reqprio> フィールドが、0 より小さいか、\n"
"I<sysconf(_SC_AIO_PRIO_DELTA_MAX)> が返す上限よりも大きかった。"

#. type: SH
#: build/C/man7/aio.7:162 build/C/man3/aio_cancel.3:110
#: build/C/man3/aio_error.3:78 build/C/man3/aio_fsync.3:99
#: build/C/man3/aio_init.3:92 build/C/man3/aio_read.3:128
#: build/C/man3/aio_return.3:74 build/C/man3/aio_suspend.3:102
#: build/C/man3/aio_write.3:133 build/C/man2/io_cancel.2:64
#: build/C/man2/io_destroy.2:53 build/C/man2/io_getevents.2:90
#: build/C/man2/io_setup.2:68 build/C/man2/io_submit.2:243
#: build/C/man3/lio_listio.3:202
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/aio.7:164
msgid "The POSIX AIO interfaces are provided by glibc since version 2.1."
msgstr ""
"POSIX AIO インターフェイスは glibc バージョン 2.1 以降で提供されている。"

#. type: SH
#: build/C/man7/aio.7:164 build/C/man3/aio_cancel.3:126
#: build/C/man3/aio_error.3:94 build/C/man3/aio_fsync.3:115
#: build/C/man3/aio_init.3:96 build/C/man3/aio_read.3:144
#: build/C/man3/aio_return.3:90 build/C/man3/aio_suspend.3:118
#: build/C/man3/aio_write.3:149 build/C/man2/io_cancel.2:66
#: build/C/man2/io_destroy.2:55 build/C/man2/io_getevents.2:92
#: build/C/man2/io_setup.2:70 build/C/man2/io_submit.2:245
#: build/C/man3/lio_listio.3:219
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/aio.7:166 build/C/man3/aio_cancel.3:128
#: build/C/man3/aio_error.3:96 build/C/man3/aio_fsync.3:117
#: build/C/man3/aio_read.3:146 build/C/man3/aio_return.3:92
#: build/C/man3/aio_suspend.3:120 build/C/man3/aio_write.3:151
#: build/C/man3/lio_listio.3:221
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: SH
#: build/C/man7/aio.7:166 build/C/man3/aio_read.3:146
#: build/C/man3/aio_suspend.3:120 build/C/man3/aio_write.3:151
#: build/C/man2/io_cancel.2:70 build/C/man2/io_destroy.2:59
#: build/C/man2/io_getevents.2:96 build/C/man2/io_setup.2:74
#: build/C/man2/io_submit.2:249 build/C/man3/lio_listio.3:221
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man7/aio.7:173
msgid ""
"It is a good idea to zero out the control block buffer before use (see "
"B<memset>(3)).  The control block buffer and the buffer pointed to by "
"I<aio_buf> must not be changed while the I/O operation is in progress.  "
"These buffers must remain valid until the I/O operation completes."
msgstr ""
"使用前に制御ブロックバッファーを 0 で埋めるのはよい考えである\n"
"(B<memset>(3) 参照)。I/O 操作が実行中の間は、制御ブロックバッファーと\n"
"I<aio_buf> が指すバッファーを変更してはならない。I/O 操作が完了するまで、\n"
"これらのバッファーは有効な状態に保たなければならない。"

#. type: Plain text
#: build/C/man7/aio.7:177
msgid ""
"Simultaneous asynchronous read or write operations using the same I<aiocb> "
"structure yield undefined results."
msgstr ""
"同じ I<aiocb> 構造体を使って、同時に複数の非同期の読み出し操作や\n"
"書き込み操作を行った場合に、どのような結果になるかは未定義である。"

#.  http://lse.sourceforge.net/io/aio.html
#.  http://lse.sourceforge.net/io/aionotes.txt
#.  http://lwn.net/Articles/148755/
#. type: Plain text
#: build/C/man7/aio.7:195
msgid ""
"The current Linux POSIX AIO implementation is provided in user space by "
"glibc.  This has a number of limitations, most notably that maintaining "
"multiple threads to perform I/O operations is expensive and scales poorly.  "
"Work has been in progress for some time on a kernel state-machine-based "
"implementation of asynchronous I/O (see B<io_submit>(2), B<io_setup>(2), "
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2)), but this "
"implementation hasn't yet matured to the point where the POSIX AIO "
"implementation can be completely reimplemented using the kernel system calls."
msgstr ""
"現在の Linux では、POSIX AIO 実装は glibc によりユーザー空間で提供\n"
"されている。このため、制限がいくつかあり、最も顕著なものは、I/O 操作を\n"
"実行する複数のスレッドの管理コストが高く、スケーラビリティに欠けること\n"
"である。しばらくの間、カーネルのステートマシンによる非同期 I/O の実装\n"
"の作業が行われているが (B<io_submit>(2), B<io_setup>(2), \n"
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2) 参照)、\n"
"この実装はまだ POSIX AIO 実装をカーネルシステムコールにより\n"
"再実装するほど成熟したものてはない。"

#. type: SH
#: build/C/man7/aio.7:195 build/C/man3/aio_cancel.3:128
#: build/C/man3/aio_error.3:96 build/C/man3/aio_read.3:158
#: build/C/man3/aio_return.3:92
#, fuzzy, no-wrap
#| msgid "EXAMPLE"
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man7/aio.7:208
msgid ""
"The program below opens each of the files named in its command-line "
"arguments and queues a request on the resulting file descriptor using "
"B<aio_read>(3).  The program then loops, periodically monitoring each of the "
"I/O operations that is still in progress using B<aio_error>(3).  Each of the "
"I/O requests is set up to provide notification by delivery of a signal.  "
"After all I/O requests have completed, the program retrieves their status "
"using B<aio_return>(3)."
msgstr ""
"下記のプログラムは、コマンドライン引き数で指定された名前のファイルを\n"
"それぞれオープンし、得られたファイルディスクリプターに対するリクエストを\n"
"B<aio_read>(3) を使ってキューに入れる。その後、このプログラムはループに\n"
"入り、定期的に B<aio_error>(3) を使ってまだ実行中の各 I/O 操作を監視す\n"
"る。各 I/O リクエストは、シグナルの配送による完了通知が行われるように設\n"
"定される。全ての I/O リクエストが完了した後、B<aio_return>(3) を使って\n"
"それぞれのステータスを取得する。"

#. type: Plain text
#: build/C/man7/aio.7:214
msgid ""
"The B<SIGQUIT> signal (generated by typing control-\\e) causes the program "
"to request cancellation of each of the outstanding requests using "
"B<aio_cancel>(3)."
msgstr ""
"B<SIGQUIT> シグナル (control-\\e をタイプすると生成できる) を送ると、\n"
"このプログラムは B<aio_cancel>(3) を使って\n"
"完了していない各リクエストにキャンセル要求を送る。"

#. type: Plain text
#: build/C/man7/aio.7:219
msgid ""
"Here is an example of what we might see when running this program.  In this "
"example, the program queues two requests to standard input, and these are "
"satisfied by two lines of input containing \"abc\" and \"x\"."
msgstr ""
"以下はこのプログラムを実行した際の出力例である。\n"
"この例では、標準入力に対して 2 つのリクエストを行い、\n"
"\"abc\" と \"x\" という 2 行の入力を行っている。"

#. type: Plain text
#: build/C/man7/aio.7:243
#, no-wrap
msgid ""
"$ B<./a.out /dev/stdin /dev/stdin>\n"
"opened /dev/stdin on descriptor 3\n"
"opened /dev/stdin on descriptor 4\n"
"aio_error():\n"
"    for request 0 (descriptor 3): In progress\n"
"    for request 1 (descriptor 4): In progress\n"
"B<abc>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 0 (descriptor 3): I/O succeeded\n"
"    for request 1 (descriptor 4): In progress\n"
"aio_error():\n"
"    for request 1 (descriptor 4): In progress\n"
"B<x>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 1 (descriptor 4): I/O succeeded\n"
"All I/O requests completed\n"
"aio_return():\n"
"    for request 0 (descriptor 3): 4\n"
"    for request 1 (descriptor 4): 2\n"
msgstr ""
"$ B<./a.out /dev/stdin /dev/stdin>\n"
"opened /dev/stdin on descriptor 3\n"
"opened /dev/stdin on descriptor 4\n"
"aio_error():\n"
"    for request 0 (descriptor 3): In progress\n"
"    for request 1 (descriptor 4): In progress\n"
"B<abc>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 0 (descriptor 3): I/O succeeded\n"
"    for request 1 (descriptor 4): In progress\n"
"aio_error():\n"
"    for request 1 (descriptor 4): In progress\n"
"B<x>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 1 (descriptor 4): I/O succeeded\n"
"All I/O requests completed\n"
"aio_return():\n"
"    for request 0 (descriptor 3): 4\n"
"    for request 1 (descriptor 4): 2\n"

#. type: SS
#: build/C/man7/aio.7:245
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man7/aio.7:255
#, fuzzy, no-wrap
#| msgid ""
#| "#include E<lt>stdlib.hE<gt>\n"
#| "#include E<lt>unistd.hE<gt>\n"
#| "#include E<lt>stdio.hE<gt>\n"
#| "#include E<lt>errno.hE<gt>\n"
#| "#include E<lt>aio.hE<gt>\n"
#| "#include E<lt>signal.hE<gt>\n"
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>aio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>aio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: build/C/man7/aio.7:257
#, no-wrap
msgid "#define BUF_SIZE 20     /* Size of buffers for read operations */\n"
msgstr "#define BUF_SIZE 20     /* Size of buffers for read operations */\n"

#. type: Plain text
#: build/C/man7/aio.7:259
#, no-wrap
msgid "#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr "#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man7/aio.7:266
#, no-wrap
msgid ""
"struct ioRequest {      /* Application-defined structure for tracking\n"
"                           I/O requests */\n"
"    int           reqNum;\n"
"    int           status;\n"
"    struct aiocb *aiocbp;\n"
"};\n"
msgstr ""
"struct ioRequest {      /* Application-defined structure for tracking\n"
"                           I/O requests */\n"
"    int           reqNum;\n"
"    int           status;\n"
"    struct aiocb *aiocbp;\n"
"};\n"

#. type: Plain text
#: build/C/man7/aio.7:270
#, no-wrap
msgid ""
"static volatile sig_atomic_t gotSIGQUIT = 0;\n"
"                        /* On delivery of SIGQUIT, we attempt to\n"
"                           cancel all outstanding I/O requests */\n"
msgstr ""
"static volatile sig_atomic_t gotSIGQUIT = 0;\n"
"                        /* On delivery of SIGQUIT, we attempt to\n"
"                           cancel all outstanding I/O requests */\n"

#. type: Plain text
#: build/C/man7/aio.7:276
#, no-wrap
msgid ""
"static void             /* Handler for SIGQUIT */\n"
"quitHandler(int sig)\n"
"{\n"
"    gotSIGQUIT = 1;\n"
"}\n"
msgstr ""
"static void             /* Handler for SIGQUIT */\n"
"quitHandler(int sig)\n"
"{\n"
"    gotSIGQUIT = 1;\n"
"}\n"

#. type: Plain text
#: build/C/man7/aio.7:278
#, no-wrap
msgid "#define IO_SIGNAL SIGUSR1   /* Signal used to notify I/O completion */\n"
msgstr "#define IO_SIGNAL SIGUSR1   /* Signal used to notify I/O completion */\n"

#. type: Plain text
#: build/C/man7/aio.7:284
#, fuzzy, no-wrap
#| msgid ""
#| "static void                 /* Handler for I/O completion signal */\n"
#| "aioSigHandler(int sig, siginfo_t *si, void *ucontext)\n"
#| "{\n"
#| "    write(STDOUT_FILENO, \"I/O completion signal received\\en\", 31);\n"
msgid ""
"static void                 /* Handler for I/O completion signal */\n"
"aioSigHandler(int sig, siginfo_t *si, void *ucontext)\n"
"{\n"
"    if (si-E<gt>si_code == SI_ASYNCIO) {\n"
"        write(STDOUT_FILENO, \"I/O completion signal received\\en\", 31);\n"
msgstr ""
"static void                 /* Handler for I/O completion signal */\n"
"aioSigHandler(int sig, siginfo_t *si, void *ucontext)\n"
"{\n"
"    write(STDOUT_FILENO, \"I/O completion signal received\\en\", 31);\n"

#. type: Plain text
#: build/C/man7/aio.7:291
#, fuzzy, no-wrap
#| msgid ""
#| "    /* The corresponding ioRequest structure would be available as\n"
#| "           struct ioRequest *ioReq = si-E<gt>si_value.sival_ptr;\n"
#| "       and the file descriptor would then be available via\n"
#| "           ioReq-E<gt>aiocbp-E<gt>aio_fildes */\n"
#| "}\n"
msgid ""
"        /* The corresponding ioRequest structure would be available as\n"
"               struct ioRequest *ioReq = si-E<gt>si_value.sival_ptr;\n"
"           and the file descriptor would then be available via\n"
"               ioReq-E<gt>aiocbp-E<gt>aio_fildes */\n"
"    }\n"
"}\n"
msgstr ""
"    /* The corresponding ioRequest structure would be available as\n"
"           struct ioRequest *ioReq = si-E<gt>si_value.sival_ptr;\n"
"       and the file descriptor would then be available via\n"
"           ioReq-E<gt>aiocbp-E<gt>aio_fildes */\n"
"}\n"

#. type: Plain text
#: build/C/man7/aio.7:299
#, fuzzy, no-wrap
#| msgid ""
#| "int\n"
#| "main(int argc, char *argv[])\n"
#| "{\n"
#| "    struct ioRequest *ioList;\n"
#| "    struct aiocb *aiocbList;\n"
#| "    struct sigaction sa;\n"
#| "    int s, j;\n"
#| "    int numReqs;        /* Total number of queued I/O requests */\n"
#| "    int openReqs;       /* Number of I/O requests still in progress */\n"
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sigaction sa;\n"
"    int s;\n"
"    int numReqs;        /* Total number of queued I/O requests */\n"
"    int openReqs;       /* Number of I/O requests still in progress */\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ioRequest *ioList;\n"
"    struct aiocb *aiocbList;\n"
"    struct sigaction sa;\n"
"    int s, j;\n"
"    int numReqs;        /* Total number of queued I/O requests */\n"
"    int openReqs;       /* Number of I/O requests still in progress */\n"

#. type: Plain text
#: build/C/man7/aio.7:305
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt> E<lt>pathnameE<gt>...\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt> E<lt>pathnameE<gt>...\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/aio.7:307
#, no-wrap
msgid "    numReqs = argc - 1;\n"
msgstr "    numReqs = argc - 1;\n"

#. type: Plain text
#: build/C/man7/aio.7:309
#, no-wrap
msgid "    /* Allocate our arrays */\n"
msgstr "    /* Allocate our arrays */\n"

#. type: Plain text
#: build/C/man7/aio.7:313
#, fuzzy, no-wrap
#| msgid ""
#| "    ioList = calloc(numReqs, sizeof(struct ioRequest));\n"
#| "    if (ioList == NULL)\n"
#| "        errExit(\"calloc\");\n"
msgid ""
"    struct ioRequest *ioList = calloc(numReqs, sizeof(*ioList));\n"
"    if (ioList == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""
"    ioList = calloc(numReqs, sizeof(struct ioRequest));\n"
"    if (ioList == NULL)\n"
"        errExit(\"calloc\");\n"

#. type: Plain text
#: build/C/man7/aio.7:317
#, fuzzy, no-wrap
#| msgid ""
#| "    aiocbList = calloc(numReqs, sizeof(struct aiocb));\n"
#| "    if (aiocbList == NULL)\n"
#| "        errExit(\"calloc\");\n"
msgid ""
"    struct aiocb *aiocbList = calloc(numReqs, sizeof(*aiocbList));\n"
"    if (aiocbList == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""
"    aiocbList = calloc(numReqs, sizeof(struct aiocb));\n"
"    if (aiocbList == NULL)\n"
"        errExit(\"calloc\");\n"

#. type: Plain text
#: build/C/man7/aio.7:319
#, no-wrap
msgid "    /* Establish handlers for SIGQUIT and the I/O completion signal */\n"
msgstr "    /* Establish handlers for SIGQUIT and the I/O completion signal */\n"

#. type: Plain text
#: build/C/man7/aio.7:322
#, no-wrap
msgid ""
"    sa.sa_flags = SA_RESTART;\n"
"    sigemptyset(&sa.sa_mask);\n"
msgstr ""
"    sa.sa_flags = SA_RESTART;\n"
"    sigemptyset(&sa.sa_mask);\n"

#. type: Plain text
#: build/C/man7/aio.7:326
#, no-wrap
msgid ""
"    sa.sa_handler = quitHandler;\n"
"    if (sigaction(SIGQUIT, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""
"    sa.sa_handler = quitHandler;\n"
"    if (sigaction(SIGQUIT, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"

#. type: Plain text
#: build/C/man7/aio.7:331
#, no-wrap
msgid ""
"    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n"
"    sa.sa_sigaction = aioSigHandler;\n"
"    if (sigaction(IO_SIGNAL, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""
"    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n"
"    sa.sa_sigaction = aioSigHandler;\n"
"    if (sigaction(IO_SIGNAL, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"

#. type: Plain text
#: build/C/man7/aio.7:334
#, no-wrap
msgid ""
"    /* Open each file specified on the command line, and queue\n"
"       a read request on the resulting file descriptor */\n"
msgstr ""
"    /* Open each file specified on the command line, and queue\n"
"       a read request on the resulting file descriptor */\n"

#. type: Plain text
#: build/C/man7/aio.7:339
#, fuzzy, no-wrap
#| msgid ""
#| "    for (j = 0; j E<lt> numReqs; j++) {\n"
#| "        ioList[j].reqNum = j;\n"
#| "        ioList[j].status = EINPROGRESS;\n"
#| "        ioList[j].aiocbp = &aiocbList[j];\n"
msgid ""
"    for (int j = 0; j E<lt> numReqs; j++) {\n"
"        ioList[j].reqNum = j;\n"
"        ioList[j].status = EINPROGRESS;\n"
"        ioList[j].aiocbp = &aiocbList[j];\n"
msgstr ""
"    for (j = 0; j E<lt> numReqs; j++) {\n"
"        ioList[j].reqNum = j;\n"
"        ioList[j].status = EINPROGRESS;\n"
"        ioList[j].aiocbp = &aiocbList[j];\n"

#. type: Plain text
#: build/C/man7/aio.7:345
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_fildes = open(argv[j + 1], O_RDONLY);\n"
"        if (ioList[j].aiocbp-E<gt>aio_fildes == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"opened %s on descriptor %d\\en\", argv[j + 1],\n"
"                ioList[j].aiocbp-E<gt>aio_fildes);\n"
msgstr ""
"        ioList[j].aiocbp-E<gt>aio_fildes = open(argv[j + 1], O_RDONLY);\n"
"        if (ioList[j].aiocbp-E<gt>aio_fildes == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"opened %s on descriptor %d\\en\", argv[j + 1],\n"
"                ioList[j].aiocbp-E<gt>aio_fildes);\n"

#. type: Plain text
#: build/C/man7/aio.7:349
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_buf = malloc(BUF_SIZE);\n"
"        if (ioList[j].aiocbp-E<gt>aio_buf == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""
"        ioList[j].aiocbp-E<gt>aio_buf = malloc(BUF_SIZE);\n"
"        if (ioList[j].aiocbp-E<gt>aio_buf == NULL)\n"
"            errExit(\"malloc\");\n"

#. type: Plain text
#: build/C/man7/aio.7:357
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_nbytes = BUF_SIZE;\n"
"        ioList[j].aiocbp-E<gt>aio_reqprio = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_offset = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_notify = SIGEV_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_signo = IO_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_value.sival_ptr =\n"
"                                &ioList[j];\n"
msgstr ""
"        ioList[j].aiocbp-E<gt>aio_nbytes = BUF_SIZE;\n"
"        ioList[j].aiocbp-E<gt>aio_reqprio = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_offset = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_notify = SIGEV_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_signo = IO_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_value.sival_ptr =\n"
"                                &ioList[j];\n"

#. type: Plain text
#: build/C/man7/aio.7:362
#, no-wrap
msgid ""
"        s = aio_read(ioList[j].aiocbp);\n"
"        if (s == -1)\n"
"            errExit(\"aio_read\");\n"
"    }\n"
msgstr ""
"        s = aio_read(ioList[j].aiocbp);\n"
"        if (s == -1)\n"
"            errExit(\"aio_read\");\n"
"    }\n"

#. type: Plain text
#: build/C/man7/aio.7:364
#, no-wrap
msgid "    openReqs = numReqs;\n"
msgstr "    openReqs = numReqs;\n"

#. type: Plain text
#: build/C/man7/aio.7:366
#, no-wrap
msgid "    /* Loop, monitoring status of I/O requests */\n"
msgstr "    /* Loop, monitoring status of I/O requests */\n"

#. type: Plain text
#: build/C/man7/aio.7:369
#, no-wrap
msgid ""
"    while (openReqs E<gt> 0) {\n"
"        sleep(3);       /* Delay between each monitoring step */\n"
msgstr ""
"    while (openReqs E<gt> 0) {\n"
"        sleep(3);       /* Delay between each monitoring step */\n"

#. type: Plain text
#: build/C/man7/aio.7:371
#, no-wrap
msgid "        if (gotSIGQUIT) {\n"
msgstr "        if (gotSIGQUIT) {\n"

#. type: Plain text
#: build/C/man7/aio.7:375
#, no-wrap
msgid ""
"            /* On receipt of SIGQUIT, attempt to cancel each of the\n"
"               outstanding I/O requests, and display status returned\n"
"               from the cancellation requests */\n"
msgstr ""
"            /* On receipt of SIGQUIT, attempt to cancel each of the\n"
"               outstanding I/O requests, and display status returned\n"
"               from the cancellation requests */\n"

#. type: Plain text
#: build/C/man7/aio.7:377
#, no-wrap
msgid "            printf(\"got SIGQUIT; canceling I/O requests: \\en\");\n"
msgstr "            printf(\"got SIGQUIT; canceling I/O requests: \\en\");\n"

#. type: Plain text
#: build/C/man7/aio.7:394
#, fuzzy, no-wrap
#| msgid ""
#| "            for (j = 0; j E<lt> numReqs; j++) {\n"
#| "                if (ioList[j].status == EINPROGRESS) {\n"
#| "                    printf(\"    Request %d on descriptor %d:\", j,\n"
#| "                            ioList[j].aiocbp-E<gt>aio_fildes);\n"
#| "                    s = aio_cancel(ioList[j].aiocbp-E<gt>aio_fildes,\n"
#| "                            ioList[j].aiocbp);\n"
#| "                    if (s == AIO_CANCELED)\n"
#| "                        printf(\"I/O canceled\\en\");\n"
#| "                    else if (s == AIO_NOTCANCELED)\n"
#| "                            printf(\"I/O not canceled\\en\");\n"
#| "                    else if (s == AIO_ALLDONE)\n"
#| "                        printf(\"I/O all done\\en\");\n"
#| "                    else\n"
#| "                        errMsg(\"aio_cancel\");\n"
#| "                }\n"
#| "            }\n"
msgid ""
"            for (int j = 0; j E<lt> numReqs; j++) {\n"
"                if (ioList[j].status == EINPROGRESS) {\n"
"                    printf(\"    Request %d on descriptor %d:\", j,\n"
"                            ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                    s = aio_cancel(ioList[j].aiocbp-E<gt>aio_fildes,\n"
"                            ioList[j].aiocbp);\n"
"                    if (s == AIO_CANCELED)\n"
"                        printf(\"I/O canceled\\en\");\n"
"                    else if (s == AIO_NOTCANCELED)\n"
"                        printf(\"I/O not canceled\\en\");\n"
"                    else if (s == AIO_ALLDONE)\n"
"                        printf(\"I/O all done\\en\");\n"
"                    else\n"
"                        perror(\"aio_cancel\");\n"
"                }\n"
"            }\n"
msgstr ""
"            for (j = 0; j E<lt> numReqs; j++) {\n"
"                if (ioList[j].status == EINPROGRESS) {\n"
"                    printf(\"    Request %d on descriptor %d:\", j,\n"
"                            ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                    s = aio_cancel(ioList[j].aiocbp-E<gt>aio_fildes,\n"
"                            ioList[j].aiocbp);\n"
"                    if (s == AIO_CANCELED)\n"
"                        printf(\"I/O canceled\\en\");\n"
"                    else if (s == AIO_NOTCANCELED)\n"
"                            printf(\"I/O not canceled\\en\");\n"
"                    else if (s == AIO_ALLDONE)\n"
"                        printf(\"I/O all done\\en\");\n"
"                    else\n"
"                        errMsg(\"aio_cancel\");\n"
"                }\n"
"            }\n"

#. type: Plain text
#: build/C/man7/aio.7:397
#, no-wrap
msgid ""
"            gotSIGQUIT = 0;\n"
"        }\n"
msgstr ""
"            gotSIGQUIT = 0;\n"
"        }\n"

#. type: Plain text
#: build/C/man7/aio.7:400
#, no-wrap
msgid ""
"        /* Check the status of each I/O request that is still\n"
"           in progress */\n"
msgstr ""
"        /* Check the status of each I/O request that is still\n"
"           in progress */\n"

#. type: Plain text
#: build/C/man7/aio.7:407
#, fuzzy, no-wrap
#| msgid ""
#| "        printf(\"aio_error():\\en\");\n"
#| "        for (j = 0; j E<lt> numReqs; j++) {\n"
#| "            if (ioList[j].status == EINPROGRESS) {\n"
#| "                printf(\"    for request %d (descriptor %d): \",\n"
#| "                        j, ioList[j].aiocbp-E<gt>aio_fildes);\n"
#| "                ioList[j].status = aio_error(ioList[j].aiocbp);\n"
msgid ""
"        printf(\"aio_error():\\en\");\n"
"        for (int j = 0; j E<lt> numReqs; j++) {\n"
"            if (ioList[j].status == EINPROGRESS) {\n"
"                printf(\"    for request %d (descriptor %d): \",\n"
"                        j, ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                ioList[j].status = aio_error(ioList[j].aiocbp);\n"
msgstr ""
"        printf(\"aio_error():\\en\");\n"
"        for (j = 0; j E<lt> numReqs; j++) {\n"
"            if (ioList[j].status == EINPROGRESS) {\n"
"                printf(\"    for request %d (descriptor %d): \",\n"
"                        j, ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                ioList[j].status = aio_error(ioList[j].aiocbp);\n"

#. type: Plain text
#: build/C/man7/aio.7:422
#, fuzzy, no-wrap
#| msgid ""
#| "                switch (ioList[j].status) {\n"
#| "                case 0:\n"
#| "                    printf(\"I/O succeeded\\en\");\n"
#| "                    break;\n"
#| "                case EINPROGRESS:\n"
#| "                    printf(\"In progress\\en\");\n"
#| "                    break;\n"
#| "                case ECANCELED:\n"
#| "                    printf(\"Canceled\\en\");\n"
#| "                    break;\n"
#| "                default:\n"
#| "                    errMsg(\"aio_error\");\n"
#| "                    break;\n"
#| "                }\n"
msgid ""
"                switch (ioList[j].status) {\n"
"                case 0:\n"
"                    printf(\"I/O succeeded\\en\");\n"
"                    break;\n"
"                case EINPROGRESS:\n"
"                    printf(\"In progress\\en\");\n"
"                    break;\n"
"                case ECANCELED:\n"
"                    printf(\"Canceled\\en\");\n"
"                    break;\n"
"                default:\n"
"                    perror(\"aio_error\");\n"
"                    break;\n"
"                }\n"
msgstr ""
"                switch (ioList[j].status) {\n"
"                case 0:\n"
"                    printf(\"I/O succeeded\\en\");\n"
"                    break;\n"
"                case EINPROGRESS:\n"
"                    printf(\"In progress\\en\");\n"
"                    break;\n"
"                case ECANCELED:\n"
"                    printf(\"Canceled\\en\");\n"
"                    break;\n"
"                default:\n"
"                    errMsg(\"aio_error\");\n"
"                    break;\n"
"                }\n"

#. type: Plain text
#: build/C/man7/aio.7:428
#, no-wrap
msgid ""
"                if (ioList[j].status != EINPROGRESS)\n"
"                    openReqs--;\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"                if (ioList[j].status != EINPROGRESS)\n"
"                    openReqs--;\n"
"            }\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/aio.7:430
#, no-wrap
msgid "    printf(\"All I/O requests completed\\en\");\n"
msgstr "    printf(\"All I/O requests completed\\en\");\n"

#. type: Plain text
#: build/C/man7/aio.7:432
#, no-wrap
msgid "    /* Check status return of all I/O requests */\n"
msgstr "    /* Check status return of all I/O requests */\n"

#. type: Plain text
#: build/C/man7/aio.7:436
#, fuzzy, no-wrap
#| msgid ""
#| "    printf(\"aio_return():\\en\");\n"
#| "    for (j = 0; j E<lt> numReqs; j++) {\n"
#| "        ssize_t s;\n"
msgid ""
"    printf(\"aio_return():\\en\");\n"
"    for (int j = 0; j E<lt> numReqs; j++) {\n"
"        ssize_t s;\n"
msgstr ""
"    printf(\"aio_return():\\en\");\n"
"    for (j = 0; j E<lt> numReqs; j++) {\n"
"        ssize_t s;\n"

#. type: Plain text
#: build/C/man7/aio.7:441
#, no-wrap
msgid ""
"        s = aio_return(ioList[j].aiocbp);\n"
"        printf(\"    for request %d (descriptor %d): %zd\\en\",\n"
"                j, ioList[j].aiocbp-E<gt>aio_fildes, s);\n"
"    }\n"
msgstr ""
"        s = aio_return(ioList[j].aiocbp);\n"
"        printf(\"    for request %d (descriptor %d): %zd\\en\",\n"
"                j, ioList[j].aiocbp-E<gt>aio_fildes, s);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/aio.7:444
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man7/aio.7:445 build/C/man3/aio_cancel.3:131
#: build/C/man3/aio_error.3:99 build/C/man3/aio_fsync.3:117
#: build/C/man3/aio_init.3:98 build/C/man3/aio_read.3:161
#: build/C/man3/aio_return.3:95 build/C/man3/aio_suspend.3:146
#: build/C/man3/aio_write.3:163 build/C/man2/io_cancel.2:100
#: build/C/man2/io_destroy.2:89 build/C/man2/io_getevents.2:131
#: build/C/man2/io_setup.2:104 build/C/man2/io_submit.2:279
#: build/C/man3/lio_listio.3:233
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/aio.7:460
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<io_submit>(2), B<aio_cancel>(3), B<aio_error>(3), B<aio_init>(3), "
"B<aio_read>(3), B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3)"
msgstr ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<io_submit>(2), B<aio_cancel>(3), B<aio_error>(3), B<aio_init>(3), "
"B<aio_read>(3), B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3)"

#. type: Plain text
#: build/C/man7/aio.7:466
msgid ""
"\"Asynchronous I/O Support in Linux 2.5\", Bhattacharya, Pratt, Pulavarty, "
"and Morgan, Proceedings of the Linux Symposium, 2003, E<.UR https://www."
"kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf> E<.UE>"
msgstr ""

#. type: SH
#: build/C/man7/aio.7:466 build/C/man3/aio_cancel.3:140
#: build/C/man3/aio_error.3:108 build/C/man3/aio_fsync.3:127
#: build/C/man3/aio_init.3:100 build/C/man3/aio_read.3:170
#: build/C/man3/aio_return.3:104 build/C/man3/aio_suspend.3:156
#: build/C/man3/aio_write.3:172 build/C/man2/io_cancel.2:108
#: build/C/man2/io_destroy.2:97 build/C/man2/io_getevents.2:140
#: build/C/man2/io_setup.2:112 build/C/man2/io_submit.2:287
#: build/C/man3/lio_listio.3:241
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/aio.7:474 build/C/man3/aio_cancel.3:148
#: build/C/man3/aio_error.3:116 build/C/man3/aio_fsync.3:135
#: build/C/man3/aio_init.3:108 build/C/man3/aio_read.3:178
#: build/C/man3/aio_return.3:112 build/C/man3/aio_suspend.3:164
#: build/C/man3/aio_write.3:180 build/C/man2/io_cancel.2:116
#: build/C/man2/io_destroy.2:105 build/C/man2/io_getevents.2:148
#: build/C/man2/io_setup.2:120 build/C/man2/io_submit.2:295
#: build/C/man3/lio_listio.3:249
#, fuzzy
#| msgid ""
#| "This page is part of release 3.79 of the Linux I<man-pages> project.  A "
#| "description of the project, information about reporting bugs, and the "
#| "latest version of this page, can be found at \\%http://www.kernel.org/doc/"
#| "man-pages/."
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.79 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/aio_cancel.3:24
#, no-wrap
msgid "AIO_CANCEL"
msgstr "AIO_CANCEL"

#. type: TH
#: build/C/man3/aio_cancel.3:24 build/C/man3/aio_error.3:24
#: build/C/man3/aio_read.3:24 build/C/man3/aio_return.3:24
#, fuzzy, no-wrap
#| msgid "2013-06-21"
msgid "2020-06-09"
msgstr "2013-06-21"

#. type: Plain text
#: build/C/man3/aio_cancel.3:27
msgid "aio_cancel - cancel an outstanding asynchronous I/O request"
msgstr "aio_cancel - 完了していない非同期 I/O リクエストをキャンセルする"

#. type: SH
#: build/C/man3/aio_cancel.3:27 build/C/man3/aio_error.3:27
#: build/C/man3/aio_fsync.3:27 build/C/man3/aio_init.3:28
#: build/C/man3/aio_read.3:27 build/C/man3/aio_return.3:27
#: build/C/man3/aio_suspend.3:28 build/C/man3/aio_write.3:27
#: build/C/man2/io_cancel.2:10 build/C/man2/io_destroy.2:10
#: build/C/man2/io_getevents.2:10 build/C/man2/io_setup.2:10
#: build/C/man2/io_submit.2:11 build/C/man3/lio_listio.3:27
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/aio_cancel.3:29 build/C/man3/aio_error.3:29
#: build/C/man3/aio_fsync.3:29 build/C/man3/aio_read.3:29
#: build/C/man3/aio_return.3:29 build/C/man3/aio_write.3:29
msgid "B<#include E<lt>aio.hE<gt>>"
msgstr "B<#include E<lt>aio.hE<gt>>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:31
msgid "B<int aio_cancel(int >I<fd>B<, struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_cancel(int >I<fd>B<, struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:33 build/C/man3/aio_error.3:33
#: build/C/man3/aio_fsync.3:33 build/C/man3/aio_init.3:37
#: build/C/man3/aio_read.3:33 build/C/man3/aio_return.3:33
#: build/C/man3/aio_write.3:33
msgid "Link with I<-lrt>."
msgstr "I<-lrt> でリンクする。"

#. type: Plain text
#: build/C/man3/aio_cancel.3:51
msgid ""
"The B<aio_cancel>()  function attempts to cancel outstanding asynchronous I/"
"O requests for the file descriptor I<fd>.  If I<aiocbp> is NULL, all such "
"requests are canceled.  Otherwise, only the request described by the control "
"block pointed to by I<aiocbp> is canceled.  (See B<aio>(7)  for a "
"description of the I<aiocb> structure.)"
msgstr ""
"B<aio_cancel>() 関数は、ファイルディスクリプター I<fd> についての完了して\n"
"いない非同期 I/O リクエストをキャンセルしようとする。 I<aiocbp> が\n"
"NULL の場合、そのような全てのリクエストがキャンセルされる。 I<aiocbp>\n"
"が NULL でない場合、I<aiocbp> で指された制御ブロックで記述されたリクエ\n"
"ストのみがキャンセルされる。(I<aiocb> 構造体の説明は B<aio>(7) を参照)"

#. type: Plain text
#: build/C/man3/aio_cancel.3:63
msgid ""
"Normal asynchronous notification occurs for canceled requests (see "
"B<aio>(7)  and B<sigevent>(7)).  The request return status "
"(B<aio_return>(3))  is set to -1, and the request error status "
"(B<aio_error>(3))  is set to B<ECANCELED>.  The control block of requests "
"that cannot be canceled is not changed."
msgstr ""
"キャンセルされたリクエストに対して、通常の非同期通知が起こる\n"
"(B<aio>(7) と B<sigevent>(7) を参照)。\n"
"リクエストの返り値 (B<aio_return>(3)) は -1 に設定され、\n"
"リクエストのエラー状態 (B<aio_error>(3)) は B<ECANCELED> に設定される。\n"
"キャンセルできないリクエストの制御ブロックは変更されない。"

#. type: Plain text
#: build/C/man3/aio_cancel.3:70
msgid ""
"If the request could not be canceled, then it will terminate in the usual "
"way after performing the I/O operation.  (In this case, B<aio_error>(3)  "
"will return the status B<EINPROGRESSS>.)"
msgstr ""
"リクエストがキャンセルできない場合には、\n"
"B<aio_cancel>() は通常の I/O 操作の実行後と同じように終了する。\n"
"(この場合、 B<aio_error>(3) はステータス B<EINPROGRESSS> を返す)。"

#. type: Plain text
#: build/C/man3/aio_cancel.3:77
msgid ""
"If I<aiocbp> is not NULL, and I<fd> differs from the file descriptor with "
"which the asynchronous operation was initiated, unspecified results occur."
msgstr ""
"I<aiocbp> が NULL でなく、かつ I<fd> が非同期操作が開始されたファイルディスク"
"リプターと異なる場合、 生じる結果は不定である。"

#.  FreeBSD: not those on raw disk devices.
#. type: Plain text
#: build/C/man3/aio_cancel.3:80
msgid "Which operations are cancelable is implementation-defined."
msgstr "どの操作をキャンセルできるかは、実装定義である。"

#. type: SH
#: build/C/man3/aio_cancel.3:80 build/C/man3/aio_error.3:44
#: build/C/man3/aio_fsync.3:73 build/C/man3/aio_read.3:88
#: build/C/man3/aio_return.3:49 build/C/man3/aio_suspend.3:79
#: build/C/man3/aio_write.3:95 build/C/man2/io_cancel.2:45
#: build/C/man2/io_destroy.2:37 build/C/man2/io_getevents.2:59
#: build/C/man2/io_setup.2:40 build/C/man2/io_submit.2:204
#: build/C/man3/lio_listio.3:108
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/aio_cancel.3:84
msgid "The B<aio_cancel>()  function returns one of the following values:"
msgstr "B<aio_cancel>() 関数は以下のいずれかの値を返す。"

#. type: TP
#: build/C/man3/aio_cancel.3:84
#, no-wrap
msgid "B<AIO_CANCELED>"
msgstr "B<AIO_CANCELED>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:87
msgid "All requests were successfully canceled."
msgstr "全てのリクエストが正常にキャンセルされた。"

#. type: TP
#: build/C/man3/aio_cancel.3:87
#, no-wrap
msgid "B<AIO_NOTCANCELED>"
msgstr "B<AIO_NOTCANCELED>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:93
msgid ""
"At least one of the requests specified was not canceled because it was in "
"progress.  In this case, one may check the status of individual requests "
"using B<aio_error>(3)."
msgstr ""
"指定されたリクエストのうち少なくとも一つが、実行中のため\n"
"キャンセルできなかった。この場合には、B<aio_error>(3) を使って\n"
"個々のリクエストの状態を確認できる。"

#. type: TP
#: build/C/man3/aio_cancel.3:93
#, no-wrap
msgid "B<AIO_ALLDONE>"
msgstr "B<AIO_ALLDONE>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:96
msgid "All requests had already been completed before the call."
msgstr "呼び出しの前に全てのリクエストがすでに完了していた。"

#. type: TP
#: build/C/man3/aio_cancel.3:96
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: build/C/man3/aio_cancel.3:101
msgid ""
"An error occurred.  The cause of the error can be found by inspecting "
"I<errno>."
msgstr ""
"エラーが発生した。\n"
"I<errno> を確認することでエラーの原因を知ることができる。"

#. type: TP
#: build/C/man3/aio_cancel.3:102 build/C/man3/aio_fsync.3:83
#: build/C/man3/aio_read.3:107 build/C/man3/aio_write.3:114
#: build/C/man2/io_submit.2:214
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:106
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターでない。"

#. type: TP
#: build/C/man3/aio_cancel.3:106 build/C/man3/aio_error.3:74
#: build/C/man3/aio_fsync.3:95 build/C/man3/aio_read.3:119
#: build/C/man3/aio_return.3:70 build/C/man3/aio_suspend.3:98
#: build/C/man3/aio_write.3:129 build/C/man2/io_cancel.2:60
#: build/C/man2/io_destroy.2:49 build/C/man2/io_getevents.2:86
#: build/C/man2/io_setup.2:64 build/C/man2/io_submit.2:230
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/aio_cancel.3:110
msgid "B<aio_cancel>()  is not implemented."
msgstr "B<aio_cancel>() は実装されていない。"

#. type: Plain text
#: build/C/man3/aio_cancel.3:114
msgid "The B<aio_cancel>()  function is available since glibc 2.1."
msgstr "B<aio_cancel>() 関数は glibc 2.1 以降で利用できる。"

#. type: SH
#: build/C/man3/aio_cancel.3:114 build/C/man3/aio_error.3:82
#: build/C/man3/aio_fsync.3:103 build/C/man3/aio_read.3:132
#: build/C/man3/aio_return.3:78 build/C/man3/aio_suspend.3:106
#: build/C/man3/aio_write.3:137 build/C/man3/lio_listio.3:206
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/aio_cancel.3:117 build/C/man3/aio_error.3:85
#: build/C/man3/aio_fsync.3:106 build/C/man3/aio_read.3:135
#: build/C/man3/aio_return.3:81 build/C/man3/aio_suspend.3:109
#: build/C/man3/aio_write.3:140 build/C/man3/lio_listio.3:209
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/aio_cancel.3:121 build/C/man3/aio_error.3:89
#: build/C/man3/aio_fsync.3:110 build/C/man3/aio_read.3:139
#: build/C/man3/aio_return.3:85 build/C/man3/aio_suspend.3:113
#: build/C/man3/aio_write.3:144 build/C/man3/lio_listio.3:213
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/aio_cancel.3:121 build/C/man3/aio_error.3:89
#: build/C/man3/aio_fsync.3:110 build/C/man3/aio_read.3:139
#: build/C/man3/aio_return.3:85 build/C/man3/aio_suspend.3:113
#: build/C/man3/aio_write.3:144 build/C/man3/lio_listio.3:213
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/aio_cancel.3:121 build/C/man3/aio_error.3:89
#: build/C/man3/aio_fsync.3:110 build/C/man3/aio_read.3:139
#: build/C/man3/aio_return.3:85 build/C/man3/aio_suspend.3:113
#: build/C/man3/aio_write.3:144 build/C/man3/lio_listio.3:213
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/aio_cancel.3:124
#, fuzzy, no-wrap
#| msgid "B<aio_cancel>(3)"
msgid "B<aio_cancel>()"
msgstr "B<aio_cancel>(3)"

#. type: tbl table
#: build/C/man3/aio_cancel.3:124 build/C/man3/aio_error.3:92
#: build/C/man3/aio_fsync.3:113 build/C/man3/aio_read.3:142
#: build/C/man3/aio_return.3:88 build/C/man3/aio_suspend.3:116
#: build/C/man3/aio_write.3:147 build/C/man3/lio_listio.3:216
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/aio_cancel.3:124 build/C/man3/aio_error.3:92
#: build/C/man3/aio_fsync.3:113 build/C/man3/aio_read.3:142
#: build/C/man3/aio_return.3:88 build/C/man3/aio_suspend.3:116
#: build/C/man3/aio_write.3:147 build/C/man3/lio_listio.3:216
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:131 build/C/man3/aio_error.3:99
#: build/C/man3/aio_read.3:161 build/C/man3/aio_return.3:95
msgid "See B<aio>(7)."
msgstr "B<aio>(7) を参照。"

#. type: Plain text
#: build/C/man3/aio_cancel.3:140
msgid ""
"B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), \n"
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: build/C/man3/aio_error.3:24
#, no-wrap
msgid "AIO_ERROR"
msgstr "AIO_ERROR"

#. type: Plain text
#: build/C/man3/aio_error.3:27
msgid "aio_error - get error status of asynchronous I/O operation"
msgstr "aio_error - 非同期 I/O 操作のエラー状態を取得する"

#. type: Plain text
#: build/C/man3/aio_error.3:31
msgid "B<int aio_error(const struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_error(const struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: build/C/man3/aio_error.3:44
msgid ""
"The B<aio_error>()  function returns the error status for the asynchronous I/"
"O request with control block pointed to by I<aiocbp>.  (See B<aio>(7)  for a "
"description of the I<aiocb> structure.)"
msgstr ""
"B<aio_error>() 関数は I<aiocbp> で指された制御ブロックでの非同期 I/O リクエ"
"ス\n"
"トのエラー状態を返す。(I<aiocb> 構造体の説明は B<aio>(7) を参照)"

#. type: Plain text
#: build/C/man3/aio_error.3:46
msgid "This function returns one of the following:"
msgstr "この関数の返り値は以下のいずれかである。"

#. type: IP
#: build/C/man3/aio_error.3:46 build/C/man3/aio_error.3:50
#: build/C/man3/aio_error.3:53 build/C/man3/aio_error.3:55
#: build/C/man3/aio_suspend.3:42 build/C/man3/aio_suspend.3:46
#: build/C/man3/aio_suspend.3:48
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/aio_error.3:50
msgid "B<EINPROGRESS>, if the request has not been completed yet."
msgstr "B<EINPROGRESS> (リクエストがまだ完了していない場合)"

#. type: Plain text
#: build/C/man3/aio_error.3:53
msgid "B<ECANCELED>, if the request was canceled."
msgstr "B<ECANCELED> (リクエストがキャンセルされた場合)"

#. type: Plain text
#: build/C/man3/aio_error.3:55
msgid "0, if the request completed successfully."
msgstr "0 (リクエストが正常に完了した場合)"

#. type: Plain text
#: build/C/man3/aio_error.3:66
msgid ""
"A positive error number, if the asynchronous I/O operation failed.  This is "
"the same value that would have been stored in the I<errno> variable in the "
"case of a synchronous B<read>(2), B<write>(2), B<fsync>(2), or "
"B<fdatasync>(2)  call."
msgstr ""
"正のエラー番号 (非同期 I/O 命令が失敗した場合)。\n"
"同期の B<read>(2), B<write>(2), B<fsync>(2), B<fdatasync>(2) の呼び出しの場合"
"で\n"
"I<errno> 変数に格納されるのと同じ値になる。"

#. type: Plain text
#: build/C/man3/aio_error.3:74
msgid ""
"I<aiocbp> does not point at a control block for an asynchronous I/O request "
"of which the return status (see B<aio_return>(3))  has not been retrieved "
"yet."
msgstr ""
"I<aiocbp> が、まだ返り値 (return status)  (B<aio_return>(3)  を参照) が取得さ"
"れていない非同期 I/O リクエストの制御ブロックを指していない。"

#. type: Plain text
#: build/C/man3/aio_error.3:78
msgid "B<aio_error>()  is not implemented."
msgstr "B<aio_error>() は実装されていない。"

#. type: Plain text
#: build/C/man3/aio_error.3:82
msgid "The B<aio_error>()  function is available since glibc 2.1."
msgstr "B<aio_error>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/aio_error.3:92
#, fuzzy, no-wrap
#| msgid "B<aio_error>(3)"
msgid "B<aio_error>()"
msgstr "B<aio_error>(3)"

#. type: Plain text
#: build/C/man3/aio_error.3:108
msgid ""
"B<aio_cancel>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: build/C/man3/aio_fsync.3:24
#, no-wrap
msgid "AIO_FSYNC"
msgstr "AIO_FSYNC"

#. type: TH
#: build/C/man3/aio_fsync.3:24 build/C/man3/aio_suspend.3:25
#: build/C/man3/aio_write.3:24
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:27
msgid "aio_fsync - asynchronous file synchronization"
msgstr "aio_fsync - 非同期ファイルを同期させる"

#. type: Plain text
#: build/C/man3/aio_fsync.3:31
msgid "B<int aio_fsync(int >I<op>B<, struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_fsync(int >I<op>B<, struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: build/C/man3/aio_fsync.3:44
msgid ""
"The B<aio_fsync>()  function does a sync on all outstanding asynchronous I/O "
"operations associated with I<aiocbp-E<gt>aio_fildes>.  (See B<aio>(7)  for a "
"description of the I<aiocb> structure.)"
msgstr ""
"B<aio_fsync>() 関数は、 I<aiocbp-E<gt>aio_fildes> で関連付けられているまだ\n"
"完了していない全ての非同期 I/O 操作を同期させる。\n"
"(I<aiocb> 構造体の説明は B<aio>(7) を参照)"

#. type: Plain text
#: build/C/man3/aio_fsync.3:58
msgid ""
"More precisely, if I<op> is B<O_SYNC>, then all currently queued I/O "
"operations shall be completed as if by a call of B<fsync>(2), and if I<op> "
"is B<O_DSYNC>, this call is the asynchronous analog of B<fdatasync>(2)."
msgstr ""
"より正確に言うと、 I<op> が B<O_SYNC> の場合、現在キューに入れられている全"
"て\n"
"の I/O 操作は、 B<fsync>(2) が呼ばれたかのように完了されるだろう。 また\n"
"I<op> が B<O_DSYNC> の場合、この呼び出しは B<fdatasync>(2) の非同期版となる。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:60
msgid "Note that this is a request only; it does not wait for I/O completion."
msgstr ""
"この関数はリクエストを行うだけである点に注意すること。\n"
"I/O の完了の待ち合わせは行わない。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:73
msgid ""
"Apart from I<aio_fildes>, the only field in the structure pointed to by "
"I<aiocbp> that is used by this call is the I<aio_sigevent> field (a "
"I<sigevent> structure, described in B<sigevent>(7)), which indicates the "
"desired type of asynchronous notification at completion.  All other fields "
"are ignored."
msgstr ""
"I<aiocbp> で指される構造体のフィールドのうち、この呼び出しで I<aio_fildes>\n"
"以外に使用されるのは I<aio_sigevent> フィールド (I<sigevent> 構造体、説明は\n"
"B<sigevent>(7) 参照) のみである。このフィールドは、完了時の非同期通知に使用\n"
"したいタイプを示す。 その他のフィールドは無視される。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:79
msgid ""
"On success (the sync request was successfully queued)  this function returns "
"0.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 (同期リクエストをキューに入れるのに成功した場合)、 この関数は 0 "
"を返す。 エラーの場合、-1 が返され、 I<errno> が適切に設定される。"

#. type: TP
#: build/C/man3/aio_fsync.3:80 build/C/man3/aio_read.3:104
#: build/C/man3/aio_suspend.3:88 build/C/man3/aio_write.3:111
#: build/C/man2/io_cancel.2:51 build/C/man2/io_setup.2:46
#: build/C/man2/io_submit.2:211 build/C/man3/lio_listio.3:150
#: build/C/man3/lio_listio.3:153
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man3/aio_fsync.3:83 build/C/man3/aio_read.3:107
#: build/C/man3/aio_write.3:114 build/C/man3/lio_listio.3:153
msgid "Out of resources."
msgstr "リソースが足りない。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:87 build/C/man3/aio_write.3:118
msgid "I<aio_fildes> is not a valid file descriptor open for writing."
msgstr ""
"I<aio_fildes> が書き込みのためにオープンされた有効なファイルディスクリプター"
"ではない。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:95
msgid ""
"Synchronized I/O is not supported for this file, or I<op> is not B<O_SYNC> "
"or B<O_DSYNC>."
msgstr ""
"このファイルでは同期 I/O がサポートされていない。\n"
"または I<op> が B<O_SYNC> でも B<O_DSYNC> でもない。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:99
msgid "B<aio_fsync>()  is not implemented."
msgstr "B<aio_fsync>() は実装されていない。"

#. type: Plain text
#: build/C/man3/aio_fsync.3:103
msgid "The B<aio_fsync>()  function is available since glibc 2.1."
msgstr "The B<aio_fsync>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/aio_fsync.3:113
#, fuzzy, no-wrap
#| msgid "B<aio_fsync>(3)"
msgid "B<aio_fsync>()"
msgstr "B<aio_fsync>(3)"

#. type: Plain text
#: build/C/man3/aio_fsync.3:127
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), "
"B<sigevent>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), "
"B<sigevent>(7)"

#. type: TH
#: build/C/man3/aio_init.3:25
#, no-wrap
msgid "AIO_INIT"
msgstr "AIO_INIT"

#. type: Plain text
#: build/C/man3/aio_init.3:28
msgid "aio_init - asynchronous I/O initialization"
msgstr "aio_init - 非同期 I/O の初期化"

#. type: Plain text
#: build/C/man3/aio_init.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>aio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>aio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/aio_init.3:34
#, no-wrap
msgid "B<void aio_init(const struct aioinit *>I<init>B<);>\n"
msgstr "B<void aio_init(const struct aioinit *>I<init>B<);>\n"

#. type: Plain text
#: build/C/man3/aio_init.3:44
msgid ""
"The GNU-specific B<aio_init>()  function allows the caller to provide tuning "
"hints to the glibc POSIX AIO implementation.  Use of this function is "
"optional, but to be effective, it must be called before employing any other "
"functions in the POSIX AIO API."
msgstr ""
"GNU 固有の B<aio_init>() 関数を使うと、呼び出し側が glibc の POSIX AIO 実装"
"に\n"
"対して調整 (チューニング) のヒントを与えることができる。この関数は使用しな"
"く\n"
"てもよいが、この関数が効果を持つには、POSIX AIO API の他の関数を利用する前"
"に\n"
"呼び出さなければならない。"

#. type: Plain text
#: build/C/man3/aio_init.3:48
msgid ""
"The tuning information is provided in the buffer pointed to by the argument "
"I<init>.  This buffer is a structure of the following form:"
msgstr ""
"チューニングの情報は、引き数 I<init> が指すバッファーで与える。\n"
"このバッファーは以下の形式の構造体である。"

#. type: Plain text
#: build/C/man3/aio_init.3:63
#, no-wrap
msgid ""
"struct aioinit {\n"
"    int aio_threads;    /* Maximum number of threads */\n"
"    int aio_num;        /* Number of expected simultaneous\n"
"                           requests */\n"
"    int aio_locks;      /* Not used */\n"
"    int aio_usedba;     /* Not used */\n"
"    int aio_debug;      /* Not used */\n"
"    int aio_numusers;   /* Not used */\n"
"    int aio_idle_time;  /* Number of seconds before idle thread\n"
"                           terminates (since glibc 2.2) */\n"
"    int aio_reserved;\n"
"};\n"
msgstr ""
"struct aioinit {\n"
"    int aio_threads;    /* Maximum number of threads */\n"
"    int aio_num;        /* Number of expected simultaneous\n"
"                           requests */\n"
"    int aio_locks;      /* Not used */\n"
"    int aio_usedba;     /* Not used */\n"
"    int aio_debug;      /* Not used */\n"
"    int aio_numusers;   /* Not used */\n"
"    int aio_idle_time;  /* Number of seconds before idle thread\n"
"                           terminates (since glibc 2.2) */\n"
"    int aio_reserved;\n"
"};\n"

#. type: Plain text
#: build/C/man3/aio_init.3:69
msgid "The following fields are used in the I<aioinit> structure:"
msgstr "I<aioinit> 構造体のフィールドのうち以下が使用される。"

#. type: TP
#: build/C/man3/aio_init.3:69
#, no-wrap
msgid "I<aio_threads>"
msgstr "I<aio_threads>"

#. type: Plain text
#: build/C/man3/aio_init.3:77
msgid ""
"This field specifies the maximum number of worker threads that may be used "
"by the implementation.  If the number of outstanding I/O operations exceeds "
"this limit, then excess operations will be queued until a worker thread "
"becomes free.  If this field is specified with a value less than 1, the "
"value 1 is used.  The default value is 20."
msgstr ""
"このフィールドは、AIO の実装が使用できるワーカースレッド数の最大値を指定す"
"る。\n"
"完了していない I/O 操作の数がこの上限を超えた場合、超過した操作は\n"
"空いたワーカースレッドができるまでキューに入る。\n"
"このフィールドに 1 未満の値を指定した場合には、値 1 が使用される。\n"
"デフォルト値は 20 である。"

#. type: TP
#: build/C/man3/aio_init.3:77
#, no-wrap
msgid "I<aio_num>"
msgstr "I<aio_num>"

#.  FIXME . But, if aio_num > 32, the behavior looks strange. See
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12083
#. type: Plain text
#: build/C/man3/aio_init.3:86
msgid ""
"This field should specify the maximum number of simultaneous I/O requests "
"that the caller expects to enqueue.  If a value less than 32 is specified "
"for this field, it is rounded up to 32.  The default value is 64."
msgstr ""
"このフィールドは、呼び出し側がキューに入れる予定の\n"
"同時 I/O リクエスト数の最大値を指定する。\n"
"このフィールドに 32 未満の値が指定された場合、値は 32 に切り上げられる。\n"
"デフォルト値は 64 である。"

#. type: TP
#: build/C/man3/aio_init.3:86
#, no-wrap
msgid "I<aio_idle_time>"
msgstr "I<aio_idle_time>"

#. type: Plain text
#: build/C/man3/aio_init.3:92
msgid ""
"This field specifies the amount of time in seconds that a worker thread "
"should wait for further requests before terminating, after having completed "
"a previous request.  The default value is 1."
msgstr ""
"このフィールドは、あるワーカースレッドが、前のリクエストの処理を完了してか"
"ら、\n"
"次のリクエストをどのくらい時間待つかを秒単位で指定する。\n"
"指定した時間を経過しても次のリクエストがなければ、\n"
"そのワーカースレッドは終了される。デフォルト値は 1 秒である。"

#. type: Plain text
#: build/C/man3/aio_init.3:96
msgid "The B<aio_init>()  function is available since glibc 2.1."
msgstr "The B<aio_init>() 関数は glibc 2.1 以降で利用できる。"

#. type: Plain text
#: build/C/man3/aio_init.3:98
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/aio_init.3:100
msgid "B<aio>(7)"
msgstr "B<aio>(7)"

#. type: TH
#: build/C/man3/aio_read.3:24
#, no-wrap
msgid "AIO_READ"
msgstr "AIO_READ"

#. type: Plain text
#: build/C/man3/aio_read.3:27
msgid "aio_read - asynchronous read"
msgstr "aio_read - 非同期で読み込む"

#. type: Plain text
#: build/C/man3/aio_read.3:31
msgid "B<int aio_read(struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_read(struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: build/C/man3/aio_read.3:41
msgid ""
"The B<aio_read>()  function queues the I/O request described by the buffer "
"pointed to by I<aiocbp>.  This function is the asynchronous analog of "
"B<read>(2).  The arguments of the call"
msgstr ""
"B<aio_read>() 関数は、I<aiocbp> が指すバッファーに記載された I/O リクエスト"
"を\n"
"キューに入れる。この関数は B<read>(2) の非同期版である。\n"
"呼び出し"

#. type: Plain text
#: build/C/man3/aio_read.3:43
#, no-wrap
msgid "    read(fd, buf, count)\n"
msgstr "    read(fd, buf, count)\n"

#. type: Plain text
#: build/C/man3/aio_read.3:56 build/C/man3/aio_write.3:56
msgid ""
"correspond (in order) to the fields I<aio_fildes>, I<aio_buf>, and "
"I<aio_nbytes> of the structure pointed to by I<aiocbp>.  (See B<aio>(7)  for "
"a description of the I<aiocb> structure.)"
msgstr ""
"の各引き数は I<aiocb> が指す構造体の I<aio_fildes>, I<aio_buf>, "
"I<aio_nbytes>\n"
"に (この順序で) 対応する (I<aiocb> 構造体の説明は B<aio>(7) を参照)。"

#. type: Plain text
#: build/C/man3/aio_read.3:62
#, fuzzy
#| msgid ""
#| "The data is read starting at the absolute file offset I<aiocbp-"
#| "E<gt>aio_offset>, regardless of the current file offset.  After the call, "
#| "the value of the current file offset is unspecified."
msgid ""
"The data is read starting at the absolute position I<aiocbp-"
"E<gt>aio_offset>, regardless of the file offset.  After the call, the value "
"of the file offset is unspecified."
msgstr ""
"データの読み込みは、カレントのファイルオフセットに関係なく、\n"
"絶対ファイルオフセット I<aiocbp-E<gt>aio_offset> を開始点として行われる。\n"
"呼び出しの後のカレントのファイルオフセットは規定されていない。"

#. type: Plain text
#: build/C/man3/aio_read.3:75
msgid ""
"The \"asynchronous\" means that this call returns as soon as the request has "
"been enqueued; the read may or may not have completed when the call "
"returns.  One tests for completion using B<aio_error>(3).  The return status "
"of a completed I/O operation can be obtained by B<aio_return>(3).  "
"Asynchronous notification of I/O completion can be obtained by setting "
"I<aiocbp-E<gt>aio_sigevent> appropriately; see B<sigevent>(7)  for details."
msgstr ""
"「非同期」とは「リクエストがキューに入れられたら、この呼び出しはすぐに返"
"る」\n"
"ということである。 呼び出しから戻った時に、読み込みは完了しているかも知れない"
"し、\n"
"完了していないかも知れない。 B<aio_error>(3) を使うことで完了したかをテストで"
"きる。\n"
"完了した I/O 操作の返り値は B<aio_return>(3) で取得できる。\n"
"I<aiocbp-E<gt>aio_sigevent> を適切に設定することで、\n"
"I/O 完了の非同期通知は受けることもできる。詳細は B<sigevent>(7) を参照。"

#. type: Plain text
#: build/C/man3/aio_read.3:82 build/C/man3/aio_write.3:89
msgid ""
"If B<_POSIX_PRIORITIZED_IO> is defined, and this file supports it, then the "
"asynchronous operation is submitted at a priority equal to that of the "
"calling process minus I<aiocbp-E<gt>aio_reqprio>."
msgstr ""
"B<_POSIX_PRIORITIZED_IO> が定義されていて、 かつファイルがこれをサポートして"
"いる場合、 非同期操作は呼び出したプロセスの優先度から I<aiocbp-"
"E<gt>aio_reqprio> を引いた優先度で登録 (submit) される。"

#. type: Plain text
#: build/C/man3/aio_read.3:86 build/C/man3/aio_write.3:93
msgid "The field I<aiocbp-E<gt>aio_lio_opcode> is ignored."
msgstr "フィールド I<aiocbp-E<gt>aio_lio_opcode> は無視される。"

#. type: Plain text
#: build/C/man3/aio_read.3:88
msgid "No data is read from a regular file beyond its maximum offset."
msgstr ""
"最大オフセットを超えた通常のファイルからは、何もデータが読み込まれない。"

#. type: Plain text
#: build/C/man3/aio_read.3:103 build/C/man3/aio_write.3:110
msgid ""
"On success, 0 is returned.  On error, the request is not enqueued, -1 is "
"returned, and I<errno> is set appropriately.  If an error is detected only "
"later, it will be reported via B<aio_return>(3)  (returns status -1) and "
"B<aio_error>(3)  (error status\\(emwhatever one would have gotten in "
"I<errno>, such as B<EBADF>)."
msgstr ""
"成功した場合、0 が返される。 エラーの場合、リクエストはキューに入れられず、\n"
"-1 が返されて、 I<errno> が適切に設定される。 エラーは後でのみ検知された場合"
"は、\n"
"エラーは B<aio_return>(3) と B<aio_error>(3) 経由で報告されることになる\n"
"(B<aio_return>(3) は状態 -1 を返し、B<aio_error>(3) でエラー状態\\(em\n"
"I<errno> で取得できる B<EBADF> のようなエラー状態が返される)。"

#. type: Plain text
#: build/C/man3/aio_read.3:111
msgid "I<aio_fildes> is not a valid file descriptor open for reading."
msgstr ""
"I<aio_fildes> は読み込みのためにオープンされた有効なファイルディスクリプター"
"でない。"

#. type: Plain text
#: build/C/man3/aio_read.3:119
msgid ""
"One or more of I<aio_offset>, I<aio_reqprio>, or I<aio_nbytes> are invalid."
msgstr ""
"I<aio_offset>, I<aio_reqprio>, I<aio_nbytes> のうち 1 つ以上が無効である。"

#. type: Plain text
#: build/C/man3/aio_read.3:123
msgid "B<aio_read>()  is not implemented."
msgstr "B<aio_read>() は実装されていない。"

#. type: TP
#: build/C/man3/aio_read.3:123
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: build/C/man3/aio_read.3:128
msgid ""
"The file is a regular file, we start reading before end-of-file and want at "
"least one byte, but the starting position is past the maximum offset for "
"this file."
msgstr ""
"ファイルが通常のファイルであり、 ファイルの終端の前から読み込みを開始して、 "
"少なくとも 1 バイトを読み込もうとした。 しかし開始位置がこのファイルの最大オ"
"フセットを超えていた。"

#. type: Plain text
#: build/C/man3/aio_read.3:132
msgid "The B<aio_read>()  function is available since glibc 2.1."
msgstr "The B<aio_read>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/aio_read.3:142
#, fuzzy, no-wrap
#| msgid "B<aio_read>(3)"
msgid "B<aio_read>()"
msgstr "B<aio_read>(3)"

#.  or the control block of the operation
#. type: Plain text
#: build/C/man3/aio_read.3:154
msgid ""
"It is a good idea to zero out the control block before use.  The control "
"block must not be changed while the read operation is in progress.  The "
"buffer area being read into must not be accessed during the operation or "
"undefined results may occur.  The memory areas involved must remain valid."
msgstr ""
"使用する前に制御ブロックを 0 にしておくのは、よい考えである。 この制御ブロッ"
"クは、読み込み操作が進行している間は変更すべきでない。 読み込まれるバッファー"
"領域は 操作の最中にアクセスすべきではない。 さもないと起こる結果が不定にな"
"る。 これに含まれるメモリー領域は、有効なままにしなければならない。"

#. type: Plain text
#: build/C/man3/aio_read.3:158 build/C/man3/aio_write.3:163
#: build/C/man3/lio_listio.3:233
msgid ""
"Simultaneous I/O operations specifying the same I<aiocb> structure produce "
"undefined results."
msgstr ""
"同じ I<aiocb> 構造体を指定して同時に複数の I/O 操作を行った場合、\n"
"どのような結果になるかは不定である。"

#. type: Plain text
#: build/C/man3/aio_read.3:170
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: build/C/man3/aio_return.3:24
#, no-wrap
msgid "AIO_RETURN"
msgstr "AIO_RETURN"

#. type: Plain text
#: build/C/man3/aio_return.3:27
msgid "aio_return - get return status of asynchronous I/O operation"
msgstr "aio_return - 非同期 I/O 操作の返り値 (return status) を取得する"

#. type: Plain text
#: build/C/man3/aio_return.3:31
msgid "B<ssize_t aio_return(struct aiocb *>I<aiocbp>B<);>"
msgstr "B<ssize_t aio_return(struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: build/C/man3/aio_return.3:44
msgid ""
"The B<aio_return>()  function returns the final return status for the "
"asynchronous I/O request with control block pointed to by I<aiocbp>.  (See "
"B<aio>(7)  for a description of the I<aiocb> structure.)"
msgstr ""
"B<aio_return>() 関数は I<aiocbp> で指された制御ブロックにおける非同期 I/O\n"
"リクエストの最終的な返り値を返す。\n"
"(I<aiocb> 構造体の説明は B<aio>(7) を参照)"

#. type: Plain text
#: build/C/man3/aio_return.3:49
msgid ""
"This function should be called only once for any given request, after "
"B<aio_error>(3)  returns something other than B<EINPROGRESS>."
msgstr ""
"この関数は、 B<aio_error>(3)  が B<EINPROGRESS> 以外を返した後で、 与えられた"
"リクエストに対して 1 回だけ呼ばれるべきである。"

#. type: Plain text
#: build/C/man3/aio_return.3:59
#, fuzzy
#| msgid ""
#| "If the asynchronous I/O operation has completed, this function returns "
#| "the value that would have been returned in case of a synchronous "
#| "B<read>(2), B<write>(2), B<fsync>(2)  or B<fdatasync>(2), call."
msgid ""
"If the asynchronous I/O operation has completed, this function returns the "
"value that would have been returned in case of a synchronous B<read>(2), "
"B<write>(2), B<fsync>(2)  or B<fdatasync>(2), call.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"非同期 I/O 操作が完了した場合、この関数は、同期呼び出し B<read>(2),\n"
"B<write>(2), B<fsync>(2), B<fdatasync>(2) が返すのと同じ値を返す。"

#. type: Plain text
#: build/C/man3/aio_return.3:64
msgid ""
"If the asynchronous I/O operation has not yet completed, the return value "
"and effect of B<aio_return>()  are undefined."
msgstr ""
"非同期 I/O 操作が完了していない場合、\n"
"B<aio_return>() の返り値とその影響は不定である。"

#. type: Plain text
#: build/C/man3/aio_return.3:70
msgid ""
"I<aiocbp> does not point at a control block for an asynchronous I/O request "
"of which the return status has not been retrieved yet."
msgstr ""
"I<aiocbp> が、返り値がまだ取得されていない非同期 I/O リクエストの 制御ブロッ"
"クを指していない。"

#. type: Plain text
#: build/C/man3/aio_return.3:74
msgid "B<aio_return>()  is not implemented."
msgstr "B<aio_return>() は実装されていない。"

#. type: Plain text
#: build/C/man3/aio_return.3:78
msgid "The B<aio_return>()  function is available since glibc 2.1."
msgstr "The B<aio_return>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/aio_return.3:88
#, fuzzy, no-wrap
#| msgid "B<aio_return>(3)"
msgid "B<aio_return>()"
msgstr "B<aio_return>(3)"

#. type: Plain text
#: build/C/man3/aio_return.3:104
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: build/C/man3/aio_suspend.3:25
#, no-wrap
msgid "AIO_SUSPEND"
msgstr "AIO_SUSPEND"

#. type: Plain text
#: build/C/man3/aio_suspend.3:28
msgid "aio_suspend - wait for asynchronous I/O operation or timeout"
msgstr "aio_suspend - 非同期 I/O 操作またはタイムアウトを待つ"

#. type: Plain text
#: build/C/man3/aio_suspend.3:32 build/C/man3/lio_listio.3:30
#, no-wrap
msgid "B<#include E<lt>aio.hE<gt>>\n"
msgstr "B<#include E<lt>aio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/aio_suspend.3:35
#, fuzzy, no-wrap
#| msgid ""
#| "B<int lio_listio(int >I<mode>B<, struct aiocb *const >I<aiocb_list>B<[],>\n"
#| "B<               int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgid ""
"B<int aio_suspend(const struct aiocb * const >I<aiocb_list>B<[],>\n"
"B<                int >I<nitems>B<, const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int lio_listio(int >I<mode>B<, struct aiocb *const >I<aiocb_list>B<[],>\n"
"B<               int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: build/C/man3/aio_suspend.3:37 build/C/man3/lio_listio.3:35
#, no-wrap
msgid "Link with I<-lrt>.\n"
msgstr "I<-lrt> でリンクする。\n"

#. type: Plain text
#: build/C/man3/aio_suspend.3:42
msgid ""
"The B<aio_suspend>()  function suspends the calling thread until one of the "
"following occurs:"
msgstr ""
"B<aio_suspend>() 関数は、以下のいずれかが発生するまで\n"
"呼び出したスレッドの実行を停止 (suspend) する。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:46
msgid ""
"One or more of the asynchronous I/O requests in the list I<aiocb_list> has "
"completed."
msgstr ""
"I<aiocb_list> リスト内の非同期 I/O リクエストのうち、少なくとも一つが完了し"
"た。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:48
msgid "A signal is delivered."
msgstr "シグナルが配送された。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:55
msgid ""
"I<timeout> is not NULL and the specified time interval has passed.  (For "
"details of the I<timespec> structure, see B<nanosleep>(2).)"
msgstr ""
"I<timeout> が NULL でない場合に、指定した時間が経過した\n"
"(I<timespec> 構造体の詳細は B<nanosleep>(2) を参照)。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:73
msgid ""
"The I<nitems> argument specifies the number of items in I<aiocb_list>.  Each "
"item in the list pointed to by I<aiocb_list> must be either NULL (and then "
"is ignored), or a pointer to a control block on which I/O was initiated "
"using B<aio_read>(3), B<aio_write>(3), or B<lio_listio>(3).  (See B<aio>(7)  "
"for a description of the I<aiocb> structure.)"
msgstr ""
"I<nitems> 引き数は I<aiocb_list> の要素数を指定する。\n"
"I<aiocb_list> が指すリストの各要素は、NULL (これは無視される) か、\n"
"B<aio_read>(3), B<aio_write>(3), B<lio_listio>(3) を使って I/O が開始された\n"
"制御ブロックへのポインターでなければならない。\n"
"(I<aiocb> 構造体の説明は B<aio>(7) を参照)"

#. type: Plain text
#: build/C/man3/aio_suspend.3:79
msgid ""
"If B<CLOCK_MONOTONIC> is supported, this clock is used to measure the "
"timeout interval (see B<clock_gettime>(3))."
msgstr ""
"B<CLOCK_MONOTONIC> がサポートされる場合、 このクロックを使ってタイムアウト"
"の\n"
"間隔が計測される (B<clock_gettime>(3) を参照)。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:87
msgid ""
"If this function returns after completion of one of the I/O requests "
"specified in I<aiocb_list>, 0 is returned.  Otherwise, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"I<aiocb_list> で指定された I/O リクエストの 1 つが完了した後に\n"
"この関数が返った場合は、0 が返される。\n"
"それ以外の場合は、 -1 が返り、 I<errno> にエラーを示す値に設定される。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:92
msgid ""
"The call timed out before any of the indicated operations had completed."
msgstr "指示された操作のどれも完了しないうちに、呼び出しがタイムアウトした。"

#. type: TP
#: build/C/man3/aio_suspend.3:92 build/C/man2/io_getevents.2:77
#: build/C/man3/lio_listio.3:161
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man3/aio_suspend.3:98
msgid ""
"The call was ended by signal (possibly the completion signal of one of the "
"operations we were waiting for); see B<signal>(7)."
msgstr ""
"この呼び出しがシグナルによって終了させられた (このシグナルは、完了を待ってい"
"た\n"
"操作のいずれかの完了シグナルの可能性もある)。B<signal>(7) 参照。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:102
msgid "B<aio_suspend>()  is not implemented."
msgstr "B<aio_suspend>() は実装されていない。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:106
msgid "The B<aio_suspend>()  function is available since glibc 2.1."
msgstr "The B<aio_suspend>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/aio_suspend.3:116
#, fuzzy, no-wrap
#| msgid "B<aio_suspend>(3)"
msgid "B<aio_suspend>()"
msgstr "B<aio_suspend>(3)"

#. type: Plain text
#: build/C/man3/aio_suspend.3:124
msgid ""
"One can achieve polling by using a non-NULL I<timeout> that specifies a zero "
"time interval."
msgstr ""
"時間間隔が 0 であることを指定する NULL ではない I<timeout> を使って、ポーリン"
"グを行うこともできる。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:130
msgid ""
"If one or more of the asynchronous I/O operations specified in I<aiocb_list> "
"has already completed at the time of the call to B<aio_suspend>(), then the "
"call returns immediately."
msgstr ""
"I<aiocb_list> リストで指定した非同期 I/O 操作のうち、\n"
"B<aio_suspend>() を呼び出した時点ですでに完了したものがある場合、\n"
"B<aio_suspend>() はすぐに返る。"

#. type: Plain text
#: build/C/man3/aio_suspend.3:140
msgid ""
"To determine which I/O operations have completed after a successful return "
"from B<aio_suspend>(), use B<aio_error>(3)  to scan the list of I<aiocb> "
"structures pointed to by I<aiocb_list>."
msgstr ""
"B<aio_suspend>() が成功で返った後でどの I/O 操作が完了したかを特定するに"
"は、\n"
"B<aio_error>(3) を使って I<aiocb_list> が指す I<aiocb> 構造体のリストを\n"
"スキャンする。"

#. type: SH
#: build/C/man3/aio_suspend.3:140 build/C/man2/io_getevents.2:126
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=13172
#. type: Plain text
#: build/C/man3/aio_suspend.3:146
msgid ""
"The glibc implementation of B<aio_suspend>()  is not async-signal-safe, in "
"violation of the requirements of POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:156
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), B<time>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), B<time>(7)"

#. type: TH
#: build/C/man3/aio_write.3:24
#, no-wrap
msgid "AIO_WRITE"
msgstr "AIO_WRITE"

#. type: Plain text
#: build/C/man3/aio_write.3:27
msgid "aio_write - asynchronous write"
msgstr "aio_write - 非同期で書き込む"

#. type: Plain text
#: build/C/man3/aio_write.3:31
msgid "B<int aio_write(struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_write(struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: build/C/man3/aio_write.3:41
msgid ""
"The B<aio_write>()  function queues the I/O request described by the buffer "
"pointed to by I<aiocbp>.  This function is the asynchronous analog of "
"B<write>(2).  The arguments of the call"
msgstr ""
"B<aio_write>() 関数は、I<aiocbp> が指すバッファーに記載された I/O リクエスト"
"をキューに入れる。この関数は B<write>(2) の非同期版である。\n"
"呼び出し"

#. type: Plain text
#: build/C/man3/aio_write.3:43
#, no-wrap
msgid "    write(fd, buf, count)\n"
msgstr "    write(fd, buf, count)\n"

#. type: Plain text
#: build/C/man3/aio_write.3:69
#, fuzzy
#| msgid ""
#| "If B<O_APPEND> is not set, the data is written starting at the absolute "
#| "file offset I<aiocbp-E<gt>aio_offset>, regardless of the current file "
#| "offset.  If B<O_APPEND> is set, data is written at the end of the file in "
#| "the same order as B<aio_write>()  calls are made.  After the call, the "
#| "value of the current file offset is unspecified."
msgid ""
"If B<O_APPEND> is not set, the data is written starting at the absolute "
"position I<aiocbp-E<gt>aio_offset>, regardless of the file offset.  If "
"B<O_APPEND> is set, data is written at the end of the file in the same order "
"as B<aio_write>()  calls are made.  After the call, the value of the file "
"offset is unspecified."
msgstr ""
"B<O_APPEND> が設定されない場合、カレントのファイルオフセットに関係なく、 \n"
"データは絶対ファイルオフセット I<aiocbp-E<gt>aio_offset> を開始点として書き込"
"まれる。\n"
"B<O_APPEND> が設定されている場合、データはファイルの末尾に、\n"
"B<aio_write>() の呼び出しが行われたのと同じ順序で書き込まれる。\n"
"この呼び出しの後のカレントのファイルオフセットは規定されていない。"

#. type: Plain text
#: build/C/man3/aio_write.3:82
msgid ""
"The \"asynchronous\" means that this call returns as soon as the request has "
"been enqueued; the write may or may not have completed when the call "
"returns.  One tests for completion using B<aio_error>(3).  The return status "
"of a completed I/O operation can be obtained B<aio_return>(3).  Asynchronous "
"notification of I/O completion can be obtained by setting I<aiocbp-"
"E<gt>aio_sigevent> appropriately; see B<sigevent>(7)  for details."
msgstr ""
"「非同期」とは「リクエストがキューに入れられたら、この呼び出しはすぐに返"
"る」\n"
"ということである。 呼び出しから戻った時に、書き込みは完了しているかも知れない"
"し、\n"
"完了していないかも知れない。 B<aio_error>(3) を使うことで完了したかをテストで"
"きる。\n"
"完了した I/O 操作の返り値は B<aio_return>(3) で取得できる。\n"
"I<aiocbp-E<gt>aio_sigevent> を適切に設定することで、\n"
"I/O 完了の非同期通知は受けることもできる。詳細は B<sigevent>(7) を参照。"

#. type: Plain text
#: build/C/man3/aio_write.3:95
msgid "No data is written to a regular file beyond its maximum offset."
msgstr "最大オフセットを超えた通常のファイルには、何もデータが書き込まれない。"

#. type: TP
#: build/C/man3/aio_write.3:118
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man3/aio_write.3:122
msgid ""
"The file is a regular file, we want to write at least one byte, but the "
"starting position is at or beyond the maximum offset for this file."
msgstr ""
"ファイルは通常のファイルであり、少なくとも 1 バイトを書き込もうとしている。 "
"しかし開始位置が、このファイルの最大オフセットと同じかそれを超えている。"

#. type: Plain text
#: build/C/man3/aio_write.3:129
msgid ""
"One or more of I<aio_offset>, I<aio_reqprio>, I<aio_nbytes> are invalid."
msgstr ""
"I<aio_offset>, I<aio_reqprio>, I<aio_nbytes> のうち 1 つ以上が無効である。"

#. type: Plain text
#: build/C/man3/aio_write.3:133
msgid "B<aio_write>()  is not implemented."
msgstr "B<aio_write>() は実装されていない。"

#. type: Plain text
#: build/C/man3/aio_write.3:137
msgid "The B<aio_write>()  function is available since glibc 2.1."
msgstr "The B<aio_write>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/aio_write.3:147
#, fuzzy, no-wrap
#| msgid "B<aio_write>(3)"
msgid "B<aio_write>()"
msgstr "B<aio_write>(3)"

#.  or the control block of the operation
#. type: Plain text
#: build/C/man3/aio_write.3:159
msgid ""
"It is a good idea to zero out the control block before use.  The control "
"block must not be changed while the write operation is in progress.  The "
"buffer area being written out must not be accessed during the operation or "
"undefined results may occur.  The memory areas involved must remain valid."
msgstr ""
"使用する前に制御ブロックを 0 にしておくのは、よい考えである。 この制御ブロッ"
"クは、読み込み操作が進行している間は変更すべきでない。 読み込まれるバッファー"
"領域は 操作の最中にアクセスすべきではない。 さもないと起こる結果が不定にな"
"る。 これに含まれるメモリー領域は、有効なままにしなければならない。"

#. type: Plain text
#: build/C/man3/aio_write.3:172
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_suspend>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_suspend>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: build/C/man2/io_cancel.2:7
#, no-wrap
msgid "IO_CANCEL"
msgstr "IO_CANCEL"

#. type: TH
#: build/C/man2/io_cancel.2:7 build/C/man2/io_destroy.2:7
#: build/C/man2/io_getevents.2:7 build/C/man2/io_setup.2:7
#: build/C/man2/io_submit.2:8
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:10
msgid "io_cancel - cancel an outstanding asynchronous I/O operation"
msgstr "io_cancel - 未処理の非同期 I/O 操作の取り消し"

#. type: Plain text
#: build/C/man2/io_cancel.2:13 build/C/man2/io_destroy.2:13
#: build/C/man2/io_setup.2:13 build/C/man2/io_submit.2:14
#, no-wrap
msgid "B<#include E<lt>linux/aio_abi.hE<gt>>          /* Defines needed types */\n"
msgstr "B<#include E<lt>linux/aio_abi.hE<gt>>          /* 必要な型の定義 */\n"

#. type: Plain text
#: build/C/man2/io_cancel.2:16
#, no-wrap
msgid ""
"B<int io_cancel(aio_context_t >I<ctx_id>B<, struct iocb *>I<iocb>B<,>\n"
"B<              struct io_event *>I<result>B<);>\n"
msgstr ""
"B<int io_cancel(aio_context_t >I<ctx_id>B<, struct iocb *>I<iocb>B<,>\n"
"B<              struct io_event *>I<result>B<);>\n"

#. type: Plain text
#: build/C/man2/io_cancel.2:20 build/C/man2/io_destroy.2:19
#: build/C/man2/io_getevents.2:22 build/C/man2/io_setup.2:19
#: build/C/man2/io_submit.2:21
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/io_cancel.2:29 build/C/man2/io_destroy.2:28
#: build/C/man2/io_getevents.2:31 build/C/man2/io_submit.2:30
msgid ""
"I<Note>: this page describes the raw Linux system call interface.  The "
"wrapper function provided by I<libaio> uses a different type for the "
"I<ctx_id> argument.  See NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:45
msgid ""
"The B<io_cancel>()  system call attempts to cancel an asynchronous I/O "
"operation previously submitted with B<io_submit>(2).  The I<iocb> argument "
"describes the operation to be canceled and the I<ctx_id> argument is the AIO "
"context to which the operation was submitted.  If the operation is "
"successfully canceled, the event will be copied into the memory pointed to "
"by I<result> without being placed into the completion queue."
msgstr ""
"B<io_cancel>() システムコールは、過去に B<io_submit>(2) を使って登録された非"
"同期 I/O (AIO) 操作の取り消しを行おうとする。 I<iocb> 引き数は取り消したい操"
"作が示し、 I<ctx_id> 引き数は、取り消しを行う操作が登録された AIO コンテキス"
"トである。操作の取り消しに成功すると、対象のイベントは I<result> で指されたメ"
"モリーに コピーされる (このとき、完了キューへの移動は行われない)。"

#. type: Plain text
#: build/C/man2/io_cancel.2:50
msgid ""
"On success, B<io_cancel>()  returns 0.  For the failure return, see NOTES."
msgstr ""
"成功した場合、 B<io_cancel>()  は 0 を返す。 失敗時の返り値については、「注"
"意」の節を参照すること。"

#. type: Plain text
#: build/C/man2/io_cancel.2:54
msgid "The I<iocb> specified was not canceled."
msgstr "指定された I<iocb> の取り消しが行われなかった。"

#. type: TP
#: build/C/man2/io_cancel.2:54 build/C/man2/io_destroy.2:43
#: build/C/man2/io_getevents.2:74 build/C/man2/io_setup.2:53
#: build/C/man2/io_submit.2:217
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/io_cancel.2:57 build/C/man2/io_submit.2:220
msgid "One of the data structures points to invalid data."
msgstr "データ構造の中に無効なデータを指しているものがある。"

#. type: Plain text
#: build/C/man2/io_cancel.2:60 build/C/man2/io_destroy.2:49
msgid "The AIO context specified by I<ctx_id> is invalid."
msgstr "I<ctx_id> で指定された AIO コンテキストが無効である。"

#. type: Plain text
#: build/C/man2/io_cancel.2:64
msgid "B<io_cancel>()  is not implemented on this architecture."
msgstr "B<io_cancel>()  はこのアーキテクチャーでは実装されていない。"

#. type: Plain text
#: build/C/man2/io_cancel.2:66 build/C/man2/io_destroy.2:55
#: build/C/man2/io_getevents.2:92 build/C/man2/io_setup.2:70
#: build/C/man2/io_submit.2:245
msgid "The asynchronous I/O system calls first appeared in Linux 2.5."
msgstr "非同期 I/O システムコールは Linux 2.5 で初めて登場した。"

#. type: Plain text
#: build/C/man2/io_cancel.2:70
msgid ""
"B<io_cancel>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""
"B<io_cancel>()  は Linux 固有であり、移植を想定したプログラムで使用すべきでは"
"ない。"

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: build/C/man2/io_cancel.2:79
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_cancel>()  wrapper function provided by I<libaio>."
msgstr ""
"glibc はこのシステムコールのラッパー関数を提供していない。\n"
"B<syscall>(2) を使ってこのシステムコールを起動することができる。\n"
"しかし、たいていは、このシステムコールを呼び出したいのではなく、\n"
" I<libaio> が提供している B<io_cancel> ラッパー関数を呼び出したい\n"
"場合がほとんどであろう。"

#.  But glibc is confused, since <libaio.h> uses 'io_context_t' to declare
#.  the system call.
#. type: Plain text
#: build/C/man2/io_cancel.2:100 build/C/man2/io_destroy.2:89
#: build/C/man2/io_getevents.2:126 build/C/man2/io_submit.2:279
msgid ""
"Note that the I<libaio> wrapper function uses a different type "
"(I<io_context_t>)  for the I<ctx_id> argument.  Note also that the I<libaio> "
"wrapper does not follow the usual C library conventions for indicating "
"errors: on error it returns a negated error number (the negative of one of "
"the values listed in ERRORS).  If the system call is invoked via "
"B<syscall>(2), then the return value follows the usual conventions for "
"indicating an error: -1, with I<errno> set to a (positive) value that "
"indicates the error."
msgstr ""
"I<libaio> のラッパー関数では I<ctx_id> 引き数に別の型\n"
"(I<io_context_t>) が使われることに注意すること。\n"
"また、I<libaio> のラッパー関数は、エラーの通知が通常の C ライブラリの\n"
"慣習にしたがっておらず、エラーの場合には負のエラー番号 (エラーの節に列\n"
"挙されている値の一つを負にしたもの) が返り値となる点にも注意すること。\n"
"B<syscall>(2) 経由でシステムコールを起動すると、返り値は通常のエラー通\n"
"知の慣習に したがってものとなり、エラーの場合には -1 が返り、 I<errno>\n"
"にエラーを示す (正の) 値が設定される。"

#.  .SH AUTHOR
#.  Kent Yoder.
#. type: Plain text
#: build/C/man2/io_cancel.2:108
msgid ""
"B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""
"B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"

#. type: TH
#: build/C/man2/io_destroy.2:7
#, no-wrap
msgid "IO_DESTROY"
msgstr "IO_DESTROY"

#. type: Plain text
#: build/C/man2/io_destroy.2:10
msgid "io_destroy - destroy an asynchronous I/O context"
msgstr "io_destroy - 非同期 I/O コンテキストの消去"

#. type: Plain text
#: build/C/man2/io_destroy.2:15
#, no-wrap
msgid "B<int io_destroy(aio_context_t >I<ctx_id>B<);>\n"
msgstr "B<int io_destroy(aio_context_t >I<ctx_id>B<);>\n"

#. type: Plain text
#: build/C/man2/io_destroy.2:37
msgid ""
"The B<io_destroy>()  system call will attempt to cancel all outstanding "
"asynchronous I/O operations against I<ctx_id>, will block on the completion "
"of all operations that could not be canceled, and will destroy the I<ctx_id>."
msgstr ""
"B<io_destroy>() システムコールは、実行中の I<ctx_id> で指定された非同期 I/O "
"操作をすべて取り消そうとし、取り消せなかったすべての操作が完了するまで停止 "
"(block) し、その後 I<ctx_id> の削除を行う。"

#. type: Plain text
#: build/C/man2/io_destroy.2:42
msgid ""
"On success, B<io_destroy>()  returns 0.  For the failure return, see NOTES."
msgstr ""
"成功した場合、 B<io_destroy>()  は 0 を返す。 失敗時の返り値については、「注"
"意」の節を参照すること。"

#. type: Plain text
#: build/C/man2/io_destroy.2:46
msgid "The context pointed to is invalid."
msgstr "データ構造の中に無効なデータを指しているものがある。"

#. type: Plain text
#: build/C/man2/io_destroy.2:53
msgid "B<io_destroy>()  is not implemented on this architecture."
msgstr "B<io_destroy>()  はこのアーキテクチャーでは実装されていない。"

#. type: Plain text
#: build/C/man2/io_destroy.2:59
msgid ""
"B<io_destroy>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""
"B<io_destroy>()  は Linux 固有であり、移植を想定したプログラムで使用すべきで"
"はない。"

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: build/C/man2/io_destroy.2:68
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_destroy>()  wrapper function provided by I<libaio>."
msgstr ""
"glibc はこのシステムコールのラッパー関数を提供していない。\n"
"B<syscall>(2) を使ってこのシステムコールを起動することができる。\n"
"しかし、たいていは、このシステムコールを呼び出したいのではなく、\n"
" I<libaio> が提供している B<io_destroy> ラッパー関数を呼び出したい\n"
"場合がほとんどであろう。"

#.  .SH AUTHOR
#.  Kent Yoder.
#. type: Plain text
#: build/C/man2/io_destroy.2:97
msgid ""
"B<io_cancel>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""
"B<io_cancel>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"

#. type: TH
#: build/C/man2/io_getevents.2:7
#, no-wrap
msgid "IO_GETEVENTS"
msgstr "IO_GETEVENTS"

#. type: Plain text
#: build/C/man2/io_getevents.2:10
msgid "io_getevents - read asynchronous I/O events from the completion queue"
msgstr "io_getevents - 完了キューから非同期 I/O イベントを読み出す"

#. type: Plain text
#: build/C/man2/io_getevents.2:14
#, no-wrap
msgid ""
"B<#include E<lt>linux/aio_abi.hE<gt>>         /* Defines needed types */\n"
"B<#include E<lt>linux/time.hE<gt>>            /* Defines 'struct timespec' */\n"
msgstr ""
"B<#include E<lt>linux/aio_abi.hE<gt>>         /* 必要な型の定義 */\n"
"B<#include E<lt>linux/time.hE<gt>>            /* 'struct timespec' の定義 */\n"

#. type: Plain text
#: build/C/man2/io_getevents.2:18
#, no-wrap
msgid ""
"B<int io_getevents(aio_context_t >I<ctx_id>B<, long >I<min_nr>B<, long >I<nr>B<,>\n"
"B<                 struct io_event *>I<events>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int io_getevents(aio_context_t >I<ctx_id>B<, long >I<min_nr>B<, long >I<nr>B<,>\n"
"B<                 struct io_event *>I<events>B<, struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/io_getevents.2:38
#, fuzzy
#| msgid ""
#| "The B<io_getevents>()  system call attempts to read at least I<min_nr> "
#| "events and up to I<nr> events from the completion queue of the AIO "
#| "context specified by I<ctx_id>.  The I<timeout> argument specifies the "
#| "amount of time to wait for events, where a NULL timeout waits until at "
#| "least I<min_nr> events have been seen.  Note that I<timeout> is relative."
msgid ""
"The B<io_getevents>()  system call attempts to read at least I<min_nr> "
"events and up to I<nr> events from the completion queue of the AIO context "
"specified by I<ctx_id>."
msgstr ""
"B<io_getevents>() システムコールは、少なくとも I<min_nr> の、最大\n"
"I<nr> 個のイベントを、 I<ctx_id> 引き数で指定された AIO (非同期 I/O) \n"
"コンテキストの 完了キューから読み出そうとする。 I<timeout> はイベント\n"
"読み出しの待ち時間の合計を指定する。 タイムアウトに NULL を指定した場合、\n"
"少なくとも I<min_nr> 個のイベントが 読み出されるまで待つことを意味する。\n"
"注意点を以下にあげる: I<timeout> は相対的な指定である。"

#. type: Plain text
#: build/C/man2/io_getevents.2:41
msgid ""
"The I<timeout> argument specifies the amount of time to wait for events, and "
"is specified as a relative timeout in a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:48
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;      /* seconds */\n"
"    long   tv_nsec;     /* nanoseconds [0 .. 999999999] */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:53
msgid ""
"The specified time will be rounded up to the system clock granularity and is "
"guaranteed not to expire early."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:59
msgid ""
"Specifying I<timeout> as NULL means block indefinitely until at least "
"I<min_nr> events have been obtained."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:71
#, fuzzy
#| msgid ""
#| "On success, B<io_getevents>()  returns the number of events read: 0 if no "
#| "events are available, or less than I<min_nr> if the I<timeout> has "
#| "elapsed.  For the failure return, see NOTES."
msgid ""
"On success, B<io_getevents>()  returns the number of events read.  This may "
"be 0, or a value less than I<min_nr>, if the I<timeout> expired.  It may "
"also be a nonzero value less than I<min_nr>, if the call was interrupted by "
"a signal handler."
msgstr ""
"成功すると、 B<io_getevents>()  は読み出したイベント数を返す。 イベントが一つ"
"も読み出されなかった場合は 0 が返され、 I<timeout> 時間が経過した場合は "
"I<min_nr> 未満の値が返される。 失敗時の返り値については、「注意」の節を参照す"
"ること。"

#. type: Plain text
#: build/C/man2/io_getevents.2:73
#, fuzzy
#| msgid ""
#| "On success, B<io_setup>()  returns 0.  For the failure return, see NOTES."
msgid "For the failure return, see NOTES."
msgstr ""
"成功した場合、 B<io_setup>()  は 0 を返す。 失敗時の返り値については、「注"
"意」の節を参照すること。"

#. type: Plain text
#: build/C/man2/io_getevents.2:77
msgid "Either I<events> or I<timeout> is an invalid pointer."
msgstr "I<events> または I<timeout> が無効なポインターである。"

#. type: Plain text
#: build/C/man2/io_getevents.2:81
msgid "Interrupted by a signal handler; see B<signal>(7)."
msgstr "シグナルハンドラーにより割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/io_getevents.2:86
msgid ""
"I<ctx_id> is invalid.  I<min_nr> is out of range or I<nr> is out of range."
msgstr ""
"I<ctx_id> が無効である。もしくは、I<min_nr> または I<nr> が 範囲外の値であ"
"る。"

#. type: Plain text
#: build/C/man2/io_getevents.2:90
msgid "B<io_getevents>()  is not implemented on this architecture."
msgstr "B<io_getevents>()  がこのアーキテクチャーでは実装されていない。"

#. type: Plain text
#: build/C/man2/io_getevents.2:96
msgid ""
"B<io_getevents>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""
"B<io_getevents>()  は Linux 固有であり、移植を想定したプログラムで 使用すべき"
"ではない。"

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: build/C/man2/io_getevents.2:105
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_getevents>()  wrapper function provided by I<libaio>."
msgstr ""
"glibc はこのシステムコールのラッパー関数を提供していない。\n"
"B<syscall>(2) を使ってこのシステムコールを起動することができる。\n"
"しかし、たいていは、このシステムコールを呼び出したいのではなく、\n"
" I<libaio> が提供している B<io_getevents> ラッパー関数を呼び出したい\n"
"場合がほとんどであろう。"

#. type: Plain text
#: build/C/man2/io_getevents.2:131
msgid ""
"An invalid I<ctx_id> may cause a segmentation fault instead of generating "
"the error B<EINVAL>."
msgstr ""
"無効な I<ctx_id> を指定した場合、エラー B<EINVAL> が生成されず、セグメンテー"
"ション違反 (segmentation fault) が発生する場合がある。"

#.  .SH AUTHOR
#.  Kent Yoder.
#. type: Plain text
#: build/C/man2/io_getevents.2:140
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7), B<time>(7)"
msgstr ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7), B<time>(7)"

#. type: TH
#: build/C/man2/io_setup.2:7
#, no-wrap
msgid "IO_SETUP"
msgstr "IO_SETUP"

#. type: Plain text
#: build/C/man2/io_setup.2:10
msgid "io_setup - create an asynchronous I/O context"
msgstr "io_setup - 非同期 I/O コンテキストを作成する"

#. type: Plain text
#: build/C/man2/io_setup.2:15
#, fuzzy, no-wrap
#| msgid "B<int io_setup(unsigned >I<nr_events>B<, aio_context_t *>I<ctx_idp>B<);>\n"
msgid "B<long io_setup(unsigned >I<nr_events>B<, aio_context_t *>I<ctx_idp>B<);>\n"
msgstr "B<int io_setup(unsigned >I<nr_events>B<, aio_context_t *>I<ctx_idp>B<);>\n"

#. type: Plain text
#: build/C/man2/io_setup.2:28
msgid ""
"I<Note>: this page describes the raw Linux system call interface.  The "
"wrapper function provided by I<libaio> uses a different type for the "
"I<ctx_idp> argument.  See NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:40
msgid ""
"The B<io_setup>()  system call creates an asynchronous I/O context suitable "
"for concurrently processing I<nr_events> operations.  The I<ctx_idp> "
"argument must not point to an AIO context that already exists, and must be "
"initialized to 0 prior to the call.  On successful creation of the AIO "
"context, I<*ctx_idp> is filled in with the resulting handle."
msgstr ""
"B<io_setup>() システムコールは、 I<nr_events> 個のイベントを\n"
"同時に実行に適した非同期 I/O (AIO) コンテキストの作成を行う。 I<ctx_idp> 引き"
"数\n"
"は、すでに存在する AIO コンテキストを指していてはならず、\n"
"B<io_setup>() の呼び出しの前に 0 に初期化されていなければならない。\n"
"AIO コンテキストの作成に成功すると、 I<*ctx_idp> に作成された AIO \n"
"コンテキストへのポインターがセットされる。"

#. type: Plain text
#: build/C/man2/io_setup.2:45
msgid ""
"On success, B<io_setup>()  returns 0.  For the failure return, see NOTES."
msgstr ""
"成功した場合、 B<io_setup>()  は 0 を返す。 失敗時の返り値については、「注"
"意」の節を参照すること。"

#. type: Plain text
#: build/C/man2/io_setup.2:53
#, fuzzy
#| msgid ""
#| "The specified I<nr_events> exceeds the user's limit of available events, "
#| "as defined in I</proc/sys/fs/aio-max-nr>."
msgid ""
"The specified I<nr_events> exceeds the limit of available events, as defined "
"in I</proc/sys/fs/aio-max-nr> (see B<proc>(5))."
msgstr ""
"指定された I<nr_events> がユーザーが使用できるイベント数の上限を越えている。"
"イベント数の上限は I</proc/sys/fs/aio-max-nr> で定義されている。"

#. type: Plain text
#: build/C/man2/io_setup.2:56
msgid "An invalid pointer is passed for I<ctx_idp>."
msgstr "I<ctx_idp> に無効なポインターが指定されている。"

#. type: Plain text
#: build/C/man2/io_setup.2:61
msgid ""
"I<ctx_idp> is not initialized, or the specified I<nr_events> exceeds "
"internal limits.  I<nr_events> should be greater than 0."
msgstr ""
"I<ctx_idp> が初期化されていないか、指定された I<nr_events> が内部の\n"
"制限値を越えている。また、 I<nr_events> は 0 より大きい値に設定\n"
"すべきである。"

#. type: TP
#: build/C/man2/io_setup.2:61
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/io_setup.2:64
msgid "Insufficient kernel resources are available."
msgstr "必要なカーネルリソースを得られない。"

#. type: Plain text
#: build/C/man2/io_setup.2:68
msgid "B<io_setup>()  is not implemented on this architecture."
msgstr "B<io_setup>()  がこのアーキテクチャーでは実装されていない。"

#. type: Plain text
#: build/C/man2/io_setup.2:74
msgid ""
"B<io_setup>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""
"B<io_setup>()  は Linux 固有であり、移植を想定したプログラムで 使用すべきでは"
"ない。"

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: build/C/man2/io_setup.2:83
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_setup>()  wrapper function provided by I<libaio>."
msgstr ""
"glibc はこのシステムコールのラッパー関数を提供していない。\n"
"B<syscall>(2) を使ってこのシステムコールを起動することができる。\n"
"しかし、たいていは、このシステムコールを呼び出したいのではなく、\n"
" I<libaio> が提供している B<io_setup> ラッパー関数を呼び出したい\n"
"場合がほとんどであろう。"

#.  But glibc is confused, since <libaio.h> uses 'io_context_t' to declare
#.  the system call.
#. type: Plain text
#: build/C/man2/io_setup.2:104
msgid ""
"Note that the I<libaio> wrapper function uses a different type "
"(I<io_context_t\\ *>)  for the I<ctx_idp> argument.  Note also that the "
"I<libaio> wrapper does not follow the usual C library conventions for "
"indicating errors: on error it returns a negated error number (the negative "
"of one of the values listed in ERRORS).  If the system call is invoked via "
"B<syscall>(2), then the return value follows the usual conventions for "
"indicating an error: -1, with I<errno> set to a (positive) value that "
"indicates the error."
msgstr ""
"I<libaio> のラッパー関数では I<ctx_idp> 引き数に別の型\n"
"(I<io_context_t\\ *>) が使われることに注意すること。\n"
"また、I<libaio> のラッパー関数は、エラーの通知が通常の C ライブラリの\n"
"慣習にしたがっておらず、エラーの場合には負のエラー番号 (エラーの節に列\n"
"挙されている値の一つを負にしたもの) が返り値となる点にも注意すること。\n"
"B<syscall>(2) 経由でシステムコールを起動すると、返り値は通常のエラー\n"
"通知の慣習に したがってものとなり、エラーの場合には -1 が返り、 \n"
"I<errno> にエラーを示す (正の) 値が設定される。"

#.  .SH AUTHOR
#.  Kent Yoder.
#. type: Plain text
#: build/C/man2/io_setup.2:112
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_submit>(2), "
"B<aio>(7)"

#. type: TH
#: build/C/man2/io_submit.2:8
#, no-wrap
msgid "IO_SUBMIT"
msgstr "IO_SUBMIT"

#. type: Plain text
#: build/C/man2/io_submit.2:11
msgid "io_submit - submit asynchronous I/O blocks for processing"
msgstr "io_submit - 非同期 I/O ブロックを処理待ちキューに登録する"

#. type: Plain text
#: build/C/man2/io_submit.2:17
#, no-wrap
msgid "B<int io_submit(aio_context_t >I<ctx_id>B<, long >I<nr>B<, struct iocb **>I<iocbpp>B<);>\n"
msgstr "B<int io_submit(aio_context_t >I<ctx_id>B<, long >I<nr>B<, struct iocb **>I<iocbpp>B<);>\n"

#. type: Plain text
#: build/C/man2/io_submit.2:40
msgid ""
"The B<io_submit>()  system call queues I<nr> I/O request blocks for "
"processing in the AIO context I<ctx_id>.  The I<iocbpp> argument should be "
"an array of I<nr> AIO control blocks, which will be submitted to context "
"I<ctx_id>."
msgstr ""
"B<io_submit>() システムコールは、AIO コンテキスト I<ctx_id> に I<nr> 個\n"
"の I/O リクエストを処理待ちとしてキューに追加する。 I<iocbpp> 引き数は、\n"
"AIO コンテキスト I<ctx_id> に登録される I<nr> 個の AIO 制御ブロックの\n"
"配列になっていなければならない。"

#. type: Plain text
#: build/C/man2/io_submit.2:46
msgid ""
"The I<iocb> (I/O control block) structure defined in I<linux/aio_abi.h> "
"defines the parameters that control the I/O operation."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:50
#, fuzzy, no-wrap
#| msgid "#include E<lt>aiocb.hE<gt>\n"
msgid "#include E<lt>linux/aio_abi.hE<gt>\n"
msgstr "#include E<lt>aiocb.hE<gt>\n"

#. type: Plain text
#: build/C/man2/io_submit.2:64
#, no-wrap
msgid ""
"struct iocb {\n"
"    __u64   aio_data;\n"
"    __u32   PADDED(aio_key, aio_rw_flags);\n"
"    __u16   aio_lio_opcode;\n"
"    __s16   aio_reqprio;\n"
"    __u32   aio_fildes;\n"
"    __u64   aio_buf;\n"
"    __u64   aio_nbytes;\n"
"    __s64   aio_offset;\n"
"    __u64   aio_reserved2;\n"
"    __u32   aio_flags;\n"
"    __u32   aio_resfd;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:68
#, fuzzy, no-wrap
#| msgid "I<aio_threads>"
msgid "I<aio_data>"
msgstr "I<aio_threads>"

#. type: Plain text
#: build/C/man2/io_submit.2:76
msgid ""
"This data is copied into the I<data> field of the I<io_event> structure upon "
"I/O completion (see B<io_getevents>(2))."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:76
#, fuzzy, no-wrap
#| msgid "I<aio_buf>"
msgid "I<aio_key>"
msgstr "I<aio_buf>"

#. type: Plain text
#: build/C/man2/io_submit.2:82
msgid ""
"This is an internal field used by the kernel.  Do not modify this field "
"after an B<io_submit>()  call."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:82
#, fuzzy, no-wrap
#| msgid "I<aio_filedes>"
msgid "I<aio_rw_flags>"
msgstr "I<aio_filedes>"

#. type: Plain text
#: build/C/man2/io_submit.2:86
msgid ""
"This defines the R/W flags passed with structure.  The valid values are:"
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:87
#, no-wrap
msgid "B<RWF_APPEND> (since Linux 4.16)"
msgstr ""

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: build/C/man2/io_submit.2:101
msgid ""
"Append data to the end of the file.  See the description of the flag of the "
"same name in B<pwritev2>(2)  as well as the description of B<O_APPEND> in "
"B<open>(2).  The I<aio_offset> field is ignored.  The file offset is not "
"changed."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:101
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.13)"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:111
msgid ""
"Write operation complete according to requirement of synchronized I/O data "
"integrity.  See the description of the flag of the same name in "
"B<pwritev2>(2)  as well the description of B<O_DSYNC> in B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:111
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.13)"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:114
msgid "High priority request, poll if possible"
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:114
#, no-wrap
msgid "B<RWF_NOWAIT> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:128
msgid ""
"Don't wait if the I/O will block for operations such as file block "
"allocations, dirty page flush, mutex locks, or a congested block device "
"inside the kernel.  If any of these conditions are met, the control block is "
"returned immediately with a return value of B<-EAGAIN> in the I<res> field "
"of the I<io_event> structure (see B<io_getevents>(2))."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:128
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.13)"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:138
msgid ""
"Write operation complete according to requirement of synchronized I/O file "
"integrity.  See the description of the flag of the same name in "
"B<pwritev2>(2)  as well the description of B<O_SYNC> in B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:147
msgid ""
"This defines the type of I/O to be performed by the I<iocb> structure.  The "
"valid values are defined by the enum defined in I<linux/aio_abi.h>:"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:160
#, no-wrap
msgid ""
"enum {\n"
"    IOCB_CMD_PREAD = 0,\n"
"    IOCB_CMD_PWRITE = 1,\n"
"    IOCB_CMD_FSYNC = 2,\n"
"    IOCB_CMD_FDSYNC = 3,\n"
"    IOCB_CMD_POLL = 5,\n"
"    IOCB_CMD_NOOP = 6,\n"
"    IOCB_CMD_PREADV = 7,\n"
"    IOCB_CMD_PWRITEV = 8,\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:165
msgid "This defines the requests priority."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:178
#, fuzzy, no-wrap
#| msgid "I<aio_filedes>"
msgid "I<aio_flags>"
msgstr "I<aio_filedes>"

#. type: Plain text
#: build/C/man2/io_submit.2:184
msgid ""
"This is the set of flags associated with the I<iocb> structure.  The valid "
"values are:"
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:185
#, no-wrap
msgid "B<IOCB_FLAG_RESFD>"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:191
msgid ""
"Asynchronous I/O control must signal the file descriptor mentioned in "
"I<aio_resfd> upon completion."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:191
#, no-wrap
msgid "B<IOCB_FLAG_IOPRIO> (since Linux 4.18)"
msgstr ""

#.  commit d9a08a9e616beeccdbd0e7262b7225ffdfa49e92
#. type: Plain text
#: build/C/man2/io_submit.2:200
msgid ""
"Interpret the I<aio_reqprio> field as an B<IOPRIO_VALUE> as defined by "
"I<linux/ioprio.h>."
msgstr ""

#. type: TP
#: build/C/man2/io_submit.2:201
#, fuzzy, no-wrap
#| msgid "I<aio_threads>"
msgid "I<aio_resfd>"
msgstr "I<aio_threads>"

#. type: Plain text
#: build/C/man2/io_submit.2:204
#, fuzzy
#| msgid "aio_error - get error status of asynchronous I/O operation"
msgid ""
"The file descriptor to signal in the event of asynchronous I/O completion."
msgstr "aio_error - 非同期 I/O 操作のエラー状態を取得する"

#. type: Plain text
#: build/C/man2/io_submit.2:210
#, fuzzy
#| msgid ""
#| "On success, B<io_submit>()  returns the number of I<iocb>s submitted "
#| "(which may be 0 if I<nr> is zero).  For the failure return, see NOTES."
msgid ""
"On success, B<io_submit>()  returns the number of I<iocb>s submitted (which "
"may be less than I<nr>, or 0 if I<nr> is zero).  For the failure return, see "
"NOTES."
msgstr ""
"成功すると、 B<io_submit>()  は登録した I<iocb> の個数を返す (I<nr> が 0 の場"
"合は 0 を返す)。 失敗時の返り値については、「注意」の節を参照すること。"

#. type: Plain text
#: build/C/man2/io_submit.2:214
msgid "Insufficient resources are available to queue any I<iocb>s."
msgstr "何個かの I<iocb> をキューに入れるのに必要なリソースが得られない。"

#. type: Plain text
#: build/C/man2/io_submit.2:217
msgid "The file descriptor specified in the first I<iocb> is invalid."
msgstr "先頭の I<iocb> に指定されたファイルディスクリプターが無効である。"

#. type: Plain text
#: build/C/man2/io_submit.2:230
#, fuzzy
#| msgid ""
#| "The AIO context specified by I<ctx_id> is invalid.  I<nr> is less than "
#| "0.  The I<iocb> at I<*iocbpp[0]> is not properly initialized, or the "
#| "operation specified is invalid for the file descriptor in the I<iocb>."
msgid ""
"The AIO context specified by I<ctx_id> is invalid.  I<nr> is less than 0.  "
"The I<iocb> at I<*iocbpp[0]> is not properly initialized, the operation "
"specified is invalid for the file descriptor in the I<iocb>, or the value in "
"the I<aio_reqprio> field is invalid."
msgstr ""
"I<ctx_id> で指定された AIO コンテキストが無効である。 I<nr> が 0 未満で\n"
"ある。 I<*iocbpp[0]> の I<iocb> が適切に初期化されていないか、\n"
"指定された操作がその I<iocb> 中のファイルディスクリプターに対して 無効\n"
"である。"

#. type: Plain text
#: build/C/man2/io_submit.2:234
msgid "B<io_submit>()  is not implemented on this architecture."
msgstr "B<io_submit>()  はこのアーキテクチャーでは実装されていない。"

#. type: TP
#: build/C/man2/io_submit.2:234
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:243
msgid ""
"The I<aio_reqprio> field is set with the class B<IOPRIO_CLASS_RT>, but the "
"submitting context does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:249
msgid ""
"B<io_submit>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""
"B<io_submit>()  は Linux 固有であり、移植を想定したプログラムで 使用すべきで"
"はない。"

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: build/C/man2/io_submit.2:258
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_submit>()  wrapper function provided by I<libaio>."
msgstr ""
"glibc はこのシステムコールのラッパー関数を提供していない。\n"
"B<syscall>(2) を使ってこのシステムコールを起動することができる。\n"
"しかし、たいていは、このシステムコールを呼び出したいのではなく、\n"
" I<libaio> が提供している B<io_submit> ラッパー関数を呼び出したい\n"
"場合がほとんどであろう。"

#.  .SH AUTHOR
#.  Kent Yoder.
#. type: Plain text
#: build/C/man2/io_submit.2:287
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<aio>(7)"
msgstr ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<aio>(7)"

#. type: TH
#: build/C/man3/lio_listio.3:24
#, no-wrap
msgid "LIO_LISTIO"
msgstr "LIO_LISTIO"

#. type: TH
#: build/C/man3/lio_listio.3:24
#, fuzzy, no-wrap
#| msgid "2013-04-10"
msgid "2020-04-11"
msgstr "2013-04-10"

#. type: Plain text
#: build/C/man3/lio_listio.3:27
msgid "lio_listio - initiate a list of I/O requests"
msgstr "lio_listio - リストの I/O リクエストを開始する"

#. type: Plain text
#: build/C/man3/lio_listio.3:33
#, no-wrap
msgid ""
"B<int lio_listio(int >I<mode>B<, struct aiocb *const >I<aiocb_list>B<[],>\n"
"B<               int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""
"B<int lio_listio(int >I<mode>B<, struct aiocb *const >I<aiocb_list>B<[],>\n"
"B<               int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: build/C/man3/lio_listio.3:41
msgid ""
"The B<lio_listio>()  function initiates the list of I/O operations described "
"by the array I<aiocb_list>."
msgstr ""
"B<lio_listio>() 関数は、配列 I<aiocb_list> で指定された I/O 操作の\n"
"リストをそれぞれ開始する。"

#. type: Plain text
#: build/C/man3/lio_listio.3:45
msgid "The I<mode> operation has one of the following values:"
msgstr "I<mode> 引き数には以下のいずれかの値を指定する。"

#. type: TP
#: build/C/man3/lio_listio.3:45
#, no-wrap
msgid "B<LIO_WAIT>"
msgstr "B<LIO_WAIT>"

#. type: Plain text
#: build/C/man3/lio_listio.3:51
msgid ""
"The call blocks until all operations are complete.  The I<sevp> argument is "
"ignored."
msgstr ""
"全ての操作が完了するまで、呼び出しは停止 (block) する。\n"
"I<sevp> 引き数は無視される。"

#. type: TP
#: build/C/man3/lio_listio.3:51
#, no-wrap
msgid "B<LIO_NOWAIT>"
msgstr "B<LIO_NOWAIT>"

#. type: Plain text
#: build/C/man3/lio_listio.3:63
msgid ""
"The I/O operations are queued for processing and the call returns "
"immediately.  When all of the I/O operations complete, asynchronous "
"notification occurs, as specified by the I<sevp> argument; see "
"B<sigevent>(7)  for details.  If I<sevp> is NULL, no asynchronous "
"notification occurs."
msgstr ""
"I/O 操作は処理を行うためのキューに入れられ、呼び出しは直ちに返る。\n"
"全ての I/O 操作が完了すると、 I<sevp> 引き数で指定した非同期通知が\n"
"行われる。詳細は B<sigevent>(7) を参照。I<sevp> が NULL の場合、\n"
"非同期通知は行われない。"

#. type: Plain text
#: build/C/man3/lio_listio.3:77
msgid ""
"The I<aiocb_list> argument is an array of pointers to I<aiocb> structures "
"that describe I/O operations.  These operations are executed in an "
"unspecified order.  The I<nitems> argument specifies the size of the array "
"I<aiocb_list>.  null pointers in I<aiocb_list> are ignored."
msgstr ""
"I<aiocb_list> 引き数は、I/O 操作を指定する I<aiocb> 構造体へのポインター\n"
"の配列である。指定された操作の実行順序は規定されていない。\n"
"I<nitems> 引き数は、配列 I<aiocb_list> の大きさを指定する。\n"
"I<aiocb_list> 内のヌルポインターは無視される。"

#. type: Plain text
#: build/C/man3/lio_listio.3:83
msgid ""
"In each control block in I<aiocb_list>, the I<aio_lio_opcode> field "
"specifies the I/O operation to be initiated, as follows:"
msgstr ""
"I<aiocb_list> の各制御ブロックでは、\n"
"I<aio_lio_opcode> フィールドで開始する I/O 操作を指定する。\n"
"I<aio_lio_opcode> には以下の値が指定できる。"

#. type: TP
#: build/C/man3/lio_listio.3:83
#, no-wrap
msgid "B<LIO_READ>"
msgstr "B<LIO_READ>"

#. type: Plain text
#: build/C/man3/lio_listio.3:89
msgid ""
"Initiate a read operation.  The operation is queued as for a call to "
"B<aio_read>(3)  specifying this control block."
msgstr ""
"読み出し操作を開始する。操作はキューに入れられ、\n"
"この制御ブロックを指定して B<aio_read>(3) の呼び出しが行われる。"

#. type: TP
#: build/C/man3/lio_listio.3:89
#, no-wrap
msgid "B<LIO_WRITE>"
msgstr "B<LIO_WRITE>"

#. type: Plain text
#: build/C/man3/lio_listio.3:95
msgid ""
"Initiate a write operation.  The operation is queued as for a call to "
"B<aio_write>(3)  specifying this control block."
msgstr ""
"書き込み操作を開始する。操作はキューに入れられ、\n"
"この制御ブロックを指定して B<aio_write>(3) の呼び出しが行われる。"

#. type: TP
#: build/C/man3/lio_listio.3:95
#, no-wrap
msgid "B<LIO_NOP>"
msgstr "B<LIO_NOP>"

#. type: Plain text
#: build/C/man3/lio_listio.3:98
msgid "Ignore this control block."
msgstr "この制御ブロックを無視する。"

#. type: Plain text
#: build/C/man3/lio_listio.3:108
msgid ""
"The remaining fields in each control block have the same meanings as for "
"B<aio_read>(3)  and B<aio_write>(3).  The I<aio_sigevent> fields of each "
"control block can be used to specify notifications for the individual I/O "
"operations (see B<sigevent>(7))."
msgstr ""
"各制御ブロックの残りのフィールドは、\n"
"B<aio_read>(3) や B<aio_write>(3) の場合と同じ意味を持つ。\n"
"各制御ブロックの I<aio_sigevent> フィールドは、\n"
"個々の I/O 操作で通知方法を指定するのに使用される\n"
"(B<sigevent>(7) 参照)。"

#. type: Plain text
#: build/C/man3/lio_listio.3:118
msgid ""
"If I<mode> is B<LIO_NOWAIT>, B<lio_listio>()  returns 0 if all I/O "
"operations are successfully queued.  Otherwise, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"I<mode> が B<LIO_NOWAIT> の場合、 B<lio_listio>() は全ての操作が\n"
"正常にキューに入れられた場合に 0 を返す。\n"
"そうでない場合は、-1 が返り、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man3/lio_listio.3:128
msgid ""
"If I<mode> is B<LIO_WAIT>, B<lio_listio>()  returns 0 when all of the I/O "
"operations have completed successfully.  Otherwise, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"I<mode> が B<LIO_WAIT> の場合、 B<lio_listio>() は全ての操作が\n"
"正常に完了した場合に 0 を返す。\n"
"そうでない場合は、-1 が返り、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man3/lio_listio.3:146
msgid ""
"The return status from B<lio_listio>()  provides information only about the "
"call itself, not about the individual I/O operations.  One or more of the I/"
"O operations may fail, but this does not prevent other operations "
"completing.  The status of individual I/O operations in I<aiocb_list> can be "
"determined using B<aio_error>(3).  When an operation has completed, its "
"return status can be obtained using B<aio_return>(3).  Individual I/O "
"operations can fail for the reasons described in B<aio_read>(3)  and "
"B<aio_write>(3)."
msgstr ""
"B<lio_listio>() の返り値から得られる情報は、関数呼び出し自体に関する\n"
"ものだけであり、個々の I/O 操作に関する情報は得られない。\n"
"個々の I/O 操作は失敗することがあるが、これにより他の I/O 操作が完了\n"
"しなくなるといったことはない。 B<aio_error>(3) を使うと、\n"
"I<aiocb_list> の個々の I/O 操作のステータスを知ることができる。\n"
"ある I/O 操作が完了すると、その終了ステータスはB<aio_return>(3) を使う\n"
"ことで取得できる。個々の I/O 操作は B<aio_read>(3) や B<aio_write>(3)\n"
"に書かれている理由で失敗する場合がある。"

#. type: Plain text
#: build/C/man3/lio_listio.3:150
msgid "The B<lio_listio>()  function may fail for the following reasons:"
msgstr "B<lio_listio>() 関数は以下の理由で失敗する。"

#.  Doesn't happen in glibc(?)
#. type: Plain text
#: build/C/man3/lio_listio.3:161
msgid ""
"The number of I/O operations specified by I<nitems> would cause the limit "
"B<AIO_MAX> to be exceeded."
msgstr ""
"I<nitems> で指定された数の I/O 操作を行うと、\n"
"非同期 I/O 操作の数が上限 B<AIO_MAX> を超えてしまう状況であった。"

#. type: Plain text
#: build/C/man3/lio_listio.3:171
#, fuzzy
#| msgid ""
#| "I<mode> was B<LIO_WAIT> and a signal was caught before all I/O operations "
#| "completed.  (This may even be one of the signals used for asynchronous I/"
#| "O completion notification.)"
msgid ""
"I<mode> was B<LIO_WAIT> and a signal was caught before all I/O operations "
"completed; see B<signal>(7).  (This may even be one of the signals used for "
"asynchronous I/O completion notification.)"
msgstr ""
"I<mode> が B<LIO_WAIT> で、全ての I/O 操作が完了する前にシグナルが\n"
"捕捉された (非同期 I/O の完了通知に使用されるシグナルの場合もこれに\n"
"該当する)。"

#.  Doesn't happen in glibc(?)
#. type: Plain text
#: build/C/man3/lio_listio.3:179
msgid "I<mode> is invalid, or I<nitems> exceeds the limit B<AIO_LISTIO_MAX>."
msgstr ""
"I<mode> が不正であるか、\n"
"I<nitems> が上限 B<AIO_LISTIO_MAX> を超えている。"

#. type: TP
#: build/C/man3/lio_listio.3:179
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#.  e.g., ioa_reqprio or aio_lio_opcode was invalid
#. type: Plain text
#: build/C/man3/lio_listio.3:187
msgid ""
"One of more of the operations specified by I<aiocb_list> failed.  The "
"application can check the status of each operation using B<aio_return>(3)."
msgstr ""
"I<aiocb_list> で指定された操作の中に失敗したものがあった。\n"
"アプリケーションは、 B<aio_return>(3) を使用して、\n"
"個々の操作のステータスを確認することができる。"

#. type: Plain text
#: build/C/man3/lio_listio.3:202
msgid ""
"If B<lio_listio>()  fails with the error B<EAGAIN>, B<EINTR>, or B<EIO>, "
"then some of the operations in I<aiocb_list> may have been initiated.  If "
"B<lio_listio>()  fails for any other reason, then none of the I/O operations "
"has been initiated."
msgstr ""
"B<lio_listio> がエラー B<EAGAIN>, B<EINTR>, B<EIO> で失敗した場合、\n"
"I<aiocb_list> で指定した操作のいくつかは開始されていることがある。\n"
"B<lio_listio> が他の理由で失敗した場合には、\n"
"どの I/O 操作も開始されていない。"

#. type: Plain text
#: build/C/man3/lio_listio.3:206
msgid "The B<lio_listio>()  function is available since glibc 2.1."
msgstr "The B<lio_listio>() 関数は glibc 2.1 以降で利用できる。"

#. type: tbl table
#: build/C/man3/lio_listio.3:216
#, fuzzy, no-wrap
#| msgid "B<lio_listio>(3)"
msgid "B<lio_listio>()"
msgstr "B<lio_listio>(3)"

#.  or the control block of the operation
#. type: Plain text
#: build/C/man3/lio_listio.3:229
msgid ""
"It is a good idea to zero out the control blocks before use.  The control "
"blocks must not be changed while the I/O operations are in progress.  The "
"buffer areas being read into or written from must not be accessed during the "
"operations or undefined results may occur.  The memory areas involved must "
"remain valid."
msgstr ""
"使用前に制御ブロックを 0 で埋めるのは良い考えである。\n"
"I/O 操作の実行中は制御ブロックを変更してはならない。データの読み書き先\n"
"のバッファー領域に I/O 操作の実行中にアクセスしてはならない。さもないと、\n"
"どのような結果になるか分からない。また、関係するメモリー領域も有効な状態\n"
"のままにしておかなければならない。"

#. type: Plain text
#: build/C/man3/lio_listio.3:241
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<aio>(7)"

#~ msgid "2014-04-06"
#~ msgstr "2014-04-06"

#~ msgid "#define errMsg(msg)  do { perror(msg); } while (0)\n"
#~ msgstr "#define errMsg(msg)  do { perror(msg); } while (0)\n"

#~ msgid ""
#~ "E<.UR http://www.squid-cache.org\\:/~adrian\\:/Reprint-Pulavarty-OLS2003."
#~ "pdf> E<.UE>"
#~ msgstr ""
#~ "E<.UR http://www.squid-cache.org\\:/~adrian\\:/Reprint-Pulavarty-OLS2003."
#~ "pdf> E<.UE>"

#~ msgid "2012-05-08"
#~ msgstr "2012-05-08"

#~ msgid "2013-07-04"
#~ msgstr "2013-07-04"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid "The B<aio_error>()  function is thread-safe."
#~ msgstr "B<aio_error>() 関数はスレッドセーフである。"

#~ msgid "2012-04-26"
#~ msgstr "2012-04-26"

#~ msgid "The B<aio_return>()  function is thread-safe."
#~ msgstr "The B<aio_return>() 関数はスレッドセーフである。"

#~ msgid "B<int aio_suspend(const struct aiocb * const >I<aiocb_list>B<[],>\n"
#~ msgstr "B<int aio_suspend(const struct aiocb * const >I<aiocb_list>B<[],>\n"

#~ msgid "B<                int >I<nitems>B<, const struct timespec *>I<timeout>B<);>\n"
#~ msgstr "B<                int >I<nitems>B<, const struct timespec *>I<timeout>B<);>\n"

#~ msgid "2013-04-08"
#~ msgstr "2013-04-08"

#~ msgid "2012-07-13"
#~ msgstr "2012-07-13"
