'\" t
.\"
.\" Author: Lasse Collin
.\"
.\" This file has been put into the public domain.
.\" You can do whatever you want with this file.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" translated for 5.2.5, 2022-05-21 ribbon <ribbon@users.osdn.me>
.\"
.TH XZ 1 2020\-02\-01 Tukaani "XZ Utils"
.
.SH 名前
xz, unxz, xzcat, lzma, unlzma, lzcat \- .xz, .lzma ファイルの圧縮、伸長を行います。
.
.SH 書式
\fBxz\fP [\fIoption...\fP] [\fIfile...\fP]
.
.SH コマンドエイリアス
\fBunxz\fP は \fBxz \-\-decompress\fP と同じです。
.br
\fBxzcat\fP は \fBxz \-\-decompress \-\-stdout\fP と同じです。
.br
\fBlzma\fP は \fBxz \-\-format=lzma\fP と同じです。
.br
\fBunlzma\fP は \fBxz \-\-format=lzma \-\-decompress\fP と同じです。
.br
\fBlzcat\fP は \fBxz \-\-format=lzma \-\-decompress \-\-stdout\fP と同じです。
.PP
ファイル圧縮を行うスクリプトを記述する場合は、\fBunxz\fP や \fBxzcat\fP などを用いるのではなく、常に \fBxz\fP コマンドに適切な引数
(\fBxz \-d\fP or \fBxz \-dc\fP) をつけて利用することをお勧めします。
.
.SH 説明
\fBxz\fP は汎用目的のデータ圧縮ツールです。コマンドラインには \fBgzip\fP(1) や \fBbzip2\fP(1)
と同等の文法が用いられています。ネイティブなファイルフォーマットは \fB.xz\fP です。さらに LZMA Utils が利用しているこれまでの
\&\fB.lzma\fP フォーマットや、コンテナーフォーマットヘッダーを持たない、生の (raw) 圧縮ストリームにも対応しています。
.PP
\fBxz\fP は指定されたオペレーションモードに従って、各 \fIfile\fP の圧縮、伸長を行います。\fIfiles\fP が指定されていない、または \fB\-\fP
と指定された場合、\fBxz\fP
は標準入力からデータを読み込んで、処理結果を標準出力へ書き出します。端末上において圧縮データを標準出力に書き出そうとした場合には、\fBxz\fP
は処理停止します (エラーを表示して \fIfile\fP
の処理をスキップします)。同様に端末上において圧縮データを標準入力から読み込もうとした場合も、\fBxz\fP は処理停止します。
.PP
\fB\-\-stdout\fP の指定がなく \fIfiles\fP が \fB\-\fP でない場合は新規のファイル生成となり、そのファイル名は元の \fIfile\fP
から命名されます。
.IP \(bu 3
圧縮時は、目的とするファイルフォーマット (\fB.xz\fP または \fB.lzma\fP)
をサフィックスとして、元のファイル名にこれを加えたファイル名とします。
.IP \(bu 3
伸長時は、サフィックス \fB.xz\fP または \fB.lzma\fP を取り除いて、目的のファイル名とします。\fBxz\fP はサフィックスとして \fB.txz\fP
と \fB.tlz\fP も識別します。この場合はサフィックスを \fB.tar\fP として置き換えます。
.PP
目的とするファイルがすでに存在している場合、エラーが表示されて \fIfile\fP に対する処理はスキップされます。
.PP
出力先が標準出力でなく、以下のいずれかに該当する場合、\fBxz\fP は警告を表示して \fIfile\fP の処理をスキップします。
.IP \(bu 3
\fIfile\fP が通常の (regular)
ファイルではない場合。シンボリックリンクをたどることはありません。したがってその場合は通常のファイルではないものとして扱われます。
.IP \(bu 3
\fIfile\fP が複数のハードリンクを持つ場合。
.IP \(bu 3
\fIfile\fP に setuid、setgid、スティッキービット (sticky bit) セットがある場合。
.IP \(bu 3
オペレーションモードが圧縮として設定されていて、\fIfile\fP のサフィックスが目的とするファイルフォーマットにすでになっていた場合 (\fB.xz\fP
への圧縮時にすでに \fB.xz\fP や \fB.txz\fP であった場合、また \fB.lzma\fP への圧縮時にすでに \fB.lzma\fP や \fB.tlz\fP
であった場合)。
.IP \(bu 3
オペレーションモードが伸長として設定されていて、\fIfile\fP のサフィックスが対応しているファイルフォーマット (\fB.xz\fP, \fB.txz\fP,
\&\fB.lzma\fP, \fB.tlz\fP) でない場合。
.PP
\fIfile\fP に対する圧縮または伸長が正常に処理された後は、元のソース \fIfile\fP
の所有者、グループ、パーミッション、アクセス時刻、更新時刻を、目的とするファイルにコピーします。グループ情報のコピーに失敗した場合は、パーミッションを修正して、元のソース
\fIfile\fP にアクセス権を有していなかったユーザーが、目的のファイルにアクセスできないようにします。現状の \fBxz\fP
では、アクセスコントロールリストや拡張属性のようなメタデータのコピーには対応していません。
.PP
目的とするファイルのクローズ処理が正常終了したら、\fB\-\-keep\fP が指定されていない限り、ソース \fIfile\fP は削除されます。このソース
\fIfile\fP は、出力先が標準出力である場合には削除されません。
.PP
\fBxz\fP に対して \fBSIGINFO\fP や \fBSIGUSR1\fP
を送信すると、標準エラー出力に対して進捗情報を出力します。この用途は限られています。なぜなら標準エラー出力先が端末である場合、\fB\-\-verbose\fP
を利用すれば進捗インジケーターが自動的に更新されるためです。
.
.SS メモリ利用
\fBxz\fP が利用するメモリ量は、圧縮の設定により数 100
キロバイトから数ギガバイトまでとさまざまです。ファイル圧縮時に利用される設定は、ファイル伸長時のメモリ利用を決定づけます。通常、伸長処理に要するメモリ容量は、圧縮処理においてファイル生成に必要となるメモリ容量の
5\ % から 20\ % です。たとえば \fBxz \-9\fP によって圧縮されたファイルを伸長するには、今のところ 65\ MiB
のメモリを要します。ただし \fB.xz\fP ファイルの伸長に数ギガバイトを利用することも可能です。
.PP
特にかつてのシステムを利用してきたユーザーは、あまりにもメモリが大量に消費されるので、好ましく思わないかもしれません。そのような状況を回避するために
\fBxz\fP
にはビルトインのメモリ制限機能があります。これはデフォルトでは無効化されています。オペレーティングシステムの中には、プロセスのメモリ利用を制限する方法を提供するものがありますが、そこに依存するのは、柔軟性に欠けると考えられてきました
(たとえば \fBulimit\fP(1) を利用して仮想メモリを制限すると、\fBmmap\fP(2) が機能しなくなる傾向にあるなどです)。
.PP
メモリ制限機能を有効にするには、コマンドラインオプション \fB\-\-memlimit=\fP\fIlimit\fP を指定します。この制限機能は、環境変数
\fBXZ_DEFAULTS\fP を用いて \& \fBXZ_DEFAULTS=\-\-memlimit=150MiB\fP
のようにしてデフォルトで有効にしておくと、利用しやすくなります。この制限機能は、圧縮時と伸長時のそれぞれに対して
\fB\-\-memlimit\-compress=\fP\fIlimit\fP および \fB\-\-memlimit\-decompress=\fP\fIlimit\fP
を使えば、個別に指定することができます。この 2 つのオプションを \fBXZ_DEFAULTS\fP
以外のところで用いるのは、あまり意味がありません。なぜなら \fBxz\fP が圧縮と伸長を同時に処理することはありえず、また
\fB\-\-memlimit=\fP\fIlimit\fP (あるいは \fB\-M\fP \fIlimit\fP)
と設定しておくことの方が、コマンドラインから入力するよりも短くて済むからです。
.PP
伸長時に、指定したメモリ利用制限を超過した場合、\fBxz\fP はエラーを表示し伸長処理は失敗します。圧縮時にその制限が超過した場合、\fBxz\fP
はその制限値を引き下げて、制限を超過しないようにします (ただし \fB\-\-format=raw\fP または \fB\-\-no\-adjust\fP
の指定時は除きます)。このような処理方法により、制限値が極端に小さくない限り、処理は失敗しないようになります。設定値を引き下げいく際には、圧縮レベルを示すプリセット値までには至らない範囲で、徐々に引き下げられていきます。たとえばこの設定値が
\fBxz \-9\fP に必要となる容量よりも少しだけ小さかった場合、設定値の引き下げはほんの少しだけ行われるものであって、\fBxz \-8\fP
に必要となる容量まで一気に引き下げられるわけではありません。
.
.SS ".xz ファイルの連結とパディング"
複数の \fB.xz\fP ファイルは、その状態のまま連結 (concatenate) することができます。連結されたファイルを \fBxz\fP
が伸長する際には、あたかも 1 つの \fB.xz\fP ファイルであるかのようにして処理します。
.PP
連結した間の部分や連結の最後に、パディング (padding)
という追加データを挿入することができます。パディングはヌルバイトによって構成されるものであり、そのサイズは 4
バイトの倍数でなければなりません。これが有用となるのは、たとえば 512 バイト単位のブロックごとにファイルサイズを定めるような媒体に \fB.xz\fP
ファイルを保存する場合です。
.PP
連結とパディングは、\fB.lzma\fP ファイルや生の (raw) ストリームにおいて行うことはできません。
.
.SH オプション
.
.SS 整数に対するサフィックスと特別な値
整数引数を必要とする場面の多くにおいては、サフィックスをさらにつけることで多大な数値を簡単に表現できるようにしています。整数値とそのサフィックスの間には空白文字を含めないでください。
.TP 
\fBKiB\fP
1,024 (2^10) の倍数を表現します。\fBKiB\fP と同じ意味を表す \fBKi\fP, \fBk\fP, \fBkB\fP, \fBK\fP, \fBKB\fP
が利用できます。
.TP 
\fBMiB\fP
1,048,576 (2^20) の倍数を表現します。\fBMiB\fP と同じ意味を表す \fBMi\fP, \fBm\fP, \fBM\fP, \fBMB\fP が利用できます。
.TP 
\fBGiB\fP
1,073,741,824 (2^30) の倍数を表現します。\fBGiB\fP と同じ意味を表す \fBGi\fP, \fBg\fP, \fBG\fP, \fBGB\fP
が利用できます。
.PP
特別な数値指定 \fBmax\fP が利用できます。これはそのオプションにおいてサポートされている最大整数値を表します。
.
.SS オペレーションモード
オペレーションモードオプションが複数指定された場合は、最後の指定が有効となります。
.TP 
\fB\-z\fP, \fB\-\-compress\fP
圧縮を指示します。これはデフォルトのオペレーションモードです。オペレーションモードオプションが指定されなかった場合、あるいはコマンドラインからの指定において暗にオペレーションモードの指定が含まれていない場合に採用されます
(たとえば \fBunxz\fP には \fB\-\-decompress\fP が暗に含まれています)。
.TP 
\fB\-d\fP, \fB\-\-decompress\fP, \fB\-\-uncompress\fP
伸長を指示します。
.TP 
\fB\-t\fP, \fB\-\-test\fP
圧縮された \fIfiles\fP の整合性をテストします。このオプションは \fB\-\-decompress \-\-stdout\fP
とすることと同じです。ただし伸長されるデータが、標準出力へは書き込まれずに捨てられてしまう場合を除きます。このオプションでは、ファイル生成や削除は発生しません。
.TP 
\fB\-l\fP, \fB\-\-list\fP
圧縮された \fIfiles\fP
に関する情報を一覧表示します。伸長処理が行われるわけではなく、ファイル生成や削除は発生しません。このリストモードでは、標準入力あるいは他のシークできない入力ソースからの圧縮データは読み込むことができません。
.IP ""
このオプションによる一覧出力では、\fIfiles\fP に関する基本的な情報が、1 つにつき 1 行ずつ表示されます。さらに詳しい情報を得るには
\fB\-\-verbose\fP オプションも併用します。それ以上に細かい情報を得るには \fB\-\-verbose\fP を 2
回指定します。ただしこれを行うと処理が遅くなるかもしれません。細かい情報を得るためには、数多くの検索処理が必要となるためです。詳細な情報を出力する際の出力幅は
80 文字を超えます。したがって \& \fBless\ \-S\fP
を利用するなどして出力をパイプすれば、横幅が十分に取れない端末であっても問題なく利用できます。
.IP ""
実際の出力は \fBxz\fP のバージョンやロケール指定により変わります。マシンにとって読み込み可能な出力とするには、\fB\-\-robot \-\-list\fP
を利用してください。
.
.SS "オペレーション修飾子 (operation modifiers)"
.TP 
\fB\-k\fP, \fB\-\-keep\fP
入力ファイルを削除しません。
.TP 
\fB\-f\fP, \fB\-\-force\fP
このオプションには複数の効果があります。
.RS
.IP \(bu 3
目的とするファイルがすでに存在していた場合、そのファイルを削除してから圧縮や伸長を行います。
.IP \(bu 3
入力ファイルが通常ファイルへのシンボリックリンクである場合、ハードリンクを複数持つ場合、setuid, setgid, スティッキービット
(sticky bit) セットを持つ場合であっても、圧縮または伸長を行います。setuid, setgid,
スティッキービットは目的となるファイルにはコピーされません。
.IP \(bu 3
\fB\-\-decompress\fP \fB\-\-stdout\fP が指定された際に \fBxz\fP
がソースファイルの種類を認識できなかった場合は、ソースファイルがそのまま標準出力へコピーされます。これは \fBxzcat\fP \fB\-\-force\fP
を利用した際に、ソースファイルが \fBxz\fP によって圧縮されていないファイルであっても \fBcat\fP(1)
と同じように処理できることになります。将来的に \fBxz\fP
は新たな圧縮ファイルフォーマットをサポートするかもしれないので、単に標準出力へコピーするのではなく、多くのファイルタイプを伸長できるようになるかもしれません。\fB\-\-format=\fP\fIformat\fP
を指定すれば、\fBxz\fP が伸長を行うファイルフォーマットをただ 1 つに限定することができます。
.RE
.TP 
\fB\-c\fP, \fB\-\-stdout\fP, \fB\-\-to\-stdout\fP
圧縮または伸長する際に、出力先をファイルではなく標準出力とします。このオプションには \fB\-\-keep\fP の指定が暗に含まれます。
.TP 
\fB\-\-single\-stream\fP
\&\fB.xz\fP の入力ストリームから最初の 1
つだけを伸長します。そしてそのストリームの続きとして入力データが残っていても、そのことを示さずに無視します。ただし通常は、そういったゴミデータが続いていると
\fBxz\fP はエラーを出力します。
.IP ""
\fBxz\fP では \fB.lzma\fP ファイルや生の (raw)
ストリームからの複数ストリームは伸長処理を行いません。そこでこのオプションを利用しておけば、\fB.lzma\fP
ファイルや生のストリームの次にくるゴミデータを無視できます。
.IP ""
本オプションは、オペレーションモードが \fB\-\-decompress\fP または \fB\-\-test\fP である場合には何も行いません。
.TP 
\fB\-\-no\-sparse\fP
スパース (sparse)
ファイルを生成しないようにします。伸長処理によって通常ファイルを生成する際に、伸長したデータ内にバイナリ値ゼロの並びが長く続く場合、\fBxz\fP
はデフォルトでスパースファイルを生成しようとします。このような処理は、たとえ出力先が標準出力であっても、この標準出力が通常ファイルに結びついていて、かつ所定の条件をいくつか満たすことで安全に処理が進められるのであれば、同様に処理されます。スパースファイルを生成すれば、ディスク容量を節約できます。またディスク
I/O の回数が減るので、伸長処理時間が短縮されます。
.TP 
\fB\-S\fP \fI.suf\fP, \fB\-\-suffix=\fP\fI.suf\fP
圧縮処理においては、目的とするファイルのサフィックスを \fB.xz\fP や \fB.lzma\fP ではなく \fI.suf\fP
とします。標準出力への書き出しではなく、ソースファイルがすでにサフィックス \fI.suf\fP
を持っていた場合は、警告メッセージが表示されて、そのファイルの処理はスキップされます。
.IP ""
伸長処理においては、ファイルのサフィックスを \fB.xz\fP, \fB.txz\fP, \fB.lzma\fP, \fB.tlz\fP に加えて \fI.suf\fP
を扱うようにします。ソースファイルのサフィックスが \fI.suf\fP である場合、このサフィックスを取り除いたものを目的のファイル名とします。
.IP ""
生の (raw) ストリームを圧縮または伸長する場合
(\fB\-\-format=raw\fP)、標準出力に書き込む場合を除き、サフィックスは必ずつけなければなりません。生のストリームに対するデフォルトのサフィックスがないためです。
.TP 
\fB\-\-files\fP[\fB=\fP\fIfile\fP]
処理対象とする \fIfile\fP のファイル名を読み込みます。\fIfile\fP
を省略した場合、ファイル名は標準入力から読み込まれます。ファイル名は改行文字によって終了していなければなりません。ダッシュ (\fB\-\fP)
は通常のファイル名として扱われます。つまり標準入力を意味するものではありません。ファイル名がコマンドライン引数からも指定された場合、\fIfile\fP
からファイル名を読み込む前にその指定が処理されます。
.TP 
\fB\-\-files0\fP[\fB=\fP\fIfile\fP]
これは \fB\-\-files\fP[\fB=\fP\fIfile\fP] と同等です。ただしこれを利用する場合、各ファイル名はヌル文字で区切られていなければなりません。
.
.SS 基本的なファイルフォーマットと圧縮オプション
.TP 
\fB\-F\fP \fIformat\fP, \fB\-\-format=\fP\fIformat\fP
圧縮または伸長を行う際のファイルフォーマットを \fIformat\fP に指定します。
.RS
.TP 
\fBauto\fP
これがデフォルトの設定です。圧縮処理の場合、\fBauto\fP は \fBxz\fP
と同じになります。伸長処理の場合、入力ファイルのフォーマットは自動検出されます。ただし生の (raw) ストリーム (\fB\-\-format=raw\fP
により生成される) は自動検出されません。
.TP 
\fBxz\fP
ファイルフォーマット \fB.xz\fP として圧縮します。また伸長時には \fB.xz\fP ファイルのみを受けつけます。
.TP 
\fBlzma\fP, \fBalone\fP
古いファイルフォーマット \fB.lzma\fP として圧縮します。また伸長時には \fB.lzma\fP ファイルのみを受けつけます。別名 \fBalone\fP は
LZMA Utils との後方互換性のために提供されています。
.TP 
\fBraw\fP
生の (raw) ストリームを (ヘッダーはなしにして)
圧縮または伸長します。これは上級者向けの利用を意図しています。生のストリームをデコードするためには、\fB\-\-format=raw\fP
の指定、および明示的なフィルターチェーン (filter chain) の指定が必要です。フィルターチェーンは通常はコンテナーヘッダー内に保存されます。
.RE
.TP 
\fB\-C\fP \fIcheck\fP, \fB\-\-check=\fP\fIcheck\fP
整合性チェックのタイプを指定します。このチェックは伸長データから計算され、\fB.xz\fP ファイル内に保存されます。本オプションは、\fB.xz\fP
フォーマットへの圧縮時にのみ効果があります。つまり \fB.lzma\fP フォーマットでは、整合性チェック機能はサポートされていません。整合性チェックは
(もしあれば) \fB.xz\fP ファイルの伸長時に検証されます。
.IP ""
サポートされる \fIcheck\fP のタイプは以下です：
.RS
.TP 
\fBnone\fP
整合性チェックを一切計算しません。通常はあまりよくないことです。別の方法によってデータ整合性が検証されるのであれば、このタイプを利用することができます。
.TP 
\fBcrc32\fP
IEEE\-802.3 (Ethernet) による多項式を利用して CRC32 を計算します。
.TP 
\fBcrc64\fP
ECMA\-182 による多項式を用いて CRC64 を計算します。これがデフォルトです。CRC32
に比べると、破損ファイルの検出に若干有利であり、処理速度の違いは気にならない程度であるからです。
.TP 
\fBsha256\fP
SHA\-256 を計算します。CRC32 や CRC64 に比べると、処理速度がやや劣ります。
.RE
.IP ""
\&\fB.xz\fP ヘッダーの整合性を、常に CRC32 によって検証します。これを変更したり無効化することはできません。
.TP 
\fB\-\-ignore\-check\fP
伸長時に圧縮データの整合性チェックを検証しません。\fB.xz\fP ヘッダー内にある CRC32 値は、それでも普通に検証されます。
.IP ""
\fBこのオプションが何を行うのかを理解していない場合は利用しないでください。\fP 本オプションを利用する状況は以下のとおりです：
.RS
.IP \(bu 3
壊れた .xz ファイルからデータ回復を試みる場合。
.IP \(bu 3
伸長処理の速度改善を図る場合。このオプションが効果があるのは、たいていは、 SHA\-256
を利用する場合、または極めて効率よく圧縮されたファイルの場合です。ただしこの目的であっても、外部の別手段を利用してファイル整合性の検証を完全に行う場合を除き、推奨されません。
.RE
.TP 
\fB\-0\fP ... \fB\-9\fP
圧縮プリセットレベル (preset level) を選択します。デフォルトは \fB\-6\fP
です。複数のプリセットレベルが指定された場合、最後に指定されたものが採用されます。カスタムフィルターチェーン (custom filter chain)
がすでに指定されている場合、圧縮プリセットレベルの指定により、そのカスタムフィルターチェーンの指定は解除されます。
.IP ""
プリセットの違いは、\fBgzip\fP(1) や \fBbzip2\fP(1)
にはない重要な意味があります。圧縮処理に対するプリセット指定は、伸長時におけるメモリ容量を決定づけます。したがってより高度なプリセットレベルを用いると、小容量の
RAM しかない旧来のシステムでは、伸長時に相当な負荷がかかるかもしれません。特に \fBgzip\fP(1) や \fBbzip2\fP(1) では \-9
をよく指定しますが、\fBxz\fP では \fB何も考えず常に \-9 を用いるのは得策ではありません\fP。
.RS
.TP 
\fB\-0\fP ... \fB\-3\fP
比較的速いプリセットです。\fB\-0\fP は \fBgzip \-9\fP
よりも圧縮性能がよく、高速に処理されます。より高いプリセット値では、\fBbzip2\fP(1)
と同等またはそれ以上の圧縮率が得られ、より高速に処理されます。ただしこの結果は、圧縮を行うデータタイプに大きく依存します。
.TP 
\fB\-4\fP ... \fB\-6\fP
古いシステムでの利用時でも伸長処理におけるメモリ利用は妥当なもので、圧縮処理も良好に行われます。\fB\-6\fP がデフォルトです。たとえば、たった 16\ MiB RAM しかないシステム上において伸長処理を行うことになっても、これを選んでおけば間違いはなく、配布を問題なく行うことができます。(\fB\-5e\fP
や \fB\-6e\fP を選ぶことも有効かもしれません。\fB\-\-extreme\fP 参照のこと。)
.TP 
\fB\-7 ... \-9\fP
これらは \fB\-6\fP と同様ですが、より高圧縮になるとともに、伸長時はより多くのメモリを必要とします。これが有効になるのは、圧縮ファイルがそれぞれ 8\ MiB, 16\ MiB, 32\ MiB を超える場合です。
.RE
.IP ""
同一のハードウェア上であれば、伸長にかかる処理速度は毎秒、データ圧縮に要したバイト数の倍数にほぼ一致します。言い換えると、通常は圧縮率が高ければ伸長処理は速くなります。ということはつまり、単位時間内に生成される伸長処理の出力データ量は、状況によりさまざまであるということです。
.IP ""
以下の表はプリセットの特徴をまとめたものです。
.RS
.RS
.PP
.TS
tab(;);
c c c c c
n n n n n.
プリセット;DictSize;CompCPU;CompMem;DecMem
\-0;256 KiB;0;3 MiB;1 MiB
\-1;1 MiB;1;9 MiB;2 MiB
\-2;2 MiB;2;17 MiB;3 MiB
\-3;4 MiB;3;32 MiB;5 MiB
\-4;4 MiB;4;48 MiB;5 MiB
\-5;8 MiB;5;94 MiB;9 MiB
\-6;8 MiB;6;94 MiB;9 MiB
\-7;16 MiB;6;186 MiB;17 MiB
\-8;32 MiB;6;370 MiB;33 MiB
\-9;64 MiB;6;674 MiB;65 MiB
.TE
.RE
.RE
.IP ""
各カラムは以下のとおりです。
.RS
.IP \(bu 3
DictSize とは LZMA2 辞書サイズです。辞書を利用すると、伸長するファイルサイズ以上にメモリを消費します。つまり \fB\-7\fP
\&... \fB\-9\fP は、本当に利用する必要がないのであれば、用いるべきでない理由がここにあります。\fB\-6\fP
またはこれ未満において、消費されるメモリ容量は通常は十分に少なく、問題にならない程度です。
.IP \(bu 3
CompCPU とは LZMA2 設定における簡易表現であり、圧縮速度に影響を及ぼすものです。辞書サイズももちろん速度に影響します。したがって
CompCPU が同一である \fB\-6\fP ... \fB\-9\fP
に対しては、プリセット値が高くなるほど、処理速度が低下する傾向にあります。処理が低下するということは、その分、圧縮率が向上する可能性があります。\fB\-\-extreme\fP
を参照してください。
.IP \(bu 3
CompMem はシングルスレッドモードにおいて、圧縮処理時のメモリ消費量を表します。これは \fBxz\fP
バージョンが異なることで変化する場合があります。メモリ消費量は、マルチスレッドモードでの機能によっては、シングルスレッドモードよりも急激に高まる場合があります。
.IP \(bu 3
DecMem
は伸長処理時におけるメモリ消費量を表します。つまり圧縮時の設定が、伸長処理時のメモリ消費量を決定づけるものです。実際に伸長処理におけるメモリ消費量は、LZMA2
辞書サイズより若干大きくなります。ただし上の表に示した値は、きれいな MiB 値になるように切り上げています。
.RE
.TP 
\fB\-e\fP, \fB\-\-extreme\fP
指定されているプリセットレベル (\fB\-0\fP ... \fB\-9\fP) に比較して、より遅い処理方式 (variant)
を用います。これにより少しでも高圧縮率が得られるようにします。ただし場合によっては、期待に沿わない結果となることもあります。伸長処理時におけるメモリ利用量には影響しません。ただし圧縮処理時のメモリ利用量は、そのときのレベルが
\fB\-0\fP ... \fB\-3\fP である場合には若干増加します。
.IP ""
辞書サイズを 4\ MiB、8\ MiB とするプリセットが 2 つずつあり、プリセット \fB\-3e\fP と \fB\-5e\fP はそれぞれ \fB\-4e\fP と
\fB\-6e\fP に比べて若干高速になる (CompCPU は低くなる) 設定です。このようにして 2 つのプリセットが異なることになります。
.RS
.RS
.PP
.TS
tab(;);
c c c c c
n n n n n.
プリセット;DictSize;CompCPU;CompMem;DecMem
\-0e;256 KiB;8;4 MiB;1 MiB
\-1e;1 MiB;8;13 MiB;2 MiB
\-2e;2 MiB;8;25 MiB;3 MiB
\-3e;4 MiB;7;48 MiB;5 MiB
\-4e;4 MiB;8;48 MiB;5 MiB
\-5e;8 MiB;7;94 MiB;9 MiB
\-6e;8 MiB;8;94 MiB;9 MiB
\-7e;16 MiB;8;186 MiB;17 MiB
\-8e;32 MiB;8;370 MiB;33 MiB
\-9e;64 MiB;8;674 MiB;65 MiB
.TE
.RE
.RE
.IP ""
たとえば 8\ MiB の辞書サイズとなるプリセットは、全部で 4 つあります。これらにおいて処理が高速となる順は \fB\-5\fP, \fB\-6\fP,
\fB\-5e\fP, \fB\-6e\fP です。
.TP 
\fB\-\-fast\fP
.PD 0
.TP 
\fB\-\-best\fP
.PD
これらはそれぞれ \fB\-0\fP と \fB\-9\fP に対するエイリアスですが、やや誤解を招きやすいものです。これは LZMA Utils
との後方互換性のために提供されています。このオプションを利用することは避けてください。
.TP 
\fB\-\-block\-size=\fP\fIsize\fP
\&\fB.xz\fP フォーマットに圧縮する場合に、入力データを \fIsize\fP
バイトごとのブロックに分割します。このブロックは互いに独立して圧縮されます。これはマルチスレッド対応のためであり、限定されたランダムアクセス伸張を可能にします。このオプションによって、通常はマルチスレッドモードでのデフォルトブロックサイズをオーバーライドします。ただしこのオプションは、シングルスレッドモードでも利用することができます。
.IP ""
マルチスレッドモードにおいては、\fIsize\fP バイトのおよそ 3 倍分が、各スレッドの入出力バッファとして割り当てられます。デフォルトの
\fIsize\fP は LZMA2 辞書サイズの 3 倍か、1 MiB のいずれか大きい方になります。通常なら、LZMA2 辞書サイズの 2 ～ 4
倍か、最低 1 MiB が適正な値です。\fIsize\fP に LZMA2 辞書サイズよりも小さな値を用いると、RAM を無駄に消費します。LZMA2
辞書のバッファはすべてが十分に利用されることはないためです。ブロックサイズはブロックヘッダー内に保存されます。これは \fBxz\fP
の将来版において、マルチスレッドでの伸長処理に利用される予定です。
.IP ""
シングルスレッドモードでは、デフォルトではブロック分割処理は行われません。本オプションを設定しても、メモリ利用量には影響しません。サイズ情報はブロックヘッダーに保存されないため、シングルモードにおいて生成されたファイルは、マルチスレッドで生成されたファイルと同一にはならなくなります。サイズ情報を含んでいないということは、つまり
\fBxz\fP の将来版において、マルチスレッドモードにおける伸長処理が不能となる場合があることを意味します。
.TP 
\fB\-\-block\-list=\fP\fIsizes\fP
\&\fB.xz\fP フォーマットに圧縮する場合に、非圧縮データから指定された間隔分をあけて、新たなブロックを開始します。
.IP ""
非圧縮ブロックの \fIsizes\fP は、カンマ区切りリストとして指定します。サイズを省略する (2 つ以上の連続したカンマのみを記述する)
と、それは省略表記として前ブロックのサイズを利用する指定となります。
.IP ""
入力ファイルが \fIsize\fP の合計よりも大きかった場合、\fIsizes\fP
の最後に指定された値を用いて、入力ファイルを繰り返し処理します。特別な設定値として \fB0\fP
を用いると、これが最終の値として用いられ、ファイルの残りのデータを単一のブロックとしてエンコード処理を行うことを指示します。
.IP ""
\fIsizes\fP に設定した値が、エンコード処理するブロックサイズ (スレッドモードにおけるデフォルト値、あるいは
\fB\-\-block\-size=\fP\fIsize\fP に指定された値) を超える場合、\fIsizes\fP
に指定されたブロック範囲を超えたところで追加のブロックを生成します。たとえば\fB\-\-block\-size=10MiB\fP
\fB\-\-block\-list=5MiB,10MiB,8MiB,12MiB,24MiB\fP と指定し、入力ファイルが 80 MiB であった場合、合計で
11 ブロック、つまり順番に 5, 10, 8, 10, 2, 10, 10, 4, 10, 10, 1 MiB のブロックとなります。
.IP ""
マルチスレッドモードの場合、ブロックサイズはブロックヘッダー内に保存されます。これはシングルスレッドモードでは行われません。したがってエンコード処理結果は、マルチスレッドモードによるものとは同一になりません。
.TP 
\fB\-\-flush\-timeout=\fP\fItimeout\fP
圧縮時に、前回のフラッシュ処理から\fItimeout\fPミリ秒(正の整数)以上経過し、それ以上の入力を読み取るとブロックされるような場合、処理中断していた入力データがエンコード処理からフラッシュされて、出力ストリームでの利用が可能になります。こういった処理は、\fBxz\fP
がネットワーク越しにストリームされたデータを圧縮する際に活用されます。\fItimeout\fP
に小さな値を設定しておくと、受信したデータの最終分を利用する際に、わずかな遅延を起こすものとなります。もっともこの \fItimeout\fP
に大きな値を設定しておけば、高圧縮率が得られます。
.IP ""
この機能はデフォルトでは無効化されています。本オプションが複数回指定されると、最後の指定が適用されます。特別な値として \fItimeout\fP に
\fB0\fP を設定すると、本機能を明示的に無効にするものとなります。
.IP ""
本機能は非 POSIX システム上では利用できません。
.IP ""
.\" FIXME
なお \fB本機能はまだ実験段階のものです。\fP 今のところ \fBxz\fP
のバッファリング方法に問題があるため、ストリームをリアルタイムで伸長する処理には適していません。
.TP 
\fB\-\-memlimit\-compress=\fP\fIlimit\fP
圧縮時のメモリ利用制限を設定します。本オプションが複数回指定された場合、最後の指定が適用されます。
.IP ""
圧縮設定が \fIlimit\fP を超えた場合、\fBxz\fP
はその設定を引き下げて、制限を超えないようにします。そして自動調整がなされたことを出力表示します。このような調整処理は、圧縮処理にあたって
\fB\-\-format=raw\fP や \fB\-\-no\-adjust\fP が指定された場合には行われません。この場合 \fBxz\fP
はエラーを表示して、終了ステータス 1 を返して終了します。
.IP ""
\fIlimit\fP を指定する方法はいくつかあります。
.RS
.IP \(bu 3
\fIlimit\fP にバイト数の絶対値を指定します。この際には \fBMiB\fP のような整数サフィックスを利用するのが便利です。たとえば
\fB\-\-memlimit\-compress=80MiB\fP とします。
.IP \(bu 3
\fIlimit\fP に物理メモリ (RAM) の総容量に対するパーセントを指定することができます。環境変数 \fBXZ_DEFAULTS\fP
を用いてさまざまなコンピューター間において、シェル初期化スクリプトを利用するような場合に特に活用することができます。この方法を用いると、よりメモリ容量の多いシステムでは、自動的に制限値が大きくなります。たとえば
\fB\-\-memlimit\-compress=70%\fP とします。
.IP \(bu 3
\fIlimit\fP を \fB0\fP に指定すれば、デフォルト設定に戻すことができます。現時点では \fIlimit\fP に \fBmax\fP (メモリ利用制限なし)
と指定することと同じです。マルチスレッド対応が実装されたら、マルチスレッド処理時の \fB0\fP と \fBmax\fP
の意味が変わるかもしれません。したがって詳細が決定するまでの間は、\fBmax\fP ではなく \fB0\fP を用いておくことをお勧めします。
.RE
.IP ""
32 ビット版 \fBxz\fP には特別なケースがあります。\fIlimit\fP の設定が \fB4020\ MiB\fP を超える場合、\fIlimit\fP は
\fB4020\ MiB\fP に設定されます。(そうなったとしても \fB0\fP と \fBmax\fP
には影響しません。なお伸長処理にこのような機能はありません。) この機能が他に支障を引き起こさない限りは、32 ビット実行モジュールが 4\ GiB
アドレス空間にアクセスするものとして有用です。
.IP ""
\fBメモリ利用\fP のセクションも参照してください。
.TP 
\fB\-\-memlimit\-decompress=\fP\fIlimit\fP
伸長時のメモリ利用制限を設定します。これは \fB\-\-list\fP モードに影響します。\fIlimit\fP を超えなければ処理できなくなった場合、\fBxz\fP
はエラーを表示して伸長処理は失敗します。\fIlimit\fP の設定する別の方法については \fB\-\-memlimit\-compress=\fP\fIlimit\fP
を参照してください。
.TP 
\fB\-M\fP \fIlimit\fP, \fB\-\-memlimit=\fP\fIlimit\fP, \fB\-\-memory=\fP\fIlimit\fP
これは \fB\-\-memlimit\-compress=\fP\fIlimit \fP\fB\-\-memlimit\-decompress=\fP\fIlimit\fP
と指定することと同じです。
.TP 
\fB\-\-no\-adjust\fP
圧縮設定がメモリ利用制限を超えた場合、\fBxz\fP
はエラーを表示して終了します。デフォルトでは、設定内容は引き下げられる方向に調整されます。そのようにしてメモリ利用制限を超えないようにします。この自動調整機能は、生の
(raw) ストリーム生成時 (\fB\-\-format=raw\fP 指定時) は常に無効です。
.TP 
\fB\-T\fP \fIthreads\fP, \fB\-\-threads=\fP\fIthreads\fP
ワーカースレッド数を指定します。\fIthreads\fP に対して特別な値 \fB0\fP を指定すると、\fBxz\fP はシステム上の CPU
コア分のスレッドを利用します。実際のスレッド数は \fIthreads\fP
の指定値より小さくなることがあります。それは入力ファイルのサイズが、指定されたスレッドを必要とするほどには大きくない場合や、スレッドを多く利用しすぎることによってメモリ利用制限を超える場合などです。
.IP ""
現在行われているスレッド処理方法は 1
つだけです。入力データをブロック分けして、互いに独立して圧縮を行うという方法です。デフォルトのブロックサイズは、圧縮レベルに依存します。これは
\fB\-\-block\-size=\fP\fIsize\fP オプションによってオーバーライドすることができます。
.IP ""
伸長処理時のスレッド化はまだ実装されていません。スレッド化に対応しているのは、入力ファイルに複数ブロックが含まれていて、そのサイズ情報がブロックヘッダーに存在しているファイルのみです。マルチスレッドモードにおいて圧縮されたファイルは、この条件をすべて満たします。しかしシングルスレッドモードにおいて圧縮されたファイルでは、\fB\-\-block\-size=\fP\fIsize\fP
を指定していたとしても、この条件を満たしません。
.
.SS カスタム圧縮フィルターチェーン
カスタムフィルターチェーン (custom filter chain)
を用いると、圧縮設定を細かく設定することができ、プリセット値に関連づいた設定に頼る必要がなくなります。カスタムフィルターチェーンが指定されると、コマンドライン上でプリセットオプション
(\fB\-0\fP ... \fB\-9\fP および \fB\-\-extreme\fP)
が初めに指定されていても無視されます。また複数のカスタムフィルター指定の後ろにプリセットオプションが指定された場合は、新たな意味になるプリセット指定が採用されて、それよりも前に指定されていたカスタムフィルターチェーンは無視されます。
.PP
フィルターチェーンというものは、コマンドライン上のパイプ処理と同じように動作します。圧縮時には、伸長されている入力データが 1
つめのフィルターに受け渡されます。そしてその出力は、次のフィルターがあればそこに受け渡されます。最終のフィルターから出力される結果が、圧縮ファイルとして書き出されます。指定できるフィルターチェーンは最大
4 つまでです。通常、フィルターチェーンを利用するのは、せいぜい 1 つか 2 つまでです。
.PP
フィルターの多くは、どこに記述するかという制限があります。たとえばフィルターの中にはチェーン内の最終フィルターとしてしか動作しないものがあります。逆に最終フィルターとしては動作しないものもあります。もちろんどの場所に置いても動作するものも存在します。フィルターにもよりますが、こういった制約はフィルター設計によって発生している場合や、セキュリティ問題を回避するために存在している場合もあります。
.PP
カスタムフィルターチェーンは、フィルターオプションを必要な分だけ、またフィルターチェーンの中で実行させたい順番で指定します。つまりフィルターオプションとして指定する順番が極めて重要です。生の
(raw) ストリーム (\fB\-\-format=raw\fP 指定)
をデコードする際には、それが圧縮された際に指定された順番どおりのフィルターチェーンを指定します。
.PP
フィルターには、フィルター固有の \fIoptions\fP があり、カンマで区切ったリストにより指定します。\fIoptions\fP
に余計なカンマがあると無視されます。すべてのオプションにはデフォルト値が設定されています。したがってオプションは、変更したいもののみ指定するだけで十分です。
.PP
フィルターチェーンと \fIoptions\fP をすべて見るには \fBxz \-vv\fP を入力します (つまり \fB\-\-verbose\fP を 2
回指定します)。これにより、プリセットが利用するフィルターチェーンオプションも参照することができます。
.TP 
\fB\-\-lzma1\fP[\fB=\fP\fIoptions\fP]
.PD 0
.TP 
\fB\-\-lzma2\fP[\fB=\fP\fIoptions\fP]
.PD
フィルター LZMA1 および LZMA2 をフィルターチェーンに追加します。これらのフィルターは、チェーン内の最終フィルターとしてのみ利用できます。
.IP ""
LZMA1 は古いフィルターです。古い \fB.lzma\fP ファイルフォーマットは LZMA1 のみに対応していて、つまりこのフィルターは
\&\fB.lzma\fP 向けだけにサポートされています。LZMA2 は LZMA1 の更新版であり、LZMA1
が抱えている具体的な問題を修正しています。\fB.xz\fP フォーマットは LZMA2 を利用していて、LZMA1
には一切対応していません。圧縮速度および圧縮率は、LZMA1 と LZMA2 において実質変わりません。
.IP ""
LZMA1 と LXMA2 における \fIoptions\fP は共通しています。
.RS
.TP 
\fBpreset=\fP\fIpreset\fP
LZMA1 および LZMA2 の \fIoptions\fP をすべて \fIpreset\fP にリセットします。\fIpreset\fP は整数により構成され、英字
1 文字からなるプリセット修飾子をつける場合があります。整数とは \fB0\fP から \fB9\fP までの値であり、コマンドラインオプション \fB\-0\fP
\&... \fB\-9\fP に対応します。プリセット修飾子とは、今のところ \fBe\fP というもののみがサポートされています。これは \fB\-\-extreme\fP
に対応します。\fBpreset\fP の指定がなかった場合、LZMA1 および LZMA2 の \fIoptions\fP はともにプリセット \fB6\fP
に対応する値がデフォルトして採用されます。
.TP 
\fBdict=\fP\fIsize\fP
辞書の (履歴バッファの) \fIsize\fP
は、直近にメモリ上で処理され保持されている伸長データのバイト量を表します。そのアルゴリズムでは、伸長データの中からバイトシーケンスの繰り返し
(合致するもの)
を探し出そうとします。そしてその時点での辞書内データへの参照に置き換えます。辞書が大きくなれば、それだけ合致する機会は増えることになります。つまり辞書の
\fIsize\fP を増やしておけば、普通は圧縮率が向上します。ただし伸長ファイル以上に辞書サイズが大きいと、メモリを無駄に消費します。
.IP ""
辞書の \fIsize\fP は通常は 64\ KiB から 64\ MiB です。最小でも 4\ KiB です。圧縮用の最大値は、今のところ 1.5\ GiB (1536\ MiB) です。伸長処理においては 4\ GiB 未満、1 バイトまでの辞書がすでにサポートされています。4\ GiB は
LZMA1 および LZMA2 のストリームフォーマットにおける最大値です。
.IP ""
辞書の \fIsize\fP とマッチ検索処理 (match finder; \fImf\fP) はともに、LZMA1 または LZMA2
のエンコード処理におけるメモリ利用量を決定づけます。伸長処理においては、圧縮時に用いられた辞書 \fIsize\fP と同じ (あるいはそれよりも大きい)
サイズが必要になります。つまり伸長処理時のメモリ利用量は、圧縮時に用いられた辞書サイズによって決定します。\fB.xz\fP ヘッダーには辞書の
\fIsize\fP が、2^\fIn\fP または 2^\fIn\fP + 2^(\fIn\fP\-1) のいずれかとして保存されます。したがってこの \fIsizes\fP
はどちらかと言うと、圧縮時に適したものです。これ以外の \fIsizes\fP は \fB.xz\fP ヘッダーに保存される際に切り上げられます。
.TP 
\fBlc=\fP\fIlc\fP
リテラルコンテキスト (literal context) のビット数を指定します。最小値は 0、最大値は 4、デフォルトは 3 です。また \fIlc\fP
と \fIlp\fP を合計した値は 4 を超えてはなりません。
.IP ""
エンコード処理に際して合致しなかったバイトは、すべてリテラルとしてエンコードされます。つまりリテラルとは、1 回に 1 つずつエンコードされる、単純な
8 ビットのバイト列です。
.IP ""
リテラルの処理では、直前に伸長したバイトの上位 \fIlc\fP
ビットは、次のバイトと相関関係にあるという前提としています。たとえば通常の英文の場合、英大文字の次にはたいていは小文字が続きます。そしてその小文字の次は、たいていは別の小文字が続きます。また
US\-ASCII キャラクターセットの場合、大文字の上位 3 ビットは 010 であり、小文字の場合は 011 です。\fIlc\fP が最低 3
として設定されていれば、リテラル処理は伸長データ内のこの特性を利用することができます。
.IP ""
デフォルト値 (3) は通常はうまく動作します。圧縮率を最大にしたい場合は \fBlc=4\fP
を試してみてください。これによって多少はうまくいくことがありますが、場合によっては圧縮率が悪くなることもあります。もし悪くなった場合には \&
\fBlc=2\fP といった指定も試してみてください。
.TP 
\fBlp=\fP\fIlp\fP
リテラルポジション (literal position) のビット数を指定します。最小値は 0、最大値は 4、デフォルトは 0 です。
.IP ""
\fIlp\fP はリテラルをエンコードする際に、伸長データ内においてどのようなバイトの並び (alignment)
を前提にするのかという点に影響します。バイトの並びに関する詳細は、以下の \fIpb\fP を参照してください。
.TP 
\fBpb=\fP\fIpb\fP
ポジションのビット数を指定します。最小値は 0、最大値は 4、デフォルトは 2 です。
.IP ""
\fIpb\fP は全般に、伸長データ内においてどのようなバイトの並び (alignment) を前提にするのかという点に影響します。デフォルト値は 4
バイトの並びを意味します (2^\fIpb\fP=2^2=4)。他に類推する手段がない場合には、これがうまく動作します。
.IP ""
バイトの並び方がわかっている場合、それに応じて \fIpb\fP を設定しておけば、ファイルサイズをやや小さくできる場合があります。たとえば 1
バイト並びのテキストファイル (US\-ASCII, ISO\-8859\-*, UTF\-8) の場合、\fBpb=0\fP
に設定しておくと、圧縮率がやや向上します。UTF\-16 テキストであれば \fBpb=1\fP とするのが最適です。バイトの並びが 3
バイトなどのような奇数である場合、\fBpb=0\fP とするのが最良かもしれません。
.IP ""
前提となったバイトの並びは \fIpb\fP や \fIlp\fP を使って調整ができますが、それでも LZMA1 や LZMA2 は 16
バイトの並びの方がふさわしいものです。したがって LZMA1 や LZMA2
を使って圧縮することが多いファイル形式を設計する場合には、このことに配慮しておく価値があるかもしれません。
.TP 
\fBmf=\fP\fImf\fP
マッチ検索処理 (match finder)
は、エンコード処理速度、メモリ利用量、圧縮率に大きな影響を与えます。通常はバイナリツリーによるマッチ検索処理よりも、ハッシュチェーンによるマッチ検索処理の方が早くなります。デフォルト値は
\fIpreset\fP の値により変わります。0 のときは \fBhc3\fP、1\-3 のときは \fBhc4\fP、それ以外は \fBbt4\fP がデフォルトになります。
.IP ""
マッチ検索処理は以下に示すものがサポートされます。以下に示すメモリ利用計算式 (memory usage formulas)
はかなりの概算であり、\fIdict\fP が 2 のべき乗である場合、実際に最も近くなります。
.RS
.TP 
\fBhc3\fP
2 バイトまたは 3 バイトハッシング (hashing) を用いたハッシュチェーン (hash chain)。
.br
\fInice\fP の最小値は 3 です。
.br
メモリ利用量：
.br
\fIdict\fP * 7.5 (\fIdict\fP <= 16 MiB である場合);
.br
\fIdict\fP * 5.5 + 64 MiB (\fIdict\fP > 16 MiB である場合)
.TP 
\fBhc4\fP
2 バイト、3 バイト、4 バイトハッシングを用いたハッシュチェーン。
.br
\fInice\fP の最小値は 4 です。
.br
メモリ利用量：
.br
\fIdict\fP * 7.5 (\fIdict\fP <= 32 MiB である場合);
.br
\fIdict\fP * 6.5 (\fIdict\fP > 32 MiB である場合)
.TP 
\fBbt2\fP
2 バイトハッシングを用いたバイナリツリー (binary tree)。
.br
\fInice\fP の最小値は 2 です。
.br
メモリ利用量: \fIdict\fP * 9.5
.TP 
\fBbt3\fP
2 バイトと 3 バイトハッシングを用いたバイナリツリー。
.br
\fInice\fP の最小値は 3 です。
.br
メモリ利用量：
.br
\fIdict\fP * 11.5 (\fIdict\fP <= 16 MiB である場合);
.br
\fIdict\fP * 9.5 + 64 MiB (\fIdict\fP > 16 MiB である場合)
.TP 
\fBbt4\fP
2 バイト、3 バイト、4 バイトハッシングを用いたバイナリツリー。
.br
\fInice\fP の最小値は 4 です。
.br
メモリ利用量：
.br
\fIdict\fP * 11.5 (\fIdict\fP <= 32 MiB である場合);
.br
\fIdict\fP * 10.5 (\fIdict\fP > 32 MiB である場合)
.RE
.TP 
\fBmode=\fP\fImode\fP
圧縮の \fImode\fP は、マッチ検索処理によって生成されるデータの分析手法を指定します。サポートされる \fImodes\fP は \fBfast\fP と
\fBnormal\fP です。デフォルトは \fIpresets\fP が 0\-3 のとき \fBfast\fP、\fIpresets\fP が 4\-9 のとき
\fBnormal\fP です。
.IP ""
一般的に \fBfast\fP が用いられるのはハッシュチェーンによるマッチ検索処理の場合であり、\fBnormal\fP
はバイナリツリーによるマッチ検索処理の場合です。これは \fIpresets\fP が用いるものと同じです。
.TP 
\fBnice=\fP\fInice\fP
マッチ処理に対して適切なバイト数と思われる値を指定します。最低 \fInice\fP
バイト分にマッチしたとき、アルゴリズムはそれ以上、マッチする可能性をあきらめて探さないようにします。
.IP ""
\fINice\fP は 2 ～ 273 バイトの範囲とします。値を大きくすれば処理速度は低下しますが、より高い圧縮率が得られる傾向にあります。デフォルト値は
\fIpreset\fP の値によって変わります。
.TP 
\fBdepth=\fP\fIdepth\fP
マッチ検索処理において、検索する最大深さを指定します。デフォルトは特別な値 0 です。この値は、圧縮処理において \fImf\fP と \fInice\fP
の値から妥当な値 \fIdepth\fP が決定されることを意味します。
.IP ""
ハッシュチェーンに対しての妥当な \fIdepth\fP の値は 4 ～ 100 です。バイナリツリーでは 16 ～ 1000 です。\fIdepth\fP
に対して非常に大きな値を設定すると、ファイル内容によってはエンコード処理が極端に遅くなる場合があります。時間が無用に長くなりすぎた際に圧縮を取りやめる段取りが整っていないのであれば、\fIdepth\fP
に 1000 以上の値を設定することは避けてください。
.RE
.IP ""
生の (raw) ストリーム (\fB\-\-format=raw\fP 指定) に対するデコード処理の際には、LZMA2 は辞書サイズ \fIsize\fP
だけが必要です。LZMA1 の場合は \fIlc\fP, \fIlp\fP, \fIpb\fP だけあれば十分です。
.TP 
\fB\-\-x86\fP[\fB=\fP\fIoptions\fP]
.PD 0
.TP 
\fB\-\-powerpc\fP[\fB=\fP\fIoptions\fP]
.TP 
\fB\-\-ia64\fP[\fB=\fP\fIoptions\fP]
.TP 
\fB\-\-arm\fP[\fB=\fP\fIoptions\fP]
.TP 
\fB\-\-armthumb\fP[\fB=\fP\fIoptions\fP]
.TP 
\fB\-\-sparc\fP[\fB=\fP\fIoptions\fP]
.PD
branch/call/jump (BCJ)
フィルターをフィルターチェーンに追加します。このフィルターは、フィルターチェーン内の最終フィルターとして利用することはできません。
.IP ""
BCJ フィルターは、マシンコード内の相対アドレスを絶対アドレスに変換します。これによりデータサイズは変わりません。ただし冗長性は増します。LZMA2
からは 0 ～ 15\ % 小さな \fB.xz\fP ファイルが生成されることになります。BCJ
フィルターはいつでも元に戻すことができます。つまり誤ったデータタイプに対して BCJ
フィルターを用いても、データを失うことはありません。ただし圧縮率がやや低下することがあります。
.IP ""
BCJ フィルターを実行ファイル全体に適用しても、問題はありません。そしてこのフィルターを実行ファイルの実行セクション (executable
section)
にのみ適用する必要はありません。実行モジュールと実行不可ファイルを両方含むアーカイブに対してこのフィルターを適用すると、良い結果が得られる場合もあり、そうでない場合もあります。したがって一般的には、バイナリパッケージを配布向けに圧縮する際にまで、BCJ
フィルターを用いるのは適切ではありません。
.IP ""
この BCJ フィルターは非常に高速であり、目立ったメモリ消費は発生しません。BCJ
フィルターによってファイル圧縮率が向上したとすれば、伸長処理の速度が向上します。なぜなら同一のハードウェア上であれば、伸長にかかる処理速度は毎秒、データ圧縮に要したバイト数の倍数にほぼ一致するからです。
.IP ""
この BCJ フィルターには、圧縮率に関して以下のような問題があります。
.RS
.IP \(bu 3
実行コードを含んだファイル (たとえばオブジェクトファイル、スタティックライブラリ、Linux カーネルモジュールなど)
の中には、命令内のアドレスにフィルター値が埋め込まれることになります。この BCJ
フィルターは、それでもアドレス変換を続行しますが、そういったファイルにおいては圧縮率が悪くなる場合があります。
.IP \(bu 3
似通った実行ファイルが複数含まれるアーカイブに対して BCJ フィルターを適用すると、BCJ
フィルターを使わなかった場合に比べて圧縮率が悪くなります。これは BCJ
フィルターが実行ファイル間の境界を検出しないためであり、各実行ファイルに対してアドレス変換のカウンターをリセットしないことから発生します。
.RE
.IP ""
今後は新たなフィルターを通じて、上記の 2 つの問題は解消される予定です。従来の BCJ
フィルターは、埋め込みシステムにおいては引き続き有用となるはずです。新たなフィルターによるデコード処理は、より大きくなりメモリ消費も増加するはずだからです。
.IP ""
命令セットが異なるとバイトの並びも異なります:
.RS
.RS
.PP
.TS
tab(;);
l n l
l n l.
フィルター;Alignment;説明
x86;1;32 ビット、64 ビット x86
PowerPC;4;ビッグエンディアンのみ
ARM;4;リトルエンディアンのみ
ARM\-Thumb;2;リトルエンディアンのみ
IA\-64;16;ビッグおよびリトルエンディアン
SPARC;4;ビッグおよびリトルエンディアン
.TE
.RE
.RE
.IP ""
BCJ フィルターによって処理したデータは、通常は LZMA2 によって圧縮されるので、利用された BCJ フィルターのバイト並びにマッチするように
LZMA2 オプションが設定されていれば、圧縮率はわずかながら改善されます。たとえば IA\-64 フィルターを用いた場合、LZMA2 に対しては
\fBpb=4\fP (2^4=16) とするのが適切です。x86 フィルターの場合は例外として考えてください。x86
実行ファイルを圧縮する場合には、LZMA2 のデフォルトである 4 バイト並びを必ず用いるようにするのが適切です。
.IP ""
BCJ フィルターはすべて同一の \fIoptions\fP をサポートします。
.RS
.TP 
\fBstart=\fP\fIoffset\fP
相対および絶対アドレス間の変換の際に用いられる、オフセット値 \fIoffset\fP の開始位置を指定します。\fIoffset\fP
はフィルターのバイト並びの倍数でなければなりません (上表参照)。デフォルトはゼロです。現実にはデフォルト値で十分です。つまり \fIoffset\fP
を独自に設定しても、たいていは役に立ちません。
.RE
.TP 
\fB\-\-delta\fP[\fB=\fP\fIoptions\fP]
フィルターチェーンにデルタ (delta)
フィルターを追加します。デルタフィルターは、フィルターチェーン内の最終フィルターとして利用することはできません。
.IP ""
現時点では、単純にバイト単位によるデルタ計算のみがサポートされています。これはたとえばビットマップイメージあるいは PCM
オーディオを圧縮する際に利用できます。ただし特別に用意されたアルゴリズムを使えば Delta + LZMA2
よりも優れた結果が得られるかもしれません。これはオーディオデータに対しては明らかなことで、\fBflac\fP(1)
などを用いれば、圧縮はより速く適切なものになります。
.IP ""
サポートされている \fIoptions\fP：
.RS
.TP 
\fBdist=\fP\fIdistance\fP
デルタ計算の \fIdistance\fP をバイト単位で指定します。\fIdistance\fP は 1 ～ 256 であることが必要です。デフォルトは 1
です。
.IP ""
たとえば \fBdist=2\fP を指定し、入力が 8 バイト A1 B1 A2 B3 A3 B5 A4 B7 であったとすると、出力は A1 B1 01
02 01 02 01 02 となります。
.RE
.
.SS その他のオプション
.TP 
\fB\-q\fP, \fB\-\-quiet\fP
警告メッセージや通知メッセージを省略します。この指定を 2
つ重ねると、エラーメッセージも省略します。本オプションは終了ステータスには影響しません。警告メッセージがたとえ省略されていても変わらないことなので、終了ステータスには警告を示す値が返されます。
.TP 
\fB\-v\fP, \fB\-\-verbose\fP
詳細な出力とします。標準エラー出力が端末に接続されている場合、\fBxz\fP は進捗インジケーターを表示します。\fB\-\-verbose\fP を 2
つ重ねて指定すると、さらに詳細な出力が行われます。
.IP ""
進捗インジケーターには以下の情報が表示されます。
.RS
.IP \(bu 3
入力ファイルのサイズがわかっている場合は、完了率が表示されます。これはパイプ処理の場合には表示されません。
.IP \(bu 3
生成された圧縮データ量 (圧縮時) または消費された圧縮データ量 (伸長時) が表示されます。
.IP \(bu 3
消費された伸長データ量 (圧縮時) または生成された伸長データ量 (伸長時) が表示されます。
.IP \(bu 3
圧縮率が表示されます。これはその時点までに圧縮されたデータ量を、未圧縮のデータ量で割った値として算出されます。
.IP \(bu 3
圧縮または伸長の処理速度が表示されます。これは消費された伸長データ (圧縮時) または生成された伸長データ (伸長時)
の秒ごとの処理量です。処理量の表示は \fBxz\fP がファイル処理を開始した後、しばらくたってから表示されます。
.IP \(bu 3
経過時間を M:SS または H:MM:SS の書式により表示します。
.IP \(bu 3
入力ファイルのサイズがわかっている場合だけ、残り時間の見積もりが表示されます。その場合、\fBxz\fP
がファイル処理を開始してから、数秒が経過した後に表示が始まります。時刻表記は精度を落として、小数点表記を行いません。たとえば 2 min 30 s
とします。
.RE
.IP ""
標準エラー出力先が端末ではない場合、\fB\-\-verbose\fP
によって出力される内容は、ファイル名、圧縮サイズ、伸長サイズ、圧縮率です。また圧縮あるいは伸長が始まると、表示可能であれば処理速度や経過時間を 1
行にまとめて標準エラー出力に書き出します。処理速度や経過時間が表示されるのは、あくまで処理時間が一定秒数以上かかる場合のみです。ユーザーによる処理中断のように処理が完了しなかった場合でも、入力ファイルサイズがわかっていれば、完了率は表示されます。
.TP 
\fB\-Q\fP, \fB\-\-no\-warn\fP
警告に相当する状況が発生したとしても、終了ステータスは 2 に設定しないでください。本オプションは詳細表示のレベルには影響しません。したがって
\fB\-\-quiet\fP と \fB\-\-no\-warn\fP の 2
つは、警告を非表示とするために利用するものであって、終了ステータスを変更する目的で用いてはなりません。
.TP 
\fB\-\-robot\fP
マシン解析が可能な書式でメッセージ出力を行います。これは liblzma でなく \fBxz\fP
を利用したフロントエンドを容易に構築できるように意図したものです。おそらくは、さまざまなスクリプトを用いることを想定しています。本オプションを使って出力した結果は、\fBxz\fP
の将来のリリースに向けて安定して提供していくつもりです。詳しくは \fBロボットモード\fP セクションを参照してください。
.TP 
\fB\-\-info\-memory\fP
読みやすい書式で以下の出力を行います。\fBxz\fP が識別している、システム搭載の物理メモリ (RAM)
量。圧縮および伸長におけるメモリ利用制限。これを表示して正常終了します。
.TP 
\fB\-h\fP, \fB\-\-help\fP
よく利用されるオプションに対するヘルプメッセージを表示して、正常終了します。
.TP 
\fB\-H\fP, \fB\-\-long\-help\fP
\fBxz\fP の全機能を説明するヘルプメッセージを表示して、正常終了します。
.TP 
\fB\-V\fP, \fB\-\-version\fP
\fBxz\fP と liblzma のバージョン番号を読みやすい書式で表示します。マシンが解析しやすい出力とするには、\fB\-\-version\fP の前に
\fB\-\-robot\fP を指定します。
.
.SH ロボットモード
ロボットモードは \fB\-\-robot\fP オプションを指定することで有効になります。これを指定すると、別プログラムが \fBxz\fP
の出力を解析しやすくなります。今のところ \fB\-\-robot\fP は、\fB\-\-version\fP, \fB\-\-info\-memory\fP, \fB\-\-list\fP
をともに指定したときのみ機能するようになっています。将来は圧縮時、伸長時にも対応する予定です。
.
.SS バージョン
\fBxz \-\-robot \-\-version\fP を実行すると、\fBxz\fP と liblzma のバージョンを以下の書式により出力します:
.PP
\fBXZ_VERSION=\fP\fIXYYYZZZS\fP
.br
\fBLIBLZMA_VERSION=\fP\fIXYYYZZZS\fP
.TP 
\fIX\fP
メジャーバージョン。
.TP 
\fIYYY\fP
マイナーバージョン。偶数が安定版を意味します。奇数はアルファ版かベータ版を表します。
.TP 
\fIZZZ\fP
安定版に対するパッチレベル。または単に開発版の割り振り番号。
.TP 
\fIS\fP
安定度合い。0 はアルファ版、1 はベータ版、2 は安定版をそれぞれ表します。\fIYYY\fP が偶数のとき \fIS\fP は必ず 2 となります。
.PP
\fBxz\fP と liblzma が同一 XZ Utils リリースのものである限り、2 行に表示されている \fIXYYYZZZS\fP
の表記は同一になります。
.PP
例： 4.999.9beta は \fB49990091\fP、5.0.0 は \fB50000002\fP と表記されます。
.
.SS メモリ制限に関する情報
\fBxz \-\-robot \-\-info\-memory\fP を指定すると、タブで区切った 3 つの情報を 1 行で出力します：
.IP 1. 4
物理メモリ (RAM) の総容量。バイト単位。
.IP 2. 4
圧縮時のメモリ利用制限。バイト単位。特別な値としてゼロがあります。これはシングルスレッドモードでのデフォルト値であり、無制限を意味します。
.IP 3. 4
伸長時のメモリ利用制限。バイト単位。特別な値としてゼロがあります。これはシングルスレッドモードでのデフォルト値であり、無制限を意味します。
.PP
\fBxz \-\-robot \-\-info\-memory\fP
の出力項目は、今後追加される可能性があります。ただし複数行にわたって出力するような変更は行いません。
.
.SS リストモード
\fBxz \-\-robot \-\-list\fP はタブ区切りによる出力を行います。各行における先頭カラムは、それぞれの行に示される情報の種類を表します。
.TP 
\fBname\fP
ファイルの一覧を示す際にはこれが必ず第 1 行めに置かれます。その行の第 2 カラムにはファイル名が出力されます。
.TP 
\fBfile\fP
この行には \fB.xz\fP ファイルに関する全体的な情報が示されます。この行は必ず \fBname\fP 行の次に表示されます。
.TP 
\fBstream\fP
この行タイプは \fB\-\-verbose\fP が指定された場合にのみ表示されます。\fB.xz\fP ファイル内に存在するストリーム分だけ \fBstream\fP
行が出力されます。
.TP 
\fBblock\fP
この行タイプは \fB\-\-verbose\fP が指定された場合にのみ表示されます。\fB.xz\fP ファイル内に存在するブロック分だけ \fBblock\fP
行が出力されます。\fBblock\fP 行は \fBstream\fP
行の出力がすべて行われた後に出力されます。つまりタイプの異なる両者が混在して出力されることはありません。
.TP 
\fBsummary\fP
この行タイプは \fB\-\-verbose\fP が 2 重に指定された場合にのみ表示されます。この行は \fBblock\fP 行の次に出力されます。\fBfile\fP
行と同様に \fBsummary\fP 行には \fB.xz\fP ファイルに関する全体的な情報が示されます。
.TP 
\fBtotals\fP
本行は必ず出力結果の最終行に位置します。ここには総数、総サイズが示されます。
.PP
\fBfile\fP 行のカラム：
.PD 0
.RS
.IP 2. 4
ファイル内のストリーム数。
.IP 3. 4
ストリーム内のブロック総数。
.IP 4. 4
ファイルの圧縮サイズ。
.IP 5. 4
ファイルの伸長サイズ。
.IP 6. 4
圧縮率。たとえば \fB0.123\fP など。圧縮率が 9.999 を超える場合は、圧縮率は表示せず 3 つのダッシュ (\fB\-\-\-\fP) が表示されます。
.IP 7. 4
整合性チェックの名称をカンマ区切りで指定したリスト。既知の整合性チェック名として、以下の表記が用いられます。\fBNone\fP, \fBCRC32\fP,
\fBCRC64\fP, \fBSHA\-256\fP。未知のチェックタイプには \fBUnknown\-\fP\fIN\fP が用いられます。ここで \fIN\fP は 10 数値
(1 桁または 2 桁) で表されるチェック ID です。
.IP 8. 4
ファイル内ストリームのパディング (padding) データの総量。
.RE
.PD
.PP
\fBstream\fP 行のカラム：
.PD 0
.RS
.IP 2. 4
ストリーム番号 (先頭を 1 とします)。
.IP 3. 4
ストリーム内のブロック数。
.IP 4. 4
圧縮データの開始オフセット。
.IP 5. 4
伸長データの開始オフセット。
.IP 6. 4
圧縮サイズ (ストリームパディングを含みません)。
.IP 7. 4
伸長サイズ。
.IP 8. 4
圧縮率。
.IP 9. 4
整合性チェック名。
.IP 10. 4
ストリームパディングのサイズ。
.RE
.PD
.PP
\fBblock\fP 行のカラム：
.PD 0
.RS
.IP 2. 4
当ブロックに含まれるストリーム数。
.IP 3. 4
ストリーム先頭からの相対的なブロック数 (先頭ブロックを 1 とします)。
.IP 4. 4
ファイル先頭からの相対的なブロック数。
.IP 5. 4
ファイル先頭からの相対的な圧縮開始オフセット。
.IP 6. 4
ファイル先頭からの相対的な伸長開始オフセット。
.IP 7. 4
ブロックの総圧縮サイズ (ヘッダーを含みます)。
.IP 8. 4
伸長サイズ。
.IP 9. 4
圧縮率。
.IP 10. 4
整合性チェック名。
.RE
.PD
.PP
\fB\-\-verbose\fP が 2 重に指定された場合、\fBblock\fP 行にはさらに以下のカラムが出力されます。これは \fB\-\-verbose\fP が 1
つだけ指定された際には表示されません。この情報取得にあたってはさらにシークを必要とするため、その分だけ処理が遅くなります。
.PD 0
.RS
.IP 11. 4
16 進数表記による整合性チェック値。
.IP 12. 4
ブロックヘッダーサイズ。
.IP 13. 4
ブロックフラグ。\fBc\fP は圧縮サイズが存在することを示します。\fBu\fP
は伸長サイズが存在することを示します。このフラグが設定されていない場合、固定幅の文字出力は行わずにダッシュ (\fB\-\fP)
だけを表示します。将来の版においては、新しいフラグがこの文字列の後ろに追加されるかもしれません。
.IP 14. 4
ブロック内の実際の圧縮データサイズ (ブロックヘッダー、ブロックパディング、チェック項目は除きます)。
.IP 15. 4
\fBxz\fP の現バージョンを使って、このブロックの伸長を行うために必要となるメモリ利用量。バイト単位。
.IP 16. 4
フィルターチェーン。圧縮時に利用されたオプションは、ほとんど知ることができません。\fB.xz\fP
ヘッダーにオプションが保存されますが、それは伸長時に必要となるオプションだけだからです。
.RE
.PD
.PP
\fBsummary\fP 行のカラム：
.PD 0
.RS
.IP 2. 4
\fBxz\fP の現バージョンを使って、このファイルの伸長を行うために必要となるメモリ利用量。バイト単位。
.IP 3. 4
\fByes\fP または \fBno\fP。全ブロックヘッダー内に、圧縮サイズと伸長サイズがともに保存されているかどうかを表します。
.PP
\fBxz\fP \fI5.1.2alpha\fP \fI以降\fP：
.IP 4. 4
ファイル伸長に必要となる \fBxz\fP の最低バージョン。
.RE
.PD
.PP
\fBtotals\fP 行のカラム：
.PD 0
.RS
.IP 2. 4
ストリーム数。
.IP 3. 4
ブロック数。
.IP 4. 4
圧縮サイズ。
.IP 5. 4
伸長サイズ。
.IP 6. 4
圧縮率の平均。
.IP 7. 4
ファイル内に存在している整合性チェック名をカンマで区切ったリスト。
.IP 8. 4
ストリームパディングのサイズ。
.IP 9. 4
ファイル数。ここにこのカラムを設けることで、これ以前のカラムの並びが \fBfile\fP 行と同じになるようにします。
.PD
.RE
.PP
\fB\-\-verbose\fP が 2 重指定され \fBtotals\fP 行にカラム追加された場合：
.PD 0
.RS
.IP 10. 4
\fBxz\fP の現バージョンを使って、このファイルの伸長を行うために必要となる最大メモリ利用量。バイト単位。
.IP 11. 4
\fByes\fP または \fBno\fP。全ブロックヘッダー内に、圧縮サイズと伸長サイズがともに保存されているかどうかを表します。
.PP
\fBxz\fP \fI5.1.2alpha\fP \fI以降\fP：
.IP 12. 4
ファイル伸長に必要となる \fBxz\fP の最低バージョン。
.RE
.PD
.PP
将来版において、新たな行タイプの追加、あるいは既存行タイプへのカラム追加があるかもしれません。ただし既存カラムが変更されることはありません。
.
.SH 終了ステータス
.TP 
\fB0\fP
正常終了。
.TP 
\fB1\fP
エラー発生。
.TP 
\fB2\fP
警告に相当する何かが発生。ただし実際のエラーが発生したわけではない。
.PP
通知 (警告やエラーではない) が標準エラー出力に表示されても、終了ステータスには影響しません。
.
.SH 環境変数
\fBxz\fP では環境変数 \fBXZ_DEFAULTS\fP および \fBXZ_OPT\fP
をこの順で、設定された空白区切りのオプションを読み込みます。これは、コマンドラインから指定されたオプションよりも前に処理されます。環境変数から読み取られるのはオプションだけです。オプション以外の情報はすべて無視されます。オプションの読み込みは
\fBgetopt_long\fP(3) を使って行われますが、コマンドライン引数の読み込みにも用いられています。
.TP 
\fBXZ_DEFAULTS\fP
ユーザー定義あるいはシステムワイドなデフォルトオプションを指定します。通常はシェル初期化スクリプト内において設定され、デフォルトで利用する \fBxz\fP
のメモリ利用制限処理を有効にします。シェル初期化スクリプトあるいはこれに相当する特別なケースを除くと、スクリプトにおいて \fBXZ_DEFAULTS\fP
を設定したり未設定にしたりしてはなりません。
.TP 
\fBXZ_OPT\fP
\fBxz\fP コマンドラインからオプション指定ができない場合に、B(xz)
にオプションを受け渡すために用います。これを利用するのは、たとえばスクリプトから、あるいは GNU \fBtar\fP(1) のようなツールから \fBxz\fP
を実行する場合です:
.RS
.RS
.PP
.nf
\f(CWXZ_OPT=\-2v tar caf foo.tar.xz foo\fP
.fi
.RE
.RE
.IP ""
スクリプトにおいてそのスクリプト固有のデフォルト圧縮オプションを設定するために \fBXZ_OPT\fP を用いる場合があります。その場合であっても
\fBXZ_OPT\fP のオーバーライドが認められるのは、たとえば以下に示すように \fBsh\fP(1) スクリプト内にて妥当な利用の仕方をする場合に限ります：
.RS
.RS
.PP
.nf
\f(CWXZ_OPT=${XZ_OPT\-"\-7e"}
export XZ_OPT\fP
.fi
.RE
.RE
.
.SH "LZMA Utils との互換性"
\fBxz\fP のコマンドラインの文法は、実質的に LZMA Utils 4.32.x にある \fBlzma\fP, \fBunlzma\fP, \fBlzcat\fP
のスーパーセットになっています。LZMA Utils を用いる既存のスクリプトは、たいていは特に変更することなくそのまま XZ Utils
に置き換えることができます。ただし非互換性も存在しており、中には問題が発生する場合もあります。
.
.SS 圧縮プリセットレベル
圧縮レベルのプリセット値は \fBxz\fP と LZMA Utils
において同一の番号振りにはなっていません。もっとも重要な違いは、さまざまなプリセットに対する辞書サイズがどのように割り振られているか、という点です。辞書サイズは、おおまかに言えば伸長処理時のメモリ利用量に等しくなります。
.RS
.PP
.TS
tab(;);
c c c
c n n.
レベル;xz;LZMA Utils
\-0;256 KiB;なし
\-1;1 MiB;64 KiB
\-2;2 MiB;1 MiB
\-3;4 MiB;512 KiB
\-4;4 MiB;1 MiB
\-5;8 MiB;2 MiB
\-6;8 MiB;4 MiB
\-7;16 MiB;8 MiB
\-8;32 MiB;16 MiB
\-9;64 MiB;32 MiB
.TE
.RE
.PP
辞書サイズの違いは、圧縮時でのメモリ利用量にも影響します。ただし LZMA Utils と XZ Utils
の違いは他にあって、その違いの方がより大きなものです。
.RS
.PP
.TS
tab(;);
c c c
c n n.
レベル;xz;LZMA Utils 4.32.x
\-0;3 MiB;なし
\-1;9 MiB;2 MiB
\-2;17 MiB;12 MiB
\-3;32 MiB;12 MiB
\-4;48 MiB;16 MiB
\-5;94 MiB;26 MiB
\-6;94 MiB;45 MiB
\-7;186 MiB;83 MiB
\-8;370 MiB;159 MiB
\-9;674 MiB;311 MiB
.TE
.RE
.PP
デフォルトのプリセットレベルは LZMA Utils では \fB\-7\fP ですが、XZ Utils では \fB\-6\fP です。ともにデフォルトで 8 MiB
の辞書を利用します。
.
.SS "ストリーム化されている/されていない .lzma ファイル"
ファイルの伸長サイズは \fB.lzma\fP ヘッダーに保存されます。LZMA Utils
は、通常のファイルを圧縮する際にはこれを保存します。代替策案として、伸長サイズが不明であるとマークしておき、ペイロード終了マーカー
(end\-of\-payload marker) を使って伸長処理の終了位置を示すこともあります。LZMA Utils
はこの方法を、伸長サイズが不明なときに利用します。たとえばパイプを使った場合がこの利用にあたります。
.PP
\fBxz\fP では \fB.lzma\fP ファイルを伸長する際に、ペイロード終了マーカーを利用することも利用しないこともできます。しかし \fBxz\fP
から生成された すべての \fB.lzma\fP に対しては、ペイロード終了マーカーを利用して、\fB.lzma\fP
ヘッダー内に伸長サイズが不明であるものとしてマークします。これは特殊なケースで問題となる場合があります。たとえば埋め込みデバイス上での \fB.lzma\fP
伸長処理は、伸長サイズがわかっていないファイルでは動作しないかもしれません。このような問題に遭遇した場合は、LZMA Utils または LZMA
SDK を利用して、伸長サイズが明確となっている \fB.lzma\fP ファイルを生成してください。
.
.SS "サポートされない .lzma ファイル"
\&\fB.lzma\fP フォーマットが用いる \fIlc\fP 値は 8 まで、\fIlp\fP 値は 4 までです。LZMA Utils がファイル伸長する際には
\fIlc\fP と \fIlp\fP の値はどのような値であってもかまいませんが、ただし \fBlc=3\fP かつ \fBlp=0\fP
のファイルが常に生成されます。これ以外の \fIlc\fP や \fIlp\fP を生成するには \fBxz\fP か LZMA SDK を利用してください。
.PP
liblzma 内の LZMA1 フィルターの実装では、\fIlc\fP と \fIlp\fP の合計が 4
を超えてはならないものとなっています。したがってこの制限を超えた \fB.lzma\fP ファイルは \fBxz\fP を使って伸長することはできません。
.PP
LZMA Utils が生成する \fB.lzma\fP ファイルは、辞書サイズが 2^\fIn\fP (2 のべき乗)
のものだけです。ただしどのようなサイズのファイルでも受けることはできます。一方 liblzma が受付られるのは、辞書サイズが 2^\fIn\fP または
2^\fIn\fP + 2^(\fIn\fP\-1) であるような \fB.lzma\fP ファイルのみです。これは \fB.lzma\fP
ファイルを検出する際に、誤った検出を回避するためです。
.PP
上のような制約は現実に問題となることはありません。事実上 \fB.lzma\fP ファイルは liblzma
が受け入れる設定すべてを使って圧縮されるものとなっているからです。
.
.SS ゴミデータ
LZMA Utils は伸長時に、最初の \fB.lzma\fP ストリーム以降のデータは完全に無視します。ほとんどの場合、これはバグになります。これはまた
LZMA Utils が、連結された \fB.lzma\fP ファイルを伸長できないことを表しています。
.PP
\&\fB.lzma\fP の最初のストリーム以降にデータが残っている場合、\fBxz\fP は \fB\-\-single\-stream\fP
が指定されていない限りは、そのファイルが壊れているとみなします。したがって、ゴミデータは無視される扱いである前提で作られているスクリプトは、動作しなくなるかもしれません。
.
.SH 情報
.
.SS 圧縮結果はさまざま
同一の圧縮前ファイルを使って圧縮ファイルを生成したとしても、XZ Utils
バージョンが異なると、その生成結果は異なることになります。それは圧縮オプションが全く同じであっても起こります。ファイルフォーマットに影響を与えることなく、エンコード処理は常に
(より高速に、より高圧縮に) 改善されているためです。XZ Utils
バージョンが同一であっても、ビルド時のオプションが違っていると、生成結果が異なる場合もあります。
.PP
このことは \fB\-\-rsyncable\fP が実装された際には問題となります。rsync の機能を用いる際には、古いファイルと新しいファイルを同一の xz
バージョンで圧縮しておかないと、rsync 処理ができないということになります。この問題を解決するには、どちらかのエンコード実装を凍結して、xz
バージョン間において安定して rsync 処理ができるような出力とすることが必要になります。
.
.SS "埋め込み .xz の伸長処理"
XZ Embedded のような埋め込み \fB.xz\fP 伸長処理の実装では、整合性チェックのうち \fBnone\fP と \fBcrc32\fP
以外のものを使ったファイル生成には対応する必要がありません。デフォルトは \fB\-\-check=crc64\fP
ですから、埋め込みシステム上でのファイル生成時は \fB\-\-check=none\fP か \fB\-\-check=crc32\fP を指定しなければなりません。
.PP
埋め込みシステムを除くと、\fB.xz\fP フォーマットにおける伸長処理では、\fIcheck\fP タイプすべてに対応しています。あるいは特定の
\fIcheck\fP がサポートされていなかったとしても、最低でも整合性チェックの検証を行わずにファイル伸長処理が可能となっています。
.PP
XZ Embedded は BCJ フィルターに対応しています。ただしデフォルトの開始オフセットしか利用できません。
.
.SH 利用例
.
.SS 基本
ファイル \fIfoo\fP を圧縮して \fIfoo.xz\fP を生成します。利用する圧縮レベルはデフォルト (\fB\-6\fP) です。圧縮が成功したら
\fIfoo\fP を削除します:
.RS
.PP
.nf
\f(CWxz foo\fP
.fi
.RE
.PP
\fIbar.xz\fP を伸長して \fIbar\fP を得ます。伸長処理に成功しても \fIbar.xz\fP は削除しません:
.RS
.PP
.nf
\f(CWxz \-dk bar.xz\fP
.fi
.RE
.PP
プリセット \fB\-4e\fP (\fB\-4 \-\-extreme\fP) を用いて \fIbaz.tar.xz\fP を生成します。これはたとえばデフォルトの \fB\-6\fP
に比べて処理速度は低下しますが、圧縮時や伸長時のメモリ消費は少なくて済みます (それぞれ 48\ MiB と 5\ MiB)：
.RS
.PP
.nf
\f(CWtar cf \- baz | xz \-4e > baz.tar.xz\fP
.fi
.RE
.PP
圧縮されたファイルや未圧縮のファイルを混在させ、ただ 1 つのコマンドを使って標準出力を行うことができます:
.RS
.PP
.nf
\f(CWxz \-dcf a.txt b.txt.xz c.txt d.txt.lzma > abcd.txt\fP
.fi
.RE
.
.SS 複数ファイルの並行圧縮処理
GNU および *BSD の \fBfind\fP(1) や \fBxargs\fP(1) では、複数ファイルを並行処理により圧縮することができます:
.RS
.PP
.nf
\f(CWfind . \-type f \e! \-name '*.xz' \-print0 \e
    | xargs \-0r \-P4 \-n16 xz \-T1\fP
.fi
.RE
.PP
\fBxargs\fP(1) に対する \fB\-P\fP オプションが、\fBxz\fP 処理に対する並行処理数を設定しています。\fB\-n\fP
オプションの最適値は、どれだけのファイルを圧縮するかによって変わります。ファイル数がほんの数個である場合、おそらくこの値は 1
が適切です。ファイル数が数万のレベルなら 100 以上が適切であり、これによって \fBxargs\fP(1) が最終的に作り出す \fBxz\fP
プロセスを抑えられます。
.PP
\fBxz\fP に対してオプション \fB\-T1\fP を指定していますが、これは強制的にシングルスレッドモードにします。\fBxargs\fP(1)
は通常は並行処理数を制御するために利用されているからです。
.
.SS ロボットモード
複数ファイルを圧縮したことによって、合計で何バイト分が保存されたかを計算します:
.RS
.PP
.nf
\f(CWxz \-\-robot \-\-list *.xz | awk '/^totals/{print $5\-$4}'\fP
.fi
.RE
.PP
スクリプト実行の際には、利用している \fBxz\fP が最新版であるかどうかを確認したい場合があります。以下の \fBsh\fP(1) スクリプトでは、\fBxz\fP
ツールのバージョン番号が最低でも 5.0.0 であるかどうかを確認しています。この方法は \fB\-\-robot\fP
オプションに対応していない古いベータ版に対しても利用できます:
.RS
.PP
.nf
\f(CWif ! eval "$(xz \-\-robot \-\-version 2> /dev/null)" ||
        [ "$XZ_VERSION" \-lt 50000002 ]; then
    echo "Your xz is too old."
fi
unset XZ_VERSION LIBLZMA_VERSION\fP
.fi
.RE
.PP
\fBXZ_OPT\fP を利用して伸長時のメモリ利用制限を設定します。ただしすでに設定されていた場合、その設定が増えることはありません:
.RS
.PP
.nf
\f(CWNEWLIM=$((123 << 20))  # 123 MiB
OLDLIM=$(xz \-\-robot \-\-info\-memory | cut \-f3)
if [ $OLDLIM \-eq 0 \-o $OLDLIM \-gt $NEWLIM ]; then
    XZ_OPT="$XZ_OPT \-\-memlimit\-decompress=$NEWLIM"
    export XZ_OPT
fi\fP
.fi
.RE
.
.SS カスタム圧縮フィルターチェーン
カスタムフィルターチェーンを利用する一番簡単な方法は LZMA2
プリセットを用いることです。プリセットには、圧縮設定の中から有用な設定を組み合わせて、その一部を割り当てているため、それを使うのが簡単です。
.PP
オプション \fB\-0\fP ... \fB\-9\fP, \fB\-\-extreme\fP のところで説明した一覧表内の CompCPU カラムは、LZMA2
プリセット値をカスタマイズする際に活用できます。上で説明済の 2 つの表から、関連するところを抜粋したものが以下です:
.RS
.PP
.TS
tab(;);
c c
n n.
プリセット;CompCPU
\-0;0
\-1;1
\-2;2
\-3;3
\-4;4
\-5;5
\-6;6
\-5e;7
\-6e;8
.TE
.RE
.PP
効率よく圧縮するためには、ある程度大きな (たとえば 32 MiB 程度の) 辞書が必要であることがわかっているとします。一方で \fBxz \-8\fP
の指定時よりも速く処理がしたいとします。その場合は CompCPU 値が低い (たとえば 1 であるような)
プリセットを使えば、より大きな辞書を利用するように調整ができます:
.RS
.PP
.nf
\f(CWxz \-\-lzma2=preset=1,dict=32MiB foo.tar\fP
.fi
.RE
.PP
ファイルによっては、上のコマンドの実行により、圧縮効率が著しく改善されて \fBxz \-6\fP よりも高速処理される場合があります。ただし CompCPU
値を低くしたとしても、大きな辞書を使ったことが効果を発揮するようなファイルは限られることは強調しておきます。大きな辞書を用いた効果が発揮される状況は、おそらく最低数メガバイトの総量で、似通ったファイルを含むアーカイブである場合です。辞書サイズは、個々のファイルに比べれば十分に大きなサイズにする必要があります。そうしておけば、LZMA2
が並んだファイルの類似性に対して効果を発揮する処理を行ってくれます。
.PP
仮に圧縮時や伸長時のメモリ利用を大きな値とするのが有効であり、また圧縮するファイルが最低でも数 100 メガバイトあるなら、\fBxz \-9\fP
が利用する辞書サイズ 64 MiB よりもさらに大きなサイズを利用するのが効果的かもしれません:
.RS
.PP
.nf
\f(CWxz \-vv \-\-lzma2=dict=192MiB big_foo.tar\fP
.fi
.RE
.PP
上の利用例に示しているように \fB\-vv\fP (\fB\-\-verbose \-\-verbose\fP)
を用いると、圧縮および伸長におけるメモリ必要量が確認できます。なお伸長ファイルサイズよりも大きな辞書を利用すると、メモリを無駄に消費します。したがって上のコマンドは、容量が少ないファイルに対しては効果が期待できません。
.PP
圧縮時間は問題にならないこともあります。しかし伸長時のメモリ利用量は低く抑えるべきです。たとえば埋め込みシステムでは、ファイル伸長時のメモリ利用は極力低く抑えたいところです。以下のコマンドでは、基本として
\fB\-6e\fP (\fB\-6 \-\-extreme\fP) を利用し、辞書サイズは 64\ KiB と小さくしています。XZ Embedded を利用すると
(だからこそ \fB\-\-check=crc32\fP を用いるのですが)、伸長処理によるファイル生成の際には 100\ KiB のメモリ利用に抑えられます。
.RS
.PP
.nf
\f(CWxz \-\-check=crc32 \-\-lzma2=preset=6e,dict=64KiB foo\fP
.fi
.RE
.PP
できるだけ多くのバイトを圧縮したい場合は、リテラルコンテキスト (\fIlc\fP) ビット値と、ポジションビット (\fIpb\fP)
を調整するのが有効になる場合があります。リテラルポジションビット (\fIlp\fP) の調整も有効かもしれませんが、通常は \fIlc\fP と \fIpb\fP
の方が重要です。たとえばソースコードアーカイブと言えば、ほとんどが US\-ASCII テキストであるため、以下に示すように処理すれば、\fBxz \-6e\fP
の処理よりもほんの少しだけ (0.1\ % 程度) 小さくなります (\fBlc=4\fP を除いた処理も試してください):
.RS
.PP
.nf
\f(CWxz \-\-lzma2=preset=6e,pb=0,lc=4 source_code.tar\fP
.fi
.RE
.PP
特定のファイルタイプに対しては、LZMA2 に別のフィルターを加えることで、圧縮処理が改善することがあります。たとえば x86\-32 や x86\-64
の共有ライブラリに対しては x86 BCJ フィルターを使うことがこれにあたります:
.RS
.PP
.nf
\f(CWxz \-\-x86 \-\-lzma2 libfoo.so\fP
.fi
.RE
.PP
フィルターオプションの並びは重要です。\fB\-\-x86\fP が \fB\-\-lzma2\fP の後ろに指定されると \fBxz\fP はエラーを表示します。この理由は
LZMA2 の後ろにフィルターを置くことはできないためであり、さらに x86 BCJ
フィルターはチェーン内の最終フィルターにすることもできないからです。
.PP
LZMA2 にデルタフィルターを合わせて利用すると、ビットマップイメージに対しては良好な結果が得られます。この結果は普通 PNG
を上回るはずです。PNG には単純なデルタよりも高度なフィルターをいくつか有していますが、実際の圧縮にあたっては Deflate が用いられています。
.PP
イメージデータは非圧縮形式で保存する必要があります。たとえば非圧縮の TIFF
データなどです。デルタフィルターの距離パラメーターは、イメージ内におけるピクセルあたりのバイト数にマッチするように設定されています。たとえば 24
ビット RGB ビットマップには \fBdist=3\fP が必要です。また LZMA2 に対しては \fBpb=0\fP を指定して 3
バイト並びに対応させるのが適切です:
.RS
.PP
.nf
\f(CWxz \-\-delta=dist=3 \-\-lzma2=pb=0 foo.tiff\fP
.fi
.RE
.PP
複数のイメージが 1 つのアーカイブ (たとえば \fB.tar\fP)
にまとめられているときは、個々のイメージのピクセルあたりのバイト数が同一である場合に限って、デルタフィルターは同様に動作します。
.
.SH 関連項目
\fBxzdec\fP(1), \fBxzdiff\fP(1), \fBxzgrep\fP(1), \fBxzless\fP(1), \fBxzmore\fP(1),
\fBgzip\fP(1), \fBbzip2\fP(1), \fB7z\fP(1)
.PP
XZ Utils: <https://tukaani.org/xz/>
.br
埋め込み XZ: <https://tukaani.org/xz/embedded.html>
.br
LZMA SDK: <http://7\-zip.org/sdk.html>
